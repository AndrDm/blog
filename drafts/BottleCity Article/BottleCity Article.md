Вашему вниманию предлагается небольшой этюд выходного дня о том, как я "перекладывал" js код на Си, а затем и на LabVIEW. Увидев за чашкой кофе [пару](https://habr.com/ru/articles/815653/) [постов](https://habr.com/ru/companies/cloud4y/articles/816321/) про забавный проект, генерирующий впечатляющий ландшафт относительно несложными вычислениями, мне захотелось добавить себе в коллекцию эту игрушку (ну как мы иногда ставим бесполезных слоников на каминную полку), так что я решил потратить обеденный перерыв для наброска, но там всё оказалось не так просто. Технически удобнее перед тем, как переписывать алгоритм на LabVIEW, иметь под рукой референсный алгоритм на Си, и тут меня ждало несколько подводных камней...

---

Прежде чем продолжить, надо отметить, что я вроде не новичок в программировании, работаю уже больше двадцати пяти лет, и вроде знаю Си, меня не испугать алгоритмами и численными методами, но я в жизни своей ни строчки не написал на JavaScript, так что пост этот может быть интересен взглядом новичка на вещи, которые для для профессионалов очевидны и сами собой разумеются. С другой стороны я профи в LabVIEW, а большая часть аудитории, читающая этот пост будет смотреть на графический код ровно теми же глазами новичка, которыми я у видел js. Как заметил Козьма Прутков — "хороший специалист подобен флюсу — полнота его односторонняя". По ходу повествования я буду упоминать много других продуктов, в том числе коммерческих, но рекламной нагрузки пост не несёт.

Итак, всё, что  меня было в руках, это вот эта [ссылка](https://capjs.3d2k.com/?filename=City256&crushed=t*%3D60%0Afor%7Bc.width%3Dw%3D99%2C%2B%2Bt%2Ci%3D6e3%3Bi--%3Bc.getContext%602d%60.fillRect%7Bi%27%2Ci%28%7C0%2C1-d*Z%28%2Bs%2C1%7D%7Dfor%7Ba%3Di%27%2F50-1%2Cs%21-i%2F4e3%2CX%3Dt%2CY%3DZ%3DdA%3B%2B%2BZ%3Cw%26%7BY%3C6-%7B32%3CZ%2627%3CX%27%26%26X%2F9%5EZ%2F8%7D*8%2546%7C%7Cd%7C%7Bs%3D%7BX%26Y%26Z%7D%253%2FZ%2Ca%21%2Cd%3DZ%28%7D%7D%3BY-%29%7DX%2B%3Da%21%29A%27%25w%28%2Fw%29%3DbA%3D1%01A%29%28%27%21_).

Всё перед газами:

![image-20240528062228926](assets/image-20240528062228926.png)

Поскольку я человек ленивый (а таким и должен быть в какой-то мере программист), то я решил воспользоваться ИИ для "пристрелки". Надо сказать, что технологии впечатляют — я уже довольно давно использую их для небольших фрагментов рутинного кода. Вот буквально несколько дней назад мне потребовался кусочек на Си для бинарного поиска и получить результат можно очень быстро, но как говорится — доверяй, но проверяй.

[Поехали](https://www.perplexity.ai/search?q=pending&newFrontendContextUUID=b3acbadd-e72d-4bd1-922c-d0555736aa2b): 

```c
#include <stdio.h>
#include <math.h>

int main() {
    int t = 0, w = 99, i, a, s, b, X, Y, Z, d;
    t *= 60;

    for (w = 99, ++t, i = 6000; i--; ) {
        for (a = (i % w) / 50 - 1, s = b = 1 - i / 4000, X = t, Y = Z = d = 1; 
             ++Z < w && (Y < 6 - (32 < Z && 27 < X % w && X / 9 ^ Z / 8) * 8 % 46 || d
                         || (s = (X & Y & Z) % 3 / Z, a = b = 1, d = Z / w)); Y -= b){
            X += a;
        }
    }
    return 0;
}
```

Выше я воспользовался perplexity.ai. Я в основном использую этот сервис, потому что он из немногих, не заблокированных у меня на работе, где гайки закручены - у меня там нет никаких ИИ, нет облаков, соцсетей кроме хабра да линкедина тоже нет, ну что поделать, полиси такое.

Пока что мы не будем включать мозги, а просто снабдим этот код выводом интенсивностей пикселей. ИИ, кстати забыл, что она вычисляется как 1-d*Z/w+s, нет проблем, добавляем, я покажу скриншот, как это у меня выглядит, оно даже компиляется в лёт без единого предупреждения:

![image-20240528064839924](assets/image-20240528064839924.png)

Большинству листающих этот пост данная среда разработки покажется незнакомой. Это [LabWindows CVI](https://www.ni.com/en/shop/electronic-test-instrumentation/programming-environments-for-electronic-test-and-instrumentation/what-is-labwindows-cvi.html). Я использую его для несложных проектов на Си. Достоинства в том, что продукт прост как пять копеек, легковесен, не перегружен настройками, плюс тесно интегрирован с продуктами NI и вот ещё очень удобное дерево выбора библиотечных функций слева. Недостатки — это чистый незамутнённый Си, плюсплюсов туда не завезли, под капотом древний clang 3.3, соответственно генерируемый машинный код не очень эффективен, студия, а тем более интеловский обгоняют его по производительности, и платный к тому же — стоит не то, чтобы как крыло от боинга, но близко к тому — почти две тысячи долларов. В год. Но он идет "в нагрузку" к LabVIEW, чем я и пользуюсь. Ну вот просто знайте, что не только Студия да gcc есть.

Ладно, запускаем:

```
I = 0.000000 @ pix 5999
I = 0.000000 @ pix 5998
I = 0.000000 @ pix 5997
I = 0.000000 @ pix 5996
I = 0.000000 @ pix 5995
I = 0.000000 @ pix 5994
I = 0.000000 @ pix 5993
I = 0.000000 @ pix 5992
I = 0.000000 @ pix 5991
I = 0.000000 @ pix 5990
```

Ну кто бы сомневался.

Погодите, а какой первый пиксел должен быть?

Первым делом я вкорячил в код вывод прямо в окошко:

![image-20240529062410595](assets/image-20240529062410595.png)

Но потом уже разул глаза — там же внизу есть Watch Window:

![image-20240529062521203](assets/image-20240529062521203.png)

Удобно. Теперь мы знаем, что нулевой пиксел должен быть 0,868686...

В принципе понятно — все переменные объявлены как целые, по другому и быть не может.

Поскольку мозги мы всё ещё не хотим включать, пропробуем chatGPT

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define WIDTH 99
#define HEIGHT 60

void fillRect(int canvas[HEIGHT][WIDTH], int x, int y, int w, int h, int value) {
    for (int i = 0; i < h; ++i) {
        for (int j = 0; j < w; ++j) {
            if (x + j < WIDTH && y + i < HEIGHT && x + j >= 0 && y + i >= 0) {
                canvas[y + i][x + j] = value;
            }
        }
    }
}

void drawCanvas(int canvas[HEIGHT][WIDTH]) {
    for (int i = 0; i < HEIGHT; ++i) {
        for (int j = 0; j < WIDTH; ++j) {
            putchar(canvas[i][j] ? '#' : ' ');
        }
        putchar('\n');
    }
}

int main() {
    int t = 0;
    int canvas[HEIGHT][WIDTH];

    while (++t) {
        memset(canvas, 0, sizeof(canvas));
        
        for (int i = 6000; i--; ) {
            double a = i % WIDTH / 50.0 - 1;
            double s = 1 - i / 4000.0;
            double b = s;
            double X = t, Y = 1, Z = 1;
            int d = 1;

            for (; ++Z < WIDTH &&
                (Y < 6 - ((32 < Z && 27 < X % WIDTH && X / 9 ^ Z / 8) * 8 % 46) ||
                d || (s = (X & (int)Y & (int)Z) % 3 / Z, a = b = 1, d = Z / WIDTH)); ) {
                X += a;
                Y -= b;
            }

            fillRect(canvas, i % WIDTH, i / WIDTH, 1 - d * Z / WIDTH + s, 1, 1);
        }

        drawCanvas(canvas);
        break;  // Comment this line out if you want to continuously update t.
    }

    return 0;
}

```

О, как, он даже сделал попытку вывода в псевдографике, но нет, результат по-прежнему неверный.

Тут я подумал, что не может быть, чтобы хоть кто-то да не разобрался в этом несложном скрипте, и точно - вот этот код "разложенный" по полочкам:



