Это будет "лонгрид", но разбивать его на несколько постов я не буду, чтобы не забивать ленту почём зря, поскольку материал довольно быстро уйдёт с главной в (не побоюсь этого слова) анналы хабра, и кто-нибудь будет время от времени находить его в поиске и таки найдёт для себя что-то полезное.

Компания B&R была основана в 1971 году, штаб квартира и основное производство с учебными центрами располагаются в австрийском Эггельсберге:

![](assets/B_R-Headquater-10-2022_01-2dcf4360.jpg)

Это чуть больше сотни километров от Мюнхена на восток, где-то полтора часа езды.

Кстати, именно там и находится то знаменитое село:

![image-20241217074716413](assets/image-20241217074716413.png)

Говорят, его название сменили на Fugging, но я проезжал там несколько раз в 2019 году, когда ездил на обучение и застал именно ту вывеску. Вот за тем лесом, километров десять и будет Эггельсберг.

Сегодня у меня на рабочем столе, а значит в обзоре, типичный представитель мира ПЛК - [X20CP1586](https://www.br-automation.com/en/products/plc-systems/x20-system/x20-plc/x20cp1586/):

![](assets/X20CP1586.right-5ffface7.jpg)

Это ПЛК на процессоре Intel Atom. Конкретно в этой модели установлен [Atom E680T](https://www.intel.com/content/www/us/en/products/sku/52498/intel-atom-processor-e680t-512k-cache-1-60-ghz/specifications.html), с частотой 1.6 ГГц. Процессор довольно слабенький, 24 кБ кэш данных, 32 кБ кэш команд, 512 кБ кэша второго уровня, третьего и нет вовсе. Выполнен по технологии 45 нм на архитектуре Tunnel Creek. Выпущен аж в 2010 году, был предназначен как раз для использования в ПЛК и всяком эмбеддинге. На борту у конкретно этого ПЛК 512 МБ памяти DDR2 800 SDRAM. Максимально процессор может адресовать 2 ГБ. Память распаяна. Охлаждение пассивное, TDP там всего 4.5 ватта, но диапазон рабочих температур довольно широкий: от -25°C до 60°C. Кстати, современные ПЛК недалеко ушли от этого, в топовых на данный момент [X20CP3686X](https://www.br-automation.com/en/products/plc-systems/x20-system/x20-plc/x20cp3686x/) да [X20CP3687X](https://www.br-automation.com/en/products/plc-systems/x20-system/x20-plc/x20cp3687x/) установлены Атомы E3930 и E3940, а память добили до одного и двух гигов, но уже DDR4, спасибо и на этом. Крышку я, с вашего позволения, снимать не буду, там довольно хлипкие "одноразовые" защёлки, радиатор охлаждения хорошо виден через решётку корпуса:

<ФОТО>

По сути это обычный одноплатный компьютер с парой специальных фишек. Давайте посмотрим на его интерфейсы поближе, снизу видно два обычных RJ45 коннектора. Слева IF2 - это гигабитный Ethernet. Правее - это [POWERLINK](https://ru.wikipedia.org/wiki/Ethernet_powerlink), это в общем тот же Ethernet, но "реального времени" расширенный для высокоточной синхронизации узлов сети (мы говорим о временах порядка нескольких микросекунд). Затем у нас есть пара USB (оба 1.1/2.0), над ними разъём CF карты — это суть накопитель, на котором операционная система и управляющая программа. Справа X2X Link. Это проприетарная полевая шина для бэкплейна, на которую "нанизываются" модули расширения. Вы можете спросить, где же IF1, а он тут есть — это RS232 выведенный на тот же коннектор (строго говоря это [X20TB12](https://www.br-automation.com/en/products/io-systems/x20-system/terminal-blocks/x20tb12/) терминал блок), на который подаётся питание. Батарейка CMOS (3 V / 950 mAh) прячется под крышкой: 

<ФОТО>

Пустой слот посередине между терминальным блоком и процессором предназначен для модулей расширения [других шин](https://www.br-automation.com/en-us/products/networks-and-fieldbus-modules/) типа EtherCAT, ModbusTCP, DeviceNet и т.д., например если вам нужно общаться с конвейером, которым управляет ПЛК с шиной Profibus, то туда будет вставлен вот такой модуль:

![](assets/X20BC0063.right-c7a052ab.jpg)

Справа "нанизываются" модули расширения. Их огромное количество, я в учебных целях возьму пару самых "ходовых", это один модуль входов и один выходов.

Питается эта игрушка от 24 вольт (что в общем стандарт в промышленности), потребляет где-то пол-ампера.

### Программирование ПЛК

Давайте теперь посмотрим, как этот "Лего" конструктор программируется. 

Для этого предназначена IDE, которая называется Automation Studio. Актуальная на момент обзора версия 6.1.1.14, выпущенная в середине декабря, но этот старенький ПЛК в ней не поддерживается, так что я буду пользоваться четвёртой версией (визуально шестая от четвёртой мало чем отличается). Все скриншоты будут на английском, русского сюда не завезли, тут уж извините. Впрочем других языков кроме немецкого там тоже нет. Скачать можно бесплатно [вот отсюда](https://www.br-automation.com/de/downloads/#categories=Software-1344987434933/Automation+Studio-1344987435049/Automation+Studio+6-1713276081004). Вначале надо ставить 6.0.2.177, затем накатить обновление до 6.1.1.14. Триальную лицензию на 90 дней робот раздаёт бесплатно [вот здесь](https://www.br-automation.com/en/service/software-registration/automation-studio-licensing/). Там ограничено время работы двумя часами и выпилены онлайн обновления, в остальном "на попробовать" — самое то. По истечении 90 дней можно без проблем просить снова и снова. Единственно — я честно не уверен, что всё это доступно из России, но ВэПээНы пока вроде работают. Там в комплект входит очень неплохой симулятор, то есть можно сконфигурировать реальное железо, и запускать код даже при его отсутствии.

Изначально ПЛК "мёртв", ему нужно залить на флешку образ, который сначала нужно изготовить, для этого "с нуля" создаётся проект и конфигурируется в точном соответствии с железом, которым вы располагаете:

![](assets/image-20241216104824209.png)

Я не буду превращать пост в простыню скриншотов (у меня в общем не стоит задачи заменить инструкцию), просто обозначу ключевые места, чтобы у вас сложилась "общая картина". У меня, кстати, остались кой какие учебные материалы, в том числе на русском, если кому надо — стукнитесь в личку.

Среда разработки выглядит вот таким образом — слева окошко с тремя вкладками - логическое представление (там как раз находятся ваши программы. что крутятся в ПЛК), затем конфигурационная вкладка, где ПЛК конфигурируется да программируется и физическое представление, где конфигурируется железо. Нам надо собрать конфигурацию с двумя модулями - входы 9371 и выходы 9322. Они просто перетягивются мышкой из библиотеки, список доступных модулей там очень большой, так что проще воспользоваться поиском, вот так:

![](assets/plc2.gif)

Теперь нам надо как-то "достучаться" до выходов и получить значения входов, делается это очень простым способом, давайте поморгаем светодиодиками.

В лучших традициях некошерного программирования я заведу две глобальные переменные LED11 и LED12:

![](assets/plc3.gif)

А теперь я просто сделаю маппинг этих переменных на физические выходы:

![](assets/plc4.gif)

И так далее. Для входов всё происходит ровно также. Осталось написать программу, которая будет периодически перебрасывать true в false.

Вообще говоря среда разработки предоставляет возможности написания программ на девяти языках, пять из которых определены стандартом IEC 61131-3 (европейский EN 61131 или МЭК 61131-3), но для начала давайте воспользуемся Си и вам сразу стает понятен принцип программирования.

Для того, чтобы добавить Си-программу, надо просто перейти на вкладку логического представления, найти в списке справа "ANSI C Program All in One" да щёлкнуть два раза (или просто перетащить мышкой на проект): 

![image-20241217125924542](assets/image-20241217125924542.png)

Для вас будет создан файл main.c с тремя функциями, куда нужно будет длобавить в нашем случае одну-единственную строчку:

![image-20241217130420207](assets/image-20241217130420207.png)

В принципе если вы загрузите эту программу в ПЛК, то светодиод начнёт мигать, но тут надо сделать небольшое пояснение. Функции ProgramInit() и ProgramExit() вызываются одноразово при старте ПЛК и останове, а вот ProgramCyclic() вызывается циклически (её имя как бы намекает). Фактически там крутится бесконечный цикл, но он спрятан в недрах ПЛК, вам не нужно о нём заботиться. В этом цикле читаются все входы и переменные, затем выполняется ProgramCyclic(), после чего все выходы устанавливаются в соответствующие значения сообразно логике программы. Как часто вызывается ProgramCyclic()? Это определяется вот здесь в конфигурации:

![image-20241217131313011](assets/image-20241217131313011.png)

Вам доступно восемь "Cyclic" слотов с разным временем цикла. Программы можно добавлять сюда и перетаскивать их мышкой. В один слот можно поместить любое количество программ (предел мне неизвестен). Предопределённое время можно изменить вот здесь:

![image-20241217131805037](assets/image-20241217131805037.png)

Минимально возможное время зависит от конкретного ПЛК, обычно 100-400 µs. Duration - это и есть время цикла, о Tolerance мы поговорим чуть ниже. В общем случае своим кодом вы должны уложиться во время Duration+Tolerance, иначе ПЛК свалится в ошибку (он ведь суть контроллер реального времени).

Вот собственно и всё, теперь программу можно загрузить в контроллер

![image-20241217132645046](assets/image-20241217132645046.png)

Если у вас нет физического контроллера, то можно активировать симуляцию:

![image-20241217132822963](assets/image-20241217132822963.png)

Процесс загрузки выглядит вот так:

![](assets/plc_transfer.gif)

Как вы могли заметить, ПЛК перезагрузился. Он делает это не всегда, при небольших изменениях программа подменяется "на лету" без останова. На самом деле перезагрузка добавляет определённую головную боль, например, у вас ПЛК может управлять конвейером и для холодного рестарта вам может потребоваться снять все детали. Сименсовский ПЛК значительно более "устойчив", а этот перегружается по каждому чиху, но к этому в общем можно привыкнуть.

А, нам же ещё хочется видеть изменение переменных в реальном времени, для этого есть Монитор, гуда можно перетаскивать переменные, ну и просто наведя мышкой на код можно видеть что там происходит:

![](assets/plc_watch.gif)

Прежде чем продолжать, давайте очень быстро и поверхностно пробежимся по остальным восьми языкам, начиная с тех пяти, что определены в МЭК 61131-3. Устройство у всех одинаково — есть Cyclic программа, куда и вписывается (или врисовывается) код.

**ST - Structured Text.** Это текстовый язык и (так уж исторически сложилось) один из основных, на котором происходит разработка программ на B&R ПЛК. Это такой "паскалеподобный" язык.

Мигание светодиодом на нём будет выглядеть просто вот так:

```structured text
PROGRAM _CYCLIC
	LED11 := NOT LED11;	 
END_PROGRAM
```

В остальном язык как язык, если вы писали на Паскале или на Дельфи, вам понравится.

**IL — Instruction List.** Это тоже текстовый язык, весьма низкоуровневый, его ещё иногда называют "ассемблером для ПЛК". Я сто лет на нём ничего не писал, самый простой способ инвертировать выход выглядит вероятно как-то вот так:

```
PROGRAM _CYCLIC
	LDN LED12
	ST LED12
END_PROGRAM
```

Тут мы грузим инвертированный сигнал (LoaDNegative) в аккумулятор и пишем обратно (STore). Там есть и условия и переходы.

**LD - Ladder Diagram.** Это графический язык, который называют языком релейно-контактной логики. Если вы в прошлой жизни были электриком, то вам сюда.

![](assets/plc_LD.gif)

В последней версии визуально выглядит посимпатичнее чем раньше (а так вообще вся эта среда разработки "привет из девяностых").

**FBD — Function Block Diagram**. Это также графический язык. Выглядит как-то так:

![](assets/plc_fbd2.gif)

Вся программа будет выполняться поблочно и последовательно.

**SFC — Sequential Function Chart**. Тут есть шаги-экшены и переходы между ними:

На самом деле язык действительно не очень простой (в смысле интуитивности), за деталями могу предложить сходить в пост "[Светофор на ПЛК – все языки МЭК 61131-3](https://habr.com/ru/articles/209290/)", там всё то же, что и выше, только подробнее. 

**CFC —  Continuous Function Chart.** Этот язык не включён в МЭК 61131-3, но представляет собой, скажем так, расширение FBD, куда привнесена идеология потоков данных.

Я отставлю здесь скриншот из файла помощи:

![image-20241217144929799](assets/image-20241217144929799.png)

Не будет вызывать отторжения у тех, кто программировал на LabVIEW.

**AB — B&R Automation Basic**. Это текстовый язык - специальное "изобретение" B&R.

Бейсик как есть, некромантам понравится.

**С++**. Об этом девятом языке особо говорить не о чем, Си++ он везде плюсплюс, базовый набросок инвертирования выхода от Си отличаться в общем не будет, но ниже будет пример поинтереснее.

### Оценка производительности ПЛК.

Ладно, вернёмся к нормальному программированию. Мне на досуге стало любопытно, как можно замерить время выполнения участка кода. Это на самом деле довольно важно, мы как-то делали перемещение манипулятора с анализом коллизий (чтобы грубо говоря не въехать в стену), и действительно упёрлись в то, что не укладывались во время цикла, а увеличивать его не хотелось, так как это приводило к большим задержкам (приходилось тормозить сильно не доезжая до точки коллизии). Ну и просто интересно. И хотя в Automation Studio  есть инструменты для трачссировки и профайлинга, однако мне хотелось "классического" бенчмарка, но оказалось, что функции запроса времени возвращают нули... И тут я вспомнил, что ведь есть ещё ассемблер, и я могу позвать rdtsc и да, этот ПЛК можно программировать на ассемблере.

Для начала просто поупражняемся. Пример использования ассемблера есть даже в файле помощи B&R, он выглядит вот так:

```
.globl asmfun
asmfun:
	push %ebp
	mov %esp, %ebp
	sub $0x18, %esp
	mov 0x8(%ebp), %eax
	mov %ax, 0xfe(%ebp)
	movzwl 0xfe(%ebp), %eax
	inc %eax
	movswl %ax, %edx
	mov %edx, %eax
	lea 0x0(%esi), %esi
	leave 
ret 
```

Тут просто инкремент, я не знаю зачем так сложно. Сложим, к примеру просто два целых числа:

```
.globl add_integers
.type add_integers, @function

add_integers:
    push %ebp
    mov %esp, %ebp
    
    mov 8(%ebp), %eax   # Грузим первый аргумент в eax
    add 12(%ebp), %eax  # Прибавляем второй туда же, в eax
    
    mov %ebp, %esp
    pop %ebp
    ret
```

Этот код надо положить в *.s файл, прибавить до кучи нехитрый заголовочный файл

```
/* Declaration */
int add_integers(int, int);
```

И можно использовать:

```
void _CYCLIC ProgramCyclic(void)
{
	res1 = add_integers(a++, b++);
}
```

И оно работает:

<ГИФКА>

Для тех, кому синтаксис GNU Assembler кажется богомерзким, можно и вот так:

```
.globl add_integers_intel
.type add_integers_intel, @function
.intel_syntax noprefix

add_integers_intel:
    push ebp
    mov ebp, esp
    
    mov eax, [ebp+8]   # Тут справа налево
    add eax, [ebp+12]  # 
    
    mov esp, ebp
    pop ebp
    ret
```

Ну а если лень класть код в *.s файл, то можно заинлайнить прямо в Си код:

Хоть так:

```c
int add_integers_inline(int a, int b) {
	int result;
	__asm__ (
		"movl %1, %%eax\n\t"
		"addl %2, %%eax"
		: "=a" (result)
		: "r" (a), "r" (b)
	);
	return result;
}

void _CYCLIC ProgramCyclic(void)
{
	//...
	result = add_integers_inline(a++, b++);
}
```

Либо вообще так:

```c
void _CYCLIC ProgramCyclic(void)
{
	//...
	
	__asm__ (
		"movl %1, %%eax\n\t"
		"addl %2, %%eax"
		: "=a" (result)
		: "r" (a), "r" (b)
	);
}
```

Кстати, на использование регистров rax и прочих 64-битных компилятор ругается, что говорит нам о том, что мы находимся в 32-битном окружении. 

Ну вот, теперь. после несложных упражнений можно перейти к делу.

Нам потребуется вот такая нехитрая функция, тут одна команда всего:

```assembly
uint64_t rdtsc() {
	uint32_t low, high;
	__asm__ __volatile__ (
		"rdtsc" 
		: "=a" (low), "=d" (high)
	);
	return ((uint64_t)high << 32) | low;
}
```

Заметьте, что тут добавлено __volatile__, это нужно так как формально компилятор имеет право переставлять инструкции, не влияя на результат, а нам как раз важно чтобы rdtsc была вызвана именно там, где мы просим. Тут у читателя может возникнуть закономерный вопрос "а нафига все эти пляски с ассемблером, ведь мы можем воспользоваться готовой __rdtsc(), просто подключив  x86intrin.h или x86gprintrin.h, (но не ia32intrin.h)"? Да, можем, но только в свежей Automation Studio 6, в которой наконец-то обновили gcc, а вот в Automation Studio 4 этого заголовочного файла просто нет, а только она и поддерживает устаревший ПЛК, что лежит у меня на столе. Ну и ассемблер — это же всегда весело, тут вы с процессором один-на-один.

Делаем несложную программку CycleTime:

```
#include <bur/plctypes.h>
#include <inttypes.h>

#ifdef _DEFAULT_INCLUDES
	#include <AsDefault.h>
#endif

static uint64_t cycles, cycles_saved;

uint64_t rdtsc() {
	uint32_t low, high;
	__asm__ __volatile__(
		"rdtsc" 
		: "=a" (low), 
		"=d" (high)
	);
	return ((uint64_t)high << 32) | low;
}

void _INIT ProgramInit(void)
{
	cycles_saved = rdtsc();

}

void _CYCLIC ProgramCyclic(void)
{
	cycles = rdtsc();
	CycleTimeTicks = (UDINT)(cycles - cycles_saved);
	cycles_saved = cycles;
}

void _EXIT ProgramExit(void) { }
```

 и кладём её в цикл в одну секунду

![image-20241217173342389](assets/image-20241217173342389.png)

Теперь надо как-то вытащить данные наружу (мне хочется иметь график). В принципе в Automation Studio есть встроенный профилировщик, но он выносит мне мозг, я хочу просто получить значения переменной.

Самый простой способ - просто поднять OPC UA сервер и забрать данные подходящим клиентом:

![image-20241217180047975](assets/image-20241217180047975.png)

И подключаем нашу переменную:

![image-20241217180156327](assets/image-20241217180156327.png)

Это всё. У любого АСУ ТП инженера в ящике с инструментарием валяется OPC UA клиент, обычно пользуются UA Expert:

![image-20241217180625699](assets/image-20241217180625699.png)

Теперь мне проще всего взять LabVIEW с OPC UA тулкитом и набросать вот такую оснастку:

![](assets/opcua.png)

И вот мой график количества циклов:

![image-20241217180702994](assets/image-20241217180702994.png)

Среднее значение количества тактов при 1 секундом цикле в 1593440000 намекает мне, что частота шины там 99.59 МГц (), так как 16 * 99590000 даст мне ровно то самое значение. Время цикла слегка потрясывет на плюс минус десяток тысяч тактов, но эта тысячная доля процента вообще ни о чём, вы никогда в жизни не получите такого устойчивого значения под Виндовс. Реалтайм есть реалтайм. В принципе эта тенденция будет сохраняться и при уменьшении времени цикла. На минимальном времени в сто микросекунд у нас будет 160000 тактов на цикл, но я не буду утомлять читателя ненужными цифрами.

Давайте прикинем производительность камушка. В качестве референсного кода я возьму [вот эту реализацию SHA256 на чистом Си](https://github.com/B-Con/crypto-algorithms/blob/master/sha256.c) и просто скопирую файл и заголовок в проект как есть (чуть поправив типы данных, чтобы не было предупреждений), собственно и всё. Вы, кстати, пробовали вычислить SHA256 на сименсовском ПЛК? Нет ничего невозможного, но таки придётся повозиться.

Собственно вычисление производится в три строчки, которые я обложу контролем времени:

```с
#include "sha256.h"
static long long begin, begin_saved, end;

void _INIT ProgramInit(void)
{
	int i; //C99
	for(i = 0; i< sizeof(buffer); i++) buffer[i] = 'a';
}

void _CYCLIC ProgramCyclic(void)
{
	SHA256_CTX ctx;

	begin = rdtsc();
	cycle_time = (LREAL)(begin - begin_saved);
	begin_saved = begin;
	
	sha256_init(&ctx);
	sha256_update(&ctx, buffer, sizeof(buffer));
	sha256_final(&ctx, digest);

	end = rdtsc();
	cpu_time_used = ((LREAL)(end - begin));

	MBperSec = cycle_time / cpu_time_used;
}
```

Буфер я заведу размером в мегабайт (точнее в мебибайт, если уж быть дотошным) и заполню его буквами "а". На моём десктопе этот код, будучи скомпилированным самым свежим gcc выдаёт на гора около двухсот мегабайт в секунду. Посмотрим, что будет на атомном ПЛК.

<РЕЗУЛьТАТ>

Ну, как я это называю, камушек с TDP в четыре с половиной ватта и работатет на те самые четыре с полдовиной ватта. Чудес не бывает, реалтайм это не про скорость, это про детерминированность.

### Стреляем себе в ноги

Тут мой коллега, поглядев на мои эксперименты, заявил, что мол как-же так - GKR - это типа эталон надёжности, а ты его на Си, можно ж "выстрелить себе в ногу" как это нынче модно говорить. Понятное дело, что ассемблерными вставками я могу отстрелить себе вообше всё что угодно, но давайте попробуем.

### Идём в Плюсплюсы

---



https://habr.com/ru/articles/209290/
