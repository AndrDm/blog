Вашему вниманию предлагается статья про использование сетей сортировки для быстрого поиска медианы в массивах небольшого размера (до восьми элементов), и практическая реализация с использованием SIMD команд. Информация под катом будет интересна программирующим на LabVIEW как метод увеличения производительности, но также может быть интересна широкому кругу читателей.

---

Как обычно, для экономии времени читателям — ниже мы реализуем поиск медианы различными способами, попробуем в деле шесть-семь разных компиляторов, скомпилировав на них библиотеку DLL и замерим полученную производительность, заглянем в потрошки компилята и потрогаем SIMD вплоть до AVX-512. Будет умеренное количество LabVIEW кода (но очень простого), много Си и чутка ассемблера.

### Постановка задачи

Прежде всего — зачем всё это вообще нужно. Я работаю с рентгеновскими детекторами. По сути это большой мега-фуллфрейм чёрно-белый фотоаппарат (до 40х40 см), на матрицу которого наклеен сцинтиллятор, который светится под рентгеном. Беда в том, что техпроцесс несовершенен и там бывают битые пиксели. Они могут быть как одиночные, так и целая линия может быть «выбита», если транзистор на линии чтения отъехал в иной мир. Эти пиксели могут всегда выдавать одинаковое значение (нуль или максимум), а также могут быть «горячими» или «холодными» (они считаются таковыми, если их интенсивность лежит за границами 60-130%), также могут быть сильношумящими или нелинейными, в общем есть куча стандартизированных критериев для их отбраковки, определяемых ASTM(1). Корректируются эти пиксели обычно усреднением значений интенсивности их «хороших» соседей. Для одиночного пиксела таких соседей, очевидно, будет восемь. Если это линия, то на каждой точке по линии хороших соседей будет шесть. Если таких соседей будет меньше пяти (скажем это перекрёсток двух линий, либо несколько битых пикселей неудачно слепились в кластер), то они называются CKP(2), детектор считается бракованным, и неприменим для некоторых критичных приложений (например проверка турбинных лопаток в авиации). Пользователь также должен знать, какие пикселы скорректированы, для этого в DICONDE(3) картинке к сырым данным картинки прилепляется пара масок — какие пикселы битые и где соседей меньше пяти. Есть такие пикселы и в бытовых камерах, также и в смартофонах и планшетах, просто вы их не видите, они скорректированы на заводе. Иногда не все, и часть могут быть «горячие», они видны как цветные точки , и та же RAW Therapee умеет их находить и корректировать. В обычном детекторе (разрешение которого до 4096х4096) их могут быть тысячи, а то и десятки тысяч. Хотя прогресс идёт, я видел детекторы с десятками пикселов.

Тупое усреднение соседей битых пикселей в общем работает, но есть нюанс. Дело в том, что они могут становиться слегка видимыми на сильных градиентах интенсивности, либо вызывать артефакты реконструкции, если такой детектор используется в томографии. И вот тогда замена среднего медианой может помочь.

Для демонстрации эффекта я возьму типичную ретгеновскую картинку, и накину на неё синтетическую маску-сетку таких пикселей:

Пока всё вроде хорошо.

Но теперь я применю к этой картинке агрессивный фильтр увеличения контрастности. Такие фильтры используются, поскольку картинка шестнадцатибитная, я не могу отобразить 65536 градаций одномоментно (да и глаз не увидит), поэтому диапазон «сжимается». Конкретно ниже - это результат вейвлет преобразования, где уровни пропущены через таблицы преобразования яркостей:

И вот теперь если я сильно увеличу левый верхний угол, то увижу «волосяные» линии корректированных писелей.

Да оно в общем и понятно почему происходит — если у меня есть сильный градиент (а я специально пересветил картинку, увеличив экспозицию и ток трубки), то пять пикселей будет на свету, и только три в темноте, что даст мне тёмный «прыщик», которого не будет, если взять медиану, ибо для медианы будет взято два из пяти светлых и лишь они будут усреднены, а не все. Медианная фильтрация сохраняет границы, этим всё сказано.

Всё бы ничего, но мне также это надо делать быстро. Дело в том, что детектор висит на оптоволокне либо десятигигабитном сетевом адаптере, и гонит этак двадцать-тридцать кадров в секунду. Соответственно у меня есть лишь несколько миллисекунд на всё про всё. Также надо заметить, что лишь коррекцией битых пикселов дело не ограничивается, также идёт компенсация разного усиления, виньетирования, ну и фильтры тоже можно применять в реальном времени, так что каждая сохранённая микросекунда  даст нам больше свободы во всей цепочке алгоритмов, через цепь которых проходят сырые данные от детектора до отображения на экране.