<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='pfpe.htm source file'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>pfpe.htm source file</title>
</head>
<body class='EASOURCE' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>pfpe.htm
<br/><i>Structures</i>
<br/><a href="#PFPE_DATA_DIRECTORY">PFPE_DATA_DIRECTORY</a>
<br/><a href="#PFPE_EXPORT_DIRECTORY">PFPE_EXPORT_DIRECTORY</a>
<br/><a href="#PFPE_IDATA_MAP">PFPE_IDATA_MAP</a>
<br/><a href="#PFPE_IMPORT_DESCRIPTOR">PFPE_IMPORT_DESCRIPTOR</a>
<br/><a href="#PFPE_OPTIONAL_HEADER32">PFPE_OPTIONAL_HEADER32</a>
<br/><a href="#PFPE_OPTIONAL_HEADER64">PFPE_OPTIONAL_HEADER64</a>
<br/><a href="#PFPE_BASERELOC">PFPE_BASERELOC</a>
<br/><i>Encodings</i>
<br/><a href="#PFPE_encodings">PFPE_encodings</a>
<br/><i>Procedures</i>
<br/><a href="#PfpeBaserelocCreate">PfpeBaserelocCreate</a>
<br/><a href="#PfpeBaserelocFixup">PfpeBaserelocFixup</a>
<br/><a href="#PfpeCompile">PfpeCompile</a>
<br/><a href="#PfpeExportCreate">PfpeExportCreate</a>
<br/><a href="#PfpeExportFixup">PfpeExportFixup</a>
<br/><a href="#PfpeImportCreate">PfpeImportCreate</a>
<br/><a href="#PfpeImportFixup">PfpeImportFixup</a>
<br/><a href="#PfpeLoadStubFile">PfpeLoadStubFile</a>
<br/><a href="#PfpeLoadPgm">PfpeLoadPgm</a>
<br/><a href="#PfpeOptionalHeader">PfpeOptionalHeader</a>
</h1>
<p>This source PFPE generates EuroAssembler output executable file in program format PE. as described in
<a class="EXTL" href="../eadoc/links.htm#MS_PECOFF">[MS_PECOFF]</a>.</p>
<br class="CLEAR"/>
<pre>
     EUROASM NOWARN=2101
pfpe PROGRAM FORMAT=COFF,MODEL=FLAT,WIDTH=32
     INCLUDEHEAD euroasm.htm, \  Interface (structures, symbols and macros) of other modules used in this source.
                 ea.htm,eaopt.htm,exp.htm,msg.htm,pf.htm,pfcoff.htm,pfmz.htm,pgm.htm, \
                 pgmopt.htm,reloc.htm,sss.htm,stm.htm,sym.htm
</pre><pre>
 pfpe HEAD ; Start module interface.
</pre>

<dl id="PFPE_DATA_DIRECTORY"><dt><a href="#top">&uarr; PFPE_DATA_DIRECTORY</a></dt>
<dd>Substructure used in <a href="#PFPE_OPTIONAL_HEADER32">PFPE_OPTIONAL_HEADER32</a>.DataDirectory</dd></dl><pre>
PFPE_DATA_DIRECTORY STRUC
 .VirtualAddress D DWORD ; RVA of the table (relative to ImageBase).
 .Size           D DWORD ; Number of bytes in the directory table.
 ENDSTRUC PFPE_DATA_DIRECTORY
</pre>

<dl id="PFPE_OPTIONAL_HEADER32"><dt><a href="#top">&uarr; PFPE_OPTIONAL_HEADER32</a></dt>
<dd>32bit COFF optional header used in image files (PE,DLL).</dd></dl><pre>
PFPE_OPTIONAL_HEADER32 STRUC
 .Magic                       D WORD  ; 0x010B=PE executable, 0x0107=ROMimage.
 .MajorLinkerVersion          D BYTE
 .MinorLinkerVersion          D BYTE
 .SizeOfCode                  D DWORD ; Total size of all sections with PURPOSE=CODE.
 .SizeOfInitializedData       D DWORD ; Total size of all sections with PURPOSE=DATA.
 .SizeOfUninitializedData     D DWORD ; Total size of all sections with PURPOSE=BSS.
 .AddressOfEntryPoint         D DWORD ; Entry offset relative to ImageBase, or 0.
 .BaseOfCode                  D DWORD ; Code section offset relative to ImageBase.
 .BaseOfData                  D DWORD ; Data section offset relative to ImageBase.
 .ImageBase                   D DWORD ; Preferred VA of the image, 64K aligned. NT additional fields.
 .SectionAlignment            D DWORD ; Power of 2, must be &gt; .FileAlignment, default=4K.
 .FileAlignment               D DWORD ; Power of 2, 512..64K, default=512.
 .MajorOperatingSystemVersion D WORD  ; Required version of required OS.
 .MinorOperatingSystemVersion D WORD
 .MajorImageVersion           D WORD  ; Version of this image.
 .MinorImageVersion           D WORD
 .MajorSubsystemVersion       D WORD  ; Required version of subsystem.
 .MinorSubsystemVersion       D WORD
 .Win32VersionValue           D DWORD ; Reserved, must be 0.
 .SizeOfImage                 D DWORD ; Size of image loaded in memory, rounded up to .SectionAlignment.
 .SizeOfHeaders               D DWORD ; Size of stub+PE header+section headers, rounded up to .FileAlignment.
 .CheckSum                    D DWORD
 .Subsystem                   D WORD  ; <a class="EXT" href="dict.htm#DictProgramSubsystems">DictProgramSubsystems</a>.Data value.
 .DllCharacteristics          D WORD  ; See <a href="#IMAGE_DLL_CHARACTERISTICS">DLL_CHARACTERSTICS</a> below.
 .SizeOfStackReserve          D DWORD
 .SizeOfStackCommit           D DWORD
 .SizeOfHeapReserve           D DWORD
 .SizeOfHeapCommit            D DWORD
 .LoaderFlags                 D DWORD ; Reserved, must be 0.
 .NumberOfRvaAndSizes         D DWORD ; Number of following .DataDirectory entries.
 .DataDirectory               DS 16*PFPE_DATA_DIRECTORY ; See indexes 0..15 in <a href="#PFPE_encodings">PFPE_encodings</a> below.
  ENDSTRUC PFPE_OPTIONAL_HEADER32 ; Size# = 224 = 0E0h.
</pre>

<dl id="PFPE_OPTIONAL_HEADER64"><dt><a href="#top">&uarr; PFPE_OPTIONAL_HEADER64</a></dt>
<dd>64bit COFF optional header used in image files (PE,DLL).</dd></dl><pre>
PFPE_OPTIONAL_HEADER64 STRUC
 .Magic                         D WORD ;  0x20B=PE32+ (64bit executable).
 .MajorLinkerVersion            D BYTE ; Standard members have identical offsets in 32bit and 64bit versions.
 .MinorLinkerVersion            D BYTE
 .SizeOfCode                    D DWORD
 .SizeOfInitializedData         D DWORD
 .SizeOfUninitializedData       D DWORD
 .AddressOfEntryPoint           D DWORD
 .BaseOfCode                    D DWORD
 ;  .BaseOfData                   DWORD ; Omitted in 64bit version in favour of qword .ImageBase.
 .ImageBase                     D QWORD
 .SectionAlignment              D DWORD
 .FileAlignment                 D DWORD
 .MajorOperatingSystemVersion   D WORD
 .MinorOperatingSystemVersion   D WORD
 .MajorImageVersion             D WORD
 .MinorImageVersion             D WORD
 .MajorSubsystemVersion         D WORD
 .MinorSubsystemVersion         D WORD
 .Win32VersionValue             D DWORD
 .SizeOfImage                   D DWORD
 .SizeOfHeaders                 D DWORD
 .CheckSum                      D DWORD
 .Subsystem                     D WORD
 .DllCharacteristics            D WORD  ; See <a href="#IMAGE_DLL_CHARACTERISTICS">DLL_CHARACTERSTICS</a> below.
 .SizeOfStackReserve            D QWORD ; This and following members have different offsets in 32 and 64bit version.
 .SizeOfStackCommit             D QWORD
 .SizeOfHeapReserve             D QWORD
 .SizeOfHeapCommit              D QWORD
 .LoaderFlags                   D DWORD
 .NumberOfRvaAndSizes           D DWORD
 .DataDirectory                 DS 16*PFPE_DATA_DIRECTORY ; See indexes 0..15 in <a href="#PFPE_encodings">PFPE_encodings</a> below.
 ENDSTRUC PFPE_OPTIONAL_HEADER64 ; Size# = 240 = 0F0h.
</pre>

<dl id="PFPE_BASERELOC"><dt><a href="#top">&uarr; PFPE_BASERELOC</a></dt>
<dd>This structure describes one <dfn>base relocation block</dfn>.
<!---->Dword-aligned blocks are emitted by the linker in <code>[.reloc]</code> section of PE and DLL executable files.
<br/>Base relocation blocks will be used by loader only when the image could not be loaded
<!---->at the preferred ImageBase (4 MB for PE, 256 MB for DLL).
<br/>See also <a class="EXT" href="pfcoff.htm#PFCOFF_RELOCATION">PFCOFF_RELOCATION</a> used in COFF object files, and
<a class="EXT" href="reloc.htm#RELOC">RELOC</a> used internally by €ASM.</dd></dl><pre>
PFPE_BASERELOC STRUC
 .PageRVA    D DWORD ; RVA of raw data which may need base-relocation by this block.
 .BlockSize  D DWORD ; Size of this block of relocations including .PageRVA and .BlockSize.
 .TypeOffset D 0 * WORD ; Variable number of words which combine <a class="EXT" href="pfcoff.htm#PFCOFF_encodings">type</a> and offset in 4+12 bits.
 ENDSTRUC PFPE_BASERELOC
</pre>

<dl id="PFPE_IDATA_MAP"><dt><a href="#top">&uarr; PFPE_IDATA_MAP</a></dt>
<dd>This is an &euro;ASM internal structure which describes contents of PE section
<code>[.idata]</code> created by <a href="#PfpeImportCreate">PfpeImportCreate</a>.
<br/>Each <code>.Offset*</code> member specifies offset of the table within the emitted contents of section
<code>[.idata]</code>.</dd></dl><pre>
PFPE_IDATA_MAP STRUC
.IdataPtr  D DWORD ; Pointer to <a class="EXT" href="sss.htm#SSS">SSS</a> section <code>[.idata]</code>.
.OffsetIAT D DWORD ; Offset of Import Address Table. Always 0.
.OffsetIDT D DWORD ; Offset of Import Descriptor Table.
.OffsetILT D DWORD ; Offset of Import Lookup Table.
.OffsetONT D DWORD ; Offset of Ordinal+Name Table.
.OffsetDNT D DWORD ; Offset of Dll Names Table.
.OffsetSPT D DWORD ; Offset of Stub Proxy Table.
.OffsetEND D DWORD ; Offset of end-of tables, i.e. the size of section <code>[.idata]</code>.
 ENDSTRUC PFPE_IDATA_MAP ; Size# = 32 = 020h.
</pre>

<dl id="PFPE_EXPORT_DIRECTORY"><dt><a href="#top">&uarr; PFPE_EXPORT_DIRECTORY</a></dt>
<dd>COFF export properties, used in <a href="#PfpeExportCreate">PfpeExportCreate</a>.</dd></dl><pre>
PFPE_EXPORT_DIRECTORY STRUC
 .Characteristics    D DWORD ; Reserved, must be 0.
 .TimeDateStamp      D DWORD ; Time when the export data was created.
 .MajorVersion       D WORD  ; User-defined version number of the export.
 .MinorVersion       D WORD  ; Identical with ImageVersion in optional PE header.
 .Name               D DWORD ; RVA of <a href="#PfpeExportCreate">DNT</a> (ASCIIZ DLL name).
 .Base               D DWORD ; Starting ordinal number, always 1.
 .NumberOfFunctions  D DWORD ; Number of DWORD entries in <a href="#PfpeExportCreate">EAT</a> (Export Address Table).
 .NumberOfNames      D DWORD ; Number of DWORD entries in <a href="#PfpeExportCreate">NPT</a> and WORD entries in <a href="#PfpeExportCreate">OPT</a>.
 .AddressOfFunctions D DWORD ; RVA of <a href="#PfpeExportCreate">EAT</a> (Export Address Table).
 .AddressOfNames     D DWORD ; RVA of <a href="#PfpeExportCreate">NPT</a> (Name Pointer Table).
 .AddressOfOrdinals  D DWORD ; RVA of <a href="#PfpeExportCreate">ONT</a> (Ordinal Numbers Table).
 ENDSTRUC PFPE_EXPORT_DIRECTORY ; Size# = 40 = 028h.
</pre>

<dl id="PFPE_IMPORT_DESCRIPTOR"><dt><a href="#top">&uarr; PFPE_IMPORT_DESCRIPTOR</a></dt>
<dd>COFF import properties, used in <a href="#PfpeImportCreate">PfpeImportCreate</a>.</dd></dl><pre>
PFPE_IMPORT_DESCRIPTOR STRUC
 .OriginalFirstThunk    D DWORD ; RVA of the table with name/ordinal for each import. 0 to terminate chain.
 .TimeDateStamp         D DWORD ; Time of the DLL, or 0 until the image is bound.
 .ForwarderChain        D DWORD ; Index of 1st forwarder reference or -1 if no forwarders.
 .Name                  D DWORD ; RVA of ASCIIZ DLL name.
 .FirstThunk            D DWORD ; RVA of IAT. If bound, this IAT has actual addresses.
 ENDSTRUC PFPE_IMPORT_DESCRIPTOR
</pre>

<dl id="PFPE_encodings"><dt><a href="#top">&uarr; PFPE_encodings</a></dt>
<dd>Following symbolic encodings was adopted from Win32 SDK <q>WINNT.h</q>.</dd>
<dt>See also</dt><dd><a class="EXT" href="sss.htm#SssPurposeEnc">SssPurposeEnc</a>.</dl><pre>
; <a href="#PFPE_OPTIONAL_HEADER32">PFPE_OPTIONAL_HEADER32</a>.DataDirectory and <a href="#PFPE_OPTIONAL_HEADER64">PFPE_OPTIONAL_HEADER64</a>.DataDirectory indexes:
pfpeDIRECTORY_ENTRY_EXPORT         =  0   ; Export Directory.
pfpeDIRECTORY_ENTRY_IMPORT         =  1   ; Import Directory.
pfpeDIRECTORY_ENTRY_RESOURCE       =  2   ; Resource Directory.
pfpeDIRECTORY_ENTRY_EXCEPTION      =  3   ; Exception Directory.
pfpeDIRECTORY_ENTRY_SECURITY       =  4   ; Security (certificate) Directory.
pfpeDIRECTORY_ENTRY_BASERELOC      =  5   ; Base Relocation Table.
pfpeDIRECTORY_ENTRY_DEBUG          =  6   ; Debug Directory.
pfpeDIRECTORY_ENTRY_COPYRIGHT      =  7   ; (X86 usage)
pfpeDIRECTORY_ENTRY_ARCHITECTURE   =  7   ; Architecture Specific Data. Must be 0.
pfpeDIRECTORY_ENTRY_GLOBALPTR      =  8   ; RVA of the value in GPTR register.
pfpeDIRECTORY_ENTRY_TLS            =  9   ; TLS Directory.
pfpeDIRECTORY_ENTRY_LOAD_CONFIG    = 10   ; Load Configuration Directory.
pfpeDIRECTORY_ENTRY_BOUND_IMPORT   = 11   ; Bound Import Directory in headers.
pfpeDIRECTORY_ENTRY_IAT            = 12   ; Import Address Table.
pfpeDIRECTORY_ENTRY_DELAY_IMPORT   = 13   ; Delay Load Import Descriptors.
pfpeDIRECTORY_ENTRY_CLR            = 14   ; CLR Runtime descriptor.

; <a id="IMAGE_DLL_CHARACTERISTICS" href="#PFPE_OPTIONAL_HEADER32">PFPE_OPTIONAL_HEADER32</a>.DllCharacteristic.
pfpeDLLCHARACTERISTICS_HIGH_ENTROPY_VA       = 0x0020 ; ASLR with 64 bit address space.
pfpeDLLCHARACTERISTICS_DYNAMIC_BASE          = 0x0040 ; The DLL can be relocated at load time.
pfpeDLLCHARACTERISTICS_NO_SEH                = 0x0400 ; The image does not use structured exception handling (SEH).
pfpeDLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000 ; The image is terminal server aware.


; <a href="#PFPE_BASERELOC">PFPE_BASERELOC</a>.TypeOffset base-relocation width specifiers:
pfpeREL_BASED_ABSOLUTE EQU  0 << 12 ; Empty relocation used to pad a block.                      ;>>
pfpeREL_BASED_LOW      EQU  2 << 12 ; Relocate the  word at Offset.                              ;>>
pfpeREL_BASED_HIGHLOW  EQU  3 << 12 ; Relocate the dword at Offset.                              ;>>
pfpeREL_BASED_DIR64    EQU 10 << 12 ; Relocate the qword at Offset.                              ;>>
</pre>

<pre>
 ENDHEAD pfpe  ; End of module interface.
</pre> 

<dl id="PfpeOptionalHeader">
<dt><a href="#top">&uarr; PfpeOptionalHeader</a> OptionalHeader, PgmPtr</dt>
<dd><dfn>PfpeOptionalHeader</dfn> will initizalize PE optional header structure of PE or DLL format
<!---->and set those members which can be derived from program specified with PgmPtr
<!---->at the moment of executable file construction.</dd>
<dt>Input</dt>
<dd><b>OptionalHeader</b> is pointer to <a href="#PFPE_OPTIONAL_HEADER32">PFPE_OPTIONAL_HEADER32</a> or
<a href="#PFPE_OPTIONAL_HEADER64">PFPE_OPTIONAL_HEADER64</a> object, allocated by the caller.
<br/>Which of the both classes will be actually used depends on program width.
<br/><b>PgmPtr</b> Pointer to the compiled <a class="EXT" href="pgm.htm#PGM">PGM</a>.</dd>
<dt>Output</dt>
<dd>Following members of OptionalHeader are filled: <code>.Magic</code>, <code>.AddressOfEntryPoint</code>,
<!--  <code>.BaseOfCode</code>, <code>BaseOfData</code>, -->
<code>ImageBase</code>, <code>SectionAlignment</code>,
<code>FileAlignment</code>, <code>Subsystem</code>, <code>*Version, SizeOfStack*</code>,
<code>SizeOfHeap*, NumberOfRvaAndSizes</code>.
<br/>Other members are zeroed.
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invoked by</dt>
<dd><a href="#PfpeCompile">PfpeCompile</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a class="EXT" href="sss.htm#SssFindByPurpose">SssFindByPurpose</a>
<a class="EXT" href="sym.htm#SymFindByName">SymFindByName</a>
</dd>
</dl><pre>
PfpeOptionalHeader Procedure OptionalHeader, PgmPtr
    MOV EDI,[%OptionalHeader]
    MOV EBX,[%PgmPtr]
    Clear EDI,Size=SIZE#PFPE_OPTIONAL_HEADER64 ; Clear the longer variant.
    ; <b>PFPE_OPTIONAL_HEADER32.Magic</b>.
    MOV CX,0x020B                              ; 64bit execu`table.
    JSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.10:
    MOV CX,0x010B                              ; 32bit executable.
.10:MOV [EDI+PFPE_OPTIONAL_HEADER32.Magic],CX
    ; <b>PFPE_OPTIONAL_HEADER32.AddressOfEntryPoint</b>.
    MOV ECX,[EBX+PGM.Pgmopt.EntrySize]
    MOV ESI,[EBX+PGM.Pgmopt.EntryPtr]
    TEST ECX
    JNZ .12:
    JSt [EBX+PGM.Pgmopt.Status],pgmoptExportable,.19: ; PROGRAM ENTRY is optional in DLL format.
    Msg '7710'                                 ; "PROGRAM ENTRY=" is mandatory in this program format.
.11:; Find the surrogate ENTRY as the bottom of the first CODE section. This will make PE valid in spite of E7710.
    Invoke EaBufferReserve::,%^PROC
    Invoke SssFindByPurpose::,sssSegment,sssPurposeCODE,sssNotBSS,0,EBX,EAX
    BufferRetrieve EAX
    Invoke EaBufferRelease::,EAX
    TEST ECX
    JZ .19:
    MOV ECX,[ESI]                              ; ECX is the first CODE section.
    XOR EAX,EAX
    XOR EDX,EDX
    JMP .17:
.12:StripColons ESI,ECX                        ; ESI,ECX is the raw ENTRY= value.
    Invoke SymFindByName::, symPublic,ESI,ECX,EBX
    JNC .15:
    Invoke SymFindByName::, symWeak,ESI,ECX,EBX
    JNC .15:
    LEA EAX,[EBX+PGM.Pgmopt.EntryPtr]
    Msg '7711',EAX                             ; "PROGRAM ENTRY=!1S" symbol was not found.
    JMP .11:                                   ; Use the bottom of CODE section instead.
.15:MOV ECX,[EAX+SYM.Section]                  ; Entry symbol EAX was found.
    MOV EDX,[EAX+SYM.OffsetHigh]
    MOV EAX,[EAX+SYM.OffsetLow]
.17:JECXZ .18:
    ADD EAX,[ECX+SSS.BottomLow]
    ADC EDX,[ECX+SSS.BottomHigh]               ; EDX:EAX is now VA or entry point.
    SUB EAX,[EBX+PGM.Pgmopt.ImageBaseLow]      ; Convert to RVA.                                 ;
    SBB EDX,[EBX+PGM.Pgmopt.ImageBaseHigh]                                                       ;
    JZ .18:
    LEA EAX,[EBX+PGM.Pgmopt.EntryPtr]
    Msg '7712',EAX                             ; "PROGRAM ENTRY=!1S" is above 4 GB. Ignored.
    SUB EAX,EAX
.18:MOV [EDI+PFPE_OPTIONAL_HEADER32.AddressOfEntryPoint],EAX
.19:; <b>PFPE_OPTIONAL_HEADER32 | PFPE_OPTIONAL_HEADER64</b> standard members.
    MOV EAX,[EBX+PGM.Pgmopt.SectionAlign]
    MOV EDX,[EBX+PGM.Pgmopt.FileAlign]
    MOV [EDI+PFPE_OPTIONAL_HEADER32.SectionAlignment],EAX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.FileAlignment],EDX
    MOV EAX,[EBX+PGM.Pgmopt.MinorOsVersion]
    MOV EDX,[EBX+PGM.Pgmopt.MajorOsVersion]
    MOV [EDI+PFPE_OPTIONAL_HEADER32.MinorOperatingSystemVersion],AX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.MajorOperatingSystemVersion],DX
    MOV EAX,[EBX+PGM.Pgmopt.MinorImageVersion]
    MOV EDX,[EBX+PGM.Pgmopt.MajorImageVersion]
    MOV [EDI+PFPE_OPTIONAL_HEADER32.MinorImageVersion],AX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.MajorImageVersion],DX
    MOV EAX,[EBX+PGM.Pgmopt.MinorSubsystemVersion]
    MOV EDX,[EBX+PGM.Pgmopt.MajorSubsystemVersion]
    MOV [EDI+PFPE_OPTIONAL_HEADER32.MinorSubsystemVersion],AX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.MajorSubsystemVersion],DX
    MOV EAX,[EBX+PGM.Pgmopt.MinorLinkerVersion]
    MOV EDX,[EBX+PGM.Pgmopt.MajorLinkerVersion]
    MOV [EDI+PFPE_OPTIONAL_HEADER32.MinorLinkerVersion],AL
    MOV [EDI+PFPE_OPTIONAL_HEADER32.MajorLinkerVersion],DL
    MOV ECX,[EBX+PGM.Pgmopt.Win32VersionValue]
    MOV EAX,[EBX+PGM.Pgmopt.Subsystem]
    MOV EDX,[EBX+PGM.Pgmopt.DllCharacteristics]
    MOV [EDI+PFPE_OPTIONAL_HEADER32.Win32VersionValue],ECX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.Subsystem],AX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.DllCharacteristics],DX
    ; <b>PFPE_OPTIONAL_HEADER32 | PFPE_OPTIONAL_HEADER64</b> version-specific members.
    MOV EAX,[EBX+PGM.Pgmopt.ImageBaseLow]
    MOV EDX,[EBX+PGM.Pgmopt.ImageBaseHigh]
    MOV ECX,16                                 ; Number of data directory records in optional header.
    JSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.60:
    MOV [EDI+PFPE_OPTIONAL_HEADER32.ImageBase],EAX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.NumberOfRvaAndSizes],ECX
    JMP .65:
.60:MOV [EDI+PFPE_OPTIONAL_HEADER64.ImageBase+0],EAX
    MOV [EDI+PFPE_OPTIONAL_HEADER64.ImageBase+4],EDX
    MOV [EDI+PFPE_OPTIONAL_HEADER64.NumberOfRvaAndSizes],ECX
.65:MOV EAX,[EBX+PGM.Pgmopt.SizeOfHeapCommitLow]
    MOV EDX,[EBX+PGM.Pgmopt.SizeOfHeapCommitHigh]
    MOV ECX,[EBX+PGM.Pgmopt.SizeOfHeapReserveLow]
    MOV ESI,[EBX+PGM.Pgmopt.SizeOfHeapReserveHigh]
    JSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.70:
    MOV [EDI+PFPE_OPTIONAL_HEADER32.SizeOfHeapCommit],EAX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.SizeOfHeapReserve],ECX
    JMP .75:
.70:MOV [EDI+PFPE_OPTIONAL_HEADER64.SizeOfHeapCommit+0],EAX
    MOV [EDI+PFPE_OPTIONAL_HEADER64.SizeOfHeapCommit+4],EDX
    MOV [EDI+PFPE_OPTIONAL_HEADER64.SizeOfHeapReserve+0],ECX
    MOV [EDI+PFPE_OPTIONAL_HEADER64.SizeOfHeapReserve+4],ESI
.75:MOV EAX,[EBX+PGM.Pgmopt.SizeOfStackCommitLow]
    MOV EDX,[EBX+PGM.Pgmopt.SizeOfStackCommitHigh]
    MOV ECX,[EBX+PGM.Pgmopt.SizeOfStackReserveLow]
    MOV ESI,[EBX+PGM.Pgmopt.SizeOfStackReserveHigh]
    JSt [EBX+PGM.Pgmopt+PGMOPT.Status],pgmoptWidth64,.80:
    MOV [EDI+PFPE_OPTIONAL_HEADER32.SizeOfStackCommit],EAX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.SizeOfStackReserve],ECX
    JMP .90:
.80:MOV [EDI+PFPE_OPTIONAL_HEADER64.SizeOfStackCommit+0],EAX
    MOV [EDI+PFPE_OPTIONAL_HEADER64.SizeOfStackCommit+4],EDX
    MOV [EDI+PFPE_OPTIONAL_HEADER64.SizeOfStackReserve+0],ECX
    MOV [EDI+PFPE_OPTIONAL_HEADER64.SizeOfStackReserve+4],ESI
.90:EndProcedure PfpeOptionalHeader
</pre>


<dl id="PfpeLoadPgm">
<dt><a href="#top">&uarr; PfpeLoadPgm</a> BasePgm, ObjBegin, ObjEnd, FileNamePtr</dt>
<dd>Executable format PE is not linkable, it cannot be loaded.</dd>
<dt>Input</dt>
<dd><b>BasePgm</b> is pointer to an existing <a class="EXT" href="pgm.htm#PGM">PGM
</a> to which the object file is being linked/imported.
<br/><b>ObjBegin</b> is pointer to the contents of linked/imported object file mapped in memory by the caller.
<br/><b>ObjSize</b> is number of bytes in the object file.
<br/><b>FileNamePtr</b> is pointer to zero-terminated object file name (used in error reports).</dd>
<dt>Output</dt>
<dd>-</dd>
<dt>Error</dt>
<dd>E8534 Format !1S of file "!2$" is not linkable.</dd>
<dt>Invoked from</dt>
<dd><a class="EXT" href="pf.htm#PfLoad">PfLoad</a></dd>
</dl><pre>
PfpeLoadPgm Procedure BasePgm, ObjBegin, ObjSize, FileNamePtr
    Msg '8534',Dict_FormatPE::,[%FileNamePtr]    ; Format !1S of file "!2$" is not linkable.
   EndProcedure PfpeLoadPgm
</pre>

<dl id="PfpeImportCreate">
<dt><a href="#top">&uarr; PfpeImportCreate</a> Program, IdataMapPtr</dt>
<dd><dfn>PfpeImportCreate</dfn> creates a new auxilliary section with name <code>[.idata]
</code> and <code>PURPOSE=IMPORT+IAT</code> in the main Program.
<br/>Division of the section are:
<ol><li><b>IAT</b> (Import Address Table) is a copy of ILT as compiled at link-time.
<!---->It will be fixed up by the loader at bind time
<!---->and the offsets of ONT records will be replaced with absolute DWORD|QWORD pointer
<!---->to the imported function loaded in memory.</li>
<li><b>IDT</b> (Import Descriptor Table) of <a href="#PFPE_IMPORT_DESCRIPTOR">PFPE_IMPORT_DESCRIPTOR
</a> records, one per each imported DLL. The table is terminated with an empty record.</li>
<li><b>ILT</b> (Import Lookup Table) of DWORD|QWORD offsets into ONT,
<!---->one offset per each imported  symbol.
<!---->Offsets are grouped by DLL, after the last import offset of each DLL
<!---->there is a NULL offset which terminates the group.
<br/>Offsets are RVA (related to the ImageBase).</li>
<li><b>ONT</b> (Ordinal+Name Table) is concatenation of 16bit ordinal number
<!---->and ASCIIZ string with symbol name. There is one word-aligned
<!---->Ordinal-Name concatination per each imported symbol.</li>
<li><b>DNT</b> (Dll Names Table) with ASCIIZ names of each used DLL.</li>
<li><b>SPT</b> (Stub Proxy Table) with indirect (dword or qword) absolute
<!---->near jump instruction per import. Each such proxy jump is 7 bytes long and it
<!---->uses DWORD|QWORD pointer in IAT as its indirect DWORD target.
<!---->DWORD target in the body of proxy jump needs relocation if the PE|DLL
<!---->could not be loaded at its preferred ImageBase virtual address at run-time.
<br/>Every reference made to an imported symbol in assembler source
<!---->is in fact referring to this proxy jump inside
<code>[.idata]</code> section.</li></ol>
<p>Type of pointers in ILT and IAT (DWORD|QWORD) is determined by the program width (32|64).</p>
<p>When the section is created, its RVA is not known (
<a class="EXT" href="pgm.htm#PgmLink">PgmLink</a> wasn't invoked yet)
<!---->and pointers in ILT, IAT, IDT are related to RVA=0.
<!---->Hence <a href="#PfpeImportFixup">PfpeImportFixup</a> must be invoked later to fixup the RVAs.</p>
<p>Each import creates a new public symbol with offset pointing to proxy jumps in SPT.</p>
<p>Offsets returned in IdataMapPtr can be used to calculate IMPORT and IAT data directory entries in PE optional header.</p>
<p>Section <code>[.idata]</code> will not be created when no symbol with <code>symImport &amp;&amp; symReferenced</code> is found in program.</p></dd>
<dt>Input</dt>
<dd><b>Program</b> points to PE|DLL <a class="EXT" href="pgm.htm#PGM">PGM</a> which is being linked.
<br/><b>IdataMapPtr</b> is pointer to an empty <a href="#PFPE_IDATA_MAP">PFPE_IDATA_MAP
</a> allocated by the caller, and it will be filled with offsets of section tables.</dd>
<dt>Output</dt>
<dd>New segment <code>[.idata]</code> is created and appended on Program.SssList.
<br/>Output structure at IdataMapPtr is filled with pointers to tables.
<br/>The structure is zeroed and no section is created when the program does not use imported symbols.</dd>
<dt>Error</dt>
<dd>Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>See also</dt>
<dd><a href="#PfpeImportFixup">PfpeImportFixup</a></dd>
<dt>Invoked by</dt>
<dd><a href="#PfpeCompile">PfpeCompile</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferAlign">EaBufferAlign</a>
<a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a class="EXT" href="sss.htm#SssCreateSe">SssCreateSe</a>
<a class="EXT" href="sym.htm#SymLowcaseDll">SymLowcaseDll</a>
</dd>
</dl><pre>
PfpeImportCreate Procedure Program, IdataMapPtr
SssPtr    LocalVar ; Pointer to <a class="EXT" href="sss.htm#SSS">SSS</a> <code>[.idata]</code>.
SymImpBuf LocalVar ; <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> for pointers to imported symbols.
SymPubBuf LocalVar ; Buffer for pointers to new created public symbols.
DllPtrBuf LocalVar ; Buffer with Ptr+Size of DLL names used in imports.
ILTbuffer LocalVar ; Buffer with thunks (dword or qword RVA pointers into ONT).
IDTbuffer LocalVar ; Buffer with PFPE_IMPORT_DESCRIPTOR records.
ONTbuffer LocalVar ; Buffer with 16bit ordinal + ASCIIZ symbol name strings.
DNTbuffer LocalVar ; Buffer with ASCCIZ DLL name strings.
SPTbuffer LocalVar ; Buffer with JMPN instructions to offsets from IAT.
IDTmember LocalVar Size=SIZE# PFPE_IMPORT_DESCRIPTOR ; Temporary record of IDT.
    Invoke EaBufferReserve::,PfpeImportCreate
    MOV [%SymImpBuf],EAX
    Invoke EaBufferReserve::,PfpeImportCreate
    MOV [%SymPubBuf],EAX
    Clear [%IdataMapPtr],Size=SIZE#PFPE_IDATA_MAP
    MOV EBX,[%Program]
    ; <b>Collect import symbols actually used in this program</b> into %SymImpBuf.
    SUB ECX,ECX
    ListGetFirst [EBX+PGM.SymList]
    JZ .25:                                      ; Loop .10: .. .20: collects referenced import symbols.
.10:JNSt [EAX+SYM.Status],symImport,.20:
    BufferStoreDword [%SymImpBuf],EAX
    CMP [EAX+SYM.DllNameSize],ECX
    JNE .20:                                     ; Skip default if the DLL is already specified.
    MOVD [EAX+SYM.DllNamePtr],=B"%EuroasmDefaultDllName"
    MOVD [EAX+SYM.DllNameSize],%EuroasmDefaultDllNameSize
.20:ListGetNext EAX                              ; The next symbol.
    JNZ .10:
.25:BufferRetrieve [%SymImpBuf]
    SHR ECX,2                                    ; ECX=Number of imports.
    JZ .90:                                      ; If no import is used in this program, do not create section [.idata].
    ; <b>Prepare to construct import data</b>.
    Invoke EaBufferReserve::,PfpeImportCreate
    MOV [%DllPtrBuf],EAX
    Invoke EaBufferReserve::,PfpeImportCreate
    MOV [%ILTbuffer],EAX
    Invoke EaBufferReserve::,PfpeImportCreate
    MOV [%IDTbuffer],EAX
    Invoke EaBufferReserve::,PfpeImportCreate
    MOV [%ONTbuffer],EAX
    Invoke EaBufferReserve::,PfpeImportCreate
    MOV [%DNTbuffer],EAX
    Invoke EaBufferReserve::,PfpeImportCreate
    MOV [%SPTbuffer],EAX
    ; <b>Collect used dynamic libraries</b> names into DllPtrBuf in a loop .31: .. .39:.
    ; ESI points to an array of ECX pointers to import symbol.
.31:LODSD                                        ; EAX is now pointer to a referenced import symbol.
    Invoke SymLowcaseDll::,EAX
    MOV EDI,[EAX+SYM.DllNamePtr]
    MOV EDX,[EAX+SYM.DllNameSize]
    PUSH ECX,ESI                                 ; Check if DLL name EDI,EDX already is on DllPtrBuf.
      BufferRetrieve [%DllPtrBuf]
      JECXZ .35:                                 ; If empty, go and store EDI,EDX.
.32:  Compare EDI,EDX,[ESI+0],[ESI+4]
      JE .39:                                    ; Skip when DLL EDI,EDX was already stored.
      ADD ESI,8
      SUB ECX,8
      JNZ .32:                                   ; The next DLL.
.35:  BufferStoreDword [%DllPtrBuf],EDI
      BufferStoreDword [%DllPtrBuf],EDX
.39:POP ESI,ECX
    DEC ECX
    JNZ .31:                                     ; The next import.
    ; <b>Create a new section [idata]</b>.
    MOV ECX,pgmoptWidthMask
    AND ECX,[EBX+PGM.Pgmopt.Status]
    OR ECX,sssSegment+sssNotBSS+sssPrivate+sssUsed
    Invoke SssCreateSe::,[EBX+PGM.CurrentStm],0,=B".idata",6, \
                         ECX,sssPurposeIMPORT+sssPurposeIAT,8
    MsgUnexpected cc=C
    MOV [%SssPtr],EAX                            ; EAX=^SSS - the new [.idata] segment.
    ; <b>Initialize static fields in %IDTmember</b>, based on DLL names collected in %DllPtrBuf.
    LEA EDI,[%IDTmember]                         ; One temporary record of IDT.
    XOR EAX,EAX
    MOV [EDI+PFPE_IMPORT_DESCRIPTOR.TimeDateStamp],EAX ; Always 0.
    DEC EAX
    MOV [EDI+PFPE_IMPORT_DESCRIPTOR.ForwarderChain],EAX ; Always -1.
    ; <b>Create tables for each DLL</b> which is now in %DllPtrBuf.
    BufferRetrieve [%DllPtrBuf]
    TEST ECX
    JZ .80:                                      ; Outer loop .41: .. .59: through all dynamic libraries.
.41:PUSH ECX,ESI                                 ; ESI points to QWORD (Ptr,Size) of DLL name.
      LEA EDI,[%IDTmember]
      PUSH ESI
        BufferRetrieve [%DNTbuffer]
        MOV [EDI+PFPE_IMPORT_DESCRIPTOR.Name],ECX; Future offset of DllName in DNT.
        BufferRetrieve [%ILTbuffer]
        MOV [EDI+PFPE_IMPORT_DESCRIPTOR.OriginalFirstThunk],ECX
        MOV [EDI+PFPE_IMPORT_DESCRIPTOR.FirstThunk],ECX
        BufferStore [%IDTbuffer],EDI,SIZE# PFPE_IMPORT_DESCRIPTOR
      POP ESI
      MOV EDI,[ESI+0]
      MOV EDX,[ESI+4]
      BufferStore [%DNTbuffer],EDI,EDX           ; DLL name.
      BufferStoreByte [%DNTbuffer],0             ; ASCIIZ string terminator.
      ; <b>Handle each symbol imported from current DLL named EDI,EDX</b>.
      BufferRetrieve [%SymImpBuf]
      SHR ECX,2
.42:  LODSD                                      ; Inner loop .42: .. .58: through all symbols from one DLL (EDI,EDX).
      PUSH ECX,EDX,ESI,EDI
        Compare [EAX+SYM.DllNamePtr],[EAX+SYM.DllNameSize],EDI,EDX
        JNE .58:                                 ; Skip symbol EAX when it is not from the current DLL named EDI,EDX.
        ; <b>Create record in ONT (hint-name table)</b>.
        BufferRetrieve [%ONTbuffer]              ; ECX is now offset of record within ONT.
        TEST CL,1
        JZ .43:
        BufferStoreByte [%ONTbuffer],0           ; Word alignment of %ONTbuffer.
        INC ECX
.43:    MOV EDX,[EAX+SYM.OrdinalNr]
        BufferStoreWord [%ONTbuffer],EDX         ; 16bit hint.
        BufferStore [%ONTbuffer],[EAX+SYM.NamePtr],[EAX+SYM.NameSize]
        BufferStoreByte [%ONTbuffer],0           ; ASCIIZ string terminator.
        ; <b>Store dword or qword thunk to ILT</b> (Import Lookup Table).
        JSt [EAX+SYM.Status],symImportedByOrd,.45:
        ; <b>Import by name</b> pointed to by ECX.
        PUSH ECX
          BufferRetrieve [%ILTbuffer]
          MOV EDI,ECX                            ; Store offset of thunk to EDI (0,4,8,,, in PE32 or 0,8,16,24,, in PE64).
        POP ECX
        BufferStoreDword [%ILTbuffer],ECX        ; Relative offset in ONT.
        JNSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.50:
        BufferStoreDword [%ILTbuffer],0          ; PE64 uses qword thunks.
        JMP .50:
.45:    ; <b>Import by ordinal</b> EDX. MSbit must be set in thunk.
        JNSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.46:
        BufferStoreDword [%ONTbuffer],EDX        ; 64bit mode.
        BufferStoreDword [%ONTbuffer],0x8000_0000; Signalize import by ordinal with MSbit.
        JMP .50:
.46:    OR EDX,0x8000_0000
        BufferStoreDword [%ONTbuffer],EDX        ; 32bit mode.
.50:    ; <b>Create public symbol as a copy of the imported symbol EAX</b>. It represents the proxy jump.
        MOV EDX,EAX                              ; Imported symbol.
        ListStore [EBX+PGM.SymList],EAX          ; Save copy of the imported SYM EAX. The new copy is returned in EAX.
        MOV [EDX+SYM.SymbPtr],EAX                ; Let the imported symbol refer to the new public symbol EAX
        SetSt [EDX+SYM.Status],symResolved       ;  and mark it as resolved.
        SetSt [EAX+SYM.Status],symPublic+symImport+symReferenced
        MOV EDX,[%SssPtr]                        ; ^SSS [.idata].
        MOV [EAX+SYM.Section],EDX
        BufferStoreDword [%SymPubBuf],EAX        ; Collect the just created public symbols in SymPubBuf.
        BufferRetrieve [%SPTbuffer]              ; ECX is now offset of proxy jump, relative to SPT.
        MOV [EAX+SYM.OffsetLow],ECX              ; After relocation this will be the pointer to proxy JMPN.
        ; <b>Store proxy jump instruction to SPT</b>. Target of JMPN is specified by EDI (not relocated yet).
        BufferStore [%SPTbuffer],=I"JMPN [0],ADDR=ABS,SCALE=VERBATIM",7
        ; Assembled as <code>FF2425[00000000]</code> in both 32bit and 64bit mode.
        BufferRetrieve [%SPTbuffer]
        LEA ECX,[ESI+ECX-4]                      ; ECX is now pointer to the relocable DWORD <code>[00000000]</code> in SPT.
        ; EDI is stored offset of DWORD|QWORD thunk in ILT (0,4,8,,, or 0,8,16,,, in 64bit mode).
        MOV [ECX],EDI                            ; Rewrite the jump target in the last 4 bytes of JMPN encoding with ILT index.
        ; <b>Create relocation</b> of target IAT in the body of proxy jump instruction.
        MOV EDI,EAX                              ; ^SYM - public symbol in [.idata] segment (proxy jump).
        BufferNew [EDX+SSS.RelocBuffer],SIZE# RELOC ; New absolute relocation record for JMPN's target.
        Clear EAX,Size=SIZE# RELOC
        SetSt [EAX+RELOC.Status],relocAbsVA+relocWidth32
        ; ECX points to disp32 in the encoding of JMPN proxy jump. ESI is bottom of SPT.
        SUB ECX,ESI                              ; Make the pointer to relocated DWORD relative to the start of SPT (which is in ESI).
        MOV [EAX+RELOC.OrgLow],ECX               ; ECX is now 3,10,17,24,,,
        MOV EDX,[%SssPtr]                        ; ^SSS [.idata].
        MOV [EAX+RELOC.Section],EDX
        MOV EDX,[EDX+SSS.SymPtr]                 ; symSe <code>.idata</code>.
        MOV [EAX+RELOC.Symbol],EDX
.58:  POP EDI,ESI,EDX,ECX
      DEC ECX
      JNZ .42:                                   ; The next symbol.
      ; <b>Terminate ILT of this DLL with NULL thunk</b>.
      BufferStoreDword [%ILTbuffer],0
      JNSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.59:
      BufferStoreDword [%ILTbuffer],0
.59:POP ESI,ECX
    ADD ESI,8
    SUB ECX,8
    JNZ .41:                                     ; The next DLL.
    LEA EDI,[%IDTmember]
    MOV ECX,SIZE# PFPE_IMPORT_DESCRIPTOR
    Clear EDI,Size=ECX
    BufferStore [%IDTbuffer],EDI,ECX             ; Use <b>NULL directory entry to terminate IDT</b>.
    Invoke EaBufferAlign::,[%IDTbuffer],8        ; The following ILT should be qword aligned.
    MOV EAX,[%SssPtr]
    ; <b>Populate [.idata] section EAX.EmitBuffer with its tables</b>.
    MOV EDI,[%IdataMapPtr]
    MOV [EDI+PFPE_IDATA_MAP.IdataPtr],EAX        ; Return pointer to just created section [.idata].
    SUB EDX,EDX                                  ; EDX keeps offsets of the tables relative to the bottom of section [.idata].
    MOV [EDI+PFPE_IDATA_MAP.OffsetIAT],EDX       ; Section starts with IAT at offset 0.
    BufferRetrieve [%ILTbuffer]                  ; IAT is identical with ILT at link time.
    ADD EDX,ECX
    BufferStore [EAX+SSS.EmitBuffer],ESI,ECX     ; Store IAT.
    MOV [EDI+PFPE_IDATA_MAP.OffsetIDT],EDX
    BufferRetrieve [%IDTbuffer]
    ADD EDX,ECX
    BufferStore [EAX+SSS.EmitBuffer],ESI,ECX     ; Store IDT.
    MOV [EDI+PFPE_IDATA_MAP.OffsetILT],EDX
    BufferRetrieve [%ILTbuffer]
    ADD EDX,ECX
    BufferStore [EAX+SSS.EmitBuffer],ESI,ECX     ; Store ILT.
    MOV [EDI+PFPE_IDATA_MAP.OffsetONT],EDX
    BufferRetrieve [%ONTbuffer]
    ADD EDX,ECX
    BufferStore [EAX+SSS.EmitBuffer],ESI,ECX     ; Store ONT.
    MOV [EDI+PFPE_IDATA_MAP.OffsetDNT],EDX
    BufferRetrieve [%DNTbuffer]
    ADD EDX,ECX
    BufferStore [EAX+SSS.EmitBuffer],ESI,ECX     ; Store DNT.
    MOV [EDI+PFPE_IDATA_MAP.OffsetSPT],EDX
    BufferRetrieve [%SPTbuffer]
    ADD EDX,ECX
    BufferStore [EAX+SSS.EmitBuffer],ESI,ECX     ; Store SPT.
    MOV [EDI+PFPE_IDATA_MAP.OffsetEND],EDX       ; EDX is now the raw size of [.idata] contents.
    MOV [EAX+SSS.TopLow],EDX
    ; <b>Fixup relocations of dwords in the body of proxy jumps</b>.
    MOV EDX,[EDI+PFPE_IDATA_MAP.IdataPtr]        ; ^SSS <code>[.idata]</code>.
    BufferRetrieve [EDX+SSS.RelocBuffer]
    JECXZ .70:
    MOV EAX,[EDI+PFPE_IDATA_MAP.OffsetSPT]
    SUB EDX,EDX                                  ; EDX:EAX is now the fixup delta.
.62:ADD [ESI+RELOC.OrgLow],EAX
    ADC [ESI+RELOC.OrgHigh],EDX
    ADD ESI,SIZE# RELOC
    SUB ECX,SIZE# RELOC
    JNZ .62:                                     ; The next relocation.
.70:; <b>Fixup offset of created public symbols</b> by SPT offset.
    MOV EDX,[EDI+PFPE_IDATA_MAP.OffsetSPT]
    SUB EDI,EDI                                  ; Fixup delta is EDI:EDX.
    BufferRetrieve [%SymPubBuf]
    SHR ECX,2
    JZ .80:
.71:LODSD
    ADD [EAX+SYM.OffsetLow],EDX
    ADC [EAX+SYM.OffsetHigh],EDI
.79:LOOP .71:
.80:Invoke EaBufferRelease::,[%SPTbuffer]
    Invoke EaBufferRelease::,[%DNTbuffer]
    Invoke EaBufferRelease::,[%ONTbuffer]
    Invoke EaBufferRelease::,[%IDTbuffer]
    Invoke EaBufferRelease::,[%ILTbuffer]
    Invoke EaBufferRelease::,[%DllPtrBuf]
.90:Invoke EaBufferRelease::,[%SymPubBuf]
    Invoke EaBufferRelease::,[%SymImpBuf]
   EndProcedure PfpeImportCreate
</pre>

<dl id="PfpeImportFixup">
<dt><a href="#top">&uarr; PfpeImportFixup</a> Program, OptionalHeaderPtr, IdataMapPtr</dt>
<dd><dfn>PfpeImportFixup</dfn> will update temporary offsets in import section <code>[.idata]
</code>. It is invoked when PE image was linked by
<a class="EXT" href="pgm.htm#PgmLink">PgmLink</a> and section bottoms fixed.
<br/>PfpeImportFixup also specifies RVA and sizes in
<a href="#PFPE_OPTIONAL_HEADER32">Optional Header Data Directory</a> IMPORT and IAT.</dd>
<dt>Input</dt>
<dd><b>PgmPtr</b> is pointer to the compiled and partially linked <a class="EXT" href="pgm.htm#PGM">PGM</a>.
<br/><b>OptionalHeaderPtr</b> is pointer to <a href="#PFPE_OPTIONAL_HEADER32">PFPE_OPTIONAL_HEADER32
</a> whose data directories IMPORT and IAT will be updated.
<!---->When program width is 64, this is the pointer to
<a href="#PFPE_OPTIONAL_HEADER64">PFPE_OPTIONAL_HEADER64</a> instead.
<br/><b>IdataMapPtr</b> is pointer to <a href="#PFPE_IDATA_MAP">PFPE_IDATA_MAP
</a> which have been filled with offsets of section tables by <a href="#PfpeImportCreate">PfpeImportCreate</a>.</dd>
<dt>Output</dt>
<dd>Import data section is updated.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>See also</dt>
<dd><a href="#PfpeImportCreate">PfpeImportCreate</a>.</dd>
<dt>Invoked by</dt>
<dd><a href="#PfpeCompile">PfpeCompile</a>
</dd>
</dl><pre>
PfpeImportFixup Procedure Program, OptionalHeaderPtr, IdataMapPtr
IdataRVA LocalVar                                ; RVA of <code>[.idata]</code> section.
IdataPtr LocalVar                                ; Pointer to the emitted contents of <code>[.idata]</code> section.
    MOV EBX,[%Program]
    MOV EDX,[%IdataMapPtr]
    MOV ESI,[EDX+PFPE_IDATA_MAP.IdataPtr]
    TEST ESI
    JZ .90:                                      ; Skil when section [.idata] wasn't created (no imports in image).
    MOV EAX,[ESI+SSS.BottomLow]                  ; VA of [.idata] in memory at run time.
    SUB EAX,[EBX+PGM.Pgmopt.ImageBaseLow]        ; Convert VA to RVA of IAT.
    MOV [%IdataRVA],EAX
    ; <b>Update data directory entries IAT and IMPORT</b> in optional header.
    MOV EDI,[%OptionalHeaderPtr]
    MOV ECX,[EDX+PFPE_IDATA_MAP.OffsetIDT]       ; ECX is now the size of IAT.
    JSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.10:
    ; <b>32bit program</b>.
    MOV [EDI+PFPE_OPTIONAL_HEADER32.DataDirectory+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_IAT+PFPE_DATA_DIRECTORY.VirtualAddress],EAX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.DataDirectory+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_IAT+PFPE_DATA_DIRECTORY.Size],ECX
    ADD EAX,ECX ; EAX is now RVA of IDT.
    MOV ECX,[EDX+PFPE_IDATA_MAP.OffsetEND]
    SUB ECX,[EDX+PFPE_IDATA_MAP.OffsetIDT] ; ECX is now size of IDT+ILT+ONT+DNT+SPT.
    MOV [EDI+PFPE_OPTIONAL_HEADER32.DataDirectory+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_IMPORT+PFPE_DATA_DIRECTORY.VirtualAddress],EAX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.DataDirectory+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_IMPORT+PFPE_DATA_DIRECTORY.Size],ECX
    JMP .20:
.10:; <b>64bit program</b>.
    MOV [EDI+PFPE_OPTIONAL_HEADER64.DataDirectory+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_IAT+PFPE_DATA_DIRECTORY.VirtualAddress],EAX
    MOV [EDI+PFPE_OPTIONAL_HEADER64.DataDirectory+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_IAT+PFPE_DATA_DIRECTORY.Size],ECX
    ADD EAX,ECX ; EAX is now RVA of IDT.
    MOV ECX,[EDX+PFPE_IDATA_MAP.OffsetEND]
    SUB ECX,[EDX+PFPE_IDATA_MAP.OffsetIDT]       ; ECX is now the size of IDT+ILT+ONT+DNT+SPT.
    MOV [EDI+PFPE_OPTIONAL_HEADER64.DataDirectory+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_IMPORT+PFPE_DATA_DIRECTORY.VirtualAddress],EAX
    MOV [EDI+PFPE_OPTIONAL_HEADER64.DataDirectory+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_IMPORT+PFPE_DATA_DIRECTORY.Size],ECX
.20:BufferRetrieve [ESI+SSS.EmitBuffer]          ; ESI,ECX is now the contents of IAT+IDT+ILT+ONT+DNT+SPT.
    MOV [%IdataPtr],ESI
   ; <b>Fixup Import Address Table</b>.
    MOV ECX,[EDX+PFPE_IDATA_MAP.OffsetIDT]
    ADD ECX,ESI ; ESI..ECX is now contents of IAT.
    MOV EDI,[EDX+PFPE_IDATA_MAP.OffsetONT]
    ADD EDI,[%IdataRVA]                          ; EDI is now delta fixup of dwords/qwords in IAT.
    JSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.40:
    ; <b>32bit program</b>.
    MOV EAX,[ESI+0]
    TEST EAX
    JS .28:                                      ; Do not fixup when imported by ordinal (MSbit is set).
    ADD [ESI],EDI                                ; Do not check thunk at the 1st position in IAT on NULL as it legally refers to 0-offset in ONT.
.28:LODSD                                        ; Skip the first thunk.
.30:CMP ESI,ECX
    JNB .60:
    LODSD
    TEST EAX
    JNG .30:                                     ; Skip fixup when EAX=0 or when imported by ordinal (MSbit is set).
    ADD [ESI-4],EDI                              ; Perform the fixup.
    JMP .30:
.40:; <b>64bit program</b>.
    MOV EAX,[ESI+0]
    MOV EDX,[ESI+4]
    TEST EDX
    JS .48:                                      ; Do not fixup when imported by ordinal (MSbit is set).
    ADD [ESI+0],EDI                              ; Do not check thunk at the 1st position in IAT on NULL
    ADCD [ESI+4],0                               ;   as it legally refers to 0-offset in ONT.
.48:ADD ESI,8
.50:CMP ESI,ECX
    JNB .60:
    LODSD
    XCHG EAX,EDX
    LODSD
    TEST EAX
    JS .50:                                      ; Skip fixup when imported by ordinal (MSbit is set).
    OR EAX,EDX
    JZ .50:                                      ; Skip fixup when NULL.
    ADD  [ESI-8],EDI
    ADCD [ESI-4],0
    JMP .50:
.60: ; <b>Copy fixed IAT to ILT</b>.
    MOV EDX,[%IdataMapPtr]
    MOV ESI,[EDX+PFPE_IDATA_MAP.OffsetIAT]
    MOV ECX,[EDX+PFPE_IDATA_MAP.OffsetIDT]
    MOV EDI,[EDX+PFPE_IDATA_MAP.OffsetILT]
    SUB ECX,ESI
    SHR ECX,2
    ADD ESI,[%IdataPtr]
    ADD EDI,[%IdataPtr]
    REP MOVSD
    ; <b>Fixup Import Descriptor Table</b>.
    MOV ESI,[%IdataPtr]
    MOV EDI,[%IdataRVA]                          ; Fixup delta to IAT.
    MOV ECX,[EDX+PFPE_IDATA_MAP.OffsetILT]
    MOV EAX,[EDX+PFPE_IDATA_MAP.OffsetDNT]
    ADD ECX,EDI                                  ; Fixup delta to ILT.
    ADD EAX,EDI                                  ; Fixup delta to DNT.
    ADD ESI,[EDX+PFPE_IDATA_MAP.OffsetIDT]
.70:CMPD [ESI+PFPE_IMPORT_DESCRIPTOR.ForwarderChain],-1
    JNE .90:                                     ; Empty record signalizes end of IDT.
    ADD [ESI+PFPE_IMPORT_DESCRIPTOR.OriginalFirstThunk],ECX
    ADD [ESI+PFPE_IMPORT_DESCRIPTOR.Name],EAX
    ADD [ESI+PFPE_IMPORT_DESCRIPTOR.FirstThunk],EDI
    ADD ESI,SIZE# PFPE_IMPORT_DESCRIPTOR
    JMP .70:                                     ; The next import descriptor (one for each imported DLL).
.90:EndProcedure PfpeImportFixup
</pre>

<dl id="PfpeExportCreate">
<dt><a href="#top">&uarr; PfpeExportCreate</a> Program</dt>
<dd><dfn>PfpeExportCreate</dfn> creates a new auxilliary PE/DLL section with name <code>[.edata]
</code> and <code>PURPOSE=EXPORT</code> in the main Program.
<br/>Division of the section are:
<ol><li><b>EDT</b> (Export Directory Table) with one
<a href="#PFPE_EXPORT_DIRECTORY">PFPE_EXPORT_DIRECTORY
</a> structured object. Its members specify other export tables.</li>
<li><b>EAT</b> (Export Address Table) contains DWORD RVA of exported functions (their entry point).</li>
<li><b>NPT</b> (Name Pointers Table) contains DWORD RVA of ASCIIZ function names.</li>
<li><b>ONT</b> (Ordinal Numbers Table) contains WORD ordinal number of function in EAT.</li>
<li><b>DNT</b> (Dll Name Table) contains ASCIIZ strings with DLL name.</li>
<li><b>ENT</b> (Export Names Table) contains a series of ASCIIZ strings with function names.</li>
<li><b>FWD</b> (Forwarded Names Table) contains a series of ASCIIZ strings with forwarded DLL name
<!---->(without extension &quot;dll&quot;) concatenated with function name, e.g.
<code>NTDLL.RtlAllocateHeap</code>.</li>
</ol> Number of objects in NPT and ONT (dwords and words) is the same, they are synchronized.
<!---->Function names in ENT are alphabetically sorted.</dd>
<dt>Input</dt>
<dd><b>Program</b> is pointer to <a class="EXT" href="pgm.htm#PGM">PGM</a>.
<dt>Output</dt>
<dd><b>EAX=</b> pointer to <a class="EXT" href="sss.htm#SSS">SSS</a> segment <code>[.edata]</code> created and appended on Program.SssList.
<br/><b>ECX=</b> offset of ENT related to the start of export section contents.
<br/><b>EDX=</b> offset of FWD related to the start of export section contents.</dd>
<dt>Error</dt>
<dd><b>EAX=ECX=EDX=0</b> when no program symbol is marked as exportable.</dd>
<dt>See also</dt>
<dd><a href="#PfpeExportFixup">PfpeExportFixup</a></dd>
<dt>Invoked by</dt>
<dd><a href="#PfpeCompile">PfpeCompile</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a class="EXT" href="ea.htm#EaBufferSort">EaBufferSort</a>
<a class="EXT" href="sss.htm#SssCreateSe">SssCreateSe</a>
<a class="EXT" href="sym.htm#SymStoreForwarderName">SymStoreForwarderName</a>
</dd>
</dl><pre>
PfpeExportCreate Procedure Program
SymExpBuf LocalVar ; <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> for pointers to exported symbols.
Ordinal   LocalVar ; Ordinal number of the current exported symbol.
EATbuffer LocalVar ; Buffer with RVA of exported symbols.
NPTbuffer LocalVar ; Buffer with RVA of symbol names.
ONTbuffer LocalVar ; Buffer with word ordinal numbers.
DNTbuffer LocalVar ; Buffer with RVA of DLL ASCIIZ names.
ENTbuffer LocalVar ; Buffer with RVA of exported symbol ASCIIZ names.
FWDbuffer LocalVar ; Buffer with RVA of forward-exported Dll.symbol ASCIIZ names.
EDT       LocalVar Size=SIZE#PFPE_EXPORT_DIRECTORY
    XOR EAX,EAX
    MOV [%Ordinal],EAX
    MOV [%ReturnEAX],EAX
    MOV [%ReturnECX],EAX
    MOV [%ReturnEDX],EAX
    Invoke EaBufferReserve::,PfpeExportCreate
    MOV [%SymExpBuf],EAX
    MOV EDI,EAX
    ; <b>Collect exported public symbols actually used in this program</b> into buffer EDI.
    MOV EBX,[%Program]
    ListGetFirst [EBX+PGM.SymList]
    JZ .25:                                      ; Loop .10: .. .20: collecting exports.
.10:JSt [EAX+SYM.Status],symResolved,.20:
    JNSt [EAX+SYM.Status],symExport,.20:
    MOV ECX,[EAX+SYM.SymbPtr]
    TEST ECX
    JNZ .11:
    MOV ECX,EAX
    JMP .14:
.11:MOV EDX,[EAX+SYM.Status]
    SetSt EDX,symResolved
    MOV [EAX+SYM.Status],EDX
    CMPB [ECX+SYM.Status],0
    JNZ .12:
    MOV [ECX+SYM.Status],DL                      ; Inherit symbol type from the resolved one.
.12:SetSt [EAX+SYM.Status],symExport
.14:BufferStoreDword EDI,ECX
.20:ListGetNext EAX
    JNZ .10:
.25:Invoke EaBufferSort::,EDI                    ; Alphabetically by symbol names.
    BufferRetrieve EDI
    SHR ECX,2                                    ; Number of exports.
    JZ .90:                                      ; If no export is used in this program, do not create section.
    ; <b>Prepare to construct export data</b>.
    Invoke EaBufferReserve::,PfpeExportCreate
    MOV [%EATbuffer],EAX
    Invoke EaBufferReserve::,PfpeExportCreate
    MOV [%NPTbuffer],EAX
    Invoke EaBufferReserve::,PfpeExportCreate
    MOV [%ONTbuffer],EAX
    Invoke EaBufferReserve::,PfpeExportCreate
    MOV [%DNTbuffer],EAX
    Invoke EaBufferReserve::,PfpeExportCreate
    MOV [%ENTbuffer],EAX
    Invoke EaBufferReserve::,PfpeExportCreate
    MOV [%FWDbuffer],EAX
    LEA EDI,[%EDT]
    Clear EDI,Size=SIZE#PFPE_EXPORT_DIRECTORY
    MOV EAX,[Ea.Eaopt.TimeStamp::]
    MOV [EDI+PFPE_EXPORT_DIRECTORY.TimeDateStamp],EAX
    MOV EDX,[EBX+PGM.Pgmopt.MajorImageVersion]
    MOV EAX,[EBX+PGM.Pgmopt.MinorImageVersion]
    MOV [EDI+PFPE_EXPORT_DIRECTORY.MajorVersion],DX
    MOV [EDI+PFPE_EXPORT_DIRECTORY.MinorVersion],AX
    INCD [EDI+PFPE_EXPORT_DIRECTORY.Base]        ; Always start with ordinal 1.
    BufferStore [%DNTbuffer],[EBX+PGM.Pgmopt.OutFilePtr],[EBX+PGM.Pgmopt.OutFileSize] ; Compiled DLL name.
    BufferStoreByte [%DNTbuffer],0               ; Zero-terminate the DLL name.
    ; ESI points to ECX DWORD pointers to alphabetically sorted <a class="EXT" href="sym.htm#SYM">SYM</a> objects.
.30:LODSD
    PUSH ECX,ESI
     MOV ESI,EAX                                 ; ESI is now pointer to the exported symbol.
     MOV EAX,[%Ordinal]
     BufferStoreWord  [%ONTbuffer],EAX
     INC EAX
     MOV [%Ordinal],EAX
     MOV [EDI+PFPE_EXPORT_DIRECTORY.NumberOfFunctions],EAX
     MOV [EDI+PFPE_EXPORT_DIRECTORY.NumberOfNames],EAX
     MOV [ESI+SYM.OrdinalNr],EAX
     BufferStoreDword [%EATbuffer],ESI           ; Temporarily store pointer to exported SYM
      ; instead of pointer to the function or instead of pointer to forwarded "DllName.SymbolName".
      ; This will be fixed later in PfpeExportFixup after PgmLinkSegments.
     JNSt [ESI+SYM.Status],symForwarded,.36:
     PUSH ESI                                    ; Forwarded DLL.SymbolName will be stored in FWD.
       BufferRetrieve [%FWDbuffer]
     POP ESI
     MOV [ESI+SYM.NameIndex],ECX                 ; Temporary store forwarder name offset relative to the bottom of FWD
     ; instead of RVA.  This will be fixed later in PfpeExportFixup after PgmLinkSegments.
     Invoke SymStoreForwarderName::,ESI,[%FWDbuffer]
.36: PUSH ESI                                    ; Symbol name will be stored in ENT.
       BufferRetrieve [%ENTbuffer]
     POP ESI
     BufferStoreDword [%NPTbuffer],ECX           ; Temporarily store name offset relative to the bottom of ENT
     ; instead of RVA.  This will be fixed later in PfpeExportFixup after PgmLinkSegments.
     BufferStore [%ENTbuffer],[ESI+SYM.NamePtr],[ESI+SYM.NameSize]
     BufferStoreByte [%ENTbuffer],0              ; Zero-terminate the name string.
.40:POP ESI,ECX
    DEC ECX
    JNZ .30:
    ; <b>Create export section <code>[.edata]</code>.</b>
    Invoke SssCreateSe::,[EBX+PGM.CurrentStm],0,=B'.edata',6, \
          sssSegment+sssNotBSS+sssImplicit+sssPrivate,sssPurposeEXPORT,8
    JC .80:
    MOV [%ReturnEAX],EAX
    ; <b>Populate [.edata] section EAX.EmitBuffer with its divisions</b>.
    MOV EDX,SIZE#PFPE_EXPORT_DIRECTORY
    BufferStore [EAX+SSS.EmitBuffer],EDI,EDX
    MOV EDI,EAX                                  ; EDI is now the section [.edata].
    BufferRetrieve [EDI+SSS.EmitBuffer]
    MOV [ESI+PFPE_EXPORT_DIRECTORY.AddressOfFunctions],EDX ; Temporary offset of EAT in section.
    BufferRetrieve [%EATbuffer]
    BufferStore [EDI+SSS.EmitBuffer],ESI,ECX
    BufferRetrieve [EDI+SSS.EmitBuffer]
    MOV [ESI+PFPE_EXPORT_DIRECTORY.AddressOfNames],ECX     ; Temporary offset of NPT in section.
    BufferRetrieve [%NPTbuffer]
    BufferStore [EDI+SSS.EmitBuffer],ESI,ECX
    BufferRetrieve [EDI+SSS.EmitBuffer]
    MOV [ESI+PFPE_EXPORT_DIRECTORY.AddressOfOrdinals],ECX  ; Temporary offset of ONT in section.
    BufferRetrieve [%ONTbuffer]
    BufferStore [EDI+SSS.EmitBuffer],ESI,ECX
    BufferRetrieve [EDI+SSS.EmitBuffer]
    MOV [ESI+PFPE_EXPORT_DIRECTORY.Name],ECX
    BufferRetrieve [%DNTbuffer]
    BufferStore [EDI+SSS.EmitBuffer],ESI,ECX
    BufferRetrieve [EDI+SSS.EmitBuffer]
    MOV [%ReturnECX],ECX
    BufferRetrieve [%ENTbuffer]
    BufferStore [EDI+SSS.EmitBuffer],ESI,ECX
    BufferRetrieve [EDI+SSS.EmitBuffer]
    MOV [%ReturnEDX],ECX
    BufferRetrieve [%FWDbuffer]
    BufferStore [EDI+SSS.EmitBuffer],ESI,ECX
    BufferRetrieve [EDI+SSS.EmitBuffer]
    MOV [EDI+SSS.TopLow],ECX
.80:Invoke EaBufferRelease::,[%FWDbuffer]
    Invoke EaBufferRelease::,[%ENTbuffer]
    Invoke EaBufferRelease::,[%DNTbuffer]
    Invoke EaBufferRelease::,[%ONTbuffer]
    Invoke EaBufferRelease::,[%NPTbuffer]
    Invoke EaBufferRelease::,[%EATbuffer]
.90:Invoke EaBufferRelease::,[%SymExpBuf]
  EndProcedure PfpeExportCreate
</pre>

<dl id="PfpeExportFixup">
<dt><a href="#top">&uarr; PfpeExportFixup</a> Program,  edataPtr, ENToffset, FWDoffset</dt>
<dd><dfn>PfpeExportFixup</dfn> will update temporary offsets in export section <code>[.edata]
</code>. It is invoked when PE image was linked by
<a class="EXT" href="pgm.htm#PgmLink">PgmLink</a> and section bottoms fixed.</dd>
<dt>Input</dt>
<dd><b>PgmPtr</b> is pointer to the compiled and partially linked <a class="EXT" href="pgm.htm#PGM">PGM</a>.
<br/><b>edataPtr</b> is pointer to <a class="EXT" href="sss.htm#SSS">SSS</a> object <code>[.edata]</code>.
<br/><b>ENToffset</b> is offset of ENT related to the start of <code>[.edata]</code> emit contents.
<br/><b>FWDoffset</b> is offset of FWD related to the start of <code>[.edata]</code> emit contents.</dd>
<dt>Output</dt>
<dd>Export data section is updated.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>See also</dt>
<dd><a href="#PfpeExportCreate">PfpeExportCreate</a>.</dd>
<dt>Invoked by</dt>
<dd><a href="#PfpeCompile">PfpeCompile</a>
</dd>
</dl><pre>
PfpeExportFixup Procedure Program, edataPtr, ENToffset, FWDoffset
edataRVA LocalVar ; RVA of section <code>[.edata]</code> (low dword).
    MOV EDI,[%edataPtr]
    MOV EBX,[%Program]
    TEST EDI
    JZ .90:                                      ; Do nothing when [.edata] was not created.
    MOV EAX,[EDI+SSS.BottomLow]                  ; VA of <code>[.edata]</code>.
    MOV EDX,[EDI+SSS.BottomHigh]
    SUB EAX,[EBX+PGM.Pgmopt.ImageBaseLow]        ; Convert VA to RVA.
    SBB EDX,[EBX+PGM.Pgmopt.ImageBaseHigh]
    Msg cc=NZ,'8525',EDI                         ; Size of segment [!1S] exceeded 4 GB.
    MOV [%edataRVA],EAX                          ; EAX is now fixup delta which will update pointers in export dictionary ESI.
    ; <b>Fixup RVAs in export directory</b>.
    BufferRetrieve [EDI+SSS.EmitBuffer]                    ; Get contents of [.edata] to ESI,ECX.
    MOV EDX,[ESI+PFPE_EXPORT_DIRECTORY.AddressOfNames]     ; Offset of NPT within EmitBuffer.
    MOV EBX,[ESI+PFPE_EXPORT_DIRECTORY.AddressOfFunctions] ; Offset of EAT within EmitBuffer.
    ADD EDX,ESI                                            ; EDX now points to NPT with temporary offsets to ENT.
    ADD [ESI+PFPE_EXPORT_DIRECTORY.Name],EAX
    ADD [ESI+PFPE_EXPORT_DIRECTORY.AddressOfFunctions],EAX
    ADD [ESI+PFPE_EXPORT_DIRECTORY.AddressOfNames],EAX
    ADD [ESI+PFPE_EXPORT_DIRECTORY.AddressOfOrdinals],EAX
    ; <b>Fixup RVAs of function names</b> stored in NPT.
    ; Each pointer in NPT temporarily contains an offset of ASCIIZ string
    ;  related to the start of NPT. So the 1st dword contains 0. Required delta is RVA of ENT.
    MOV EAX,[ESI+PFPE_EXPORT_DIRECTORY.AddressOfFunctions]
    SUB EAX,SIZE#PFPE_EXPORT_DIRECTORY
    ADD EAX,[%ENToffset]                         ; Compute fixup delta value.
    MOV ECX,[ESI+PFPE_EXPORT_DIRECTORY.NumberOfNames]
    JECXZ .30:
.20:ADD [EDX],EAX
    ADD EDX,4                                    ; The next name pointer.
    LOOP .20:

.30:; <b>Fixup function addresses</b> in EAT.
    ; EAT was temporarily populated in PfpeExportCreate with pointers to symbols.
    ; Now they will be replaced with RVA of the symbol (exported function entry).
    MOV EDI,[%Program]
    MOV ECX,[ESI+PFPE_EXPORT_DIRECTORY.NumberOfFunctions]
    JECXZ .90:
    ; EBX is temporary offset of EAT within [.edata]. ESI is pointer to [.edata] contents.
    ADD EBX,ESI                                  ; Pointer to EAT in memory, i.e. table of pointers to exported symbols.
.40:PUSH ECX
     MOV ESI,[EBX]                               ; ESI now points to the exported symbol.
     MOV ECX,[ESI+SYM.Section]
     JSt [ESI+SYM.Status],symForwarded,.50:
     MOV EAX,[ESI+SYM.OffsetLow]
     MOV EDX,[ESI+SYM.OffsetHigh]
     JECXZ .70:                                  ; If a scalar was exported.
     ADD EAX,[ECX+SSS.BottomLow]
     ADC EDX,[ECX+SSS.BottomHigh]                ; EDX:EAX is now VA of the symbol.
     SUB EAX,[EDI+PGM.Pgmopt.ImageBaseLow]
     SBB EDX,[EDI+PGM.Pgmopt.ImageBaseHigh]      ; VA is converted to RVA.
     Msg cc=NZ,'8525',ECX                        ; Size of segment [!1S] exceeded 4 GB.
     JMP .70:
.50: MOV EAX,[ESI+SYM.NameIndex]                 ; Temporary offset within FWD table.
     ADD EAX,[%FWDoffset]                        ; EAX is now the offset of "DLL.FwdSymbol" in [.edata].
     ADD EAX,[%edataRVA]
.70: MOV [EBX],EAX                               ; Update one pointer in EAT.
.80: ADD EBX,4                                   ; Point to the next symbol in EAT.
    POP ECX
    LOOP .40:
.90:EndProcedure PfpeExportFixup
</pre>

<dl id="PfpeBaserelocCreate">
<dt><a href="#top">&uarr; PfpeBaserelocCreate</a> Program</dt>
<dd><dfn>PfpeBaserelocCreate</dfn> creates auxilliary PE/DLL segment <code>[.reloc]</code>
<!---->with base relocations in the main Program. Size of its emitted contents is only
<!---->estimated here into SSS.Top. The actual base relocation blocks will be written
<!---->to section <code>[.reloc]</code> later by <a href="#PfpeBaserelocFixup">PfpeBaserelocFixup
</a>, after bottoms of all sections will have been fixed by <a class="EXT" href="pgm.htm#PgmLink">PgmLink</a>.</dd>
<dt>Input</dt>
<dd>New segment is created and appended on Program.SssList.
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>See also</dt>
<dd><a href="#PfpeBaserelocFixup">PfpeBaserelocFixup</a>.</dd>
<dt>Invoked by</dt>
<dd><a href="#PfpeCompile">PfpeCompile</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="sss.htm#SssCreateSe">SssCreateSe</a>
</dd>
</dl><pre>
PfpeBaserelocCreate Procedure Program
RelocCnt   LocalVar ; Total number of BASERELOC records in Program.
SegmentCnt LocalVar ; Total number of relocable sections in Program.
EmitSize   LocalVar ; Total emitted size of segments with relocations.
    ClearLocalVar
    XOR EAX,EAX
    MOV EBX,[%Program]
    ListGetFirst [EBX+PGM.SssList]
    JZ .90:
.10:JNSt [EAX+SSS.Status],sssSegment,.50:
    BufferRetrieve [EAX+SSS.RelocBuffer]
    JECXZ .50:                                   ; Skip if this segment does not contribute to BASERELOC.
    INCD [%SegmentCnt]
    LEA EDX,[ESI+ECX]                            ; End of RELOC array.
    PUSH ESI
      BufferRetrieve [EAX+SSS.EmitBuffer]
    POP ESI
    ADD [%EmitSize],ECX
.20:CMP ESI,EDX
    JNB .50:
    JNSt [ESI+RELOC.Status],relocAbsVA,.30:
    INCD [%RelocCnt]                             ; Absolute relocation will have a BASERELOC record.
.30:ADD ESI,SIZE#RELOC
    JMP .20:
.50:ListGetNext EAX                              ; The next segment.
    JNZ .10:
    MOV ECX,[%RelocCnt]
    SAL ECX,1                                    ; Each relocation takes 2 bytes.
    JZ .90:
    ; [.reloc] section will be created. Estimate its raw size.
    ; Each PFPE_BASERELOC header takes 8 bytes and it manages 4KB of emitted data.
    MOV EDI,4K
    MOV EAX,[%EmitSize]
    SUB EDX,EDX
    DIV EDI                                      ; EAX is now the maximal possible number of base relocation blocks.
    INC EAX                                      ; Round up.
    ADD EAX,[%SegmentCnt]                        ; Add one more block per each section change.
    LEA EDI,[8*EAX]                              ; Each block takes 8-byte header (SIZE#PFPE_BASERELOC).
    LEA EDI,[EDI+2*EAX]                          ; Add word alignment for each header.
    LEA EDI,[EDI+ECX+32]                         ; Add a small reserve to be safe.
    ; EDI is now estimated [.reloc] section size.
    Invoke SssCreateSe::,[EBX+PGM.CurrentStm],0,=B".reloc",6, \
                         sssSegment+sssWidth32+sssNotBSS+sssImplicit+sssPublic,sssPurposeBASERELOC,4
    MOV [EAX+SSS.TopLow],EDI
.90:EndProcedure PfpeBaserelocCreate
</pre>

<dl id="PfpeBaserelocFixup">
<dt><a href="#top">&uarr; PfpeBaserelocFixup</a> Program, SectionHeaderBuffer</dt>
<dd><dfn>PfpeBaserelocFixup</dfn> fills the emitted contents of auxilliary PE/DLL segment
<code>[reloc]</code> with base relocations in the main Program.
<br/>It is invoked when all relocation have been fixed and resolved in
<a class="EXT" href="pgm.htm#PgmLink">PgmLink
</a>, and all segments ordered in <code>Program.SegOrdBuffer</code>.</dd>
<dt>Input</dt>
<dd><b>Program</b> Pointer to the compiled and partially linked
<a class="EXT" href="pgm.htm#PGM">PGM</a>.
<br/><b>SectionHeaderBuffer</b> is pointer to BUFFER with array of
<a class="EXT" href="pfcoff.htm#PFCOFF_SECTION_HEADER">PFCOFF_SECTION_HEADER</a> records.</dd>
<dt>Output</dt>
<dd>EmitBuffer of segment with <code>PURPOSE=BASERELOC</code> (if found) is filled with
<a href="#PFPE_BASERELOC">PFPE_BASERELOC</a> records.
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invoked by</dt>
<dd><a href="#PfpeCompile">PfpeCompile</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferAlign">EaBufferAlign</a>
<a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
</dd>
</dl><pre>
PfpeBaserelocFixup Procedure Program, SectionHeaderBuffer
SssReloc      LocalVar ; Pointer to SSS [.reloc].
TypeOffsetBuf LocalVar ; Pointer to BUFFER with WORDs of one PFPE_BASERELOC block.
SectionRVA    LocalVar ; RVA of the section bottom.
PageOffset    LocalVar ; Offset of currently processed block relative to section bottom.
    Invoke EaBufferReserve::,PfpeBaserelocFixup
    MOV [%TypeOffsetBuf],EAX
    MOV EBX,[%Program]
    CALL .FlushBlock:                            ; Initialize TypeOffsetBuf and BlockRVA.

    ; <b>First segment pass</b> .10: .. .20: searches for [.reloc] section created by PfpeBaserelocCreate.
    BufferRetrieve [EBX+PGM.SegOrdBuffer]
    SAR ECX,2
    JZ .90:                                      ; If no segments are linked.
.10:LODSD
    JSt [EAX+SSS.Purpose],sssPurposeBASERELOC,.20:
    LOOP .10:
    JMP .90:                                    ; No BASERELOC section exists in PE program (e.g. pure resource DLL).

.20:MOV [%SssReloc],EAX                         ; [.reloc] section was found.
    ; <b>Second segment pass</b> .30: .. .80: handles base relocation from all segments.
    BufferRetrieve [EBX+PGM.SegOrdBuffer]
    SAR ECX,2
.30:LODSD                                       ; Get the next segment.
    JNSt [EAX+SSS.Status],sssSegment,.80:
    PUSHAD
      MOV ECX,[EAX+SSS.BottomLow]               ; Linked VA of the segment (section).
      MOV EDX,[EAX+SSS.BottomHigh]
      SUB ECX,[EBX+PGM.Pgmopt.ImageBaseLow]
      SBB EDX,[EBX+PGM.Pgmopt.ImageBaseHigh]
      Msg cc=NZ,'7922',EAX,ECX                  ; Fixup increment out of 4GB range at [!1S]:!2Hh.
      MOV [%SectionRVA],ECX
      BufferRetrieve [EAX+SSS.RelocBuffer]
      LEA EDX,[ESI+ECX]                         ; End of RELOC array.
.40:  CMP ESI,EDX
      JNB .70:
      JNSt [ESI+RELOC.Status],relocAbsVA,.60:
      ; ESI is (resolved) absolute relocation.
      MOV ECX,~(4K-1)                           ; Mask of PFPE_BASERELOC.PageOffset (0xFFFF_F000).
      AND ECX,[ESI+RELOC.OrgLow]
      CMP ECX,[%PageOffset]                     ; Check if the RELOC ESI is in the same block.
      JE .50:
      CALL .FlushBlock:                         ; Flush the previous block and start a new one.
      MOV [%PageOffset],ECX
.50:  MOV ECX,4K-1                              ; Mask of PFPE_BASERELOC.TypeOffset (0x0000_0FFF).
      AND ECX,[ESI+RELOC.OrgLow]
      MOV EAX,pfpeREL_BASED_HIGHLOW
      JSt [ESI+RELOC.Status],relocWidth32,.55:
      MOV EAX,pfpeREL_BASED_DIR64
      JSt [ESI+RELOC.Status],relocWidth64,.55:
      MOV EAX,pfpeREL_BASED_LOW
      JSt [ESI+RELOC.Status],relocWidth16,.55:
      Msg '7737',[ESI+RELOC.Section],[ESI+RELOC.OrgLow] ; Invalid base relocation at [!1S]:!2H.
      JMP .60:
.55:  OR ECX,EAX                                ; Merge PFPE_BASERELOC.TypeOffset.
      BufferStoreWord [%TypeOffsetBuf],ECX
.60:  ADD ESI,SIZE# RELOC
      JMP .40:                                  ; The next RELOC record.

PfpeBaserelocFixup.FlushBlock: PROC                               ; Write one PFPE_BASERELOC block to section <code>[.reloc]</code>.
    PUSHAD
     Invoke EaBufferAlign::,[%TypeOffsetBuf],4   ; Pad the block with an empty word if they weren't even.
     BufferRetrieve [%TypeOffsetBuf]
     JECXZ .F9:                                  ; If no base relocation appeared in this segment.
     MOV EDI,[%SssReloc]
     MOV EAX,[%PageOffset]
     ADD EAX,[%SectionRVA]
     BufferStoreDword [EDI+SSS.EmitBuffer],EAX
     LEA EAX,[ECX+SIZE# PFPE_BASERELOC]
     BufferStoreDword [EDI+SSS.EmitBuffer],EAX   ; BlockSize.
     BufferStore [EDI+SSS.EmitBuffer],ESI,ECX    ; The block is complete now.
     BufferClear [%TypeOffsetBuf]
.F9: XOR ECX,ECX
     DEC ECX
     MOV [%PageOffset],ECX                       ; Initialize PageOffset with nonexisting address.
    POPAD
    RET
    ENDP PfpeBaserelocFixup.FlushBlock:

.70:  CALL .FlushBlock:
    POPAD
.80:DEC ECX
    JNZ .30:                                   ; The next segment.
    MOV EDI,[%SssReloc]                         ; ^SSS <code>[.reloc]</code>.
    ; Base relocation blocks are now stored in [EDI+SSS.RelocBuffer].
    MOV EAX,[EDI+SSS.SegmIndex]
    MOV ESI,SIZE# PFCOFF_SECTION_HEADER
    DEC EAX                                     ; Segment index is 1-based.
    MsgUnexpected cc=S
    MUL ESI
    BufferRetrieve [%SectionHeaderBuffer]
    ADD ESI,EAX                                 ; ESI is now pointer to section header <code>[.reloc]</code>.
    PUSH ESI
      BufferRetrieve [EDI+SSS.EmitBuffer]       ; The final <code>[.reloc]</code> contents.
    POP ESI                                     ; Update <b>section header</b> with the final size ECX.
    MOV [ESI+PFCOFF_SECTION_HEADER.SizeOfRawData],ECX
    ADD ECX,[EDI+SSS.BottomLow]                 ; Update <b>SSS virtual size</b>.
    MOV [EDI+SSS.TopLow],ECX
.90:Invoke EaBufferRelease::,[%TypeOffsetBuf]
    EndProcedure PfpeBaserelocFixup
</pre>

<dl id="PfpeLoadStubFile">
<dt><a href="#top">&uarr; PfpeLoadStubFile</a> StubBuffer, Pgm</dt>
<dd><dfn>PfpeLoadStubFile</dfn> is invoked when a PE or DLL executable program is linked.
<!---->When program option STUBFILE= defines a file without path, it will search for that file
<!---->in LINKPATH= directories, check MZ format, copy the file contents to StubBuffer and close it.
<br/>If the file is not found, or if STUBFILE= is empty, PfpeLoadStubFile will use built-in default instead.</dd>
<dt>Input</dt>
<dd><b>StubBuffer</b> is pointer to the output empty
<a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a>, reserved by the caller.
<br/><b>Pgm</b>is pointer to the linked <a class="EXT" href="pgm.htm#PGM">PGM</a>.</dd>
<dt>Output</dt>
<dd>StubBuffer if filled with DOS stub.</dd>
<dt>Error</dt>
<dd>Errors E6953, E7741, E7742, E7763 are reported with macro <a class="EXT" href="msg.htm#Msg">Msg
</a>, default stub is used in this case.</dd>
<dt>Depends on</dt>
<dd><a class="EXT" href="pf.htm#PfQueryChar">PfQueryChar</a></dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="eaopt.htm#EaoptGetOnePath">EaoptGetOnePath</a>
</dd>
<dt>Invoked by</dt>
<dd><a href="#PfpeCompile">PfpeCompile</a>
</dd>
</dl><pre>
PfpeLoadStubFile Procedure StubBuffer, Pgm
PathNr    LocalVar                               ; Ordinal number of LINKPATH.
StubFile  LocalVar Size=SIZE# FILE               ; FILE object of the external stub file.
    ClearLocalVar
    MOV ESI,PfcoffStub::                         ; First assume that the <b>default stub</b> built inside euroasm.exe will be used.
    MOV EAX,PfcoffStubEnd::
    SUB EAX,ESI
    BufferStore [%StubBuffer],ESI,EAX
    MOV EBX,[%Pgm]                               ; <b>Check if stub file is explicitly specified</b>.
    MOV EDX,[EBX+PGM.Pgmopt.StubFileSize]
    MOV ESI,[EBX+PGM.Pgmopt.StubFilePtr]
    TEST EDX
    JZ .90:                                      ; If not, we're done.
    PfQueryChar '\'                              ; <b>Query if Filemask ESI,EDX was specified with path</b> (it contains slash or colon).
    JE .50:
    PfQueryChar '/'
    JE .50:
    PfQueryChar ':'
    JE .50:
    SUB EAX,EAX                                  ; When there is no path in STUBFILE=, try all pathes from LINKPATH=.
    MOV [%PathNr],EAX
.20:Invoke EaoptGetOnePath::,[Ea.Eaopt.LinkPathPtr::],[Ea.Eaopt.LinkPathSize::],[%PathNr]
    JC .E7742:                                   ; StubFile=!1$ was not found in LinkPath="!2S".
    INCD [%PathNr]                               ; Prepare for the next path.
    MOV EDX,[EBX+PGM.Pgmopt.StubFileSize]        ; One path is in ESI,ECX.
    LEA EAX,[EDX+ECX+1]
    CMP EAX,260                                  ; MAX_PATH_SIZE
    JA .E6953:                                   ; Size of LinkPath "!1_" + size of filename exceeded 260 characters.
    LEA EDI,[%StubFile+FILE.Name]                ; Assign path+stubfile name to %StubFile.
    REP MOVSB
    MOV AX,'\/'
    CMPB [Ea.EuroasmOS::],'W'                    ; Choose slash or backslash.
    JE .30:
    XCHG AL,AH
.30:CMP AL,[EDI-1]
    JE .40:
    CMP AH,[EDI-1]
    JE .40:
    STOSB                                        ; If the path was not terminated with (back)slash, append it.
.40:MOV ESI,[EBX+PGM.Pgmopt.StubFilePtr]
    MOV ECX,EDX
    REP MOVSB
    SUB EAX,EAX
    STOSB  ; Zero terminate the filename.
    LEA EDI,[%StubFile]                          ; %StubFile is now assigned with path and filemask.
    LEA EDX,[EDI+FILE.Name]
    SysOpenFileMap EDI,EDX
    JC .20:                                      ; If not found, try the next IncludePath.
    JMP .60:
.50:LEA EDI,[%StubFile]
    SysOpenFileMap EDI,ESI,FileNameSize=EDX      ; Path was present in filename ESI, use as is.
    JC .E7741:                                   ; StubFile=!1$ was no found.
.60:MOV ECX,EAX                                  ; Contents of the file is now mapped at ESI,EAX.
    CMP ECX,SIZE#PFMZ_DOS_HEADER
    JNA .E7743:                                  ; Invalid format (file is too short).
    CMPW [ESI],'MZ'
    JNE .E7743:                                  ; Invalid format.
    BufferClear [%StubBuffer]
    BufferStore [%StubBuffer],ESI,ECX
    SysCloseFile EDI
    JMP .90:
.E6953:Msg '6953',ESI                            ; Size of LinkPath "!1_" + size of filename exceeded 256 characters.
       JMP .Error:
.E7741:MOV ESI,[EBX+PGM.Pgmopt.StubFilePtr]
       Msg '7741',ESI                            ; StubFile=!1$ was no found.
       JMP .Error:
.E7742:MOV ESI,[EBX+PGM.Pgmopt.StubFilePtr]
       LEA EAX,[Ea::+EA.Eaopt.LinkPathPtr]
       Msg '7742',ESI,EAX                        ; StubFile=!1$ was no found in LinkPath="!2S".
       JMP .Error:
.E7743:MOV ESI,[EBX+PGM.Pgmopt.StubFilePtr]
       Msg '7743',ESI                            ; Invalid format of StubFile="!1$".
       SysCloseFile EDI
.Error:STC
.90:EndProcedure PfpeLoadStubFile
</pre>

<dl id="PfpeCompile">
<dt><a href="#top">&uarr; PfpeCompile</a> OutputStream, Pgm</dt>
<dd><dfn>PfpeCompile</dfn> is constructor of output PE and DLL 32bit or 64bit executable file in
<em>Microsoft Portable Executable Common Object File Format
</em> as specified in <a class="EXTL" href="../eadoc/links.htm#MS_PECOFF">[MS_PECOFF]</a>.</dd>
<dt>Input</dt>
<dd><b>OutputStream</b> is pointer to a
<a class="EXT" href="../maclib/memory32.htm#STREAM">STREAM</a> for the output file contents.
<br/><b>Pgm</b> is pointer to <a class="EXT" href="pgm.htm#PGM">PGM</a> representing completely assembled and combined program.</dd>
<dt>Output</dt>
<dd>OutputStream is filled with output file contents.</dd>
<dt>Error</dt>
<dd>Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invoked from</dt>
<dd><a class="EXT" href="pf.htm#PfOutput">PfOutput</a></dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferAlign">EaBufferAlign</a>
<a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a class="EXT" href="exp.htm#ExpAlign">ExpAlign</a>
<a class="EXT" href="pfcoff.htm#PfcoffFileHeader">PfcoffFileHeader</a>
<a class="EXT" href="pfcoff.htm#PfcoffSegmCreate">PfcoffSegmCreate</a>
<a class="EXT" href="pfcoff.htm#PfcoffSegmRawData">PfcoffSegmRawData</a>
<a class="EXT" href="pfcoff.htm#PfcoffSymFile">PfcoffSymFile</a>
<a class="EXT" href="pfcoff.htm#PfcoffSymSegment">PfcoffSymSegment</a>
<a class="EXT" href="pfcoff.htm#PfcoffSymSymbol">PfcoffSymSymbol</a>
<a href="#PfpeBaserelocCreate">PfpeBaserelocCreate</a>
<a href="#PfpeBaserelocFixup">PfpeBaserelocFixup</a>
<a href="#PfpeExportCreate">PfpeExportCreate</a>
<a href="#PfpeExportFixup">PfpeExportFixup</a>
<a href="#PfpeImportCreate">PfpeImportCreate</a>
<a href="#PfpeImportFixup">PfpeImportFixup</a>
<a href="#PfpeLoadStubFile">PfpeLoadStubFile</a>
<a href="#PfpeOptionalHeader">PfpeOptionalHeader</a>
<a class="EXT" href="pfrsrc.htm#PfrsrcLoadIconFile">PfrsrcLoadIconFile</a>
<a class="EXT" href="pgm.htm#PgmGroupByModel">PgmGroupByModel</a>
<a class="EXT" href="pgm.htm#PgmLink">PgmLink</a>
<a class="EXT" href="pgm.htm#PgmOrderSegments">PgmOrderSegments</a>
<a class="EXT" href="pgm.htm#PgmRelocResolve">PgmRelocResolve</a>
<a class="EXT" href="pgm.htm#PgmSymResolve">PgmSymResolve</a>
<a class="EXT" href="sym.htm#SymReportUnresolved">SymReportUnresolved</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfdll.htm#PfdllCompile">PfdllCompile</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t9385.htm">t9385</a>
<a class="EXT" href="../eatests/t9436.htm">t9436</a>
</dd>
</dl><pre>
PfpeCompile Procedure OutputStream, Pgm
StubFileBuf        LocalVar ; Pointer to <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> which keeps DOS stub file contents.
SectionHeaderBuf   LocalVar ; Pointer to BUFFER which keeps <a class="EXT" href="pfcoff.htm#PFCOFF_SECTION_HEADER">PFCOFF_SECTION_HEADER</a> objects, one for each segment.
RawBuf             LocalVar ; Pointer to BUFFER for emitted contents and relocations of all segments.
SymbolTableBuf     LocalVar ; Pointer to BUFFER for PFCOFF_SYMBOL records.
StringTableBuf     LocalVar ; Pointer to BUFFER for longname strings.
SectionHeaderPtr   LocalVar ; Pointer to the current <a class="EXT" href="pfcoff.htm#PFCOFF_SECTION_HEADER">PFCOFF_SECTION_HEADER</a> object on SectionHeaderBuf.
FileAddr           LocalVar ; File offset in PE file, updated on-the-fly.
ExportSection      LocalVar ; Pointer to <a class="EXT" href="sss.htm#SSS">SSS</a> with <code>[.edata]</code> section.
ENToffset          LocalVar ; Offset of ENT within export section contents.
FWDoffset          LocalVar ; Offset of FWD within export section contents.
MaxTopHigh         LocalVar ; Maximal SSS.Top of all sections.
MaxTopLow          LocalVar
InputFile          LocalVar Size=SIZE# FILE ; File object for reading stub and icon file.
CoffFileHeader     LocalVar Size=SIZE#PFCOFF_FILE_HEADER ; Room for <a class="EXT" href="pfcoff.htm#PFCOFF_FILE_HEADER">PFCOFF_FILE_HEADER</a> object.
PeOptionalHeader   LocalVar Size=SIZE#PFPE_OPTIONAL_HEADER64 ; Room for <a href="#PFPE_OPTIONAL_HEADER32">PFPE_OPTIONAL_HEADER32</a> or <a href="#PFPE_OPTIONAL_HEADER64">PFPE_OPTIONAL_HEADER64</a>.
IdataMap           LocalVar Size=SIZE# PFPE_IDATA_MAP ; Room for <a href="#PFPE_IDATA_MAP">PFPE_IDATA_MAP</a>.
    MOV EBX,[%Pgm]
    SUB EAX,EAX
    MOV [%MaxTopLow],EAX
    MOV [%MaxTopHigh],EAX
    Invoke EaBufferReserve::,%^PROC              ; <b>Reserve temporary buffers.</b>
    MOV [%SectionHeaderBuf],EAX
    Invoke EaBufferReserve::,%^PROC
    MOV [%RawBuf],EAX
    Invoke EaBufferReserve::,%^PROC
    MOV [%SymbolTableBuf],EAX
    Invoke EaBufferReserve::,%^PROC
    MOV [%StringTableBuf],EAX
    BufferStoreDword EAX,4                       ; Initialize DD StringTableSize in the buffer.
    Invoke EaBufferReserve::,%^PROC
    MOV [%StubFileBuf],EAX
    ; <b>Load DOS MZ stub into its buffer</b>.
    Invoke PfpeLoadStubFile, EAX, EBX
    Invoke EaBufferAlign::,[%StubFileBuf],8      ; The following PE signature should be QWORD aligned.
    MOV EBX,[%Pgm]                               ; <b>Preformat special PECOFF sections</b>.
    LEA EDX,[%IdataMap]
    Invoke PfpeImportCreate,EBX,EDX
    Invoke PfpeExportCreate,EBX
    MOV [%ExportSection],EAX
    MOV [%ENToffset],ECX
    MOV [%FWDoffset],EDX
    Invoke PfpeBaserelocCreate,EBX
    Invoke PfrsrcLoadIconFile::,EBX
    Invoke PgmGroupByModel::,EBX
Invoke PgmOrderSegments::,EBX
    Invoke PgmSymResolve::,EBX
    Invoke SymReportUnresolved::,EBX
.09:BufferRetrieve [%StubFileBuf]                ; Calculate the size of stub+headers into EDX.
    MOV EDX,ECX                                  ; MZ DOS header + stub program size.
    Invoke ExpAlign::,EDX,8,0                    ; The following PE signature should be QWORD aligned.
    ADD EDX,ECX
    ADD EDX,4+SIZE# PFCOFF_FILE_HEADER+SIZE# PFPE_OPTIONAL_HEADER32 ; PE signature + file header + optional header.
    JNSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.11:
    ADD EDX,SIZE# PFPE_OPTIONAL_HEADER64 - SIZE# PFPE_OPTIONAL_HEADER32
.11:BufferRetrieve [EBX+PGM.SegOrdBuffer]
    SHR ECX,2
    JZ .19:
.12:LODSD
    JNSt [EAX+SSS.Status],sssSegment,.13:
    ADD EDX,SIZE# PFCOFF_SECTION_HEADER
.13:LOOP .12:
.19:Invoke PgmLink::,EBX,EDX,EDX
    BufferRetrieve [%StubFileBuf]                ; <b>Construction of output file</b> of program EBX.
    MOV [ESI+PFMZ_DOS_HEADER.e_lfanew],ECX       ; ECX is now aligned DOS stub size. Update the pointer to PE signature.
    MOV [%FileAddr],ECX                          ; Dword <b>PE signature</b> may be temporarily ignored.
    LEA EDI,[%CoffFileHeader]                    ; Initialize <b>COFF file header</b>.
    Invoke PfcoffFileHeader::,EDI,EBX
    MOVZXW ECX,[EDI+PFCOFF_FILE_HEADER.SizeOfOptionalHeader]
    LEA EDI,[%PeOptionalHeader]                  ; Initialize <b>PE optional header</b>.
    Invoke PfpeOptionalHeader,EDI,EBX
    ADD ECX,4+SIZE# PFCOFF_FILE_HEADER           ; Skip PE signature and file header.
    ADDD [%FileAddr],ECX                         ; Now it is FA of the 1st section header.
    LEA EAX,[%IdataMap]
    Invoke PfpeImportFixup,EBX,EDI,EAX
    Invoke PfpeExportFixup,EBX,[%ExportSection],[%ENToffset],[%FWDoffset]
    Invoke PgmRelocResolve::,EBX
    ; <b>Create symbol record ".file".</b>
    LEA EAX,[Ea.SrcFile::]
    Invoke PfcoffSymFile::,EAX,[%SymbolTableBuf]
    ; <b>First segments pass</b> .30: .. .33: updates PFCOFF_FILE_HEADER.NrOfSections,
    ;   stores empty IMAGE_SECTION_HEADER object to [%SectionHeaderBuf] and
    ;   creates segment's symbol record + one auxilliary record to [%SymbolTableBuf]
    BufferRetrieve [EBX+PGM.SegOrdBuffer]        ; Array of pointers to segments, sorted order.
    SHR ECX,2 ; Number of pointers.
    JZ .37:
    LEA EDX,[%CoffFileHeader]
.30:LODSD
    JNSt [EAX+SSS.Status],sssSegment,.33:        ; Skip if EAX is not a segment ("section" in MS terminology}.
    Invoke PfcoffSegmCreate::, EAX, [%Pgm],[%SectionHeaderBuf],EDX    ; Create one section header.
    MOV EAX,[EAX+SSS.SymPtr]
    Invoke PfcoffSymSegment::,EAX,[%SymbolTableBuf],[%StringTableBuf] ; Create symbol assigned to the section EAX.
.33:LOOP .30:
.37:BufferRetrieve [%SectionHeaderBuf]
    MOV [%SectionHeaderPtr],ESI
    ADD [%FileAddr],ECX                          ; Now it is FA of raw data, i.e. .SizeOfHeaders in optional header.
    MOV EAX,[%FileAddr]
    LEA EDI,[%PeOptionalHeader]
    MOV [EDI+PFPE_OPTIONAL_HEADER32.SizeOfHeaders],EAX
    Invoke PfpeBaserelocFixup,EBX,[%SectionHeaderBuf]
    ListGetFirst [EBX+PGM.SymList]               ; <b>Symbol list pass</b> at .40: creates PFCOFF_SYMBOL_TABLE records.
    JZ .43:
.40:Invoke PfcoffSymSymbol::,EAX,[%SymbolTableBuf],[%StringTableBuf] ; Create symbol EAX.
    ListGetNext EAX
    JNZ .40:
.43:BufferRetrieve [EBX+PGM.SegOrdBuffer]        ; <b>Second segments pass</b> .43: .. .50: copies data from segments to COFF buffers.
    SHR ECX,2
    JZ .55:
.47:LODSD
    MOV EDX,EAX ; ^SSS.
    JNSt [EDX+SSS.Status],sssSegment,.50:        ; Skip when EDX is not a segment.
    Invoke PfcoffSegmRawData::,EDX,EBX,[%FileAddr],[%SectionHeaderPtr],[%RawBuf],[%StringTableBuf]
    MOV [%FileAddr],EAX
    ADDD [%SectionHeaderPtr],SIZE#PFCOFF_SECTION_HEADER
.50:LOOP .47:                                    ; The next segment.
.55:; <b>Update file header.</b>
    JNSt [Ea.Eaopt.Status::],eaoptDEBUG,.60:     ; Skip symbol table if not debug version.
    MOV EAX,[%FileAddr]                          ; Raw emitted data and relocations has been just buffered.
    LEA EDI,[%CoffFileHeader]
    MOV [EDI+PFCOFF_FILE_HEADER.PointerToSymbolTable],EAX
    BufferRetrieve [%SymbolTableBuf]             ; <b>Count the number of symbols</b>.
    MOV EAX,ECX
    SUB EDX,EDX
    MOV ECX,SIZE#PFCOFF_SYMBOL
    DIV ECX
    MOV [EDI+PFCOFF_FILE_HEADER.NumberOfSymbols],EAX
.60:LEA EDI,[%PeOptionalHeader]                  ; <b>Third segment pass</b> .65: .. .77: to update optional header.
    BufferRetrieve [EBX+PGM.SegOrdBuffer]
    SHR ECX,2
    JZ .80:
.65:LODSD
    PUSH ECX,ESI,EDI
     MOV ESI,EAX ; ^SSS.
     JNSt [ESI+SSS.Status],sssSegment,.77:       ; Skip when ESI is not a segment.
     MOV EAX,[ESI+SSS.TopLow]
     MOV EDX,[ESI+SSS.TopHigh]
     CMP EDX,[%MaxTopHigh]
     JB .73:
     JA .70:
     CMP EAX,[%MaxTopLow]
     JBE .73:
.70: MOV [%MaxTopLow],EAX
     MOV [%MaxTopHigh],EDX
.73: SUB EAX,[ESI+SSS.BottomLow]
     SBB EDX,[ESI+SSS.BottomHigh]                ; EDX:EAX is now unaligned section size.
     Invoke ExpAlign::,EAX,[EBX+PGM.Pgmopt.SectionAlign],0
     ADD ECX,EAX
     ADC EDX,0
     TEST EDX                                    ; EDX:ECX is now aligned section size.
     Msg cc=NZ,'8525',ESI                        ; Size of segment [!1S] exceeded 4 GB.
     MOV EDX,[ESI+SSS.BottomLow]                 ; EDX is now the section VA.
     SUB EDX,[EBX+PGM.Pgmopt.ImageBaseLow]       ; Convert VA to RVA (Borland linkers don't do this).
     MOV EAX,[ESI+SSS.Purpose]
     RstSt EAX,sssPurposeLITERAL+sssPurposeDRECTVE ; Get rid of pseudopurposes.
     Dispatch EAX,sssPurposeCODE,sssPurposeDATA,sssPurposeBSS
     TEST EAX,sssPurposeOptionalMask
     JZ .77:                                     ; Ignore other purposes.
     JSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.74:
     LEA EDI,[EDI+PFPE_OPTIONAL_HEADER32.DataDirectory] ; <b>RvaAndSizes of DataDirectories in optional header</b> will be specified here.
     JMP .75:
.74: LEA EDI,[EDI+PFPE_OPTIONAL_HEADER64.DataDirectory]
.75: MOV ECX,[ESI+SSS.TopLow]
     SUB ECX,[ESI+SSS.BottomLow]
     ; EDI is now pointer to 0-th member of <a href="#PFPE_DATA_DIRECTORY">PFPE_DATA_DIRECTORY</a> in optional header (32 or 64bit).
     ; EAX is special PE purpose. EDX is RVA of the segment ESI.  ECX is unaligned section data size.
     JNSt EAX,sssPurposeEXPORT,.NotEXPORT:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_EXPORT+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_EXPORT+PFPE_DATA_DIRECTORY.Size],ECX
.NotEXPORT: ; Skip directory entry IMPORT and IAT, which were set in <a href="#PfpeImportFixup">PfpeImportFixup</a>.
     JNSt EAX,sssPurposeRESOURCE,.NotRESOURCE:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_RESOURCE+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_RESOURCE+PFPE_DATA_DIRECTORY.Size],ECX
.NotRESOURCE:
     JNSt EAX,sssPurposeEXCEPTION,.NotEXCEPTION:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_EXCEPTION+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_EXCEPTION+PFPE_DATA_DIRECTORY.Size],ECX
.NotEXCEPTION:
     JNSt EAX,sssPurposeSECURITY,.NotSECURITY:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_SECURITY+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_SECURITY+PFPE_DATA_DIRECTORY.Size],ECX
.NotSECURITY:
     JNSt EAX,sssPurposeBASERELOC,.NotBASERELOC:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_BASERELOC+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_BASERELOC+PFPE_DATA_DIRECTORY.Size],ECX
.NotBASERELOC:
     JNSt EAX,sssPurposeDEBUG,.NotDEBUG:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_DEBUG+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_DEBUG+PFPE_DATA_DIRECTORY.Size],ECX
.NotDEBUG:
     JNSt EAX,sssPurposeCOPYRIGHT,.NotCOPYRIGHT:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_COPYRIGHT+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_COPYRIGHT+PFPE_DATA_DIRECTORY.Size],ECX
.NotCOPYRIGHT:
     JNSt EAX,sssPurposeGLOBALPTR,.NotGLOBALPTR:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_GLOBALPTR+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_GLOBALPTR+PFPE_DATA_DIRECTORY.Size],ECX
.NotGLOBALPTR:
     JNSt EAX,sssPurposeTLS,.NotTLS:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_TLS+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_TLS+PFPE_DATA_DIRECTORY.Size],ECX
.NotTLS:
     JNSt EAX,sssPurposeLOAD_CONFIG,.NotLOAD_CONFIG:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_LOAD_CONFIG+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_LOAD_CONFIG+PFPE_DATA_DIRECTORY.Size],ECX
.NotLOAD_CONFIG:
     JNSt EAX,sssPurposeBOUND_IMPORT,.NotBOUND_IMPORT:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_BOUND_IMPORT+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_BOUND_IMPORT+PFPE_DATA_DIRECTORY.Size],ECX
.NotBOUND_IMPORT:
     JNSt EAX,sssPurposeDELAY_IMPORT,.NotDELAY_IMPORT:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_DELAY_IMPORT+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_DELAY_IMPORT+PFPE_DATA_DIRECTORY.Size],ECX
.NotDELAY_IMPORT:
     JNSt EAX,sssPurposeCLR,.NotCLR:
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_CLR+PFPE_DATA_DIRECTORY.VirtualAddress],EDX
     MOV [EDI+SIZE#PFPE_DATA_DIRECTORY*pfpeDIRECTORY_ENTRY_CLR+PFPE_DATA_DIRECTORY.Size],ECX
.NotCLR:
     JMP .77:
     ; EDI is pointer to PFPE_OPTIONAL_HEADER32 when updating ordinary CODE,DATA or BSS section.
     ; EAX is ordinary PE purpose (CODE,DATA or BSS). EDX is RVA of the segment ESI. ECX is section-aligned section size.
.sssPurposeCODE:
     ADD [EDI+PFPE_OPTIONAL_HEADER32.SizeOfCode],ECX
     CMPD [EDI+PFPE_OPTIONAL_HEADER32.BaseOfCode],0
     JNZ .77:                                    ; If the BaseOfCode was already specified by another section.
     MOV [EDI+PFPE_OPTIONAL_HEADER32.BaseOfCode],EDX
     JMP .77:
.sssPurposeDATA:
     ADD [EDI+PFPE_OPTIONAL_HEADER32.SizeOfInitializedData],ECX
     JSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.77: ; 64bit version doesn't have BaseOfData.
     CMPD [EDI+PFPE_OPTIONAL_HEADER32.BaseOfData],0
     JNZ .77:                                    ; If the BaseOfData was already specified by another section.
     MOV [EDI+PFPE_OPTIONAL_HEADER32.BaseOfData],EDX
     JMP .77:
.sssPurposeBSS:
     ADD [EDI+PFPE_OPTIONAL_HEADER32.SizeOfUninitializedData],ECX
.77:POP EDI,ESI,ECX
    DEC ECX
    JNZ .65:                                     ; The next segment.
.80:; <b>Update image size</b>.
    MOV EAX,[%MaxTopLow]
    MOV EDX,[%MaxTopHigh]
    SUB EAX,[EBX+PGM.Pgmopt.ImageBaseLow]
    SBB EDX,[EBX+PGM.Pgmopt.ImageBaseHigh]
    JNZ .85:
    Invoke ExpAlign::,EAX,[EBX+PGM.Pgmopt.SectionAlign],0
    ADD EAX,ECX
    MOV [EDI+PFPE_OPTIONAL_HEADER32.SizeOfImage],EAX
.85:BufferRetrieve [%StubFileBuf]                ; <b>Flush all COFF components to the output stream.</b>
    StreamStore [%OutputStream],ESI,ECX          ; DOS stub, size QWORD aligned.
    StreamStoreDword [%OutputStream],'PE'        ; Signature.
    LEA EDI,[%CoffFileHeader]
    StreamStore [%OutputStream],EDI,SIZE#PFCOFF_FILE_HEADER ; COFF file header.
    LEA EDX,[%PeOptionalHeader]
    MOV ECX,SIZE#PFPE_OPTIONAL_HEADER64
    JSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64,.87:
    MOV ECX,SIZE#PFPE_OPTIONAL_HEADER32
.87:StreamStore [%OutputStream],EDX,ECX          ; PE Optional header.
    BufferRetrieve [%SectionHeaderBuf]
    StreamStore [%OutputStream],ESI,ECX          ; Section headers.
    BufferRetrieve [%RawBuf]
    StreamStore [%OutputStream],ESI,ECX          ; Section data + relocations of all segments.
    JNSt [Ea.Eaopt.Status::],eaoptDEBUG,.90:     ; Skip symbol table if not debug version.
    BufferRetrieve [%SymbolTableBuf]
    StreamStore [%OutputStream],ESI,ECX          ; Symbol table.
    BufferRetrieve [%StringTableBuf]
    MOV [ESI],ECX                                ; Update StringTable size.
    StreamStore [%OutputStream],ESI,ECX          ; String table.
.90:Invoke EaBufferRelease::,[%RawBuf]
    Invoke EaBufferRelease::,[%SymbolTableBuf]
    Invoke EaBufferRelease::,[%StringTableBuf]
    Invoke EaBufferRelease::,[%SectionHeaderBuf]
    Invoke EaBufferRelease::,[%StubFileBuf]
  EndProcedure PfpeCompile
</pre>

<pre>
  ENDPROGRAM pfpe
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
