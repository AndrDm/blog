<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='sym.htm source file'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>sym.htm source file</title>
</head>
<body class='EASOURCE' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>sym.htm
<br/><i>Class</i>
<br/><a href="#SYM">SYM</a>
<br/><i>Encodings</i>
<br/><a href="#SymEnc">SymEnc</a>
<br/><i>Macro</i>
<br/><a href="#SymMemberUpdate">SymMemberUpdate</a>
<br/><i>Procedures</i>
<br/><a href="#SymCombine">SymCombine</a>
<br/><a href="#SymCreate">SymCreate</a>
<br/><a href="#SymCreateLiteral">SymCreateLiteral</a>
<br/><a href="#SymCreateSe">SymCreateSe</a>
<br/><a href="#SymDelocalName">SymDelocalName</a>
<br/><a href="#SymDynamicLink">SymDynamicLink</a>
<br/><a href="#SymFindByIndex">SymFindByIndex</a>
<br/><a href="#SymFindByName">SymFindByName</a>
<br/><a href="#SymFindByInterName">SymFindByInterName</a>
<br/><a href="#SymFrameAddress">SymFrameAddress</a>
<br/><a href="#SymLowcaseDll">SymLowcaseDll</a>
<br/><a href="#SymReportUnresolved">SymReport Unresolved</a>
<br/><a href="#SymResolve">SymResolve</a>
<br/><a href="#SymStoreForwarderName">SymStoreForwarderName</a>
</h1>
<p>Object <strong>SYM</strong> represents a program symbol.
<br/>All defined symbols of the program including externs, literals and unnamed ($) symbols are kept on PGM.SymList.
<br/>A record on PGM.SymList is created</p><ol>
<li>when a symbol is defined (explicitly in a label field of statement),</li>
<li>when the symbol is referred and wasn't defined yet (in operand field of statement)</li>
<li>when a symbol scope is declared with GLOBAL, PUBLIC, EXTERN, EXPORT, IMPORT statement,</li>
<li>when a segment is defined (its related symSe is defined implicitly).</li>
</ol><p> Symbol is not created when its attribute is queried, e.g. in <code>%IF TYPE# aSymbol</code>.
<br/>Basic properties of symbol are
<br/>name <code>.NamePtr, .NameSize</code>,
<br/>scope <code>.Status</code>,
<br/>offset (AKA value) <code>.OffsetLow, .OffsetHigh</code>,
<br/>segment identification <code>.Section</code>.</p>
<p>When <code>SYM.Section=0</code>, it is <strong>scalar</strong> with value in <code>SYM.Offset</code>.
<br/>Otherwise it is <strong>addressing symbol</strong> and its (relocatable) virtual address is calculated as a sum of
<code>SYM.Offset</code> and VA of the bottom of its segment (even when the symbol is defined in a segment's section).
<br/>Section bottom is recalculated when each pass ends, but segment bottom is always 0 at asm-time.
<!---->When the final assembly pass terminates, sections are permanently linked to their segments
<!---->and symbol's <code>SYM.Section</code> is redefined and then it refers to its segment.
<br/>At link-time are homonymous segments from other modules combined, segment order is established by
<a class="EXT" href="pgm.htm#PgmOrderSegments">PgmOrderSegments</a>, external symbols resolved and
<code>SYM.Frame</code> then specifies the group or segment used for addressing and relocation.</p>
<h4 id="SymSssBinding">Symbols and segments binding</h4>
<p>In case of scalar (segmentless) symbols some assemblers create an auxilliary pseudosegment named
<em>.scalars</em>, <em>absolute</em> etc. When the symbol is external, its segment identification is NULL.</p>
<p>Strategy of &euro;ASM is different: scalar (numeric) symbols have their segment identification empty (<code>SYM.Section=0</code>)
<!---->and for external symbols it creates auxilliar pseudosegments of <code>sssExtern</code> type with the same name.
<!---->Each external symbol in &euro;ASM is accompanied with its homonymous external pseudosegment,
<!---->which is used in linking.</p>
<p>Also each ordinary relocable section and segment (<code>[.text], [.data]</code> etc) is accompanied with its homonymous private symbol (<code>.text, .data</code> etc) with
<code>SYM.Status=symSe</code>, which is used for relocations.</p>
<dl><dd class="PRE">
<!---->     <abbr>Standard private or public numeric (absolute) symbol</abbr>
<!---->
<!---->     &#x250C;&#x2500;&#x2500;SYM&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!---->     &#x2502;symPublic &#x2502;
<!---->     &#x2502;.Section=0&#x2502;
<!---->     &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
<!---->
<!---->     <abbr>Standard private or public address symbol</abbr>
<!---->
<!---->  &#x250C;&#x2500;>&#x250C;&#x2500;&#x2500;SYM&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x250C;>&#x250C;>&#x250C;&#x2500;&#x2500;SSS&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;>&#x250C;&#x2500;&#x2500;SYM&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!---->  &#x2502;  &#x2502;symPublic &#x2502;  &#x2502; &#x2502; &#x2502;sssSegment&#x2502;  &#x2502;  &#x2502;symSe     &#x2502;
<!---->  &#x2502;  &#x2502;.Section  &#x2502;&#x2500;&#x2500;&#x2518; &#x2502; &#x2502;.SymPtr   &#x2502;&#x2500;&#x2500;&#x2518;  &#x2502;.Section  &#x2502;&#x2500;&#x2510;
<!---->  &#x2502;  &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2502; &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;     &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;
<!---->  &#x2502;                  &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
<!---->  &#x2502;
<!---->  &#x2502;  <abbr>External unresolved symbol</abbr>
<!---->  &#x2502;
<!---->  &#x2502;&#x250C;>&#x250C;&#x2500;&#x2500;SYM&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;>&#x250C;&#x2500;&#x2500;SSS&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!---->  &#x2502;&#x2502; &#x2502;symExtern &#x2502;  &#x2502;   &#x2502;sssExtern &#x2502;
<!---->  &#x2502;&#x2502; &#x2502;.Section  &#x2502;&#x2500;&#x2500;&#x2518;   &#x2502;.SymPtr   &#x2502;&#x2500;&#x2510;
<!---->  &#x2502;&#x2502; &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;      &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;
<!---->  &#x2502;&#x2502;                                &#x2502;
<!---->  &#x2502;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
<!---->  &#x2502;
<!---->  &#x2502;  <abbr>External symbol resolved by</abbr>
<!---->  &#x2502;   <abbr>matching public symbol by name</abbr>
<!---->  &#x2502;
<!---->  &#x2502;  &#x250C;&#x2500;&#x2500;SYM&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;>&#x250C;&#x2500;&#x2500;SSS&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!---->  &#x2502;  &#x2502;symExtern &#x2502;  &#x2502;   &#x2502;sssExtern &#x2502;
<!---->  &#x2502;  &#x2502;.Section  &#x2502;&#x2500;&#x2500;&#x2518;   &#x2502;.SymPtr   &#x2502;&#x2500;&#x2510;
<!---->  &#x2502;  &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;      &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;
<!---->  &#x2502;                                 &#x2502;
<!---->  &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd></dl>
<table><caption>Actions performed with all symbols in <a class="EXT" href="pseudo.htm#PseudoENDPROGRAM">PseudoENDPROGRAM</a></caption>
<tr><th>Procedure</th><th>Condition</th><th>Action</th><th>Comment</th></tr>
<tr><td rowspan="2"><a class="EXT" href="pass.htm#PassCreate">PassCreate</a></td>
    <td></td><td>SetSt symFixed</td>
    <td rowspan="2">At the start of each pass all symbols created in previous passes are marked symFixed.</td></tr>
<tr><td></td><td>RstSt&nbsp;symDefInPass</td></tr>
<tr><td rowspan="2"><a class="EXT" href="pass.htm#PassInspect">PassInspect</a></td>
<td>All symbols are fixed</td><td>SetSt&nbsp;pgmLastPass</td><td rowspan="2">If one or more symbols is not fixed, the next pass cannot be the last.</td></tr>
<tr><td>!symFixed</td><td>RstSt pgmLastPass</td></tr>
<tr><td rowspan="4"><a class="EXT" href="pass.htm#PassDestroy">PassDestroy</a></td>
    <td>symGlobal &amp;&amp; symDefInPass</td><td>SetSt symPublic</td>
    <td rowspan="4">At the end of each pass the flag symGlobal|symGlobalRef is expanded either to symPublic or symExtern.</td></tr>
<tr><td>symGlobal &amp;&amp; !symDefInPass</td><td>SetSt symExtern</td></tr>
<tr><td>pgmLastPass &amp;&amp; !symExtern &amp;&amp; !symDefInPass &amp;&amp; !symQueried</td><td><a class="EXT" href="msg.htm#MsgE">E6601</a></td></tr>
<tr><td>pgmLastPass &amp;&amp; !symUsed &amp;&amp; !symIncluded &amp;&amp; !symPublic &amp;&amp; !symExport</td><td><a class="EXT" href="msg.htm#MsgW">W2101</a></td></tr>
</table>
<br class="CLEAR"/>
<p>Querying symbol's attributes does not throw error even if the symbol is not defined.</p>
<p>Referencing a symbol which was not defined yet does not throw
<!---->an error (unless <code>pgmLastPass</code> is set). Instead it is created with
<!---->temporary estimated attribute values:</p>
<table><caption>Initial estimated attributes of forward-referenced private symbol</caption>
<tr><th>Attribute</th><th>Value</th><th>Remark</th></tr>
<tr><td>TYPE#</td><td>'?'</td><td>Unknown in the first pass(es).</td></tr>
<tr><td>SIZE#</td><td>0</td><td>Assuming it represents a non-dimensional point.</td></tr>
<tr><td>SCOPE#</td><td>'S'</td><td>Assuming standard private scope.</td></tr>
<tr><td>OFFSET#</td><td>OFFSET#$+64</td><td>Assuming it will be defined later withing short jump reach.</td></tr>
<tr><td>SECTION#</td><td>SECTION#$</td><td>Assuming it will be defined in the same section.</td></tr>
<tr><td>SEGMENT#</td><td>SEGMENT#$</td><td>Assuming it will be defined in the same segment.</td></tr>
<tr><td>GROUP#</td><td>GROUP#$</td><td>Assuming it will be defined in the same group.</td></tr>
<tr><td>PARA#</td><td>GROUP#$&gt;&gt;4</td><td>Assuming it will be defined in the same group.</td></tr>
</table>
<table><caption>Initial estimated attributes of forward-referenced external or imported symbol</caption>
<tr><th>Attribute</th><th>Value</th><th>Remark</th></tr>
<tr><td>TYPE#</td><td>'A'</td><td>Assuming it will stay external (undefined in program).</td></tr>
<tr><td>SIZE#</td><td>0</td><td></td></tr>
<tr><td>SCOPE#</td><td>'E'</td><td>Assuming it will stay external (undefined in program).</td></tr>
<tr><td>OFFSET#</td><td>0</td><td>Runtime offset will be resolved by pseudosegment relocation.</td></tr>
<tr><td>SECTION#</td><td rowspan="4">[<em>Symbol</em>]</td><td rowspan="4">A new extern pseudosegment is created together with the symbol.
<br/>Pseudosegment name is identical with external/imported symbol name.</td></tr>
<tr><td>SEGMENT#</td></tr>
<tr><td>GROUP#</td></tr>
<tr><td>PARA  #</td></tr>
</table>
<br class="CLEAR"/>
<pre>
    EUROASM NOWARN=2101
sym PROGRAM FORMAT=COFF,MODEL=FLAT,WIDTH=32
    INCLUDEHEAD euroasm.htm, \  Interface (structures, symbols and macros) of other modules used in this source.
                ctx.htm,dict.htm,ea.htm,eaopt.htm,exp.htm,member.htm,msg.htm,pgm.htm, \
                pgmopt.htm,reloc.htm,sss.htm,stm.htm,var.htm
</pre><pre>
 sym HEAD ; Start of module interface.
</pre>

<dl id="SYM"><dt><a href="#top">&uarr; SYM</a></dt>
</dl><pre>
SYM STRUC          ; +00h.
.NamePtr       D D ; Full qualified name (leading dot resolved, colons removed), or literal name, e.g.<code>=B'abcd'</code>.
.NameSize      D D ; Number of bytes in symbol name {without colons).
.InterNamePtr  D D ; Pointer to imported symbol internal name or to forwarded export name.
.InterNameSize D D ; Number of bytes in .InterName.
                   ; +10h.
.OffsetLow     D D ; Value of scalar symbol or offset from the bottom of its <b>section</b>.
.OffsetHigh    D D ;
.SymbPtr       D D ; 0 if unresolved, or pointer to the resolved public symbol if <code>SYM.Status=symExtern|symImport|symExport</code>.
.Section       D D ; 0 for scalar, otherwise ^<a class="EXT" href="sss.htm#SSS">SSS</a> (sssSection|sssExtern) where it was defined.
                   ; +20h.
.DllNamePtr    D D ; Pointer to file name of DLL from which the symbol is imported or forwarded DLL name.
.DllNameSize   D D ; Number of bytes in .DllNamePtr.
.LinePtr       D D ; Pointer to memory-mapped source text where the symbol was declared.
.Status        D D ; Symbol properties, see <a href="#SymEnc">SymEnc</a> below.
                   ; +30h.
.Size          D D ; Number of bytes emitted or reserved by the declaring statement.
.Align         D D ; Explicit alignment.   0=default,1,2,4,8,16,...
.NameIndex     D D ; Ordinal number (0..) in the symbol table. Also used as paragraph FA of module in LIBOMF.
.NameDynIndex  D D ; Ordinal number (0..) in the dynamic symbol table use in ELFSO format.
                   ; +40h.
.OrdinalNr     D D ; Imported ordinal number value. Valid when <code>SYM.Status:symImportedByOrd</code> is set.
ENDSTRUC SYM
</pre>

<dl id="SymEnc"><dt><a href="#top">&uarr; SymEnc - symbol encodings</a></dt>
<dd>Some of the <code>SYM.Status</code> flags defined here are adopted from the refering
<a class="EXT" href="stm.htm#STM">statement</a>:  <code>symTypeMask + symPropMask</code> are kept synchronized with
<code>stmTypeMask + stmPropMask</code> in statement encoding <a class="EXT" href="stm.htm#StmEnc">StmEnc</a>.
<br/>All symbols are granted with <code>symFixed</code> in PassCreate (when a new pass starts)
<!---->and the flag is reset if symbol properties are changed in the pass.</dd></dl><pre>
 ; <b>Symbol TYPE#</b>
symTypeMask       = 0x0000_00FF ; Uppercase letter <kbd>BUWDQTOYZISNA?</kbd>. Synchronized with <a class="EXT" href="stm.htm#StmEnc">stmTypeMask</a>.
 ; <b>Symbol SCOPE#</b>.       value    scope
symPrivate        = 0x0000_0000 ; 'S'. Default standard symbol scope.
symExtern         = 0x0000_0100 ; 'E'. Explicitly declared as EXTERN.
symImport         = 0x0000_0200 ; 'I'. Explicitly declared as IMPORT.
symImportedByOrd  = 0x0000_0400 ; 'I'. Imported by ordinal, not by name. Valid with symImport only.
symExport         = 0x0000_0800 ; 'X'. Explicitly declared as EXPORT.
symForwarded      = 0x0000_1000 ; 'X'. Export of symbol provided by other DLL. Valid with symExport only
symSe             = 0x0000_2000 ; 'S'. Implicit private symbol representing the bottom address of a segment|section.
symEntry          = 0x0000_4000 ; 'P'. Program public Entry symbol. Don't E6601 if undefined in the main program.
symLiteral        = 0x0000_8000 ; 'S'. Symbol is literal.
symPublic         = 0x0001_0000 ; 'P'. Explicitly declared as PUBLIC.
symWeak           = 0x0002_0000 ; 'P'. This weak-public symbol is ignored when another nonweak public symbol is linked.
symGlobal         = 0x0004_0000 ; 'G'|'P'|'E'. Explicitly declared as GLOBAL.
symExplScopeMask  = symPublic|symExport|symExtern|symImport|symGlobal|symWeak
 ; <b>Symbol properties</b>.  Synchronized with <a class="EXT" href="stm.htm#StmEnc">stmPropMask</a>
symGlobalRef      = 0x0008_0000 ; EQU stmLabelIsPublic. 'G'|'P'|'E'. Implicitly refered as global (its name ends with <kbd>::</kbd>).
symIncluded       = 0x0010_0000 ; EQU stmIncluded. Symbol was defined in included source chunk. Do not warn W2101 if not used.
symProc           = 0x0020_0000 ; EQU stmProc. Symbol is defined as PROC or PROC1 or external function entry.
symNear           = 0x0040_0000 ; EQU stmNear. Symbol symProc has DIST=NEAR.
symFar            = 0x0080_0000 ; EQU stmFar.  Symbol symProc has DIST=FAR.
symPropMask       = symIncluded|symProc|symNear|symFar
symScopeMask      = symExplScopeMask | symGlobalRef
 ; <b>Referencing symbol flags</b>.
symEstimated      = 0x0100_0000 ; Offset and other properties are only estimated in this pass.
symDefined        = 0x0200_0000 ; Symbol was defined at least once in any pass.
symDefInPass      = 0x0400_0000 ; Symbol was already defined in this pass. Reset in PassDestroy.
symQueried        = 0x0800_0000 ; Symbol's attribute was queried. Don't E6601 if not defined and not referred.
symReferenced     = 0x1000_0000 ; Symbol was referred. It should be defined, otherwise E6601.
symUsed           = 0x2000_0000 ; Symbol was referenced or queried at least once in any pass (symDirty).
symFixed          = 0x4000_0000 ; Offset and other properties are finally computed and fixed.
symResolved       = 0x8000_0000 ; This extern|export|import symbol was matched to a public symbol.
</pre>

<pre>
  ENDHEAD sym ; End of module interface.
</pre>


<dl id="SymFindByName">
<dt><a href="#top">&uarr; SymFindByName</a> SymScope, NamePtr, NameSize, ProgPtr</dt>
<dd><dfn>SymFindByName</dfn> searches for symbol of given scope by its .Name on ProgPgm.SymList.
<!----></dd>
<dt>Input</dt>
<dd><b>SymScope</b> is one of the <a href="#SymEnc">SymEnc</a> flags
<code>symExtern, symPublic, symImport, symExport</code>, or <code>symPrivate=0</code>
<!---->which will accept symbol of any scope.
<br/><b>NamePtr</b> is pointer to the name of searched symbol.
<br/><b>NameSize</b> is size of the symbol name.
<br/><b>ProgPtr</b> Pointer to <a class="EXT" href="pgm.htm#PGM">PGM
</a>. It may be NULL, current program is searched in this case.</dd>
<dt>Output</dt>
<dd><b>CF=</b>0
<br/><b>EAX=</b> Pointer to <a href="#SYM">SYM</a> structure of the symbol.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1
<br/><b>EAX=</b> 0 - symbol not found.</dd>
<dt>Example</dt><dd class="PRE"> Invoke SymFindByName::, symExtern|symImport,ESI,ECX,0</dd>
<dt>See also</dt>
<dd><a href="#SymFindByInterName">SymFindByInterName</a>.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="exp.htm#ExpEvalIdentifier">ExpEvalIdentifier</a>
<a class="EXT" href="pf.htm#PfDrectveDestroy">PfDrectveDestroy</a>
<a class="EXT" href="pfomf.htm#PfomfLoadModule">PfomfLoadModule</a>
<a class="EXT" href="pfpe.htm#PfpeOptionalHeader">PfpeOptionalHeader</a>
<a class="EXT" href="pseudo.htm#PseudoPROC1">PseudoPROC1</a>
<a class="EXT" href="sss.htm#SssCreateStructure">SssCreateStructure</a>
<a href="#SymCombine">SymCombine</a>
<a href="#SymCreate">SymCreate</a>
<a href="#SymCreateLiteral">SymCreateLiteral</a>
<a href="#SymCreateSe">SymCreateSe</a>
<a href="#SymResolve">SymResolve</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="pgm.htm#PgmGetCurrent">PgmGetCurrent</a>
</dd>
</dl><pre>
SymFindByName Procedure SymScope, NamePtr, NameSize, ProgPtr
       MOV ESI,[%ProgPtr]
       TEST ESI
       JNZ .10:
       Invoke PgmGetCurrent::
       JC .NotFound:
       MOV ESI,EAX ; ^PGM.
 .10:  MOV EDX,[%NameSize]
       MOV EBX,[%NamePtr]
       TEST EDX
       JZ .NotFound:
       ListGetFirst [ESI+PGM.SymList]
       JZ .NotFound:
 .20:  MOV ECX,[%SymScope]
       JECXZ .40:  ; Skip symbol status check if %SymScope=0 (any scope will fit).
       JNSt [EAX+SYM.Status],ECX,.70:
 .40:  CMP EDX,[EAX+SYM.NameSize]
       JNE .70:
       MOV ESI,[EAX+SYM.NamePtr]
       MOV ECX,EDX
       MOV EDI,EBX
       REPE CMPSB
       JE .Found
 .70:  ListGetNext EAX
       JNZ .20:
.NotFound:
       SUB EAX,EAX
       STC
.Found:MOV [%ReturnEAX],EAX
     EndProcedure SymFindByName
</pre>

<dl id="SymFindByInterName">
<dt><a href="#top">&uarr; SymFindByInterName</a> SymScope, NamePtr, NameSize, ProgPtr</dt>
<dd><dfn>SymFindByInterName</dfn> searches for symbol of given scope by .InterName on ProgPgm.SymList.
<!---->SYM.InterName differs from ordinary (public) SYM.Name only in imported symbols.</dd>
<dt>Input</dt>
<dd><b>SymScope</b> is one of the <a href="#SymEnc">SymEnc</a> flags
<code>symExtern, symPublic, symImport, symExport</code>, or 0,
<!---->which will accept symbol of any scope.
<br/><b>NamePtr</b> Name of the searched symbol.
<br/><b>NameSize</b> Size of symbol internal name.
<br/><b>ProgPtr</b> Pointer to <a class="EXT" href="pgm.htm#PGM">PGM
</a>. It may be NULL, current program is searched in this case.</dd>
<dt>Output</dt>
<dd><b>CF=</b>0
<br/><b>EAX=</b> Pointer to <a href="#SYM">SYM</a> structure of the symbol.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1
<br/><b>EAX=</b> 0 - symbol not found.</dd>
<dt>Example</dt><dd class="PRE"> Invoke SymFindByInterName::,symImport,ESI,ECX,0</dd>
<dt>See also</dt>
<dd><a href="#SymFindByName">SymFindByName</a>.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfomf.htm#PfomfLoadModule">PfomfLoadModule</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="pgm.htm#PgmGetCurrent">PgmGetCurrent</a>
</dd>
</dl><pre>
SymFindByInterName Procedure SymScope, NamePtr, NameSize, ProgPtr
       MOV ESI,[%ProgPtr]
       TEST ESI
       JNZ .05:
       Invoke PgmGetCurrent::
       JC .NotFound:
       MOV ESI,EAX ; ^PGM.
 .05:  MOV EDX,[%NameSize]
       MOV EBX,[%NamePtr]
       TEST EDX
       JZ .NotFound:
       ListGetFirst [ESI+PGM.SymList]
       JZ .NotFound:
 .10:  MOV ECX,[%SymScope]
       JECXZ .20:  ; Skip symbol status check if %SymScope=0.
       JNSt [EAX+SYM.Status],ECX,.70:
 .20:  CMP EDX,[EAX+SYM.InterNameSize]
       JNE .70:
       MOV ESI,[EAX+SYM.InterNamePtr]
       MOV ECX,EDX
       MOV EDI,EBX
       REPE CMPSB
       JE .Found
 .70:  ListGetNext EAX
       JNZ .10:
.NotFound:
       SUB EAX,EAX
       STC
.Found:MOV [%ReturnEAX],EAX
     EndProcedure SymFindByInterName
</pre>

<dl id="SymFindByIndex">
<dt><a href="#top">&uarr; SymFindByIndex</a> SymIndex, ProgPtr</dt>
<dd><dfn>SymFindByIndex</dfn> will search for the symbol with given index,
<!---->which is kept as <code>SYM.NameIndex</code> in €ASM symbols stored on
<code>PGM.SymList</code> of the program identified by <code>%ProgPtr</code>.</dd>
<dt>Input</dt>
<dd><b>SymIndex</b> is the ordinal number of the index in ELF|COFF symbol table.
<br/><b>ProgPtr</b> Pointer to <a class="EXT" href="pgm.htm#PGM">PGM
</a>. It may be NULL, current program is searched in this case.</dd>
<dt>Output</dt>
<dd><b>CF=</b>0
<br/><b>EAX=</b> Pointer to <a href="#SYM">SYM</a> structure of the symbol.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1
<br/><b>EAX=</b> if no such symbols was found or if SymIndex=0.</dd>
<dt>See also</dt>
<dd><a href="#SymFindByName">SymFindByName</a>.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfcoff.htm#PfcoffRelocation2Reloc">PfcoffRelocation2Reloc</a>
<a class="EXT" href="pfelf.htm#PfelfLoadPgm">PfelfLoadPgm</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="pgm.htm#PgmGetCurrent">PgmGetCurrent</a>
</dd>
</dl><pre>
SymFindByIndex Procedure SymIndex, ProgPtr
    XOR EAX,EAX
    MOV ECX,[%SymIndex]
    STC
    JECXZ .90:
    MOV EAX,[%ProgPtr]
    TEST EAX
    JNZ .10:
    Invoke PgmGetCurrent::
    JC .90:
.10:MOV EAX,[EAX+PGM.SymList]
    ListGetFirst EAX
.30:STC
    JZ .90:
    CMP [EAX+SYM.NameIndex],ECX
    JE .90:
    ListGetNext EAX
    JMP .30:
.90:MOV [%ReturnEAX],EAX
     EndProcedure SymFindByIndex
</pre>

<dl id="SymDelocalName">
<dt><a href="#top">&uarr; SymDelocalName</a> NamePtr, NameSize, NameBuffer, Delocalize</dt>
<dd>The identifier Name is checked, delocalized and then stored to NameBuffer.
<!---->If memberDelocal is set, Name will be prefixed with current namespace when it is .local.</dd>
<dt>Input</dt>
<dd><b>NamePtr</b> Pointer to the identifier of a symbol or a structure.
<!---->It may start with dot <kbd>.</kbd>, but no trailing colons or <kbd>[ ]</kbd> are allowed.
<br/><b>NameSize</b> Number of bytes in the name.
<br/><b>NameBuffer</b> Pointer to the output <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> where the checked name will be stored. It should be empty on input.
<br/><b>Delocalize</b> is one of the flags <code>memberDelocal, memberDelocalParent</code> or <code>memberDelocalNone</code>.<ul>
<li><b>memberDelocal</b>: A name beginning with <kbd>.</kbd> will be prefixed with the current namespace.</li>
<li><b>memberDelocalParent</b>: A name beginning with <kbd>.</kbd> will be prefixed with the parent namespace.</li>
<li><b>memberDelocalNone</b>: Leading fullstop <kbd>.</kbd> is treated as ordinary letter (e.g. segment name <code>.data</code>).</li>
</ul>Regardless of Delocalize, the name is tested for permitted characters.</dd>
<dt>Output</dt>
<dd><b>CF=0, NameBuffer</b> contains valid (delocalized) symbol name.</dd>
<dt>Error</dt>
<dd><b>CF=1</b> Errors <a class="EXT" href="msg.htm#MsgE">E6110</a> reported with macro <a class="EXT" href="msg.htm#Msg">Msg
</a>. Output NameBuffer returns as much of input name as possible.</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ctx.htm#CtxPeek">CtxPeek</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="ctx.htm#CtxCreate">CtxCreate</a>
<a class="EXT" href="ctx.htm#CtxFind">CtxFind</a>
<a class="EXT" href="exp.htm#ExpEvalIdentifier">ExpEvalIdentifier</a>
<a class="EXT" href="exp.htm#ExpParseDatatype">ExpParseDatatype</a>
<a class="EXT" href="pseudo.htm#PseudoPROC1">PseudoPROC1</a>
<a class="EXT" href="pseudo.htm#PseudoSTRUC">PseudoSTRUC</a>
<a href="#SymCreate">SymCreate</a>
</dd>
</dl><pre>
SymDelocalName Procedure NamePtr, NameSize, NameBuffer, Delocalize
      MOV ECX,[%NameSize]
      MOV ESI,[%NamePtr]
      MOV EBX,[%NameBuffer]
      MOV EDX,[%Delocalize]
      JECXZ .20:                                 ; Empty name will pass.
      JNSt EDX, memberDelocal | memberDelocalParent, .20: ; If memberDelocalNone.
      CMPB [ESI],'.'                             ; Is the Name local?
      JNE .20:
      ; A local name will be prefixed with the current or parent namespace in the NameBuffer.
      SUB EAX,EAX
      JNSt [%Delocalize],memberDelocalParent,.10:
      Invoke CtxPeek::, ctxNamespace,0           ; Get and forget the current namespace context to EAX.
 .10: Invoke CtxPeek::, ctxNamespace,EAX
      JC .20:                                    ; If there's no namespace on context stack.
      BufferStore EBX,[EAX+CTX.NamePtr],[EAX+CTX.NameSize] ; Store namespace name first.
 .20: BufferStore EBX,ESI,ECX                    ; Store the (local) Name.
      BufferRetrieve EBX
      JECXZ .90:
      LODSB                                      ; Check the first character used in the name.
      DEC ECX
      ExpClassify AL
      TEST AH, expLetter | expFullstop
      JZ .E6110:                                 ; Invalid symbol name "!1S".
 .30: JECXZ .90:
      LODSB
      DEC ECX
      ExpClassify AL
      TEST AH, expLetter | expDigit | expFullstop
      JNZ .30:
.E6110:LEA EDI,[%NamePtr]
      Msg '6110',EDI,PgmStatus=pgmLastPass       ;  Invalid symbol name "!1S".
      STC
 .90:EndProcedure SymDelocalName
</pre>

<dl id="SymMemberUpdate">
<dt><a href="#top">&uarr; SymMemberUpdate</a> Member</dt>
<dd>Macro <dfn>SymMemberUpdate</dfn> will copy contents of one class member from the statement to the symbol
<!---->and clear ECX when they were different.</dd>
<dt>Input</dt><dd><b>Member</b> is the name of homonymous members in <a class="EXT" href="stm.htm#STM">STM</a> and
<a class="EXT" href="sym.htm#SYM">SYM</a>:
<code>OffsetLow</code>, <code>OffsetHigh</code>, <code>Section</code>, <code>Size</code>, <code>LinePtr</code>.
<br><b>EBX=</b> pointer to STM (source).
<br><b>EDI=</b> pointer to SYM (destination).
<br><b>ECX=</b> is the constant <code>symFixed</code> or 0.
</dd>
<dt>Output</dt><dd> Symbol refered by EDI is updated from statement refered by EBX.
<br/><b>EAX=</b>value of <code>SYM.%Member</code>.
<br/><b>ECX=</b> 0 if the members were different, otherwise ECX is unchanged.</dd>
<dt>Error</dt><dd>-</dd>
<dt>Example</dt><dd class="PRE"> SymMemberUpdate Section</dd>
<dt>Expanded by</dt><dd><a href="#SymCreate">SymCreate</a></dd>
</dl><pre>
SymMemberUpdate %MACRO Member
    MOV EAX,[EBX+STM.%Member]
    CMP EAX,[EDI+SYM.%Member]
    JE .Fixed%Member%.:
    MOV [EDI+SYM.%Member],EAX
    XOR ECX,ECX ; Set flag Fixed to FALSE.
.Fixed%Member%.:
    %ENDMACRO SymMemberUpdate
</pre>

<dl id="SymCreate">
<dt><a href="#top">&uarr; SymCreate</a> Reason, NamePtr, NameSize, Statement</dt>
<dd><p><dfn>SymCreate</dfn> returns a program symbol specified by Name.
<!---->It will create a new symbol if it didn't exist in Program.SymList.
<!---->The symbol is then updated by Statement properties.
<br/>SymCreate is invoked in those circumstances:</p>
<ul><li>When Reason is one of the flags of <code>symScopeMask</code>, symbol is <b>declared
</b>. This happens when the symbol scope is explicitly declared with pseudoinstruction
<code>GLOBAL</code>, <code>PUBLIC</code>, <code>EXTERN</code>, <code>EXPORT</code> or
<code>IMPORT</code>.</li>
<li>When Reason is <code>symDefined</code>, the symbol is <b>defined
</b>. This happens when symbol name appears in the label field of empty or machine instruction
<!---->or when it is explicitly defined with pseudoinstruction <code>EQU</code>, <code>D</code>,
<code>PROC</code> or <code>PROC1</code>.
<br/>Flag <code>symGlobalRef</code> may be set simultaneously in Reason parameter,
<!---->the symbol will be marked as symPublic or symExport later.</li>
<li>When Reason is <code>symReferenced</code>, the symbol is <b>referenced
</b>, i.e. its name figures in an expression.
<br/>Again, <code>symGlobalRef</code> may be set simultaneously with
<code>symReferenced</code> in Reason parameter.</li>
<li>When Reason is <code>symQueried</code>, this means that some attribute of the symbol is <b>queried
</b>, i.e. an expression computes its attribute, e.g. <code> %IF TYPE# Symbol = '?'</code>.
<!---->New symbol is not created when it didn't exist yet.</li>
</ul><p>Type and some other properties of created symbol are provided by
<a class="EXT" href="stm.htm#STM">STM</a>:<code>.Section</code>, <code>.Offset</code>,
<code>.Size</code>, <code>LinePtr</code>, <code>stmTypeMask</code>,<code>stmPropMask</code>.
<br/>Due to optimisation passes the final offset of the created symbol may be different from the value estimated
<!---->at symbol creation. Statement offset and other properties are updated here.
<code>SYM.Status:symFixed</code> is reset when symbol properties got changed during the update.</p></dd>
<dt>Input</dt>
<dd><b>Reason</b> is a combination of flags in
<a href="#SymEnc">symbol encoding</a>, see above.
<br/><b>NamePtr</b> is pointer to the symbol name. It can be volatile, untrimmed, colon(s) terminated and local (start with
<kbd>.</kbd>), it will be completed with namespace and permanently stored on Pgm.Pool. It may not be
<kbd>$</kbd>.
<br/><b>NameSize</b> is number of characters in the symbol name.
<br/><b>Statement</b> is pointer to <a class="EXT" href="stm.htm#STM">STM</a> - parsed statement which concerns the symbol.
<br/>It may be NULL when <code>Reason=symReferenced</code>, in this case new symbol will not be created if it didn't exist yet.</dd>
<dt>Output</dt>
<dd><b>CF=0, EAX=</b> pointer to an updated existing or just created <a href="#SYM">SYM</a> object.
<br/><b>CF=0, EAX=0</b> if the reason was symQueried and symbol is undefined.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.
<br/><b>EAX=</b>0</dd>
<dt>Depends on</dt>
<dd><a href="#SymMemberUpdate">SymMemberUpdate</a></dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="exp.htm#ExpEvalIdentifier">ExpEvalIdentifier</a>
<a class="EXT" href="ii.htm#IiAssemble">IiAssemble</a>
<a class="EXT" href="ii.htm#IiAssembleMultiop">IiAssembleMultiop</a>
<a class="EXT" href="member.htm#MemberCreate">MemberCreate</a>
<a class="EXT" href="pgm.htm#PgmGlobalEntry">PgmGlobalEntry</a>
<a class="EXT" href="pseudo.htm#PseudoData">PseudoData</a>
<a class="EXT" href="pseudo.htm#PseudoENDPROC">PseudoENDPROC</a>
<a class="EXT" href="pseudo.htm#PseudoENDPROC1">PseudoENDPROC1</a>
<a class="EXT" href="pseudo.htm#PseudoEQU">PseudoEQU</a>
<a class="EXT" href="pseudo.htm#PseudoNoOperation">PseudoNoOperation</a>
<a class="EXT" href="pseudo.htm#PseudoPROC">PseudoPROC</a>
<a class="EXT" href="pseudo.htm#PseudoPROC1">PseudoPROC1</a>
<a class="EXT" href="pseudo.htm#PseudoScope">PseudoScope</a>
<a class="EXT" href="pseudo.htm#PseudopcMACRO">PseudopcMACRO</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t1646.htm">t1646</a>
<a class="EXT" href="../eatests/t2381.htm">t2381</a>
<a class="EXT" href="../eatests/t2382.htm">t2382</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a class="EXT" href="pgm.htm#PgmGetCurrent">PgmGetCurrent</a>
<a class="EXT" href="sss.htm#SssCreateExtern">SssCreateExtern</a>
<a href="#SymDelocalName">SymDelocalName</a>
<a href="#SymFindByName">SymFindByName</a>
</dd>
</dl><pre>
SymCreate Procedure Reason, NamePtr, NameSize, Statement
PgmPtr     LocalVar ; ^Current program.
PgmStatus  LocalVar ; Local copy of program status.
Fixed      LocalVar ; Value of SYM.Status:symFixed during <a href="#SymMemberUpdate">SymMemberUpdate</a>.
    ClearLocalVar
    MOV EBX,[%Statement]
    ; <b>Check if Program and Statement is provided</b>.
    TEST EBX
    JZ .05:                              ; Internal error: creating symbol "!1S".
    MOV EDX,[EBX+STM.Program]
    MOV [%PgmPtr],EDX
    TEST EDX
    JZ .05:
    MOV EAX,[EDX+PGM.Status]
    MOV [%PgmStatus],EAX
    MOVD [%Fixed],symFixed
    JMP .10:
.05:JSt [%Reason],symReferenced,.10:
.F9960:LEA ESI,[%NamePtr]
    Msg '9960',ESI                       ; Internal error: creating symbol "!1S" outside a statement.
.Error:
    XOR EAX,EAX
    MOV [%ReturnEAX],EAX
    STC
    JMP .90:
.E6601: Msg '6601',EDI,[EDI+SYM.LinePtr] ; Symbol "!1S" mentioned at !2@ was not found.
    JMP .Error:
.E6610:Msg '6610',EDI,[EDI+SYM.LinePtr]  ; Symbol "!1S" was already defined at "!2@"
    JMP .Error:
.E6621:Msg '6621',EDI,[EDI+SYM.LinePtr]  ; External symbol "!1S" defined at "!2@" cannot be made public.
    JMP .Error:
.E6622:Msg '6622',EDI,[EDI+SYM.LinePtr]  ; Public symbol "!1S" defined at "!2@" cannot be made external.
    JMP .Error:
.E6624:Msg '6624',EDI,[EDI+SYM.LinePtr]  ; Symbol "!1S" was declared as external at !2@.
    JMP .Error:
.E6637:Msg '6637'                        ; Special symbol "$" can be defined with EQU only.
    JMP .Error:
.E6638:Msg '6638'                        ; Special symbol "$" cannot be declared global.
    JMP .Error:
.10:TEST EDX
    JNZ .12:
    Invoke PgmGetCurrent::
    MOV EDX,EAX
.12:TEST EBX
    JNZ .13:
    MOV EBX,[EDX+PGM.CurrentStm]
    TEST EBX
    JZ .F9960:
.13:; <b>Check symbol name</b>.
    MOV ESI,[%NamePtr]
    MOV ECX,[%NameSize]
    StripSpaces ESI,ECX
    StripColons ESI,ECX
    TEST ECX
    JZ .Error:                           ; Silently do not create symbol with empty name.
    CMP ECX,1
    JNE .15:
    CMPB [ESI],'$'
    JNE .15:
    JSt [%Reason],symScopeMask,.E6638:   ; Special symbol "$" cannot be declared global.
    JMP .E6637:                          ; Special symbol "$" can be defined with EQU only.
.15:; <b>Convert local name ESI,ECX to standard scope</b>.
    CMPB [ESI],'.'
    JNE .18:                             ; If the name is not local.
    Invoke EaBufferReserve::,SymCreate
    Invoke SymDelocalName,ESI,ECX,EAX,memberDelocal
    BufferRetrieve EAX
    Invoke EaBufferRelease::, EAX
.18:; ESI,ECX is now nonlocal nonempty trimmed symbol name. Check <b>if it already exists</b> on Program.SymList.
    Invoke SymFindByName,0,ESI,ECX,EDX
    MOV [%ReturnEAX],EAX                 ; Pointer to symbol, if found, otherwise 0.
    MOV EDI,EAX
    JNC .35:                             ; Skip the definition when the symbol already exists.
    ; <b>Symbol does not exist yet. A new symbol will be defined/declared/referenced/queried</b>.
    JSt [%Reason],symQueried,.90:        ; Return no symbol (EAX=0), CF=0.
    ListNew [EDX+PGM.SymList],Zeroed=yes
    MOV EDI,EAX                          ; Pointer to a new empty symbol.
    MOV [%ReturnEAX],EAX
    PoolStore [EDX+PGM.Pool],ESI,ECX
    MOV ESI,EAX                          ; ESI,ECX is now nonvolatile nonlocal symbol name in Pgm.Pool.
    MOV [EDI+SYM.NamePtr],ESI
    MOV [EDI+SYM.NameSize],ECX
    MOV ECX,[%Fixed]
    SymMemberUpdate LinePtr              ; Where was the symbol defined.
    MOV [%Fixed],ECX
    MOV EAX,[%Reason]
    SetSt [EDI+SYM.Status],EAX
    JNSt EAX,symDefined,.20:
    ; <b>New symbol is being defined</b>. Copy its type and properties from the statement.
    MOV ECX,stmTypeMask+stmPropMask+stmLabelIsPublic ; Masks aliases to symbol properties.
    AND ECX,[EBX+STM.Status]
    OR ECX,symDefined+symDefInPass
    SetSt [EDI+SYM.Status],ECX            ; Inherit type, properties and symGlobalRef from the statement.
    RstSt [EDI+SYM.Status],symEstimated
    JMP .45:
.20:JNSt EAX,symExplScopeMask, .25:
    ; <b>New symbol EDI will be declared</b> by explicit scope pseudoinstruction.
    JSt EAX,symPublic|symExport,.30:      ; Go to estimate its properties.
    ; New symbol is declared symExtern or symImport.
    Invoke SssCreateExtern::,EDI,[%PgmPtr]
    JMP .90:
.25:JNSt EAX,symReferenced,.90:
    ; <b>New symbol EDI is forward referenced</b>. Its properties will be estimated.
    SetSt EAX,symUsed+symReferenced+symEstimated + '?'
    MOV [EDI+SYM.Status],EAX
.30:MOV ECX,[%Fixed]
    SymMemberUpdate Section                ; Assume SECTION# $.
    SymMemberUpdate OffsetLow
    SymMemberUpdate OffsetHigh
    MOV [%Fixed],ECX
    ADDD [EDI+SYM.OffsetLow],64            ; Assume OFFSET# $ + 64.
    ADCD [EDI+SYM.OffsetHigh],0
    JMP .80:
.35: ; <b>Symbol EDI already exists</b>. It is redefined/redeclared/referenced.
    JNSt [%Reason],symDefined,.60:
    ; <b>Existing symbol EDI is (re)defined</b>. It will be updated from the statement EBX.
    MOV EDX,[EDI+SYM.Status]                ; Old properties.
    JSt EDX,symDefInPass, .E6610:           ; Symbol "!1S" was already defined at "!2@".
    JSt EDX,symExtern|symImport, .E6624:    ; Symbol "!1S" was declared as external at !2@.
    MOV EAX,[EBX+STM.Status]                ; New properties.
    MOV ECX,stmTypeMask+stmPropMask+stmLabelIsPublic ; Synchronized with symTypeMask+symPropMask+symGlobalRef.
    JNSt EDX,symEntry,.38:
    OR EAX,stmLabelIsPublic                 ; When the ENTRY is defined in source, pretend it is implicitely global::.
.38:; <b>Update symbol type</b> and miscellaneous properties.
    JNSt EDX,symGlobalRef,.39:
    SetSt EAX,symGlobalRef
.39:AND EAX,ECX
    AND EDX,ECX
    CMP EAX,EDX
    JE .40:
    RstSt [EDI+SYM.Status],symFixed         ; If any of symbol properties had changed, a new pass will be required.
.40:OR EAX,symDefined+symDefInPass
    NOT ECX
    ANDD [EDI+SYM.Status],ECX               ; Erase old symbol type and properties.
    SetSt [EDI+SYM.Status],EAX              ; Replace them with the new ones.
.45:; <b>Update other properties</b> from the statement.
    MOV ECX,[%Fixed]
    SymMemberUpdate Section
    JNSt [EDI+SYM.Status],symExplScopeMask,.47:
    MOV ECX,[%Fixed]                        ; Do not reset symFixed due to SYM.Section change when the symbol is defined and exported.
.47:JSt [EDI+SYM.Status],symProc,.48:       ; Size of PROC symbol will be updated in PseudoENDPROC.
    SymMemberUpdate Size
    MOV [%Fixed],ECX
    ; <b>Update offset</b>.
.48:MOV EAX,[EDI+SYM.OffsetLow]
    MOV EDX,[EDI+SYM.OffsetHigh]
    SUB EAX,[EBX+STM.OffsetLow]
    SBB EDX,[EBX+STM.OffsetHigh]            ; EDX:EAX is negative if symbol offset grows in this pass.
    JS .50:                                 ; Growing is acceptable in any pass, including the fixing one.
    JNSt [%PgmStatus],pgmFixingPass|pgmLastPass,.50:
    ; Do not decrease symbol offset in fixing pass. Stuff the emitted code with NOPs instead.
    ADD [EBX+STM.AlignBytes],EAX
    JMP .80:
.50:SUB [EDI+SYM.OffsetLow],EAX             ; Update offset in ordinary passes.
    SBB [EDI+SYM.OffsetHigh],EDX
    OR EAX,EDX
    JZ .55:
    RstSt [%Fixed],symFixed                 ; Signalize that offset has changed.
.55: ; <b>Update flag symFixed</b>.
    JSt [%Fixed],symFixed,.60:
    RstSt [EDI+SYM.Status],symFixed         ; This will force PassInspect to require one more pass.
.60:MOV EAX,[%Reason]
    JNSt EAX,symExplScopeMask,.80:
    ; <b>Existing symbol EDI is (re)declared</b>. Check for conflicts.
    JNSt EAX,symPublic|symExport,.70:
    JSt EAX,symForwarded|symExport,.70:
    JSt [EDI+SYM.Status],symExtern|symImport,.E6621: ; External symbol "!1S" defined at "!2@" cannot be made public.
.70:JNSt EAX,symExtern|symImport,.75:
    JSt [EDI+SYM.Status],symDefined,.E6622: ; Public symbol "!1S" defined at "!2@" cannot be made external.
.75:SetSt [EDI+SYM.Status],EAX              ; Update the scope.
.80:MOV EAX,[%Reason]
    JNSt EAX,symReferenced,.85:
    ; <b>Existing symbol is referenced</b>.
    SetSt EAX,symUsed
    PUSH EAX,EDI; If symbol EDI is member of a structured symbol, mark the parent symbol symReferenced, too.
      MOV EBX,EDI
      MOV EDI,[EBX+SYM.NamePtr]
      MOV ECX,[EBX+SYM.NameSize]
      MOV EDX,EDI
      MOV AL,'.'
      REPNE SCASB
      JNE .84:                              ; If there's no membership in symbol name.
      DEC EDI
      MOV ECX,[%Statement]
      JECXZ .84:
      MOV ECX,[ECX+STM.Program]
      SUB EDI,EDX                           ; EDX,EDI is now potentional parent's name.
      Invoke SymFindByName,0,EDX,EDI,ECX
      JC .84:                               ; If no parent exists.
      SetSt [EAX+SYM.Status],symUsed+symReferenced
.84:POP EDI,EAX
    SetSt [EDI+SYM.Status],EAX
    JSt [EDI+SYM.Status],symDefined,.85:
    JNSt [EDI+SYM.Status],symEstimated,.85:
    RstSt [EDI+SYM.Status],symEstimated
    XOR EAX,EAX
    MOV [EDI+SYM.OffsetLow],EAX             ; In the next passes is the original estimated offset $+64 changed to 0.
    MOV [EDI+SYM.OffsetHigh],EAX
.85:JNSt [%PgmStatus],pgmLastPass,.90:
    ; <b>Final pass check of the symbol</b>.
    JSt [EDI+SYM.Status],symDefined,.88:
    JSt [EDI+SYM.Status],symExtern|symImport|symForwarded|symEntry,.90:
    JMP .E6601:                             ; Symbol "!1S" mentioned at !2@ was not found.
.88:JSt  [EDI+SYM.Status],symIncluded|symScopeMask|symReferenced|symQueried,.90:
    MOV ECX,[EDI+SYM.Section]
    JECXZ .89:
    JSt [ECX+SSS.Status],sssStructure,.90:
.89:Msg '2101',EDI                          ; Symbol !1S was defined but never used.
.90:EndProcedure SymCreate
</pre>

<dl id="SymFrameAddress">
<dt><a href="#top">&uarr; SymFrameAddress</a> Symbol, Program</dt>
<dd><dfn>SymFrameAddress</dfn> returns addressing frame of the Symbol.
<br/>Addressing frame returned in ECX is <code>sssGroup</code> if symbol's segment is in a GROUP, otherwise
<code>sssSegment</code>. In program formats ELF* it is always <code>sssSegment
</code> because <code>sssGroup</code> represents "segment" in ELF program header.</dd>
<dt>Input</dt>
<dd><b>Symbol</b> is pointer to <a href="#SYM">SYM</a> object.
<br/><b>Program</b> is pointer to program <a class="EXT" href="pgm.htm#PGM">PGM</a> where the Symbol belongs.</dd>
<dt>Output</dt>
<dd><b>EDX:EAX</b>= offset of the Symbol.
<br/><b>ECX</b>= pointer to the group or segment <a class="EXT" href="sss.htm#SSS">SSS</a> of the symbol.
<b>ECX=0</b> when the symbol is scalar.</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pgm.htm#PgmListGlobals">PgmListGlobals</a>
</dd>
</dl><pre>
SymFrameAddress Procedure Symbol, Program
    SUB EAX,EAX
    SUB EDX,EDX
    SUB ECX,ECX
    MOV ESI,[%Symbol]
    MOV EBX,[%Program]
    TEST ESI
    JZ .80:
    MOV EAX,[ESI+SYM.OffsetLow]
    MOV EDX,[ESI+SYM.OffsetHigh]
    MOV ECX,[ESI+SYM.Section]
    JECXZ .80:                   ; Symbol is scalar.
    JSt [EBX+PGM.Pgmopt.Status],pgmoptELFbased,.80: ; Skip group in ELF* format.
    MOV EDI,[ECX+SSS.GroupPtr]
    TEST EDI
    JNZ .10:
    MOV EDI,ECX
.10:JNSt [ECX+SSS.Status],sssExtern,.20:
    MOV ESI,[ECX+SSS.SymPtr]
    TEST ESI
    JZ .80:
    ADD EAX,[ESI+SYM.OffsetLow]
    ADC EDX,[ESI+SYM.OffsetHigh]
    MOV ECX,[ESI+SYM.Section]
    JECXZ .80:
    MOV ECX,[ECX+SSS.SegmPtr]
    MOV EDI,[ECX+SSS.GroupPtr]
    TEST EDI
    JNZ .20:
    MOV EDI,ECX ; Group EDI equals to segment ECX if the segment is not grouped.
    JMP .30:
.20:MOV EDI,[EDI+SSS.GroupPtr]  ; Group might be linked from external module.
.30:TEST EDI
    JNZ .40:
    MOV EDI,ECX ; Group EDI equals to segment ECX if the segment is not grouped.
.40:; ECX is now symbol's segment and EDI its group, both are nonzero.
    JSt [EBX+PGM.Pgmopt.Status],pgmoptFLAT,.50: ; Frame is 0 in FLAT model.
    ADD EAX,[ECX+SSS.BottomLow]
    ADC EDX,[ECX+SSS.BottomHigh]
    SUB EAX,[EDI+SSS.BottomLow]
    SBB EDX,[EDI+SSS.BottomHigh]
.50:MOV ECX,EDI
.80:MOV [%ReturnEAX],EAX
    MOV [%ReturnEDX],EDX
    MOV [%ReturnECX],ECX
EndProcedure SymFrameAddress
</pre>

<dl id="SymDynamicLink">
<dt><a href="#top">&uarr; SymDynamicLink</a> Sym, PgmPtr, DllPtr, DllSize, FwdPtr, FwdSize</dt>
<dd>This procedure will set symbol's dynamic-linking properties
<code>.DllName</code> and <code>.InterName</code>. Both Dll and Fwd parameters may be empty.
<br/>If the symbol is EXPORT and FwdSize&gt;0, it will set Fwd name to Sym.InterName and make it nonvolatile.
<br/>If the symbol is IMPORT or EXPORT and DllSize&gt;0, it will set Dll name to Sym.DllName
<!---->and overwrite whatever might have been set in Sym.DllName before.
<!---->The value is not just a simple copy of DllName,
<dfn>SymDynamicLink</dfn> tries to find another older import|export symbol with the same DllName
<!---->and reuse it, so it does not waste memory in program pool.
<!---->If the name was not on the pool, this procedure will store it.</dd>
<dt>Input</dt>
<dd><b>Sym</b> is pointer to and exported|imported <a href="#SYM">SYM</a> whose .DllName and .InterName will be set.
<br/><b>PgmPtr</b> is pointer to <a class="EXT" href="pgm.htm#PGM">PGM</a> where the symbol belongs.
<br/><b>DllPtr</b> is pointer to a volatile DLL name, e.g. <q>user32.dll</q>.
<br/><b>DllSize</b> is the number of bytes in the DLL name.
<br/><b>FwdPtr</b> is pointer to a volatile forwarded symbol name.
<br/><b>FwdSize</b> is the number of bytes in the forwarded symbol name.</dd>
<dt>Output</dt>
<dd>Dynamic-linking properties of Sym are set.</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="sss.htm#SssCreateExtern">SssCreateExtern</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pseudo.htm#PseudoScope">PseudoScope</a>
</dd>
</dl><pre>
SymDynamicLink Procedure Sym,PgmPtr,DllPtr,DllSize,FwdPtr,FwdSize
     MOV EDI,[%Sym]
     MOV EBX,[%PgmPtr]
     TEST EDI
     JZ .90:
     Invoke SssCreateExtern::,EDI,EBX
     JSt [EDI+SYM.Status],symImport,.10:
     JNSt [EDI+SYM.Status],symExport,.90:
     SetSt [EDI+SYM.Status],symGlobal ; Export symbol implies globality.
.10: MOV ECX,[%DllSize]
     MOV ESI,[%DllPtr]
     JECXZ .60: ; If LIB= is not explicitly specified, leave it as is.
     ListGetFirst [EBX+PGM.SymList] ; Reuse identical DllName from any older symbol.
     JZ .40:
.20: JNSt [EAX+SYM.Status],symImport|symExport,.30:
     MOV EDX,[EAX+SYM.DllNamePtr] ; Old nonvolatile DllName.
     Compare EDX,[EAX+SYM.DllNameSize],ESI,ECX
     JE .50: ; If found, reuse previously stored name EDX.
.30: ListGetNext EAX
     JNZ .20:
.40: PoolStore [EBX+PGM.Pool],ESI,ECX ; Make DllName nonvolatile.
     MOV EDX,EAX
.50: MOV ESI,EDX
     MOV [EDI+SYM.DllNamePtr],ESI
     MOV [EDI+SYM.DllNameSize],ECX
.60: JNSt [EDI+SYM.Status],symExport,.90:
     MOV ESI,[%FwdPtr]
     MOV ECX,[%FwdSize]
     JECXZ .90: ; If no forward was specified.
     SetSt [EDI+SYM.Status],symForwarded
     PoolStore [EBX+PGM.Pool],ESI,ECX
     JMP .80:
.70: MOV EAX,[EDI+SYM.NamePtr] ; Default Fwd name is identical with symbol name.
     MOV ECX,[EDI+SYM.NameSize]
.80: MOV [EDI+SYM.InterNamePtr],EAX
     MOV [EDI+SYM.InterNameSize],ECX
.90:EndProcedure SymDynamicLink
</pre>

<dl id="SymStoreForwarderName">
<dt><a href="#top">&uarr; SymStoreForwarderName</a> Symb, FwdBuffer</dt>
<dd>This procedure will store ASCIIZ string which consists of Symb.DllName
<!---->without path and extension, concatenated with forwarder name from Symb.InterName.
<dt>Input</dt>
<dd><b>Symb</b> is pointer to <a href="#SYM">SYM</a> symbol with
<code>symExport+symForwarded</code> flags set.
<br/><b>FwdBuffer</b> is pointer to <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> where the forwarder name will be stored.</dd>
<dt>Output</dt>
<dd>Dynamic-linking properties of Sym are set.</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfpe.htm#PfpeExportCreate">PfpeExportCreate</a>
</dd>
</dl><pre>
SymStoreForwarderName Procedure Symb, FwdBuffer
     MOV EBX,[%Symb]
     JNSt [EBX+SYM.Status],symExport,.90:
     JNSt [EBX+SYM.Status],symForwarded,.90:
     MOV ESI,[EBX+SYM.DllNamePtr]
     MOV ECX,[EBX+SYM.DllNameSize]
     FileNameParse ESI,Size=ECX,Unicode=0
     SUB ECX,EAX                           ; EAX,ECX is now the file name without extension.
     MOV EDX,[%FwdBuffer]
     BufferStore EDX,EAX,ECX
     BufferStoreByte EDX,'.'
     MOV ESI,[EBX+SYM.InterNamePtr]
     MOV ECX,[EBX+SYM.InterNameSize]
     TEST ECX
     JNZ .80:
     MOV ESI,[EBX+SYM.NamePtr]
     MOV ECX,[EBX+SYM.NameSize]
.80: BufferStore EDX,ESI,ECX
     BufferStoreByte EDX,0
.90:EndProcedure SymStoreForwarderName
</pre>

<dl id="SymCreateLiteral">
<dt><a href="#top">&uarr; SymCreateLiteral</a> LitPtr, LitSize, StmPtr</dt>
<dd><dfn>SymCreateLiteral</dfn> will create a new literal symbol on <code>StmPtr.Program.SymList</code>
<!---->or reuse existing symbol with identical name.
<blockquote>LIteral strings without type specifier, e.g. <kbd>=&quot;String&quot;
</kbd> will be in fact created under modified name <kbd>=B&quot;String&quot;</kbd> or
<kbd>=U&quot;String&quot;</kbd>.</blockquote></dd>
<dt>Input</dt>
<dd><b>LitPtr</b> Source text which should be a literal, i.e. equal sign
<kbd>=</kbd> followed with optional duplication, then with short or long datatype name or structure name,
<!----> or followed with a quoted string.
<br/><b>LitSize</b> Number of bytes in source literal definition.
<br/><b>StmPtr</b> ^<a class="EXT" href="stm.htm#STM">STM</a> which refers/creates the literal symbol.</dd>
<dt>Output</dt>
<dd><b>CF=</b>0
<br/><b>EAX=</b> Pointer to new or reused <a href="#SYM">SYM</a>.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1, "E6671 Invalid syntax of literal symbol !1S" should be reported by the caller.
<br/><b>EAX=</b>0</dd>
<dt>See also</dt>
<dd><a class="EXT" href="exp.htm#ExpParseLiteral">ExpParseLiteral</a>.</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a class="EXT" href="exp.htm#ExpAlign">ExpAlign</a>
<a class="EXT" href="exp.htm#ExpEvalData">ExpEvalData</a>
<a class="EXT" href="sss.htm#SssCreateatLT">SssCreate@LT</a>
<a class="EXT" href="sss.htm#SssCreateatRT">SssCreate@RT</a>
<a class="EXT" href="sss.htm#SssEmit">SssEmit</a>
<a href="#SymFindByName">SymFindByName</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="exp.htm#ExpEval">ExpEval</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t1711.htm">t1711</a>
<a class="EXT" href="../eatests/t1713.htm">t1713</a>
<a class="EXT" href="../eatests/t1715.htm">t1715</a>
<a class="EXT" href="../eatests/t1717.htm">t1717</a>
</dd>
</dl><pre>
SymCreateLiteral Procedure LitPtr, LitSize, StmPtr
LitNameBuffer  LocalVar ; Temporary buffer for updated literal name.
LitEmitBuffer  LocalVar ; Temporary buffer for emitted data.
LitRelocBuffer LocalVar ; Temporary buffer for emitted relocations.
LitSection     LocalVar ; ^SSS with [@RT0] or [@LT*].
ExpStatus      LocalVar ; Status of literal evaluated to EXP.
     EaStackCheck                                ; Protect from SO in case of recursed literal.
     Invoke EaBufferReserve::,SymCreateLiteral
     MOV [%LitNameBuffer],EAX
     Invoke EaBufferReserve::,SymCreateLiteral
     MOV [%LitEmitBuffer],EAX
     Invoke EaBufferReserve::,SymCreateLiteral
     MOV [%LitRelocBuffer],EAX
     MOV EBX,[%StmPtr]
     TEST EBX
     JZ .Error:
     MOV EDX,[EBX+STM.Program]
     TEST EDX
     JNZ .10:
.Error:SUB EAX,EAX
     MOV [%ReturnEAX],EAX
     STC
     JMP .90:
.10: ; <b>Prepare literal name</b>.
     MOV EDI,[%LitNameBuffer]
     MOV ESI,[%LitPtr]
     MOV ECX,[%LitSize]
     StripSpaces ESI,ECX
     BufferStore EDI,ESI,ECX
     LEA EDX,[ESI+ECX]
     LODSB
     CMP AL,'='
     JNE .Error:
.14: CMP ESI,EDX
     JNB .22:
     LODSB
     ExpClassify AL
     TEST AH,expWhiteSpace
     JNZ .14:
     DEC ESI                                     ; ESI now points to source data expression.
     SUB EDX,ESI                                 ; EDX is size of the value, i.e. everything following <kbd>=</kbd>.
     TEST AH,expQuote
     JZ .22:
     ; Literal defines a string without type. <code>B</code> or <code>U</code> will be injected into its name.
     BufferClear EDI
     MOV AX,"=U"
     JSt [Ea.Eaopt.Status::],eaoptUNICODE,.18:   ; If EUROASM UNICODE=Enabled.
     MOV AX,"=B"
.18: BufferStoreWord EDI,EAX                     ; Insert either <code>=B</code> or <code>=U</code>.
     BufferStore EDI,ESI,EDX                     ; Insert the rest (quoted string).
.22: ; <b>Evaluate literal data</b> to %LitEmitBuffer and %LitRelocBuffer.
     BufferRetrieve EDI                          ; Literal name, e.g. <code>=U"Text"</code>.
     INC ESI                                     ; Omit theleading <kbd>=</kbd>.
     DEC ECX
     MOV EDX,[%LitEmitBuffer]
     Invoke ExpEvalData::,EDX,[%LitRelocBuffer],ESI,ECX,0,EBX
     MOV [%ExpStatus],EAX                        ; EAX='B' or 'W' or 'I'...etc (datatype) + expString flag.
     JC .Error:
     JNSt EAX,expString, .30:
     CMP AL,'B'
     JNE .26:
     BufferStoreByte EDX,0                       ; Terminate string literal value with NUL byte.
.26: CMP AL,'U'
     JNE .30:
     BufferStoreWord EDX,0                       ; Terminate string literal value with NUL unichar.
.30: CMP AL,'I'                                  ; <b>Get|create literal section</b> suitable for the literal data|code.
     JNE .34:
     Invoke SssCreate@RT::,0,EBX                 ; Create code literal section if it didn't exist.
     JMP .38:                                    ; EBX=^STM.
.34: Invoke SssCreate@LT::,EAX,EBX               ; Create data literal section if it didn't exist.
.38: JC .Error:
     MOV [%LitSection],EAX
     BufferRetrieve [%LitNameBuffer]
     MOV EDX,[EBX+STM.Program]
     XOR EDI,EDI
     Invoke SymFindByName,0,ESI,ECX,EDX          ; <b>Look if literal symbol with verbatim same name was already created</b> in program EDX.
     MOV [%ReturnEAX],EAX                        ; EAX=^SYM or 0.
     JNC .40:
     PoolStore [EDX+PGM.Pool],ESI,ECX             ; Not found. <b>A new literal symbol with name ESI,ECX will be created</b> in program EDX.
     MOV ESI,EAX                                  ; ESI,ECX is now nonvolatile literal name, e.g. "=B 1+2", with PGM lifetime.
     ListNew [EDX+PGM.SymList], Zeroed=yes        ; Allocate room for the new literal symbol in program EDX.
     MOV [%ReturnEAX],EAX                         ; EAX=^SYM, EBX=^STM, EDX=^PGM, ESI,ECX=literal name.
     MOV [EAX+SYM.NamePtr],ESI
     MOV [EAX+SYM.NameSize],ECX
     MOV ECX,[%ExpStatus]                         ; (Re)initialize status of literal symbol EAX.
     MOV EDX,[EBX+STM.LinePtr]
     RstSt ECX,expString
     SetSt ECX,symLiteral+symDefined+symReferenced+symUsed+symFixed
     MOV [EAX+SYM.LinePtr],EDX                    ; Source line where it was first referred, i.e. created.
     MOV [EAX+SYM.Status],ECX
.40: MOV EBX,[%LitSection]
     MOV EDI,[EAX+SYM.OffsetLow]
     JSt [EAX+SYM.Status],symDefInPass,.62:       ; Skip emit to literal section when already emitted.
     SetSt [EAX+SYM.Status],symDefInPass
     ; <b>Look if the value of symbol EAX stored in [%LitEmitBuffer] is already emitted</b> in %LitSection.
     BufferRetrieve [%LitRelocBuffer]             ; Are there any relocations in literal value?
     TEST ECX                                     ; Relocatable value cannot be shared
     JNZ .53:                                     ;  because it might be resolved to a different VA.
     BufferRetrieve [EBX+SSS.EmitBuffer]
     MOV EDI,ESI
     LEA EDX,[ESI+ECX]                            ; EDI..EDX is now the already emitted contents of literal section.
.46: BufferRetrieve [%LitEmitBuffer]              ; ESI,ECX is now the new literal value. EAX=^SYM, EBX=^SSS.
     LEA EAX,[EDI+ECX]
     CMP EAX,EDX
     JA  .53:                                     ; Skip when behind the section limit.
     PUSH EDI
       REPE CMPSB
     POP EDI
     JE .49:                                      ; Reusable literal value was found.
     ADD EDI,[EBX+SSS.Alignment]                  ; Try the next possible aligned position in literal section.
     JMP .46:
.49: ; Reusable literal value was found in SSS.EmitBuffer at EDI.
     BufferRetrieve [EBX+SSS.EmitBuffer]
     SUB EDI,ESI
     JMP .62:

.53: ; Literal value was not found in SSS.EmitBuffer. Let's emit [%LitEmitBuffer] to the section EBX.
     Invoke ExpAlign::,[EBX+SSS.OrgLow],[EBX+SSS.Alignment],0 ; Get AlignBytes to ECX.
     MOV EDI,[EBX+SSS.OrgLow]
     ADD EDI,ECX
     MOV EAX,[%ReturnEAX]
     MOV [EAX+SYM.OffsetLow],EDI
     MOV ESI,[%StmPtr]
     MOV EAX,[ESI+STM.Program]
     MOV ESI,[%LitRelocBuffer]
     JSt [EAX+PGM.Status],pgmLastPass, .57:
     XOR ESI,ESI                                  ; Do not store relocation if not in the final pass.
.57: Invoke SssEmit::,EBX,[%LitEmitBuffer],ESI,ECX
.62: MOV EAX,[%ReturnEAX]                         ; <b>Update properties of literal symbol EAX</b>.
     CMP EDI,[EAX+SYM.OffsetLow]                  ; EDI is symbol offset from segment's bottom.
     JE .70:
     MOV [EAX+SYM.OffsetLow],EDI                  ; Offset from previous pass is different.
     RstSt [EAX+SYM.Status],symFixed
.70: MOV EBX,[%LitSection]
     CMP EBX,[EAX+SYM.Section]
     JE .75:
     MOV [EAX+SYM.Section],EBX
     RstSt [EAX+SYM.Status],symFixed
.75: MOV ECX,[EBX+SSS.Alignment]
     CMP ECX,[EAX+SYM.Align]
     JE .80:
     MOV [EAX+SYM.Align],ECX
     RstSt [EAX+SYM.Status],symFixed
.80: BufferRetrieve [%LitEmitBuffer]
     CMP ECX,[EAX+SYM.Size]
     JE .90:
     MOV [EAX+SYM.Size],ECX
     RstSt [EAX+SYM.Status],symFixed
.90: PUSHFD                                       ; Keep CF.
      Invoke EaBufferRelease::,[%LitEmitBuffer]
      Invoke EaBufferRelease::,[%LitRelocBuffer]
      Invoke EaBufferRelease::,[%LitNameBuffer]
     POPFD                                        ; Restore CF.
    EndProcedure SymCreateLiteral
</pre>

    <dl id="SymCreateSe">
<dt><a href="#top">&uarr; SymCreateSe</a> SePtr, PgmPtr</dt>
<dd><dfn>SymCreateSe</dfn> will create or update a symbol of type
<code>symSe</code> with the same name as the group|segment|section.
<!---->This new symbol represents the bottom of group|segment|section and it can be used in relocations.</dd>
<dt>Input</dt>
<dd><b>SePtr</b> ^<a class="EXT" href="sss.htm#SSS">SSS</a> of type sssGroup or sssSegment or sssSection.
<br/><b>PgmPtr</b> ^<a class="EXT" href="pgm.htm#PGM">PGM</a> where the symbol belongs.</dd>
<dt>Output</dt>
<dd>Symbol symSe is created or updated and its pointer stored in SePtr's <code>SSS.SymPtr</code>.</dd>
<dt>Error</dt>
<dd><b>-</b></dd>
<dt>Invokes</dt>
<dd><a href="#SymFindByName">SymFindByName</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfelf.htm#PfelfSssTab">PfelfSssTab</a>
<a class="EXT" href="pfelfso.htm#PfelfsoSssDynTab">PfelfsoSssDynTab</a>
<a class="EXT" href="pfomf.htm#PfomfLoadModule">PfomfLoadModule</a>
<a class="EXT" href="pgm.htm#PgmGroupByModel">PgmGroupByModel</a>
<a class="EXT" href="pseudo.htm#PseudoGROUP">PseudoGROUP</a>
<a class="EXT" href="sss.htm#SssCreateImplicit">SssCreateImplicit</a>
<a class="EXT" href="sss.htm#SssCreateSe">SssCreateSe</a>
</dd>
</dl><pre>
SymCreateSe Procedure SePtr, PgmPtr
       MOV EDI,[%SePtr]
       MOV EBX,[%PgmPtr]
       MOV ESI,[EDI+SSS.NamePtr]
       MOV ECX,[EDI+SSS.NameSize]
       Invoke SymFindByName,symSe,ESI,ECX,EBX
       JNC .20:
       ListNew [EBX+PGM.SymList],Zeroed=Yes
.20:   MOV [EDI+SSS.SymPtr],EAX
       MOV [EAX+SYM.NamePtr],ESI
       MOV [EAX+SYM.NameSize],ECX
       MOV [EAX+SYM.Section],EDI
       MOV ECX,[EDI+SSS.LinePtr]
       MOV [EAX+SYM.Status],symSe+symDefined+symFixed+'A'
       MOV [EAX+SYM.LinePtr],ECX
    EndProcedure SymCreateSe
</pre>


<dl id="SymCombine">
<dt><a href="#top">&uarr; SymCombine</a> Symbol, BasePgm</dt>
<dd><dfn>SymCombine</dfn> will copy the global Symbol from linked module to the BasePgm.</dd>
<dt>Input</dt>
<dd><b>Symbol</b> is pointer to a <a href="#SYM">symbol</a> in selected module, which is being merged to BasePgm.
<br/><b>BasePgm</b> is pointer to a <a class="EXT" href="pgm.htm#PGM">PGM</a>.</dd>
<dt>Output</dt>
<dd>-</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>Invokes</dt>
<dd><a href="#SymFindByName">SymFindByName</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pgm.htm#PgmCombine">PgmCombine</a>
</dd>
</dl><pre>
SymCombine Procedure Symbol, BasePgm
    MOV EBX,[%BasePgm]
    MOV ESI,[%Symbol]
    MOV EDX,[ESI+SYM.Status]
    JNSt EDX,symSe,.30:
    MOV ECX,[ESI+SYM.Section]             ; Symbol symSe (which is assigned to a segment).
    JECXZ .90:
    JNSt [ECX+SSS.Status],sssCombined,.30:
    MOV EDX,[ECX+SSS.SegmPtr]             ; Do not copy symSe symbol from already combined segment to the BasePgm.
    MOV EAX,[EDX+SSS.SymPtr]              ; Let it refer to the symSe in BasePgm instead.
    MOV [ESI+SYM.SymbPtr],EAX
    JMP .90:
.30:JNSt EDX,symPublic,.40:
    Invoke SymFindByName, symPublic,[ESI+SYM.NamePtr],[ESI+SYM.NameSize],EBX
    JC .70:
    Msg '8540',EAX,[EAX+SYM.LinePtr]; Public symbol "!1S" was already defined at !2@.
    JMP .90:

.40:JNSt EDX,symImport,.70:
    Invoke SymFindByName, symImport,[ESI+SYM.NamePtr],[ESI+SYM.NameSize],EBX
    JC .70:
    ; Merge import symbol ESI to EAX.
    MOV [ESI+SYM.SymbPtr],EAX
    SetSt [ESI+SYM.Status],symResolved
    MOV ECX,[EAX+SYM.DllNameSize]
    TEST ECX
    JNZ .90:
    MOV EDI,[ESI+SYM.DllNamePtr]
    MOV ECX,[ESI+SYM.DllNameSize]
    MOV [EAX+SYM.DllNamePtr],EDI
    MOV [EAX+SYM.DllNameSize],ECX
    JMP .90:

.70:ListStore [EBX+PGM.SymList],ESI       ; Copy the linked symbol to BasePgm.
    MOV EDI,EAX                           ; Copied symbol on BasePgm.
    SetSt [EDI+SYM.Status],symDefined
    MOV [ESI+SYM.SymbPtr],EDI             ; Let the abandoned symbol ESI refer to copied symbol EDI.
    MOV ECX,[EDI+SYM.Section]
    JECXZ .90:
    MOV EAX,[ECX+SSS.BottomLow]
    MOV EDX,[ECX+SSS.BottomHigh]
    MOV ECX,[ECX+SSS.SegmPtr]
    SUB EAX,[ECX+SSS.BottomLow]
    SBB EDX,[ECX+SSS.BottomHigh]
    ADD [EDI+SYM.OffsetLow],EAX
    ADC [EDI+SYM.OffsetHigh],EDX
    MOV [EDI+SYM.Section],ECX
.90:EndProcedure SymCombine
</pre>

<dl id="SymReportUnresolved">
<dt><a href="#top">&uarr; SymReportUnresolved</a> PgmPtr</dt>
<dd><p><dfn>PgmCheckUnresolved</dfn> will check all external and imported symbols and report E6961
<!---->when they were not matched to their homonymous public symbols.</p>
<p>This procedure is not invoked when the program format is linkable.</p></dd>
<dt>Input</dt>
<dd><b>PgmPtr</b> is pointer to the <a class="EXT" href="pgm.htm#PGM">PGM</a> (program whose symbols are checked).</dd>
<dt>Output</dt>
<dd>-</dd>
<dt>Error</dt>
<dd>E6961 is reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a> for each unresolved symbol.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfbin.htm#PfbinCompile">PfbinCompile</a>
<a class="EXT" href="pfboot.htm#PfbootCompile">PfbootCompile</a>
<a class="EXT" href="pfcom.htm#PfcomCompile">PfcomCompile</a>
<a class="EXT" href="pfmz.htm#PfmzCompile">PfmzCompile</a>
<a class="EXT" href="pfpe.htm#PfpeCompile">PfpeCompile</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t2381.htm">t2381</a>
</dd>
</dl><pre>
SymReportUnresolved Procedure PgmPtr
    MOV EBX,[%PgmPtr]
    ListGetFirst [EBX+PGM.SymList]
    JZ .90:
.10:JNSt [EAX+SYM.Status],symExtern|symImport,.80:
    JSt [EAX+SYM.Status],symResolved|symPublic|symForwarded,.80:
    Msg '6961',EAX                               ; Unresolved external/imported symbol "!1S".
.80:ListGetNext EAX
    JNZ .10:
.90:EndProcedure SymReportUnresolved
</pre>

<dl id="SymResolve">
<dt><a href="#top">&uarr; SymResolve</a> Symbol, BasePgm</dt>
<dd>Combining linked modules often ends with multiple symbols with the same name in BasePgm.
<dfn>SymResolve</dfn> will match one unresolved external, exported and imported symbol (which was copied to the BasePgm)
<!-->with homonymous public or weak symbol.
<!-->Succesfully matched symbol is then marked with <code>symResolved</code> and its
<code>SYM.SymbPtr</code> points to the matching public (or weak) symbol in BasePgm.</dd>
<dt>Input</dt>
<dd><b>Symbol</b> is pointer to a <a href="#SYM">SYM</a>.
<br/><b>BasePgm</b> is pointer to a <a class="EXT" href="pgm.htm#PGM">PGM</a> which it is linked to.</dd>
<dt>Output</dt>
<dd>-</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>Invokes</dt>
<dd><a href="#SymFindByName">SymFindByName</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pgm.htm#PgmSymResolve">PgmSymResolve</a>
</dd>
</dl><pre>
SymResolve Procedure Symbol, BasePgm
    MOV EDI,[%Symbol]
    MOV EBX,[%BasePgm]
    JSt [EDI+SYM.Status],symResolved,.90:
    JNSt [EDI+SYM.Status],symExtern|symImport,.90:
    MOV EDX,EDI
    MOV ECX,[EDI+SYM.SymbPtr]
    JECXZ .30:
    MOV EDX,ECX
    MOV ECX,[EDX+SYM.SymbPtr]
    JECXZ .30:
    MOV EDX,ECX
.30:MOV ESI,[EDI+SYM.NamePtr]
    MOV ECX,[EDI+SYM.NameSize]
    Invoke SymFindByName,symPublic,ESI,ECX,EBX   ; Prefer PUBLIC scope.
    JNC .50:
    Invoke SymFindByName,symWeak,ESI,ECX,EBX     ; When PUBLIC symbol is not found, try to find a WEAK one.
    JNC .50:
    Invoke SymFindByName,symImport,ESI,ECX,EBX   ; Try to match external symbol to an imported one.
    JNC .50:
    Invoke SymFindByName,symSe,ESI,ECX,EBX       ; Try to match external segment's pseudosymbol to a standard one.
    JC .90:
.50:CMP EAX,EDI
    JE .90:                                      ; Never resolve symbol with itself.
    MOV [EDI+SYM.SymbPtr],EAX                    ; Pointer to the resolved public counterpart.
.60:SetSt [EDI+SYM.Status],symResolved
.70:JNSt [EDI+SYM.Status],symExport,.90:
    SetSt [EAX+SYM.Status],symExport
.90:EndProcedure SymResolve
</pre>

<dl id="SymLowcaseDll">
<dt><a href="#top">&uarr; SymLowcaseDll</a> ImpSym</dt>
<dd>Name of DLL, where is the symbol imported from, will be converted to lower case.</dd>
<dt>Input</dt>
<dd><b>ImpSym</b> is pointer to an (imported) <a href="#SYM">SYM</a>.</dd>
<dt>Output</dt>
<dd>Filename specified by <code>SYM.DllNamePtr</code> is converted to lower case.</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfpe.htm#PfpeImportCreate">PfpeImportCreate</a>
</dd>
</dl><pre>
SymLowcaseDll Procedure ImpSym
    MOV EBX,[%ImpSym]
    MOV ECX,[EBX+SYM.DllNameSize]
    JECXZ .90:
    MOV ESI,[EBX+SYM.DllNamePtr]
.20:LODSB
    CMP AL,'A'
    JB .50:
    CMP AL,'Z'
    JA .50:
    XOR AL,'A'^'a'
    MOV [ESI-1],AL
.50:DEC ECX
    JNZ .20:
.90:EndProcedure SymLowcaseDll
</pre>
<pre>
ENDPROGRAM sym
</pre><!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
