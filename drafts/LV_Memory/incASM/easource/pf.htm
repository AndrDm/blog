<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='pf.htm source file'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>pf.htm source file</title>
</head>
<body class='EASOURCE' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>pf.htm
<br/><i>Enumerations</i>
<br/><a href="#PfList">%PfList</a>
<br/><a href="#PfList">%PfPgmoptList</a>
<br/><i>Macro</i>
<br/><a href="#PfQueryChar">PfQueryChar</a>
<br/><i>Procedures</i>
<br/><a href="#PfDetect">PfDetect</a>
<br/><a href="#PfDrectveCreate">PfDrectveCreate</a>
<br/><a href="#PfDrectveDestroy">PfDrectveDestroy</a>
<br/><a href="#PfLoad">PfLoad</a>
<br/><a href="#PfOutput">PfOutput</a>
<br/><a href="#PfSuboperate">PfSuboperate</a>
</h1>
<p>This is a common source for generating EuroAssembler output file in a chosen <strong>program format</strong>.
<!---->Its interface and procedures are used in actual format modules (<q>pfbin.htm</q>, <q>pfcom.htm</q> etc).
</p>
<!--SRC_PF-->
<!--Contents between markers {!==SRC_PF==} and {!==/SRC_PF==} was generated by "generate.php".-->
<table><caption>Program formats modules</caption>
<tr><th>Format</th><th>Platform</th><th>Module file</th></tr>
<tr><th class='DIMMED'><em class='DIMMED'>all</em></th><td><small>Linker for all &euro;ASM format output files</small></td><td><a class='EXT' href='../easource/pf.htm'>pf.htm</a></td></tr>
<tr><th>BIN</th><td><small>Binary output file</small></td><td><a class='EXT' href='../easource/pfbin.htm'>pfbin.htm</a></td></tr>
<tr><th>BOOT</th><td><small>Boot sector file</small></td><td><a class='EXT' href='../easource/pfboot.htm'>pfboot.htm</a></td></tr>
<tr><th>COFF</th><td><small>16|32|64bit Common Object Format module</small></td><td><a class='EXT' href='../easource/pfcoff.htm'>pfcoff.htm</a></td></tr>
<tr><th>COM</th><td><small>16bit DOS executable</small></td><td><a class='EXT' href='../easource/pfcom.htm'>pfcom.htm</a></td></tr>
<tr><th>DLL</th><td><small>32|64bit Dynamically Linked Library</small></td><td><a class='EXT' href='../easource/pfdll.htm'>pfdll.htm</a></td></tr>
<tr><th>ELF</th><td><small>32|64bit linkable module</small></td><td><a class='EXT' href='../easource/pfelf.htm'>pfelf.htm</a></td></tr>
<tr><th>ELFSO</th><td><small>32|64bit Linux shared object</small></td><td><a class='EXT' href='../easource/pfelfso.htm'>pfelfso.htm</a></td></tr>
<tr><th>ELFX</th><td><small>32|64bit Linux executable</small></td><td><a class='EXT' href='../easource/pfelfx.htm'>pfelfx.htm</a></td></tr>
<tr><th>LIBCOF</th><td><small>Library of COFF modules</small></td><td><a class='EXT' href='../easource/pflibcof.htm'>pflibcof.htm</a></td></tr>
<tr><th>LIBOMF</th><td><small>Library of OMF modules</small></td><td><a class='EXT' href='../easource/pflibomf.htm'>pflibomf.htm</a></td></tr>
<tr><th>MZ</th><td><small>16bit DOS executable</small></td><td><a class='EXT' href='../easource/pfmz.htm'>pfmz.htm</a></td></tr>
<tr><th>OMF</th><td><small>16|32bit Object Module Format</small></td><td><a class='EXT' href='../easource/pfomf.htm'>pfomf.htm</a></td></tr>
<tr><th>PE</th><td><small>32|64bit Windows Portable Executable</small></td><td><a class='EXT' href='../easource/pfpe.htm'>pfpe.htm</a></td></tr>
<tr><th>RSRC</th><td><small>Compiled Windows resource (input only)</small></td><td><a class='EXT' href='../easource/pfrsrc.htm'>pfrsrc.htm</a></td></tr>
</table>
<!--/SRC_PF-->
<p>Most important procedure <a href="#PfOutput">PfOutput</a> is invoked after the final assembly pass
<!---->and it provides all functions of <em>linker</em>:
<ol><li>Sections of the just assembled main program are joined to their base segment,</li>
<li>external programs (modules and libraries) requested in source text by pseudoinstruction LINK
<!---->are loaded from disk, converted to internal <a class="EXT" href="pgm.htm#PGM">PGM
</a> format and saved on main program's .ModulePgmList,</li>
<li>segments of all loaded programs are combined to the main program,</li>
<li>order of segments is set,</li>
<li>segments are linked into executable image,</li>
<li>headers and other auxilliary structures are updated,</li>
<li>data in requested output file format are stored to output
<a class="EXT" href="../maclib/memory32.htm#STREAM">STREAM</a> and then to a disk file.</li></ol>

<dl id="PfModel"><dt>Linker  <a class="EXT" href="index.htm#DOM">object model</a></dt>
<dd class="PRE"><a class="EXT" href="pseudo.htm#PseudoENDPROGRAM">PseudoENDPROGRAM</a>                           ; Last statement of program reached.
    <a class="EXT" href="pgm.htm#PgmLinkSections">PgmLinkSections</a>                        ; Concatenate sections of each segment, if any.
    <a class="EXT" href="pass.htm#PassInspect">PassInspect</a>                            ; Final pass detected.
    <a class="EXT" href="pgm.htm#PgmListLiterals">PgmListLiterals</a>                        ; Write literal symbols to listing, if requested.
    <a class="EXT" href="pass.htm#PassDestroy">PassDestroy</a>                            ; The final assembly pass is ending.
    <a class="EXT" href="pgm.htm#PgmDestroy">PgmDestroy</a>                             ; The base program assembly is ending.
        <a class="EXT" href="chunk.htm#ChunkTotalLines">ChunkTotalLines</a>                    ; Some statistics, unimportant..
        <a class="EXT" href="pgm.htm#PgmCheckDirty">PgmCheckDirty</a>                      ; Check if anything was emitted to at least one segment.
        <a href="pf.htm#PfOutput">PfOutput</a>                           ; The &euro;ASM linker.
            <a class="EXT" href="pgmopt.htm#PgmoptSetLinkProp">PgmoptSetLinkProp</a>              ; Mark the output as linkable, executable etc.
            <a href="pf.htm#PfLoad">PfLoad</a>                         ; Read modules specified by LINK statements.
                <a class="EXT" href="syswin.htm#SysOpenFileMap">SysOpenFileMap</a>
                <a href="#PfDetect">PfDetect</a>                   ; Autodetect the format of linked module.
                <a class="EXT" href="pgmopt.htm#PgmoptSetLinkProp">PgmoptSetLinkProp</a>          ; Mark the loaded module properties.
                <!---->Pf<i>Format</i>LoadPgm            ; Convert linked module to &euro;ASM internal format (PGM class).
                    <a href="pfomf.htm#PfomfLoadModule">PfomfLoadModule</a>
                        <a class="EXT" href="pgmopt.htm#PgmoptSetLinkProp">PgmoptSetLinkProp</a>
                        <a href="pf.htm#PfDrectveDestroy">PfDrectveDestroy</a>
                        <a href="pgm.htm#PgmDetectImportModule">PgmDetectImportModule</a>
                    <a href="pfcoff.htm#PfcoffLoadModule">PfcoffLoadModule</a>
                        <a class="EXT" href="pgmopt.htm#PgmoptSetLinkProp">PgmoptSetLinkProp</a>
                        <a href="pf.htm#PfDrectveDestroy">PfDrectveDestroy</a>
            <a class="EXT" href="pgm.htm#PgmSelectModules">PgmSelectModules</a>               ; Select referenced modules (smart linking).
            <a class="EXT" href="pgm.htm#PgmCombine">PgmCombine</a>                     ; Combine segments and symbols of selected modules to the base PGM.
                <a class="EXT" href="sss.htm#SssCombine">SssCombine</a>
                <a class="EXT" href="reloc.htm#RelocCombine">RelocCombine</a>
            <!---->Pf<i>Format</i>Compile                ; Convert PGM to the output format and store to a stream.
                <a class="EXT" href="sss.htm#SssCreateImplicit">SssCreateImplicit</a>
                <a class="EXT" href="pfmz.htm#PfmzDefaultStack">PfmzDefaultStack</a>
                <a class="EXT" href="reloc.htm#RelocPurge">RelocPurge</a>
                <a class="EXT" href="pfpe.htm#PfpeImportCreate">PfpeImportCreate</a>
                <a class="EXT" href="pfpe.htm#PfpeExportCreate">PfpeExportCreate</a>
                <a class="EXT" href="pfpe.htm#PfpeBaserelocCreate">PfpeBaserelocCreate</a>
                <a class="EXT" href="pfrsrc.htm#PfrsrcLoadIconFile">PfrsrcLoadIconFile</a>
                <a class="EXT" href="pgm.htm#PgmOrderSegments">PgmOrderSegments</a>
                <a href="pf.htm#PfDrectveCreate">PfDrectveCreate</a>
                <a class="EXT" href="pfcoff.htm#PfcoffFileHeader">PfcoffFileHeader</a>
                <a class="EXT" href="pfpe.htm#PfpeOptionalHeader">PfpeOptionalHeader</a>
                <a class="EXT" href="pfpe.htm#PfpeImportFixup">PfpeImportFixup</a>
                <a class="EXT" href="pfpe.htm#PfpeExportFixup">PfpeExportFixup</a>
                <a class="EXT" href="pfpe.htm#PfpeBaserelocFixup">PfpeBaserelocFixup</a>
                <a class="EXT" href="pfcoff.htm#PfcoffSegmRawData">PfcoffSegmRawData</a>
                <a class="EXT" href="pgm.htm#PgmEvalEntry">PgmEvalEntry</a>
            <a href="pf.htm#PfSuboperate">PfSuboperate</a>                   ; Resolve suboperation if requested for OUTFILE=.
            <a class="EXT" href="syswin.htm#SysCreateFile">SysCreateFile</a>
            <a class="EXT" href="syswin.htm#SysWriteFile">SysWriteFile</a>                   ; Flush the memory stream to a disk file.
        <a class="EXT" href="pgm.htm#PgmListMap">PgmListMap</a>                         ; Display map of linked groups and segments in listing.
        <a class="EXT" href="pgm.htm#PgmListGlobals">PgmListGlobals</a>                     ; Display global symbols in listing.
    <a class="EXT" href="ctx.htm#CtxDiscard">CtxDiscard</a>                             ; Exit the linked program context.
</dd></dl>

<p>Linkers have to cope with three basic kinds of <b>symbols</b> and their
<b>relation to segments</b>:</p>
<ol><li>Standard <b>private</b> and <b>public</b> address symbols are associated with the segment they were defined in.
<!---->Symbol (stored in the symbol table of object file) contains ordinal number of its segment.</li>
<li>Segment of <b>external</b> symbols are not know yet at the beginning of link-time.
<!---->Their segment identifier (ordinal number) is NULL, it will be resolved later
<!---->and replaced with identifier of segment where the symbol is linked to.</li>
<li>Scalar <b>numeric</b> symbols assign special negative value to segment identifier
<!---->instead of its ordinal (<code>SYM_ABSOLUTE=-1</code> in
<a class="EXT" href="pfcoff.htm#PFCOFF_encodings">COFF</a>,
<code>SHN_ABS=-15</code> in <a class="EXT" href="pfelf.htm#PfelfEncodings">ELF</a>).
<br/>Some tools create a special pseudosegment for numeric constants, often named as
<code>.scalars</code>, <code>ABSOLUTE</code> etc.</li></ol>
<p>EuroAssembler uses a slightly different approach: absolute <b>numeric</b> symbols,
<!---->which do not belong to any segment, have their segment identifier NULL (empty).
<br/>When a symbol is declared as <b>external</b>, it is associated with a special
<em>external pseudosegment</em> which &euro;ASM creates in parallel with symbol declaration
<!---->and with identical name. This pseudosegment will be replaced by a real segment later at link time.</p>
<!----><samp>|[.text]          |
<!---->|00000123:        |
<!---->|[.text]:00000123 |StdSym: EQU $    ; Associated with the current segment <code>[.text]</code>.
<!---->|[]:00000456      |NumSym: EQU 456h ; Not associated with any segment, presented as empty <code>[]</code>.
<!---->|                 |ExtSym: EXTERN   ; Temporarily associated with pseudosegment <code>[ExtSym]</code>.</samp>
<blockquote id="ExtendFORMAT">In order to introduce a new output program format:<ol>
<li>Choose a unique format <dfn>shortcut</dfn> and add it on <a href="#PfList">PfList</a>.</li>
<li>Create source file <q>pf<small>shortcut</small>.htm</q> with the corresponding formatting procedure
<code>Pf<small>shortcut</small>Compile</code> and loading procedure
<code>Pf<small>shortcut</small>LoadPgm</code>.</li>
<li>Update procedure <a href="#PfDetect">PfDetect</a>.</li>
<li>Update procedure <a class="EXT" href="pgmopt.htm#PgmoptSetDefaults">PgmoptSetDefaults</a>.</li>
<li>Update procedure <a class="EXT" href="pgmopt.htm#PgmoptSetLinkProp">PgmoptSetLinkProp</a>.</li>
<!--li>Update procedure <a class="EXT" href="sss.htm#SssCreateImplicit">SssCreateImplicit</a>.</li-->
<li>Update procedure <a class="EXT" href="pgm.htm#PgmListMap">PgmListMap</a>.</li>
<li>Update <a class="EXT" href="../eadoc/index.htm#FORMATeq">PROGRAM FORMAT=</a> documentation in manual.</li>
<li>Create test file(s) for the new format.</li>
<li>Rebuild EuroAssembler.</li>
</ol></blockquote>
<pre>
pf PROGRAM FORMAT=COFF,MODEL=FLAT,WIDTH=32
   INCLUDEHEAD euroasm.htm, \  Interface (structures, symbols and macros) of other modules used in this source.
               dict.htm,ea.htm,eaopt.htm,exp.htm,msg.htm,pfcoff.htm,pfelf.htm,pfmz.htm, \
               pfomf.htm,pfpe.htm,pgm.htm,pgmopt.htm,sym.htm,sss.htm,stm.htm
</pre>

<pre>
 pf HEAD ; Start module interface.
</pre>

<dl id="PfList"><dt><a href="#top">&uarr; %PfList</a></dt>
<dd>This enumeration declares output program formats which EuroAssembler supports.
<br/>For each supported format it also defines a corresponding numeric option in
<a class="EXT" href="pgmopt.htm#PgmoptEnc">PgmoptEnc</a>oding:<code>
<br/>pgmoptBIN  EQU 1
<br/>pgmoptBOOT EQU 2
<br/>pgmoptCOM  EQU 3</code> etc. Names of those values are enumerated in <code>%PfPgmoptList</code>.
</dd></dl><pre>
%PfList        %SET BIN,BOOT,COM,OMF,LIBOMF,MZ,COFF,LIBCOF,DLL,PE,RSRC,ELF,ELFX,ELFSO

%value %SETA 1     ; Numeric value of <code>PGMOPT.Status</code> pgmoptBIN, pgmoptCOM etc.
%PfPgmoptList %SET ; Initialize the enumeration to emptiness.
pf %FOR %PfList
     pgmopt%pf     EQU %value ; The actual option definition.
     %PfPgmoptList %SET pgmopt%pf,%PfPgmoptList ; Prepend the option name.
     %value        %SETA %value+1 ; Increment value for the next format.
   %ENDFOR pf
</pre>

<dl id="PfQueryChar">
<dt><a href="#top">&uarr; PfQueryChar</a> Char</dt>
<dd>Macro <dfn>PfQueryChar</dfn> searches for a %Char in string ESI,EDX.</dd>
<dt>Input</dt>
<dd><b>Char</b> is a character to find.
<br/><b>ESI</b> is pointer to the searched string.
<br/><b>EDX</b> is size of the searched string.
<dt>Output</dt>
<dd><b>ZF=1</b> if the string contains Char.
<br/><b>EAX,EDI,ECX</b> changed.</dd></dl><pre>
PfQueryChar %MACRO Char ; Ad hoc macro to find a Char in string ESI,EDX.
       MOV AL,%Char
       MOV EDI,ESI
       MOV ECX,EDX
       REPNE SCASB
     %ENDMACRO PfQueryChar
</pre>

<pre>
%EuroasmDefaultDllName     %SET kernel32.dll            ; Used when IMPORT lacks the LIB= specification.
%EuroasmDefaultDllNameSize %SETS %EuroasmDefaultDllName ; Number of characters in Dll name.
</pre>
<pre>
 ENDHEAD pf  ; End of module interface.
</pre>

<dl id="PfOutput">
<dt><a href="#top">&uarr; PfOutput</a> Pgm</dt>
<dd>EuroAssembler linker. Its main procedure <dfn>PfOutput</dfn> creates output program file with name specified by <code>Pgm.Pgmopt.OutFile
</code> in the format specified by <code>Pgm.Pgmopt.Status:pgmoptFormatMask</code>.
<br/>PfOutput is dispatcher to actual format creators Pf<i>Format
</i>Compile, which write the output to an intermediary memory <a class="EXT" href="../maclib/memory32.htm#STREAM">stream
</a>. The stream is finally flushed to a disk file.</dd>
<dt>Input</dt>
<dd><b>Pgm</b> Pointer to a completely assembled
<a class="EXT" href="pgm.htm#PGM">PGM</a> object. It may have PGM.LinkFile modules (not loaded yet).</dd>
<dt>Output</dt>
<dd>Output file is written to disk.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="dict.htm#DictSearchByData">DictSearchByData</a>
<a href="#PfLoad">PfLoad</a>
<a href="#PfSuboperate">PfSuboperate</a>
<a class="EXT" href="pgm.htm#PgmCombine">PgmCombine</a>
<a class="EXT" href="pgm.htm#PgmRelocResolve">PgmRelocResolve</a>
<a class="EXT" href="pgm.htm#PgmSelectModules">PgmSelectModules</a>
<a class="EXT" href="pgm.htm#PgmSymResolve">PgmSymResolve</a>
<a class="EXT" href="pgmopt.htm#PgmoptSetLinkProp">PgmoptSetLinkProp</a>
<a class="EXT" href="reloc.htm#RelocPurge">RelocPurge</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pgm.htm#PgmDestroy">PgmDestroy</a>
</dd>
</dl><pre>
PfOutput Procedure Pgm
OutputStream LocalVar ; Pointer to a <a class="EXT" href="../maclib/memory32.htm#STREAM">STREAM</a> which will accumulate data before they are dumped to the output file.
OutputFile   LocalVar Size=SIZE#FILE ; Structure <a class="EXT" href="../maclib/winf32.htm#FILE">FILE</a> for the output file.
    MOV EBX,[%Pgm]
    Invoke PgmoptSetLinkProp::,[EBX+PGM.Pgmopt.Status]
    ; <b>Load and select all external modules</b> which were requested by pseudoinstruction LINK
    ;  and store them on <code>Pgm.ModulePgmLst</code> as objects of <a class="EXT" href="pgm.htm#PGM">PGM</a> class.
    MOV ECX,[EBX+PGM.LinkFilesNr]
    JECXZ .20:                                     ; If no link requested.
    MOV ESI,[EBX+PGM.LinkFileNamesTable]
    MOV EDI,[EBX+PGM.LinkLinePtrTable]
.10:LODSD
    Invoke PfLoad,EBX,EAX,[EDI]
    ADD EDI,4
    LOOP .10:
.20:Invoke PgmSelectModules::,EBX
    ; <b>Combine segments and symbols from loaded programs to the base program EBX</b>.
    JSt [EBX+PGM.Pgmopt.Status],pgmoptLibrary,.30: ; If the target program is a library LIBOMF or LIBCOF, loaded not selected modules are not combined.
    Invoke PgmCombine::,EBX                        ; Copy or merge selected modules to the base program EBX.
    Invoke PgmSymResolve::,EBX                     ; Resolve public and external symbols in static linking.
    Invoke PgmRelocResolve::,EBX
    Invoke RelocPurge::,EBX                        ; Omit RELOC records resolved so far.
.30:; <b>Prepare memory stream for output file</b>.
     StreamCreate [EBX+PGM.Pool],BufSize=32K
     MOV [%OutputStream],EAX
     JC .90:

     ; <b>Get the name of procedure</b> for output file formating: PfbinCompile, PfcomCompile etc.
     ; Due to file-naming conventions, the format name (BIN,COM, OMF...)
     ;    needs to be coverted to lower case at asm-time.
     MOV ECX,[EBX+PGM.Pgmopt.Status]
     AND ECX,pgmoptFormatMask
  PF %FOR %PfList
       CMP ECX,pgmopt%PF
       JNE .Not%PF:                                ; Convert program-format shortcut %PF to lowercase %pf, e.g. OMF to omf.
  %PFn %SETS %PF                                   ; Set number of characters in the shortcut to %PFn.
  %pf  %SET                                        ; Initialize the lowcase shortcut to emptiness.
     i %FOR 1..%PFn
         %lc %SETC "%PF[%i]" | 0x20                ; Convert %i-th character to lowercase
         %pf %SET %pf%lc                           ;  and append it to %pf.
       %ENDFOR i                                   ; The conversion takes place at asm-time.
       Invoke Pf%pf{}Compile::,EAX,EBX             ; <b>Invoke the actual formating</b>, e.g. PfomfCompile, PfpeCompile etc.
       JMP .35:
      .Not%PF:
     %ENDFOR PF
     JMP .90:
 .35:; <b>Apply suboperation(s) on the output file</b>.
     Invoke PfSuboperate,EBX,[%OutputStream]
     MOV [%OutputStream],EAX
     ; <b>Warn when the output file already exists</b> on <code>Src.PfList</code>.
     MOV ESI,[EBX+PGM.Pgmopt.OutFilePtr]
     MOV ECX,[EBX+PGM.Pgmopt.OutFileSize]
     ListGetFirst [Src.PfList::]
     JZ .65:
 .40:CMP ECX,[EAX+4]
     JNE .60:                                      ; If filename sizes do not match.
     MOV EDI,[EAX+0]                               ; EDI is now pointer to the first character of filename.
     PUSH EAX,ECX,ESI
 .45:  MOV AL,[ESI]
       MOV AH,[EDI]
       INC ESI
       INC EDI
       CMPB [Ea.EuroasmOS::],'W'
       JNE .50:                                    ; Skip if running on case-sensitive filesystem.
       OR AX,0x2020                                ; Simplified conversion to lowercase.
 .50:  CMP AL,AH
       JNE .55:
       LOOP .45:
 .55:POP ESI,ECX,EAX
     JNE .60:
     Msg '3990',EAX                                ; Overwriting previously generated output file "!1S".
     JMP .70:
 .60:ListGetNext EAX
     JNZ .40:
 .65:ListNew [Src.PfList::]                        ; <b>Add the filename to Src.PfList </b>.
     MOV [EAX+0],ESI                               ; Store filename ESI,ECX to the new leaf EAX.
     MOV [EAX+4],ECX
 .70:; <b>Flush the OutputStream contents to OutputFile</b> on disk.
     LEA EDI,[%OutputFile]
     Clear EDI,Size=SIZE# FILE
     SysCreateFile EDI,ESI                         ; Assign OutputFile EDI with filename ESI and open it for writing.
     JC .E7951:                                    ; Report error EAX if the file is not writable.
     StreamDump [%OutputStream], .WriteBlock:      ; Write the entire stream contents to OutputFile.
 .80:; The file is written, now prepare I0660 with <b>information about output file</b>.
     LEA EBX,[EDI+FILE.Name]
     PUSH [EDI+FILE.Size]
      SysCloseFile EDI
      MOV EAX,[%Pgm]
      LEA EDX,[EAX+PGM.Pgmopt]
      MOV EAX,[EDX+PGMOPT.Status]
      AND EAX,pgmoptModelMask
      Invoke DictSearchByData::,DictProgramModels::,EAX
      MOV EDI,ESI ; !2S
      MOV EAX,[EDX+PGMOPT.Status]
      AND EAX,pgmoptFormatMask
      Invoke DictSearchByData::,DictProgramFormats::,EAX ; ESI=!3S
      MOV ECX,pgmoptWidthMask
      AND ECX,[EDX+PGMOPT.Status]
      SAR ECX,20                                   ; Program width ECX=!1D.
     POP EAX                                       ; Output file size !5D.
     MOV EDX,[%Pgm]
     JSt [EDX+PGM.Status],pgmEnvelope,.I0760:
     Msg '0660',ECX,EDI,ESI,EBX,EAX                ; !1Dbit !2S !3S file "!4$" created, size=!5D.
     JMP .90:
.E7951:CALL .WriteBlock.E7951:                     ; Though the file EDI is not writtable,
     JMP .80:                                      ;    report I0660 (it will have size=0).

PfOutput.WriteBlock:PROC1                                  ; Callback for writing the stream-contents-block ESI,ECX to [%OutputFile].
     LEA EDI,[%OutputFile]
      SysWriteFile EDI,ESI,ECX
     JNC .OK:
.E7951:LEA ECX,[EDI+FILE.Name]                     ; Expects EDI=^FILE, EAX=error code, CF=1.
     Msg '7951',EAX,ECX                            ; Error 0x!1H writing to output file "!2$".
 .OK:RET
    ENDP1 PfOutput.WriteBlock:

.I0760:Msg '0760',ECX,EDI,ESI,EBX,EAX              ; !1Dbit !2S !3S file "!4$" created from source, size=!5D.
.90:EndProcedure PfOutput
</pre>

<dl id="PfLoad">
<dt><a href="#top">&uarr; PfLoad</a> Pgm, Filemask, LinePtr</dt>
<dd><dfn>PfLoad</dfn> will resolve linked object module name(s) specified by (possibly wildcarded) Filemask,
<!---->check their format, and convert each linked file to a <a class="EXT" href="pgm.htm#PGM">PGM
</a> structure created on Pgm.Pool. The new created PGM then will be added to Pgm.ModulePgmList.
<dt>Input</dt><dd><b>Pgm</b> is pointer to a completely assembled
<a class="EXT" href="pgm.htm#PGM">PGM</a> object to which it is linked (base program).
<br/><b>Filemask</b> is pointer to zero-terminated linked file name. It may contain path and wildcards.
<br/><b>LinePtr</b> points to the source line with LINK statement which requested the file. It is used in error messages.</dd>
<dt>Output</dt>
<dd>Requested program(s) are loaded and stored to Pgm.ModulePgmList (but not combined and linked yet).
<!-->Wildcards in their names are resolved.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>See also</dt>
<dd><a class="EXT" href="pgm.htm#PgmCombine">PgmCombine</a>.</dd>
<dt>Invoked by</dt>
<dd><a href="#PfOutput">PfOutput</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="eaopt.htm#EaoptGetOnePath">EaoptGetOnePath</a>
<a href="#PfDetect">PfDetect</a>
<a class="EXT" href="pgmopt.htm#PgmoptSetLinkProp">PgmoptSetLinkProp</a>
</dd>
</dl><pre>
PfLoad Procedure Pgm, FilemaskPtr, LinePtr
LinkFile      LocalVar Size=SIZE#FILE ; Linked file.
FilemaskEnd   LocalVar
SubopPtr      LocalVar
SubopEnd      LocalVar
PathNr        LocalVar
Status        LocalVar ; Resolving status, see the flags below.
%AtLeast1     %SETA 1  ; One or more files were resolved from wildcards.
%Wildcarded   %SETA 2  ; Filemask contains <kbd>*</kbd> or <kbd>?</kbd>.
%WithPath     %SETA 4  ; Filemask contains slash or colon.
    ClearLocalVar
    MOV ESI,[%FilemaskPtr]                       ; <b>Parse the name of linked file</b>.
    GetLength$ ESI
    StripSpaces ESI,ECX
    LEA EDX,[ESI+ECX]                            ; First suppose no quotes and no suboperations, e.g. <b>file*.obj</b>.
    MOV [%FilemaskEnd],EDX
    MOV [%SubopPtr],EDX
    MOV [%SubopEnd],EDX                          ; Suppose no suboperation.
    MOV EDI,ESI
    LODSB
    CMP AL,'"'
    JNE .10:
    MOV EDI,ESI                                  ; Filemask is in quotes.
    DEC ECX
    MOV [%FilemaskPtr],EDI
    REPNE SCASB                                  ; Search for the terminating double quote.
    Msg cc=NE,'6951',ESI                         ; Wrong linked file name !1$.',0
    JNE .90:
    MOV [%SubopPtr],EDI
    DEC EDI
    MOV [%FilemaskEnd],EDI
.10:; [%FilemaskPtr]..[%FilemaskEnd] now specifies unquoted filename, perhaps with path and wildcards, without suboperations.
     MOV ESI,[%FilemaskPtr]
     MOV EDX,[%FilemaskEnd]
     SUB EDX,ESI
     RstSt [%Status],%Wildcarded + %AtLeast1     ; Query if wildcarded (contains asterix or question mark).
     PfQueryChar '*'
     JE .20:
     PfQueryChar '?'
     JNE .30:
.20: SetSt [%Status],%Wildcarded
.30: SetSt [%Status],%WithPath                   ; Query if Filemask was specified with path (if it contains slash or colon).
     PfQueryChar '\'
     JE .55:
     PfQueryChar '/'
     JE .55:
     PfQueryChar ':'
     JE .55:
     RstSt [%Status],%WithPath
     ; If no path was specified in LINK statement, we must try all pathes from %^LINKPATH.
.40: Invoke EaoptGetOnePath::,[Ea.Eaopt.LinkPathPtr::],[Ea.Eaopt.LinkPathSize::],[%PathNr] ; Get the path to ESI,ECX.
     JC .80:                                     ; If there are no more path specified in LINKPATH=.
     INCD [%PathNr]                              ; Prepare for the next path.
     MOV EDX,[%FilemaskEnd]
     SUB EDX,[%FilemaskPtr]                      ; EDX is now size of filemask without path.
     LEA EAX,[EDX+ECX]                           ; ESI,ECX is one include path.
     CMP EAX,260                                 ; MAX_PATH_SIZE
     Msg cc=A,'6953',ESI                         ; Size of LinkPath "!1_" + size of filename exceeded 260 characters.
     JA .90:
     LEA EDI,[%LinkFile+FILE.Name]               ; Assign path+filemask to LinkFile.
     REP MOVSB
     MOV AX,'\/'
     CMPB [Ea.EuroasmOS::],'W'                   ; Choose slash or backslash.
     JE .50:
     XCHG AL,AH                                  ; Backslash if euroasm.exe runs on Windows, otherwise use slash <kbd>/</kbd>.
.50: CMP AL,[EDI-1]
     JE .60:
     CMP AH,[EDI-1]
     JE .60:
     STOSB                                       ; If the path was not terminated with slash or backslash, append it.
     JMP .60:
.55: LEA EDI,[%LinkFile+FILE.Name]
 .60:MOV ESI,[%FilemaskPtr]
     MOV ECX,EDX
     REP MOVSB
     SUB EAX,EAX                                 ; Zero terminate filemask.
     STOSB                                       ; <b>%LinkFile is now assigned with path and filemask</b>.
     LEA EDI,[%LinkFile]
     SysEachFile EDI, .File2                     ; Perform callback .File with each wildcard-resolved filename.
     JSt [%Status],%WithPath,.80:
     JSt [%Status],%Wildcarded,.40:              ; Continue search with the next link path.
     JNSt [%Status],%AtLeast1,.40:               ; If non-wildcarded file not found, continue search.
     JMP .90:

.E6954:LEA EAX,[EDI+FILE.Name]
     Msg '6954',EAX                              ; Linked file "!1$" not found.
     JMP .90:

.File2:PROC1 ; Callback from SysEachFile. Input:
        ; EBX=^FILE with assigned FILE.Name.
        ; EDX=find-handle from OS.               ; If "%eaos" === "win" only.
        ; ESI=^FILE.Name
        ; EDI=WIN32_FIND_DATAW                   ; If "%eaos" === "win" only.
     SetSt [%Status],%AtLeast1
     LEA EDX,[EBX+FILE.Name]
     SysOpenFileMap EBX,EDX
     Msg cc=C,'8530',EDX                         ; Error reading linked file "!1$".
     JC .F8:
     MOV ECX,EAX                                 ; The contents of linked file EBX is now mapped in memory ESI,ECX.
     ; <b>Detect format of linked file</b>.
     Invoke PfDetect, ESI,ECX                    ; Returns one of DictProgramFormats in EAX.
     Msg cc=Z,'8539',EDX                         ; Format of file "!1$" was not recognized.
     JZ .F8:
     MOV EDI,EAX                                 ; Pointer to Dict_Format.
     Invoke PgmoptSetLinkProp::,[EDI+DICT.Data]  ; Set properties corresponding to the format.
     TEST EAX,pgmoptLinkable | pgmoptImportable
     Msg cc=Z,'8534',EDI,EDX                     ; Format !1S of file "!2$" is not linkable.
     JZ .F8:
     PUSHAD                                      ; Convert each backslash to slash in file path.
       MOV ESI,EDX                               ;  The purpose is that a test pass no matter if it's tested
       MOV EDI,EDX                               ;  by Windows or Linux version of EuroAssembler.
.70:   LODSB
       CMP AL,0
       JE .75:
       CMP AL,'\'
       JNE .72:
       MOV AL,'/'
.72:   STOSB
       JMP .70:
.75: POPAD
     TEST EAX,pgmoptLibrary|pgmoptExportable
     MOV EAX,'0560'                              ; Linking !1S module "!2$".
     JZ .85:
     MOV EAX,'0561'                              ; Linking !1S library "!2$".
.85: Msg EAX,EDI,EDX
     CMP [EDI+DICT.Data],pgmoptELFSO
     JNE .86:
     MOV EAX,[%Pgm]
     SetSt [EAX+PGM.Status],pgmLoadsELFSO
.86:; Procedures for input file loading are PfomfLoadPgm, PfcoffLoadPgm, PfdllLoadPgm etc.
   ; Due to naming conventions we need lowercase format shortcut.
     MOV EAX,[EDI+DICT.Data]
     AND EAX,pgmoptFormatMask
  PF %FOR %PfList
       CMP AL,pgmopt%PF
       JNE .Not%PF:
       ; Convert program-format shortcut %PF to lowercase %pf, e.g. OMF to omf.
  %PFn %SETS %PF                                 ; Set number of characters in shortcut to %PFn.
  %pf  %SET                                      ; Initialize lowcase shortcut to emptiness.
     i %FOR 1..%PFn
         %lc %SETC "%PF[%i]" | 0x20              ; Convert %i-th character to lowercase
         %pf %SET %pf%lc                         ;  and append to the loading-procedure name.
       %ENDFOR i
       Invoke Pf%pf{}LoadPgm::,[%Pgm],ESI,ECX,EDX ; Perform the actual loading, e.g. PfcoffLoadPgm.
       JMP .F8:
      .Not%PF:
     %ENDFOR PF
 .F8:SysCloseFile EBX                            ; Release the memory-mapped file.
 .F9:CLC
     RET
     ENDP1 .File2:

.80: JSt [%Status],%Wildcarded,.90:              ; Do not report "E6954 not found" when specified with wildcards.
     JNSt [%Status],%AtLeast1,.E6954:            ; Linked file "!1$" not found.
.90:EndProcedure PfLoad
</pre>

<dl id="PfDetect">
<dt><a href="#top">&uarr; PfDetect</a> InputObjPtr, InputObjSize</dt>
<dd><dfn>PfDetect</dfn> will inspect and recognize the format of input file submitted to linker.</dd>
<dt>Input</dt>
<dd><b>InputObjPtr</b> is pointer to the file contents mapped in memory, loaded by the caller.
<br/><b>InputObjSize</b> is number of bytes in the file.</dd>
<dt>Output</dt>
<dd><b>ZF=0, EAX=</b> is pointer to <a class="EXT" href="dict.htm#DICT">DICT
</a> dictionary item of recognized
<a class="EXT" href="dict.htm#DictProgramFormats">DictProgramFormats</a>, e.g. <code>Dict_FormatCOFF</code>.
<br/><b>ZF=1, EAX=0</b> when none of known program linkable formats was recognized.</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>See also</dt>
<dd><a class="EXT" href="pgm.htm#PgmDetectImportModule">PgmDetectImportModule</a></dd>
<dt>Invoked by</dt>
<dd><a href="#PfLoad">PfLoad</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="pfomf.htm#PfomfLoadRecord">PfomfLoadRecord</a>
<a class="EXT" href="pfrsrc.htm#PfrsrcStoreRecord">PfrsrcStoreRecord</a>
</dd>
</dl><pre>
PfDetect Procedure InputObjPtr, InputObjSize
       MOV EBX,[%InputObjPtr]
       MOV ECX,[%InputObjSize]
       LEA EDX,[EBX+ECX] ; InputObjEnd.
        ; <b>Try format RSRC</b>. It consists of <a class="EXT" href="pfrsrc.htm#PFRSRC_RES_HEADER">PFRSRC_RES_HEADER</a> records+data.
       MOV EAX,EBX
.RSRC1:MOV ECX,[%InputObjSize]
       ADD ECX,[%InputObjPtr]
       Invoke PfrsrcStoreRecord::,EAX,EDX,[%InputObjPtr],ECX,0,0 ; Silently verify one resource header and raw data.
       JC .NoRSRC:
       JNZ .RSRC1: ; Test the next resource record at EAX.
       MOV EAX,Dict_FormatRSRC:: ; Valid format RSRC detected.
       JMP .Detected:
.NoRSRC:
       ; <b>Try format LIBCOF</b>. It starts with signature <code>!&lt;arch&gt;</code>.
       CMP ECX,8
       JB .NoLIBCOF:
       MOV EAX,0x72613C21 ; '!&lt;ar'
       CMP [EBX],EAX
       JNE .NoLIBCOF:
       MOV EAX,0x0A3E6863 ; 'ch&gt;',0x0A
       CMP [EBX+4],EAX
       JNE .NoLIBCOF
       MOV EAX,Dict_FormatLIBCOF::
       JMP .Detected:
.NoLIBCOF:
       ; <b>Try format LIBOMF</b>. It consists of valid <a class="EXT" href="pfomf.htm#PFOMF_RECORD">OMF</a> records,
       ; the first one is <a class="EXT" href="pfomf.htm#PfomfRecTypes">LIBHDR</a>.
       CMP ECX,27
       JB .NoLIBOMF: ; If too short.
       MOV ESI,EBX
       CMPB [ESI],LIBHDR
       JNE .NoLIBOMF:
       MOVZXW EDI,[ESI+1]
       ADD EDI,3 ; EDI is now library page size. Legal sizes are 16,32,64,..32K.
       TEST EDI,0x0000_000F
       JNZ .NoLIBOMF: ; If invalid page size.
       PUSH ECX
        BSF EAX,EDI
        BSR ECX,EDI
        CMP EAX,ECX
       POP ECX
       JNE .NoLIBOMF: ; If invalid page size (not power of two).
       CMP EAX,4
       JB .NoLIBOMF: ; If invalid page size.
       CMP EAX,15
       JA .NoLIBOMF: ; If invalid page size.
       DEC EDI ; Page size is OK. EDI is now the align mask for modules in library.
       MOV EDX,[ESI+3] ; File address of library dictionary.
       ADD EDX,ESI ; EDX now points to the dictionary, i.e. end of library records.
.LIBOMF1:Invoke PfomfLoadRecord::,ESI,EBX,EDX,0 ; Silently verify one OMF record.
       JC .NoLIBOMF:
       MOV AL,[ESI]
       AND AL,~1 ; Reset LSbit (when MODEND32 is used).
       CMP AL,MODEND
       JNE .LIBOMF3:
       ; Some linkers rather than blowing up the length of MODEND prefer to keep MODEND short
       ; and page-align the room between MODEND and the following THEADR/LHEADR.
       LEA EAX,[ESI+ECX]
       SUB EAX,EBX ; EAX is now FA of the end of MODEND.
       NEG EAX
       AND EAX,EDI ; 0..PageSize-1.
       ADD ESI,EAX ; Align ESI to the next page.
.LIBOMF3:ADD ESI,ECX ; ESI now points to the next OMF record.
       TEST ECX
       JNZ .LIBOMF1: ; Check the next OMF record.
       MOV EAX,Dict_FormatLIBOMF::
       JMP .Detected:
.NoLIBOMF:
       ; <b>Try format OMF</b>. If consists of valid <a class="EXT" href="pfomf.htm#PFOMF_RECORD">OMF</a> records.
       CMP ECX,10
       JB .NoOMF: ; If too short.
       MOV ESI,EBX
       MOV AL,[ESI]
       CMP AL,THEADR ; The first OMF record must be THEADR or LHEADR.
       JE .OMF1:
       CMP AL,LHEADR
       JNE .NoOMF:
.OMF1: Invoke PfomfLoadRecord::,ESI,EBX,EDX,0 ; Silently verify one OMF record.
       JC .NoOMF:
       ADD ESI,ECX ; ESI now points to the next OMF record.
       TEST ECX
       JNZ .OMF1: ; Check the next OMF record.
       MOV EAX,Dict_FormatOMF::
       JMP .Detected:
.NoOMF:
       ; <b>Try format COFF</b>. It begins with valid machine type.
       MOV ECX,[%InputObjSize]
       CMP ECX,SIZE# PFCOFF_FILE_HEADER
       JNA .NoCOFF: ; If too short.
       MOV AX,[EBX]
       Dispatch AX,pfcoffFILE_MACHINE_I386, pfcoffFILE_MACHINE_I486, \
                   pfcoffFILE_MACHINE_I586, pfcoffFILE_MACHINE_IA64, \
                   pfcoffFILE_MACHINE_AMD64, pfcoffFILE_MACHINE_UNKNOWN
       JMP .NoCOFF:
.pfcoffFILE_MACHINE_I386:
.pfcoffFILE_MACHINE_I486:
.pfcoffFILE_MACHINE_I586:
.pfcoffFILE_MACHINE_IA64:
.pfcoffFILE_MACHINE_AMD64:
.pfcoffFILE_MACHINE_UNKNOWN: ; Linked file format detected as COFF.
        MOV EAX,Dict_FormatCOFF::
        JMP .Detected:
.NoCOFF:
       ; <b>Try formats PE, DLL, MZ</b>. They begin with <code>MZ</code> signature.
       CMP ECX,SIZE#PFMZ_DOS_HEADER
       JB .NoMZ: ; If too short.
       CMPW [EBX],'MZ'
       JNE .NoMZ:
       MOV EAX,Dict_FormatMZ:: ; It may be MZ format.
       MOV ESI,[EBX+PFMZ_DOS_HEADER.e_lfanew] ; Offset to PE signature.
       ADD ESI,EBX
       CMP ESI,EDX
       JA .Detected: ; Not PE, but MZ.
       CMPD [ESI],'PE'
       JNE .Detected:; Not PE, but MZ.
       ADD ESI,4 ; Skip the PE signature to file header.
       LEA EDI,[ESI+SIZE# PFCOFF_FILE_HEADER + SIZE# PFPE_OPTIONAL_HEADER64]
       CMP EDI,EDX
       JA .Detected: ; Not PE, but MZ.
       MOV EAX,Dict_FormatDLL:: ; <b>File is PE or DLL</b>.
       JSt [ESI+PFCOFF_FILE_HEADER.Characteristics],pfcoffFILE_DLL,.Detected:
       MOV EAX,Dict_FormatPE::
       JMP .Detected:
.NoMZ:
       ; <b>Try formats ELF,XELFX, ELFSO</b>. They begin with <code>ELF</code> signature.
       CMP ECX,SIZE# PFELF_EHDR64
       JB .NONE:
       CMPD [EBX],0x464C457F
       JNE .NONE:
       MOV DL,[EBX+PFELF_EHDR64.e_type]
       MOV EAX,Dict_FormatELF::
       CMP DL,pfelfRel
       JE .Detected:
       MOV EAX,Dict_FormatELFX::
       CMP DL,pfelfExec
       JE .Detected:
       MOV EAX,Dict_FormatELFSO::
       CMP DL,pfelfDyn
       JE .Detected:
.NONE: XOR EAX,EAX ; <b>File format was not recognized</b>.
.Detected:
       MOV [%ReturnEAX],EAX
       TEST EAX ; Set ZF.
    EndProcedure PfDetect
</pre>

<dl id="PfDrectveCreate">
<dt><a href="#top">&uarr; PfDrectveCreate</a> Program</dt>
<dd><p><dfn>PfDrectveCreate</dfn> creates new auxilliary section of unspecified width with name
<code>[.drectve]</code> and <code>PURPOSE=DRECTVE</code> when a non-executable files is compiled,
<!---->if a section with that name and purpose does not exist yet. Otherwise it appends to its contents.
<br/>The section contains linker directives which will be used when the final executable is created.</p>
<p>See <a href="#PfDrectveDestroy">PfDrectveDestroy</a> for the list of supported directives.
<p>The section is not created if Windows dynamic linking is not required, i.e. when no symbol with
<!---->scope EXPORT or IMPORT was defined in the Program.</p>
<p>Raw contents of [.drectve] segment in COFF module is a plain text string, such as
<code> /IMPORT:GetStdHandle:"kernel32.dll" /ENTRY:WinMain</code>.</p>
<p>Raw contents of [.drectve] segment in ELF module is specified in documentation of ELF section type
<code>SHT_NOTE</code>.</p></dd>
<dt>Input</dt>
<dd><b>Program</b> is pointer to <a class="EXT" href="pgm.htm#PGM">PGM</a>.</dd>
<dt>Output</dt>
<dd>New segment <code>[.drectve]</code> is created in Program if entry point or
<!---->at least one imported symbol is declared in Program..</dd>
<dt>Error</dt>
<dd><b>-</b></dd>
<dt>See also</dt>
<dd><a href="#PfDrectveDestroy">PfDrectveDestroy</a></dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfcoff.htm#PfcoffCompile">PfcoffCompile</a>
<a class="EXT" href="pfelf.htm#PfelfCompile">PfelfCompile</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferAlign">EaBufferAlign</a>
<a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a class="EXT" href="sss.htm#SssCreateSe">SssCreateSe</a>
<a class="EXT" href="sss.htm#SssFindByName">SssFindByName</a>
</dd>
</dl><pre>
PfDrectveCreate Procedure Program
TextBuf   LocalVar                                       ; Pointer to a <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> with section contents.
Statement LocalVar Size=SIZE# STM                        ; Forged statement required by SssCreateSe.
    ClearLocalVar
    MOV EBX,[%Program]
    Invoke EaBufferReserve::,PfDrectveCreate
    MOV [%TextBuf],EAX
    MOV EDX,EAX
    ; <b>Create directive /ENTRY: if this Program specifies entry symbol</b>.
    MOV ECX,[EBX+PGM.Pgmopt.EntrySize]
    JECXZ .10:                                           ; If no ENTRY= was specified.
    MOV ESI,[EBX+PGM.Pgmopt.EntryPtr]
    BufferStore EDX,=B" /ENTRY:",8
    BufferStore EDX,ESI,ECX
.10:; <b>Create directives /EXPORT: and /IMPORT:</b> if such symbols exist.
    ListGetFirst [EBX+PGM.SymList]
    JZ .55:
.20:JNSt [EAX+SYM.Status],symExport,.30:
    BufferStore EDX,=B" /EXPORT:",9
    BufferStore EDX,[EAX+SYM.NamePtr],[EAX+SYM.NameSize] ; Exported symbol name.
.30:JNSt [EAX+SYM.Status],symImport,.50:
    BufferStore EDX,=B" /IMPORT:",9
    BufferStore EDX,[EAX+SYM.NamePtr],[EAX+SYM.NameSize] ; Imported symbol name.
    MOV ECX,[EAX+SYM.DllNameSize]
    MOV ESI,[EAX+SYM.DllNamePtr]
    JECXZ .50:                                           ; Default DLL <q>kernel32.dll</q> assumed.
    CMP ECX,12
    JNE .40:                                             ; Nondefault DLL.
    MOV EDI,0x20202020
    MOV ECX,[ESI+0]
    OR ECX,EDI                                           ; Convert letters to lower case.
    CMP ECX,'kern'
    JNE .40:                                             ; Nondefault DLL.
    MOV ECX,[ESI+4]
    OR ECX,EDI                                           ; Convert letters to lower case.
    CMP ECX,'el32'
    JNE .40:                                             ; Nondefault DLL.
    MOV ECX,[ESI+8]
    OR ECX,EDI                                           ; Convert letters to lower case.
    CMP ECX,'.dll'
    JE .50: ; Skip when symbol EAX is imported from the default library "%EuroasmDefaultDllName", which may be omitted.
.40:; <b>Nondefault DLL</b> is used. Store its colon-separated quoted name.
    BufferStoreWord EDX,':"'
    BufferStore EDX,[EAX+SYM.DllNamePtr],[EAX+SYM.DllNameSize]
    BufferStoreByte EDX,'"'
.50:ListGetNext EAX
    JNZ .20:                                             ; The next symbol.
.55:BufferRetrieve EDX
    CMP ECX,1
    JBE .80:                                             ; Skip if no directive was stored.
    ; <b>Section [.drectve] will be created</b>.
    LEA EDI,[%Statement]
    MOV [EDI+STM.Program],EBX
    MOV EAX,[EBX+PGM.CurrentStm]
    TEST EAX
    JZ .60:
    MOV EAX,[EAX+STM.LinePtr]
    MOV [EDI+STM.LinePtr],EAX
.60:Invoke SssFindByName::,sssSegment,sssPublic,=B'.drectve',8,EBX
    JNC .70:                                            ; If [.drectve] exists, reuse it.
    PUSH ECX
     MOV ECX,4                                          ; ELF PT_NOTE .drectve section alignment.
     JSt [EBX+PGM.Pgmopt.Status],pgmoptELFbased,.65:
     MOV CL,1                                           ; COFF .drectve section alignment.
.65: Invoke SssCreateSe::,EDI,0,=B'.drectve',8,sssSegment+sssNotBSS+sssPublic,sssPurposeDRECTVE,ECX
    POP ECX                                             ; Restore [.drectve] payload size.
.70:MOV EDI,EAX                                         ; ^SSS [drectv].
    JSt [EBX+PGM.Pgmopt.Status],pgmoptELFbased,.75:
    BufferStore [EDI+SSS.EmitBuffer],ESI,ECX            ; COFF based segment has no header.
    BufferRetrieve [EDI+SSS.EmitBuffer]
    MOV [EDI+SSS.TopLow],ECX
    JMP .80:
.75:Invoke EaBufferAlign::,EDX,8                        ; <b>ELF based formats</b>.
    BufferRetrieve EDX                                  ; ESI,ECX is the .directv strings.
    MOV EDX,[EDI+SSS.EmitBuffer]
    BufferStoreDword EDX,13                             ; namesz "EuroAssembler".
    BufferStoreDword EDX,ECX                            ; descsz [.drectv] strings.
    BufferStoreDword EDX,0x0000_00EA                    ; type 0xEA = €ASM "linker directive".
    BufferStore      EDX,=B"EuroAssembler",14           ; name.
    BufferStoreWord  EDX,0                              ; padding to DWORD.
    BufferStore      EDX,ESI,ECX                        ; desc - the actual .drectv string.
    BufferRetrieve EDX
    MOV [EDI+SSS.TopLow],ECX
.80:Invoke EaBufferRelease::,[%TextBuf]
.90:EndProcedure PfDrectveCreate
</pre>

<dl id="PfDrectveDestroy">
<dt><a href="#top">&uarr; PfDrectveDestroy</a> Program</dt>
<dd><p><dfn>PfDrectveDestroy</dfn> will find an auxiliary segment <code>[.drectve]
</code> with <code>PURPOSE=DRECTVE</code>, read, parse and assemble its emitted contents,
<!---->and then it will discard the segment.</p>
<p>Segment raw contents is plain text when COFF module is loaded.
<!-->When the [.drectve] ELF section is loaded, the plain text is encapsulated as ELF PT_NOTE section.
<br/>The PT_NOTE header and the actual plain text are DWORD aligned and they may repeat
<!-->when [.drectv] combines more then one ELF modules.</p>
<p>Typical plain-text directive looks like <code>/name: value</code>. Directive consists of</p>
<dt>prefix</dt><dd> slash <kbd>/</kbd> or hyphen <kbd>-</kbd></dd>
<dt>name</dt>
<dd>(identifier)</dd>
<dt>suffix</dt>
<dd>colon <kbd>:</kbd> or equal sign <kbd>=</kbd> or white space(s)</dd>
<dt>value</dt>
<dd>quoted or unquoted string.</dd>
<dt>Input</dt>
<dd><b>Program</b> is a pointer to the just loaded <a class="EXT" href="pgm.htm#PGM">PGM</a>.</dd>
<dt>Output</dt>
<dd>Each linker directive creates or updates its symbol in the Program.
<br/>Segment <code>[.drectve]</code> was removed from Program.SssList.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>See also</dt>
<dd><a href="pf.htm#PfDrectveCreate">PfDrectveCreate</a></dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="dict.htm#DictLookup">DictLookup</a>
<a class="EXT" href="sss.htm#SssCreateExtern">SssCreateExtern</a>
<a class="EXT" href="sss.htm#SssFindByName">SssFindByName</a>
<a class="EXT" href="sym.htm#SymFindByName">SymFindByName</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfcoff.htm#PfcoffLoadModule">PfcoffLoadModule</a>
<a class="EXT" href="pfelf.htm#PfelfLoadPgm">PfelfLoadPgm</a>
<a class="EXT" href="pfomf.htm#PfomfLoadModule">PfomfLoadModule</a>
</dd>
</dl><pre>
PfDrectveDestroy Procedure Program
DrectveSegm LocalVar       ; ^SSS [.drectve].
DrectveTop  LocalVar       ; End of SSS.EmitBuffer.
DllNameSize LocalVar       ; Components parsed from the format <code>/NAME:Value:&quot;DllName&quot;</code>.
DllNamePtr  LocalVar
ValueSize   LocalVar
ValuePtr    LocalVar
NameSize    LocalVar
NamePtr     LocalVar
    MOV EBX,[%Program]
    Invoke SssFindByName::,sssSegment,0,=B'.drectve',8,EBX
    JC .99:
    JNSt [EAX+SSS.Purpose],sssPurposeDRECTVE,.99:
    MOV [%DrectveSegm],EAX
    BufferRetrieve [EAX+SSS.EmitBuffer]
    LEA EDX,[ESI+ECX]
    MOV [%DrectveTop],EDX
    JSt [EBX+PGM.Pgmopt.Status],pgmoptELFbased,.ELF:
    CALL .Parse:
    JMP .90:
.ELF:
    LODSD                                        ; namesz DWORD (unaligned).
    Align2Dword EAX
    MOV ECX,EAX
    LODSD                                        ; descsz DWORD (unaligned).
    Align2Dword EAX
    LEA ESI,[ESI+4+ECX]                          ; Skip type and name.
    LEA EDX,[ESI+EAX]                            ; End of desc.
    CALL .Parse:
    CMP EDX,[%DrectveTop]
    JB .ELF:                                     ; When they are more then 1 concatenated PT_NOTE ELF sections.
    JMP .90:

; <b>Directive handlers</b>. They may destroy any GPR but EBP. Return via plain RET.
;  Input: EBX=^PGM,
;         ESI,ECX=Value,
;         EBP=local variables frame.

.E6120:LEA EDX,[%ValuePtr]
    Msg '6120',EDX                               ; Symbol "!1S" not found.
    RET

.ENTRY:: ; Handler of directive <b>/ENTRY:EntrySymbolName</b>. It declares executable entry point.
    PoolStore [EBX+PGM.Pool],ESI,ECX
    MOV [EBX+PGM.Pgmopt.EntryPtr],EAX
    MOV [EBX+PGM.Pgmopt.EntrySize],ECX
    RET

.EXPORT:: ; Handler of directive <b>/EXPORT:ExportedSymbolName</b>. It marks the symbol as symExport.
          ; It is used to declare exportness of a symbol inside the module for dynamic linking.
    Invoke SymFindByName::,0,ESI,ECX,EBX
    JC .E6120:
    SetSt [EAX+SYM.Status],symExport
    RET

.IMPORT:: ; Handler of directive <b>/IMPORT:ImportedSymbolName:"DllName"</b>.
          ; It creates/updates the symbol as symImport. DllName is optional.
    TEST ECX
    JZ .I9:
    MOV EDI,ESI                                  ; Beginning of the value.
    LEA EDX,[ESI+ECX]                            ; End of value.
.I1:CMP ESI,EDX
    JNB .I3:
    LODSB
    CMP AL,':'                                   ; Search for <kbd>:</kbd> or <kbd>=</kbd> which terminates ImportedSymbolName.
    JE .I2:
    CMP AL,'='
    JNE .I1:
.I2:DEC ESI
.I3:MOV ECX,ESI
    SUB ECX,EDI                                  ; EDI,ECX is now ImportedSymbolName.
    Invoke SymFindByName::,0,EDI,ECX,EBX
    JNC .I4:
    ; <b>Create imported symbol</b> named EDI,ECX in program EBX.
    ListNew [EBX+PGM.SymList],Zeroed=yes
    MOV [EAX+SYM.NamePtr],EDI
    MOV [EAX+SYM.NameSize],ECX
    XCHG EAX,EDI                                 ; EAX is now volatile symbol name, EDI=^SYM.
      PoolStore [EBX+PGM.Pool],EAX,ECX
      MOV [EDI+SYM.NamePtr],EAX
    XCHG EDI,EAX
.I4:MOV EDI,EAX                                  ; EDI is now the symbol which should be marked as imported.
    SetSt [EDI+SYM.Status],symImport
    Invoke SssCreateExtern::,EDI,EBX             ; Accompany the imported symbol with its extern pseudosegment.
    CMP ESI,EDX                                  ; At the end of value?
    JNB .I7:                                     ; If no explicit DllName follows.
    ; ImportedSymbolName is followed with colon and <b>DllName</b> in double quotes.
    LODSB                                        ; Skip the <kbd>:</kbd> or <kbd>=</kbd>.
    CMP ESI,EDX
    JNB .I7:                                     ; No explicit DllName follows.
    LODSB
    MOV AH,AL                                    ; Double quote expected.
    CMP AL,'"'
    JNE .I7:                                     ; Treat invalid DllName as default "kernel32.dll".
    MOV [EDI+SYM.DllNamePtr],ESI
.I5:CMP ESI,EDX
    JNB .I7:                                     ; Treat invalid DllName as default "kernel32.dll".
    LODSB
    CMP AL,AH
    JNE .I5:
    DEC ESI
    SUB ESI,[EDI+SYM.DllNamePtr]
    MOV [EDI+SYM.DllNameSize],ESI
    TEST ESI
    JZ .I7:
    PoolStore [EBX+PGM.Pool],[EDI+SYM.DllNamePtr],ESI,ZeroTerminate=YES
    MOV [EDI+SYM.DllNamePtr],EAX                 ; Make DllName persistent.
    RET
.I7:; No valid DllName provided, assume "kernel32.dll".
    MOV [EDI+SYM.DllNamePtr],=B"%EuroasmDefaultDllName"
    MOV [EDI+SYM.DllNameSize],%EuroasmDefaultDllNameSize
.I9:RET
                                                 ; <b>End of directive handlers</b>.
.Parse: PROC                                     ; Handle string ESI..EDX with directives for program EBX.
    ; <b>Search for the prefix of directive /Name</b>. It starts with <kbd>/</kbd> or <kbd>-</kbd>.
.10:CMP ESI,EDX
    JNB .80:
    LODSB
    CMP AL,'/'
    JE .20:
    CMP AL,'-'
    JNE .10:
.20:MOV [%NamePtr],ESI
    XOR EAX,EAX
    MOV [%ValuePtr],EAX
    MOV [%ValueSize],EAX
    MOV [%DllNamePtr],EAX
    MOV [%DllNameSize],EAX
    ; <b>Search for the suffix which terminates the /Name</b> (colon, equal or space).
.30:CMP ESI,EDX
    JNB .40:
    LODSB
    ExpClassify AL
    CMP AL,':'
    JE .35:
    CMP AL,'='
    JE .35:
    CMP AH,expWhiteSpace
    JNE .30:
.35:DEC ESI
.40:MOV ECX,ESI
    SUB ECX,[%NamePtr]
    MOV [%NameSize],ECX
    INC ESI                                      ; Skip the suffix.
.45:; <b>Search for the value</b>. It may be in quotes.
    CMP ESI,EDX
    JNB .75:
    LODSB
    ExpClassify AL
    CMP AH,expWhiteSpace
    JE .45:
    CMP AH,expQuote
    JNE .55:
    MOV AH,AL                                    ; <b>Value is in single or double quotes</b> AL=AH.
    MOV [%ValuePtr],ESI
.50:CMP ESI,EDX
    JNB .10:                                     ; Silently abandon the invalid value because it is not properly terminated.
    LODSB
    CMP AL,AH                                    ; Is it the terminating quote?
    JNE .50:
    MOV ECX,ESI
    DEC ECX
    SUB ECX,[%ValuePtr]
    MOV [%ValueSize],ECX                         ; Netto size without quotes.
    JMP .75:
.55:DEC ESI                                      ; Back to the first nonwhite value character.
    MOV [%ValuePtr],ESI                          ; <b>Value is unquoted</b>.
.60:CMP ESI,EDX
    JNB .70:                                     ; End of the value found.
    LODSB
    CMP AL,','                                   ; Unquoted comma terminates the value.
    JE .65:
    ExpClassify AL
    CMP AH,expWhiteSpace
    JNE .60:
.65:DEC ESI                                      ; Unquoted comma or space terminated the value.
.70:MOV ECX,ESI
    SUB ECX,[%ValuePtr]
    MOV [%ValueSize],ECX
.75:; <b>Name and value was succesfully parsed</b>.
    Invoke DictLookup::,DictDrectve::,[%NamePtr],[%NameSize]
    JC .10:                                      ; Silently ignore when the name is not among supported directives.
    PUSHAD                                       ; EAX is now the directive handler, e.g. <code>PfDrectveDestroy.EXPORT::</code>.
      LEA ECX,[%NamePtr]
      LEA EDX,[%ValuePtr]
      Msg '0563',ECX,EDX                         ; Accepting link directive /!1S:!2S.
      MOV ESI,[%ValuePtr]
      MOV ECX,[%ValueSize]
      CALL EAX                                   ; <b>Execute the handler</b>.
    POPAD
    JMP .10:
.80:RET
    ENDP .Parse:

.90:MOV EDX,[%DrectveSegm]
    Invoke SymFindByName::,0,[EDX+SSS.NamePtr],[EDX+SSS.NameSize],EBX
    JC .95:
    ListRemove [EBX+PGM.SymList],EAX             ; Discard the <code>.drectve</code> (symSe) symbol.
.95:ListRemove [EBX+PGM.SssList],EDX             ; Discard the <code>[.drectve]</code> segment.
.99:EndProcedure PfDrectveDestroy
</pre>

<dl id="PfSuboperate">
<dt><a href="#top">&uarr; PfSuboperate</a> Program, OutStream</dt>
<dd>Procedure <dfn>PfSuboperate</dfn> resolves suboperations specified in program option, such as
<code>PROGRAM OUTFILE="file.bin"[256..]</code>. If no suboperation is requested,
<!---->or if the <code>OUTFILE=</code> is left empty (default), this procedure does nothing.
<br/>Otherwise it will trim the OutStream and also remove suboperators from
<!---->Program.Pgmopt.OutFile specification.</dd>
<dt>Input</dt>
<dd><b>Program</b> Pointer to a completely assembled <a class="EXT" href="pgm.htm#PGM">PGM</a> object.
<br/><b>OutStream</b> is pointer to <a class="EXT" href="../maclib/memory32.htm#STREAM">STREAM
</a> which contains the complete assembled and linked output file.</dd>
<dt>Output</dt>
<dd><b>EAX</b> pointer to an output <a class="EXT" href="../maclib/memory32.htm#STREAM">STREAM
</a> with suboperated output file. It will be identical with input %OutStream when no suboperations are required.</dd>
<dt>Error</dt>
<dd>Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invoked by</dt>
<dd><a href="#PfOutput">PfOutput</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t7121.htm">t7121</a>
<a class="EXT" href="../eatests/t7122.htm">t7122</a>
<a class="EXT" href="../eatests/t7123.htm">t7123</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a class="EXT" href="exp.htm#ExpConvertToNumber">ExpConvertToNumber</a>
<a class="EXT" href="exp.htm#ExpEval">ExpEval</a>
<a class="EXT" href="exp.htm#ExpParseRange">ExpParseRange</a>
<a class="EXT" href="exp.htm#ExpParseSuboperation">ExpParseSuboperation</a>
<a class="EXT" href="var.htm#VarExpandField">VarExpandField</a>
</dd>
</dl><pre>
PfSuboperate  Procedure Program, OutStream
PfSopOutFileSize LocalVar ; Filename size with removed suboperations prepared for return.
PfSopOutFileEnd  LocalVar ; ^Behind the last closing bracket.
PfSopStart       LocalVar ; ^Opening bracket of one suboperation.
PfSopEnd         LocalVar ; ^Behind the closing bracket of one suboperation.
PfSopLeftPtr     LocalVar ; ^Left range expression.
PfSopLeftEnd     LocalVar ; ^Behind the left range expression.
PfSopRightPtr    LocalVar ; ^Right range expression.
PfSopRightEnd    LocalVar ; ^Behind the right range expression.
PfSopLeftVal     LocalVar ; Left range value.
PfSopRightVal    LocalVar ; Right range value.
PfSopStatus      LocalVar ; Bit 1 is set if the range covers both left and right value.
PfSopBuffer      LocalVar ; Temporary buffer for range calculation.
PfSopStream      LocalVar ; Temporary substream for suboperation.
PfSopExp         LocalVar Size=SIZE# EXP
    MOV EAX,[%OutStream]
    MOV EBX,[%Program]
    MOV [%ReturnEAX],EAX                   ; Prepare for the case when no suboperation is required.
    Invoke EaBufferReserve::,PfSuboperate
    MOV [%PfSopBuffer],EAX
    MOV EDI,[EBX+PGM.Pgmopt.OutFilePtr]
    MOV ECX,[EBX+PGM.Pgmopt.OutFileSize]
    MOV ESI,EDI
    MOV [%PfSopOutFileSize],ECX
    LEA EDX,[EDI+ECX]                      ; End of suboperated filename (behind the last closing bracket).
    MOV [%PfSopOutFileEnd],EDX
    ; Leading quote of filename was already removed, ESI,ECX may be e.g.<code>file.bin"{5..%&amp;-4}[256..]</code>.
    MOV AL,'"'
    REPNE SCASB
    JNE .90:                               ; If no valid suboperation.
    MOV [%PfSopStart],EDI                  ; EDI now should point to the opening bracket following the quote. Otherwise E8572.
    LEA EAX,[EDI-1]
    SUB EAX,ESI
    MOV [%PfSopOutFileSize],EAX            ; Size with removed suboperations prepared for return.
.10: ; EDI..EDX must be a suboperations chain, e.g. <code>{5..%&amp;-4}[256..]</code>, or empty.
    CMP EDI,EDX
    JNB .90:                               ; If empty chain, we're done.
    Invoke ExpParseSuboperation::,EDI,EDX  ; Returns ESI at the end of 1st suboperator (closing bracket).
    JC .E8572:                             ; Invalid suboperation of PROGRAM OUTFILE="!1S. Ignored.
    ; EDI..ESI is now one valid suboperator, e.g. <code>{5..%&amp;-4}</code>.
    MOV [%PfSopEnd],ESI
    INC EDI
    DEC ESI                                ; Strip off the brackets.
    RstSt [%PfSopStatus],1
    Invoke ExpParseRange::,EDI,ESI         ; Returns EAX behind the range operator.
    MOV [%PfSopLeftPtr],EDI
    MOV [%PfSopRightPtr],EAX
    MOV [%PfSopRightEnd],ESI
    JC .20:                                ; If no range operator <kbd>..</kbd> was found in EDI..ESI. Returned EAX=ESI.
    SetSt [%PfSopStatus],1                 ; EAX points behind the range operator <kbd>..</kbd>.
    SUB EAX,2 ; Skip the range operator.
.20:MOV [%PfSopLeftEnd],EAX                ; Both <b>range expressions are parsed now</b>.
    MOVD [%PfSopLeftVal],1                 ; Default.
    StreamReset [%ReturnEAX]
    CMPB [EDI-1],'{'
    JE .30:
    StreamGetSize [%ReturnEAX]
    JMP .32:
.30:StreamGetLines [%ReturnEAX]
.32:MOV [%PfSopRightVal],EAX ; Default.
    LEA EDX,[%PfSopExp]
    BufferClear [%PfSopBuffer]             ; Prepare to <b>evaluate the left range value</b>.
    Invoke VarExpandField::,[%PfSopLeftPtr],[%PfSopLeftEnd],[%PfSopBuffer],EAX ; Expand <kbd>%&amp;</kbd>.
    BufferRetrieve [%PfSopBuffer]
    StripSpaces ESI,ECX
    JECXZ .38:                             ; Leave empty left range at default=1.
    Invoke ExpEval::,EDX,ESI,ECX,0
    JC .E8572:                             ; Invalid suboperation of PROGRAM OUTFILE="!1S. Ignored.
    Invoke ExpConvertToNumber::,EDX
    JC .E8572:                             ; Invalid suboperation of PROGRAM OUTFILE="!1S. Ignored.
    MOV ECX,[EDX+EXP.Low]
    MOV [%PfSopLeftVal],ECX
    JMPS .40:
.38:SetSt [%PfSopStatus],1
.40:BufferClear [%PfSopBuffer]             ; <b>Evaluate the right range value</b>.
    Invoke VarExpandField::,[%PfSopRightPtr],[%PfSopRightEnd],[%PfSopBuffer],EAX
    BufferRetrieve [%PfSopBuffer]
    StripSpaces ESI,ECX
    JECXZ .45:                             ; Leave empty right range at default=%&amp;=[%PfSopRightVal].
    Invoke ExpEval::,EDX,ESI,ECX,0
    JC .E8572:                             ; Invalid suboperation of PROGRAM OUTFILE="!1S. Ignored.
    Invoke ExpConvertToNumber::,EDX
    JC .E8572:                             ; Invalid suboperation of PROGRAM OUTFILE="!1S. Ignored.
    MOV ECX,[EDX+EXP.Low]
    MOV [%PfSopRightVal],ECX
    JMP .50:
.45:JSt [%PfSopStatus],1,.50:
    MOV ECX,[%PfSopLeftVal]
    MOV [%PfSopRightVal],ECX
.50:StreamCreate [EBX+PGM.Pool]            ; <b>Both range values are calculated</b> now.
    MOV [%PfSopStream],EAX
    StreamReset [%ReturnEAX]               ; <b>Copy suboperated stream</b> [%ReturnEAX] to the new [%PfSopStream].
    SUB EDX,EDX                            ; Line counter.
    MOV ECX,[%PfSopLeftVal]
.60:INC EDX
    CMP EDX,ECX
    JNL .70:
    CMPB [EDI-1],'{'
    JE .65:
    StreamReadByte [%ReturnEAX]            ; Substring - skip 1 byte.
    JMP .60:
.65:StreamReadLn [%ReturnEAX],0            ; Sublist - skip 1 line.
    JMP .60:
.70:CMP EDX,[%PfSopRightVal]
    JG .85:
    CMPB [EDI-1],'{'
    JE .75:
    StreamReadByte [%ReturnEAX]            ; Substring - read 1 byte.
    StreamStoreByte [%PfSopStream],AL
    INC EDX
    JMP .70:
.75:BufferClear [%PfSopBuffer]
    StreamReadLn [%ReturnEAX],[%PfSopBuffer] ; Sublist - read 1 line.
    BufferRetrieve [%PfSopBuffer]
    StreamStore [%PfSopStream],ESI,ECX
    INC EDX
    JMP .70:
.85: ; [%PfSopStream] is suboperated now. It will replace current stream at [%ReturnEAX].
    MOV EAX,[%PfSopStream]
    MOV [%ReturnEAX],EAX
    MOV EDI,[%PfSopEnd]
    MOV EDX,[%PfSopOutFileEnd]
    JMP .10:                               ; Suboperators may chain.
.E8572:LEA EAX,[EBX+PGM.Pgmopt.OutFilePtr]
     Msg '8572',EAX                        ; Invalid suboperation of PROGRAM OUTFILE="!1S. Ignored.
.90:Invoke EaBufferRelease::,[%PfSopBuffer]
    MOV EAX,[%PfSopOutFileSize]
    MOV EDI,[EBX+PGM.Pgmopt.OutFilePtr]
    MOV [EBX+PGM.Pgmopt.OutFileSize],EAX   ; Remove suboperations from outfile name.
    MOVB [EDI+EAX],0                       ; Zero terminate the filename.
   EndProcedure PfSuboperate
</pre>

<pre>
  ENDPROGRAM pf
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
