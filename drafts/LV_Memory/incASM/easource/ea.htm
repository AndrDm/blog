<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='ea.htm source file'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>ea.htm source file</title>
</head>
<body class='EASOURCE' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>ea.htm
<br/><i>Tuning</i>
<br/><a href="#EaTune">EaTune</a>
<br/><i>Class</i>
<br/><a href="#EA">EA</a>
<br/><i>Object</i>
<br/><a href="#EaObj">Ea</a>
<br/><i>Macro</i>
<br/><a href="#EaStackCheck">EaStackCheck</a>
<br/><i>Procedures</i>
<br/><a href="#EaAssemble">EaAssemble</a>
<br/><a href="#EaBufferAlign">EaBufferAlign</a>
<br/><a href="#EaBufferRelease">EaBufferRelease</a>
<br/><a href="#EaBufferReserve">EaBufferReserve</a>
<br/><a href="#EaBufferSort">EaBufferSort</a>
<br/><a href="#EaCreate">EaCreate</a>
<br/><a href="#EaDestroy">EaDestroy</a>
<br/><a href="#EaDisplayPgm">EaDisplayPgm</a>
<br/><a href="#EaDisplayPosition">EaDisplayPosition</a>
<br/><a href="#EaFs2Id">EaFs2Id</a>
<br/><a href="#EaId2Fs">EaId2Fs</a>
<br/><a href="#EaIniAssemble">EaIniAssemble</a>
<br/><a href="#EaIniGlobal">EaIniGlobal</a>
<br/><a href="#EaMain">EaMain</a>
<br/><a href="#EaMallocError">EaMallocError</a>
<br/><a href="#EaStreamAlign">EaStreamAlign</a>
<br/><a href="#atRTprocedures">@RTprocedures</a>
</h1>
<p>This source file <q>ea.htm</q> contains an object Ea which represents the executable file
<q>euroasm.exe</q>. It provides initialization of €ASM and assembles all source files
<!---->specified at cmdline.
<br/>As there is only one instance of EA, the object <code>Ea</code> is defined statically.</p>
<!----><br class="CLEAR"/>
<pre>
ea PROGRAM FORMAT=COFF,MODEL=FLAT,WIDTH=32
   INCLUDEHEAD euroasm.htm, \  Interface (structures, symbols and macros) of other modules used in this source.
               dict.htm, eaopt.htm, exp.htm, ii.htm, msg.htm, pfcoff.htm, pfmz.htm, pfpe.htm, \
               pgm.htm, pgmopt.htm, reloc.htm, sss.htm, stm.htm, sym.htm
</pre><pre>
ea HEAD ; Start of module interface.
</pre>

<dl id="EaTune"><dt><a href="#top">&uarr; EaTune</a></dt>
<dd>Global parameters for fine tuning of €ASM performance.</dd></dl><pre>
%EaStackSize  %SETA 1M  ; &euro;ASM machine stack ES:ESP reserved size.
                        ;  Fatal error is thrown on overflow.
%EaPoolSize   %SETA 64K ; Initial <a class="EXT" href="../maclib/memory32.htm#POOL">POOL</a> block brutto size.
                        ;  More blocks may be allocated on demand later.
%EaBufferSize %SETA 4K  ; Initial <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> brutto size.
                        ;  It can be increased (doubled) on demand when underestimated.
%EaStackDepth %SETA 16  ; Initial number of stackable objects on <a class="EXT" href="../maclib/memory32.htm#STACK">STACK</a>.
                        ;  It can be increased (doubled) on demand when underestimated.
</pre>

<dl id="EA"><dt><a href="#top">&uarr; EA</a></dt>
<dd>Structure <dfn>EA</dfn> describes the main EuroAssembler object
<dfn>Ea</dfn> which represents the compiler itself.
<br/>Member <code>Ea.TimeStart</code> keeps the real system time when <q>euroasm.exe
</q> launched. It is used to compute the duration of runtime, which will be reported with I0980.
<!---->See also <code>Ea.Eaopt.TimeStamp</code>.
<br/>Member <code>Ea.BufferStack</code> is a pointer to
<a class="EXT" href="../maclib/memory32.htm#STACK">STACK</a> which stacks QWORDS which contain<ol>
<li>pointer to preallocated <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> in low DWORD, and</li>
<li>arbitrary nonzero identifier in high DWORD, or NULL when the buffer is released and free.</li></ol>
<br/>Member <code>Ea.StackBottom</code> is computed from <code>Ea.StackOrg
</code> decreased by the reserved stack size minus some safety reserve.
<!---->It is used for protection from stack overflow.</dd>
</dl><pre>
EA STRUC
.Version       D 8*B     ; EuroAssembler version "YYYYMMDD".
.EuroasmOS     D 4*B     ; Zero-padded shortcut of EuroAssembler platform (oper.system), e.g. "Win",0.
.Errorlevel    D D       ; Highest errorlevel reached so far in any source.
               ;+10h
.StackOrg      D D       ; €ASM machine stack pointer (ESP) at program entry.
.StackBottom   D D       ; Bottom of <q>euroasm.exe</q> reserved machine stack.
.Pool          D D       ; Pointer to Ea memory <a class="EXT" href="../maclib/memory32.htm#POOL">POOL</a>.
.BufferStack   D D       ; Pointer to <a class="EXT" href="../maclib/memory32.htm#STACK">STACK</a> of Qwords described <a href="#EA">above</a>.
               ;+20h
.Status        D D       ; Binary flags in <a href="#EaEnc">EaEnc</a> encoding.
.ArgNr         D D       ; Ordinal number of currently processed cmdline argument.
.SubPtr        D D       ; Pointer to suboperation string applied to source file.
.SubSize       D D       ; Size of suboperation string including brackets.
               ;+30h
.TimeStart     D D       ; Real time when <q>euroasm.exe</q> launched, as seconds since midnight Jan 1st 1970 UTC.
.SrcTime       D D       ; Last write time of currently processed source file.
.MemPeakSrc    D D       ; Memory allocated by Src.Pool.
.StmCount      D D       ; Total number of statements parsed.
               ;+40h
.CodePage      D D       ; Codepage currently loaded and cached in Ea.CodeTable.
.CodeTable     DU 128*U  ; Dynamically updated translate table from ANSI[128..255] to WIDE characters.
.EaoptIni      DS EAOPT  ; Global default EUROASM options valid at start of each source.
.Eaopt         DS EAOPT  ; Currently valid EUROASM options in charge. Dynamically updated.
.Pgmopt        DS PGMOPT ; Global default PROGRAM options valid at the start of each source.
.IniFile       DS FILE   ; Global configuration <a class="EXT" href="../maclib/winf32.htm#FILE">FILE</a> <q>euroasm.ini</q>.
.SrcFile       DS FILE   ; Currently processed source file specified on cmdline.
   ENDSTRUC EA
</pre>

<dl id="EaEnc"><dt><a href="#top">&uarr; EaEnc</a></dt>
<dd>Encoding of EA status flags.</dd></dl><pre>
eaAtLeast1File   EQU 1 ; <q>euroasm.exe</q> was launched with one or more input source file.
eaWildcarded     EQU 2 ; Input source file was specified with wildcard(s) <kbd>?</kbd>, <kbd>*</kbd>.
eaIniSectEUROASM EQU 4 ; [EUROASM] section of <q>euroasm.ini</q> is currently processed.
eaIniSectPROGRAM EQU 8 ; [PROGRAM] section of <q>euroasm.ini</q> is currently processed.
</pre>

<dl id="EaStackCheck"><dt><a href="#top">&uarr; EaStackCheck</a></dt>
<dd>Macro <dfn>EaStackCheck</dfn> is used to protect the program from stack overflow.
<!---->It should be used in recursively invoked procedures.</dd>
<dt>Input</dt><dd><b>-</b> Current value of ESP is compared with global member
<code>Ea.StackBottom</code>.</dd>
<dt>Output</dt><dd>Arithmetic flags are destroyed.</dd>
<dt>Error</dt><dd>F9210 Memory reserved for machine stack is too small for this program.</dd>
</dl><pre>
EaStackCheck %MACRO
    CMP ESP,[Ea.StackBottom::]
    Msg cc=B,'9210' ; Memory reserved for machine stack is too small for this source file.
   %ENDMACRO EaStackCheck
</pre>
<pre>
   ENDHEAD ea ; End of module interface.
</pre>

<dl id="EaObj"><dt><a href="#top">&uarr; Ea</a></dt>
<dd>Since there is only one instance of the main €ASM object <dfn>Ea</dfn>,
<!---->it is defined statically in [.bss] segment.</dd>
<dt>The main EuroAssembler <a class="EXT" href="index.htm#DOM">object model</a></dt>
<dd class="PRE"><a href="#EaMain">EaMain</a>::                 ; Executable entry.
   <a href="#EaCreate">EaCreate</a>              ; Ea constructor.
     <a class="EXT" href="syswin.htm#SysEachFile">SysEachFile</a>  <a href="#EaAssemble">EaAssemble</a> SourceFileFromCmdLine
   <a href="#EaDestroy">EaDestroy</a>             ; Ea destructor.
   <a class="EXT" href="syswin.htm#SysExitProcess">SysExitProcess</a>        ; Terminate <q>euroasm.exe</q>.
</dd></dl><pre>
[.bss]
Ea::        DS EA                 ; Instance of the main EuroAssembler object.
[.data]
EaVersion:: DB "%^DATE"           ; Date "YYYYMMDD" when &euro;ASM was built.
EaIniFileDefault:                 ; Factory default options from <q>../objlib/euroasm.ini</q> will be built-in to <q>euroasm.exe</q>.
  INCLUDEBIN "../objlib/euroasm.ini"
EaIniFileDefaultEnd:
</pre>

<dl id="EaMain">
<dt><a href="#top">&uarr; EaMain</a></dt>
<dd>This is the main procedure of EuroAssembler and its entry point.</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="dict.htm#DictLookup">DictLookup</a>
<a href="#EaBufferRelease">EaBufferRelease</a>
<a href="#EaBufferReserve">EaBufferReserve</a>
<a href="#EaCreate">EaCreate</a>
<a href="#EaDestroy">EaDestroy</a>
<a href="#EaIniAssemble">EaIniAssemble</a>
<a href="#EaIniGlobal">EaIniGlobal</a>
<a class="EXT" href="exp.htm#ExpParseKeyName">ExpParseKeyName</a>
<a class="EXT" href="exp.htm#ExpParseKeyValue">ExpParseKeyValue</a>
</dd>
<dt>Invoked from</dt>
<dd>OS program loader.</dd>
</dl><pre>
[.text]
EaMain:: PROC                                    ; <b>Entry point</b> of EuroAssembler. Here the execution begins and ends.
    MOV EAX,ESP
    Invoke EaCreate,EAX
    ; <b>Command-line arguments</b> are source file names mixed with EUROASM options,
    ;  separated with unquoted space or comma and they are processed in two passes:
    ; <b>Cmdline pass 1</b> will ignore filenames and store each option <em>as is</em> to a temporary buffer.
    Invoke EaBufferReserve,EaMain
    MOV EBP,EAX
    BufferStore EBP, =B "[EUROASM]",9            ; Initialize contents with division name.
    BufferStoreByte EBP,10                       ; Terminate with line-feed.
.10:INCD [Ea.ArgNr]                              ; Get the next argument (a filename or keyword option).
    SysGetArg [Ea.ArgNr]                         ; Set ESI,ECX to a cmdline argument.
    JC .30:                                      ; If there are no more arguments.
    MOV EBX,ESI                                  ; Pointer to a potential keyword.
    LEA EDI,[ESI+ECX]                            ; End of potential EUROASM keyword including its value.
    Invoke ExpParseKeyName::,ESI,EDI
    JC .10:                                      ; If the argument was not a keyword=, then it must be a filename. Ignore in pass 1.
    LEA EDX,[EAX-1]
    SUB EDX,EBX                                   ; EBX,EDX is now KeyName.
    Invoke ExpParseKeyValue::,EAX,EDI
    JC .10:                                      ; Ignore. Invalid options will be processed in cmdline pass 2 and treated as a filename.
    Invoke DictLookup::, DictEaoptMisc::,EBX,EDX ;  EBX,EDX is option key name, e.g."NOWARN". ESI,ECX is valid option value, e.g. "2100".
    JNC .20:
    Invoke DictLookup::, DictEaoptStatus::,EBX,EDX
    JNC .20:
    Invoke DictLookup::, DictEaoptFea::,EBX,EDX
    JC .10:                                      ; Ignore. Unknown options will be processed in cmdline pass 2 and treated as a filename.
.20:SysGetArg [Ea.ArgNr]                         ; Reload the whole valid argument again.
    BufferStore EBP,ESI,ECX                      ; Accumulate unassembled cmdline options in temporary buffer EBP.
    BufferStoreByte EBP,10                       ; Terminate with line-feed.
    JMP .10:                                     ; The next cmdline argument.
.30:BufferRetrieve EBP                           ; Reload plaintext cmdline EUROASM options from the temporary buffer EBP.
    ADD ECX,ESI
    ; Text at ESI..ECX is virtual <q>euroasm.ini</q> contents composed from [EUROASM] division and cmdline options.
    Invoke EaIniAssemble,ESI,ECX,Ea.Eaopt,Ea.Pgmopt ; Compile the contents to Ea.Eaopt object.
    ; Now it's time to report first informative messages. They are suppressible only by cmdline option <code>NOWARN=0010..0020</code>.
    MOV EBX,Ea.SrcFile.Name                      ; As SrcFile was not used yet, its room will be temporarily misused as the current directory name temporary storage.
    SysGetCurrentDirectory EBX
    PUSHD 8,Ea.Version
      MOV EAX,ESP
      MOV ECX,Ea.EuroasmOS
      Msg '0010',EAX,ECX                         ; EuroAssembler version !1S !2$ started.
    POP EAX,EAX
    Msg '0020',EBX                               ; Current directory is "!1$".
    Invoke EaIniGlobal                           ; Compile global <q>euroasm.ini</q> to Ea object.
    BufferRetrieve EBP
    ADD ECX,ESI
    Invoke EaIniAssemble,ESI,ECX,Ea.Eaopt,Ea.Pgmopt ; Reapply cmdline options again.
    Invoke EaBufferRelease,EBP                   ; Temporary buffer for cmdline options is no longer necessary.
    CopyTo Ea.EaoptIni, Ea.Eaopt                 ; Snapshot the starting options for each source.
    ; <b>Cmdline pass 2</b> will read&amp;assemble <b>filename(s)</b> and skip command-line options.
    MOVD [Ea.ArgNr],0                            ; Start with the first argument again.
.40:INCD [Ea.ArgNr]
    SysGetArg [Ea.ArgNr]
    JC .80:                                      ; If there are no more arguments.
    MOV EBX,ESI                                  ; Pointer to a potential keyword.
    LEA EDI,[ESI+ECX]                            ; End of potential EUROASM keyword including its value.
    Invoke ExpParseKeyName::,ESI,EDI
    JC .50:                                      ; If the argument was not a keyword=, go and treat the argument ESI,ECX as a filename to assemble.
    LEA EDX,[EAX-1]
    SUB EDX,EBX                                  ; EBX,EDX is now KeyName. Check if it is valid.
    PUSH ECX,ESI
      Invoke ExpParseKeyValue::,EAX,EDI
    POP ESI,ECX
    JC .50:                                      ; If the option value was invalid, go and treat the argument ESI,ECX as a filename to assemble.
    ; EBX,EDX is key name.
    Invoke DictLookup::, DictEaoptMisc::,EBX,EDX
    JNC .40:                                     ; Skip a valid cmdline option.
    Invoke DictLookup::, DictEaoptStatus::,EBX,EDX
    JNC .40:                                     ; Skip a valid cmdline option.
    Invoke DictLookup::, DictEaoptFea::,EBX,EDX
    JNC .40:                                     ; Skip a valid cmdline option.
.50:; ESI,ECX will be treated as a filename to assemble. It may be suboperated and it may have wildcards.
    ; String may look like <code>file.asm</code> or <code>"file*.asm"</code> or <code>"file.asm"{1..40}</code>.
    ; Filename <b>wildcards</b> without quotes will be solved by SysEachFile,
    ;   <b>suboperation</b> string will be parsed to Ea.SubPtr,Ea.SubSize.
    LEA EDX,[ESI+ECX]
    LODSB
    MOV [Ea.SubPtr],EDX                          ; Initialize Ea.Sub to an empty string.
    MOV [Ea.SubSize],0
    MOV EDI,ESI
    DEC ESI
    CMP AL,'"'
    JNE .60:                                     ; If filename is not in quotes, it cannot have suboperations.
    INC ESI                                      ; Source file is specified in quotes.
    REPNE SCASB                                  ; Find the closing quote.
    MOV [Ea.SubPtr],EDI
    SUB EDX,EDI                                  ; Suboperation size.
    LEA ECX,[EDI-1]
    MOV [Ea.SubSize],EDX
    SUB ECX,ESI                                  ; ESI,ECX is netto filename. It may contain wildcard characters <kbd>? *</kbd>.
    SetSt [Ea.Status],eaWildcarded
    RstSt [Ea.Status],eaAtLeast1File
    MOV EDX,ECX
    MOV EDI,ESI
    MOV AL,"?"
    REPNE SCASB
    MOV ECX,EDX
    JE .70:
    MOV EDI,ESI
    MOV AL,"*"
    REPNE SCASB
    MOV ECX,EDX
    JE .70:
    RstSt [Ea.Status],eaWildcarded
.60:MOV EDX,ECX
.70:SysAssignFile Ea.SrcFile,ESI,EDX
    ; Resolve wildcards using SysEachFile, and invoke callback procedure <a href="ea.htm#EaAssemble">EaAssemble</a>
    ; on each resolved source file. Succesfull callback will set flag eaAtLeast1File.
    SysEachFile Ea.SrcFile,EaAssemble
    JSt [Ea.Status],eaWildcarded | eaAtLeast1File,.40: ; Fetch and assemble the next source.
    ; Filename read from cmdline was not found, perhaps no file matched the mask.
    PUSH EDX,ESI                                 ; ESI,EDX is nonwildcarded filename from cmdline.
     MOV EAX,ESP
     Msg '8010',EAX                              ; No such file "!1S".
    POP ESI,EDX             
    JMP .40:                                     ; Fetch the next argument from cmdline.
.80: ; <b>All cmdline arguments were processed</b>.
    CMP [Ea.ArgNr],1
    Msg cc=NA,'8000'                             ; No input file specified.
.90:Invoke EaDestroy
    MOV ESP,[Ea.StackOrg]    
    SysExitProcess [Ea.Errorlevel]               ; Shutdown EuroAssembler.
   ENDP EaMain::
</pre>

<dl id="EaCreate">
<dt><a href="#top">&uarr; EaCreate</a> StackOrg</dt>
<dd>Constructor which initializes the Ea object.</dd>
<dt>Input</dt>
<dd><b>StackOrg</b> is value of ESP at program entry.</dd>
<dt>Output</dt>
<dd>Object Ea is initialized.</dd>
<dt>Invoked by</dt>
<dd><a href="#EaMain">EaMain</a>
</dd>
<dt>Invokes</dt>
<dd><a href="#EaIniAssemble">EaIniAssemble</a>
</dd>
</dl><pre>
EaCreate Procedure StackOrg
    MOV ESI,EaVersion
    MOV EDI,Ea.Version
    MOVSD                                        ; Copy the version string "YYYYMMDD" defined statically when &euro;ASM was build.
    MOVSD
    ; Set <b>&euro;ASM system %variables</b> values into Ea object.
    SysGetEuroasmOS
    MOV [Ea.EuroasmOS],EAX
    SysGetUTC                                    ; Get real system time as the number of seconds since 1.1.1970 to EAX.
    MOV [Ea.TimeStart],EAX
    MOV [Ea.Eaopt.TimeStamp],EAX                 ; Initialize nominal system time, too.
    ; <b>Manage machine stack SS:ESP</b>.
    MOV EBX,[%StackOrg]
    MOV [Ea.StackOrg],EBX                        ; EBX=Top of stack.
    SysGetStackSize                              ; EAX=size of this running &euro;ASM reserved machine stack (SS:ESP).
    Msg cc=C,'9210'
    SUB EBX,EAX                                  ; EBX=bottom of stack.
    ADD EBX,4K                                   ; A safety reserve.
    MOV [Ea.StackBottom],EBX                     ; When ESP gets below this value, F9210 is reported.
    ; <b>Pool of heap memory</b> for €ASM own memory management.
    MOV EDI,%EaPoolSize
    PoolCreate  Size=EDI, ErrorHandler=EaMallocError
    MOV [Ea.Pool],EAX
    ; <b>Stack of universal reserveable buffers</b>.
    StackCreate EAX,8,Depth=%EaStackDepth        ; BufferStack items have two DWORDs each.
    MOV [Ea.BufferStack],EAX
    ; Initialize EUROASM options with factory defaults built-in  <q>euroasm.exe</q> body.
    Invoke EaIniAssemble,EaIniFileDefault,EaIniFileDefaultEnd, Ea.Eaopt, Ea.Pgmopt
   EndProcedure EaCreate
</pre>

<dl id="EaDestroy">
<dt><a href="#top">&uarr; EaDestroy</a></dt>
<dd>Destructor of Ea object.</dd>
<dt>Input</dt>
<dd>-</dd>
<dt>Output</dt>
<dd>I0980, I0990</dd>
<dt>Error</dt>
<dd>W2575</dd>
<dt>Invoked by</dt>
<dd><a href="#EaMain">EaMain</a>
</dd>
</dl><pre>
EaDestroy Procedure
    MOV ECX,[Ea.StmCount]
    TEST ECX
    JZ .90:                                      ; If no statement was assembled.
    SysGetUTC
    SUB EAX,[Ea.TimeStart]
    JNZ .50:
    INC EAX                                      ; Round up the total assembly duration to at least 1 second.
.50:MOV EBX,EAX                                  ; EBX is the duration of assembly.
    MOV EDX,[Ea.Pool]
    PoolDestroy EDX
    Msg cc=C,'2575','Ea',EDX                     ; Deallocation of virtual memory !1C.Pool !2Hh failed.
    ADD EAX,[Ea.MemPeakSrc]
    SHR EAX,10
    Msg '0980',EAX,[Ea.StmCount],EBX             ; Peak memory allocation !1D KB. !2D statements assembled in !3D s.
.90:Msg '0990',[Ea.Errorlevel]                   ; EuroAssembler terminated with errorlevel !1D.
 EndProcedure EaDestroy
</pre>


<dl id="EaAssemble">
<dt><a href="#top">&uarr; EaAssemble</a></dt>
<dd>This procedure assembles lines from <code>Ea.SrcFile
</code>. The source filename might have been specified with wildcards. 
<!---->Usually the whole file is assembled but possible suboperation of source
<!---->can be specified with <code>Ea.SubPtr,Ea.SubSize</code>.
<br/>EaAssemble is callback procedure invoked in <a href="#EaMain">EaMain</a> from the macro
<a class="EXT" href="syswin.htm#SysEachFile">SysEachFile</a>.</dd>
<dt>Object model</dt>
<dd>See <a href="#EaObj">Ea object model</a> and <a class="EXT" href="src.htm#SrcAssemble">Stm object model</a>.</dd>
<dt>Input</dt>
<dd><b>EDI=</b> pointer to <a class="EXT" href="../maclib/winsfile.htm#WIN32_FIND_DATA">WIN32_FIND_DATAW
</a> structure with file attributes (in Windows version only).
<br/><b>Ea.SrcFile</b> is assigned with the source file name, wildcards resolved. Leading "./" is removed, if any.
<br/><b>Ea.SubPtr, Ea.SubSize</b> specifies suboperation(s) with source file as given on cmd line,
<!---->when only a part of it should be assembled, for instance <code>{1..%&amp;-40}</code>.
<!---->Ea.SubSize=0 when no suboperation of input source file was specified.</dd>
<dt>Output</dt>
<dd><b>CF=</b>0 if the source file was assembled.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 if fatal error occured (errorlevel 9)
<!---->and &euro;ASM needs to abort.</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="src.htm#SrcAssemble">SrcAssemble</a>
<a class="EXT" href="src.htm#SrcCreate">SrcCreate</a>
<a class="EXT" href="src.htm#SrcDestroy">SrcDestroy</a>
</dd>
<dt>Invoked from</dt>
<dd><a href="#EaMain">EaMain</a> as a callback.</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t1210.htm">t1210</a>
</dd>
</dl><pre>
EaAssemble Procedure
     LEA ESI,[EBX+FILE.Name]
     SysGetFileTime ESI
     MOV [Ea.SrcTime],EAX
     SetSt [Ea.Status],eaAtLeast1File
     Invoke SrcCreate::
     Invoke SrcAssemble::
     Invoke SrcDestroy::
     CMP EAX,[Ea.MemPeakSrc::]
     JNA .80:
     MOV [Ea.MemPeakSrc::],EAX
.80: CMP [Ea.Errorlevel],9
     CMC                                         ; Return CF on fatal Euroasm error, such as bad memory allocation or stack overflow.
   EndProcedure EaAssemble                       ; This prevents SysEachFile from further wildcard expansions.
</pre>

<dl id="EaMallocError">
<dt><a href="#top">&uarr; EaMallocError</a></dt>
<dd>Memory allocation exception handler. It is called from PoolCreate when
<!---->allocation request failed (fatal error).</dd>
<dt>See also</dt>
<dd><a class="EXT" href="../maclib/memory32.htm#PoolCreate">PoolCreate</a></dd>
</dl><pre>
EaMallocError:: PROC
     Msg '9110'                                  ; Cannot allocate virtual memory.
     RET
     ENDP EaMallocError
</pre>

<dl id="EaBufferReserve">
<dt><a href="#top">&uarr; EaBufferReserve</a> RequestingObject</dt>
<dd>EaBufferReserve returns empty buffer from the stack of universal buffers.
<br/>It will search Ea.BufferStack for unoccupied buffer and, if none found,
<!---->create a new one and add it on the stack. The optimal initial Ea.BufferStack size depends
<!---->on the nesting depth used in assembled program (macro in macro, nested suboperation etc)
<!---->and it is increased on demand.
<br/>Objects kept on Ea.BufferStack are QWORDS where the first DWORD is pointer to a
<a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a>, and the second DWORD
<!---->is nonzero identifier of occupation (zero value indicates that the buffer is released).</dd>
<dt>Input</dt>
<dd><b>RequestingObject</b> is address of the object which is going to use this buffer.
<!---->It is used for debugging purpose only (to find out which Procedure requested the buffer).</dd>
<dt>Output</dt>
<dd><b>CF=0</b>, <b>EAX=</b> pointer to an empty
<a class="EXT" href="../maclib/memory32.htm#BUFFER">buffer</a>.</dd>
<dt>Error</dt>
<dd><b>CF=1, EAX=0</b> fatal error F9312.</dd>
<dt>See also</dt>
<dd><a href="#EaBufferRelease">EaBufferRelease</a>.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="chunk.htm#ChunkInclude">ChunkInclude</a>
<a class="EXT" href="chunk.htm#ChunkSuboperate">ChunkSuboperate</a>
<a class="EXT" href="ctx.htm#CtxCreate">CtxCreate</a>
<a class="EXT" href="ctx.htm#CtxDiscard">CtxDiscard</a>
<a class="EXT" href="ctx.htm#CtxFind">CtxFind</a>
<a href="#EaIniGlobal">EaIniGlobal</a>
<a href="#EaMain">EaMain</a>
<a class="EXT" href="exp.htm#ExpEval">ExpEval</a>
<a class="EXT" href="exp.htm#ExpEvalData">ExpEvalData</a>
<a class="EXT" href="exp.htm#ExpEvalIdentifier">ExpEvalIdentifier</a>
<a class="EXT" href="exp.htm#ExpParseDatatype">ExpParseDatatype</a>
<a class="EXT" href="exp.htm#ExpStoreInstr">ExpStoreInstr</a>
<a class="EXT" href="ii.htm#IiAssembleMultiop">IiAssembleMultiop</a>
<a class="EXT" href="ii.htm#IiFlush">IiFlush</a>
<a class="EXT" href="lst.htm#LstGetFileName">LstGetFileName</a>
<a class="EXT" href="member.htm#MemberAdd">MemberAdd</a>
<a class="EXT" href="member.htm#MemberUpdate">MemberUpdate</a>
<a class="EXT" href="pf.htm#PfDrectveCreate">PfDrectveCreate</a>
<a class="EXT" href="pf.htm#PfSuboperate">PfSuboperate</a>
<a class="EXT" href="pfcoff.htm#PfcoffCompile">PfcoffCompile</a>
<a class="EXT" href="pfcoff.htm#PfcoffLoadPgm">PfcoffLoadPgm</a>
<a class="EXT" href="pfcom.htm#PfcomCompile">PfcomCompile</a>
<a class="EXT" href="pfelf.htm#PfelfCreate">PfelfCreate</a>
<a class="EXT" href="pfelf.htm#PfelfLoadPgm">PfelfLoadPgm</a>
<a class="EXT" href="pflibcof.htm#PflibcofCompile">PflibcofCompile</a>
<a class="EXT" href="pflibomf.htm#PflibomfCompile">PflibomfCompile</a>
<a class="EXT" href="pfmz.htm#PfmzCompile">PfmzCompile</a>
<a class="EXT" href="pfomf.htm#PfomfLoadDataBlock">PfomfLoadDataBlock</a>
<a class="EXT" href="pfomf.htm#PfomfLoadModule">PfomfLoadModule</a>
<a class="EXT" href="pfomf.htm#PfomfStoreData">PfomfStoreData</a>
<a class="EXT" href="pfomf.htm#PfomfStoreModule">PfomfStoreModule</a>
<a class="EXT" href="pfpe.htm#PfpeBaserelocFixup">PfpeBaserelocFixup</a>
<a class="EXT" href="pfpe.htm#PfpeCompile">PfpeCompile</a>
<a class="EXT" href="pfpe.htm#PfpeExportCreate">PfpeExportCreate</a>
<a class="EXT" href="pfpe.htm#PfpeImportCreate">PfpeImportCreate</a>
<a class="EXT" href="pfpe.htm#PfpeOptionalHeader">PfpeOptionalHeader</a>
<a class="EXT" href="pfrsrc.htm#PfrsrcLoadIconFile">PfrsrcLoadIconFile</a>
<a class="EXT" href="pfrsrc.htm#PfrsrcLoadPgm">PfrsrcLoadPgm</a>
<a class="EXT" href="pgm.htm#PgmDetectImportModule">PgmDetectImportModule</a>
<a class="EXT" href="pgm.htm#PgmListGlobals">PgmListGlobals</a>
<a class="EXT" href="pgm.htm#PgmListLiterals">PgmListLiterals</a>
<a class="EXT" href="pgm.htm#PgmListMap">PgmListMap</a>
<a class="EXT" href="pgm.htm#PgmOrderSymbols">PgmOrderSymbols</a>
<a class="EXT" href="pgm.htm#PgmSelectModules">PgmSelectModules</a>
<a class="EXT" href="pgmopt.htm#PgmoptSetDefaults">PgmoptSetDefaults</a>
<a class="EXT" href="pseudo.htm#PseudoData">PseudoData</a>
<a class="EXT" href="pseudo.htm#PseudoPROC1">PseudoPROC1</a>
<a class="EXT" href="pseudo.htm#PseudoSEGMENT">PseudoSEGMENT</a>
<a class="EXT" href="pseudo.htm#PseudoSTRUC">PseudoSTRUC</a>
<a class="EXT" href="pseudo.htm#PseudopcDISPLAY">PseudopcDISPLAY</a>
<a class="EXT" href="pseudo.htm#PseudopcERROR">PseudopcERROR</a>
<a class="EXT" href="pseudo.htm#PseudopcSET">PseudopcSET</a>
<a class="EXT" href="pseudo.htm#PseudopcSET2">PseudopcSET2</a>
<a class="EXT" href="pseudo.htm#PseudopcSETA">PseudopcSETA</a>
<a class="EXT" href="pseudo.htm#PseudopcSETB">PseudopcSETB</a>
<a class="EXT" href="pseudo.htm#PseudopcSETC">PseudopcSETC</a>
<a class="EXT" href="pseudo.htm#PseudopcSETE">PseudopcSETE</a>
<a class="EXT" href="pseudo.htm#PseudopcSETL">PseudopcSETL</a>
<a class="EXT" href="pseudo.htm#PseudopcSETS">PseudopcSETS</a>
<a class="EXT" href="pseudo.htm#PseudopcSETX">PseudopcSETX</a>
<a class="EXT" href="reloc.htm#RelocPurge">RelocPurge</a>
<a class="EXT" href="src.htm#SrcCreate">SrcCreate</a>
<a class="EXT" href="sss.htm#SssGuessPurpose">SssGuessPurpose</a>
<a class="EXT" href="stm.htm#StmCreate">StmCreate</a>
<a class="EXT" href="stm.htm#StmExpandField">StmExpandField</a>
<a class="EXT" href="stm.htm#StmListing">StmListing</a>
<a class="EXT" href="sym.htm#SymCreate">SymCreate</a>
<a class="EXT" href="sym.htm#SymCreateLiteral">SymCreateLiteral</a>
<a class="EXT" href="var.htm#VarExpand">VarExpand</a>
<a class="EXT" href="var.htm#VarExpandField">VarExpandField</a>
<a class="EXT" href="var.htm#VarSuboperate">VarSuboperate</a>
</dd>
</dl><pre>
EaBufferReserve Procedure RequestingObject
BufRec LocalVar Size=8
      MOV EBX,[Ea.BufferStack]
      MOV ESI,[EBX+STACK.Ptr]
      SUB ECX,ECX
.10:  SUB ESI,[EBX+STACK.Size]
      CMP ESI,[EBX+STACK.Bottom]
      JNB .50:
     ; No released buffer found on stack.
      BufferCreate [EBX+STACK.Pool],Size=%EaBufferSize
      JC .F9313:
      LEA EDI,[%BufRec]
      MOV [EDI],EAX
      MOV [EDI+4],ECX
      StackPush EBX,EDI
      JNC .30:
.F9313:SUB EAX,EAX
      Msg '9313',[%RequestingObject]             ; Alloc.error reserving buffer for !1H.
      STC
      JMP .90:
.30:  MOV ESI,EAX
.50:  CMP [ESI+4],ECX                            ; ESI is at Qword which describes the buffer.
      JNZ .10:                                   ; The buffer is occupied. Try the lower one.
      LODSD
      MOV ECX,[%RequestingObject]
      TEST ECX
      JNZ .80:
      DEC ECX                                    ; If RequestingObject was not specified, use -1 (any nonzero is OK).
.80:  MOV [ESI],ECX
      PUSHD [EAX+BUFFER.Bottom]
      POPD  [EAX+BUFFER.Ptr]                     ; BufferClear.
.90:  MOV [%ReturnEAX],EAX
      EndProcedure EaBufferReserve
</pre>

<dl id="EaBufferRelease">
<dt><a href="#top">&uarr; EaBufferRelease</a> BufferPtr</dt>
<dd>EaBufferRelease will mark the specified buffer as free.
<!---->It does not pop the buffer from Ea.BufferStack.
<!---->Released buffer may be reused later by EaBufferReserve.</dd>
<dt>Input</dt>
<dd><b>BufferPtr</b> pointer to the buffer, as returned from EaBufferReserve.
<!---->It may be 0, nothing happens in this case.</dd>
<dt>Output</dt>
<dd><b>CF=</b>0 Buffer was released and cleared.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 The specified buffer was not found on Ea.BufferStack.</dd>
<dt>See also</dt>
<dd><a href="#EaBufferReserve">EaBufferReserve</a>.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="chunk.htm#ChunkInclude">ChunkInclude</a>
<a class="EXT" href="chunk.htm#ChunkSuboperate">ChunkSuboperate</a>
<a class="EXT" href="ctx.htm#CtxDestroy">CtxDestroy</a>
<a class="EXT" href="ctx.htm#CtxDiscard">CtxDiscard</a>
<a class="EXT" href="ctx.htm#CtxFind">CtxFind</a>
<a href="#EaIniGlobal">EaIniGlobal</a>
<a href="#EaMain">EaMain</a>
<a class="EXT" href="exp.htm#ExpEval">ExpEval</a>
<a class="EXT" href="exp.htm#ExpEvalData">ExpEvalData</a>
<a class="EXT" href="exp.htm#ExpEvalIdentifier">ExpEvalIdentifier</a>
<a class="EXT" href="exp.htm#ExpParseDatatype">ExpParseDatatype</a>
<a class="EXT" href="exp.htm#ExpStoreInstr">ExpStoreInstr</a>
<a class="EXT" href="ii.htm#IiAssembleMultiop">IiAssembleMultiop</a>
<a class="EXT" href="ii.htm#IiFlush">IiFlush</a>
<a class="EXT" href="lst.htm#LstGetFileName">LstGetFileName</a>
<a class="EXT" href="member.htm#MemberAdd">MemberAdd</a>
<a class="EXT" href="member.htm#MemberUpdate">MemberUpdate</a>
<a class="EXT" href="pf.htm#PfDrectveCreate">PfDrectveCreate</a>
<a class="EXT" href="pf.htm#PfSuboperate">PfSuboperate</a>
<a class="EXT" href="pfcoff.htm#PfcoffCompile">PfcoffCompile</a>
<a class="EXT" href="pfcoff.htm#PfcoffLoadPgm">PfcoffLoadPgm</a>
<a class="EXT" href="pfcom.htm#PfcomCompile">PfcomCompile</a>
<a class="EXT" href="pfelf.htm#PfelfDestroy">PfelfDestroy</a>
<a class="EXT" href="pfelf.htm#PfelfLoadPgm">PfelfLoadPgm</a>
<a class="EXT" href="pflibcof.htm#PflibcofCompile">PflibcofCompile</a>
<a class="EXT" href="pflibomf.htm#PflibomfCompile">PflibomfCompile</a>
<a class="EXT" href="pfmz.htm#PfmzCompile">PfmzCompile</a>
<a class="EXT" href="pfomf.htm#PfomfLoadDataBlock">PfomfLoadDataBlock</a>
<a class="EXT" href="pfomf.htm#PfomfLoadModule">PfomfLoadModule</a>
<a class="EXT" href="pfomf.htm#PfomfStoreData">PfomfStoreData</a>
<a class="EXT" href="pfomf.htm#PfomfStoreModule">PfomfStoreModule</a>
<a class="EXT" href="pfpe.htm#PfpeBaserelocFixup">PfpeBaserelocFixup</a>
<a class="EXT" href="pfpe.htm#PfpeCompile">PfpeCompile</a>
<a class="EXT" href="pfpe.htm#PfpeExportCreate">PfpeExportCreate</a>
<a class="EXT" href="pfpe.htm#PfpeImportCreate">PfpeImportCreate</a>
<a class="EXT" href="pfpe.htm#PfpeOptionalHeader">PfpeOptionalHeader</a>
<a class="EXT" href="pfrsrc.htm#PfrsrcLoadIconFile">PfrsrcLoadIconFile</a>
<a class="EXT" href="pfrsrc.htm#PfrsrcLoadPgm">PfrsrcLoadPgm</a>
<a class="EXT" href="pgm.htm#PgmDetectImportModule">PgmDetectImportModule</a>
<a class="EXT" href="pgm.htm#PgmListGlobals">PgmListGlobals</a>
<a class="EXT" href="pgm.htm#PgmListLiterals">PgmListLiterals</a>
<a class="EXT" href="pgm.htm#PgmListMap">PgmListMap</a>
<a class="EXT" href="pgm.htm#PgmOrderSymbols">PgmOrderSymbols</a>
<a class="EXT" href="pgm.htm#PgmSelectModules">PgmSelectModules</a>
<a class="EXT" href="pgmopt.htm#PgmoptSetDefaults">PgmoptSetDefaults</a>
<a class="EXT" href="pseudo.htm#PseudoData">PseudoData</a>
<a class="EXT" href="pseudo.htm#PseudoPROC1">PseudoPROC1</a>
<a class="EXT" href="pseudo.htm#PseudoSEGMENT">PseudoSEGMENT</a>
<a class="EXT" href="pseudo.htm#PseudoSTRUC">PseudoSTRUC</a>
<a class="EXT" href="pseudo.htm#PseudopcDISPLAY">PseudopcDISPLAY</a>
<a class="EXT" href="pseudo.htm#PseudopcERROR">PseudopcERROR</a>
<a class="EXT" href="pseudo.htm#PseudopcSET">PseudopcSET</a>
<a class="EXT" href="pseudo.htm#PseudopcSET2">PseudopcSET2</a>
<a class="EXT" href="pseudo.htm#PseudopcSETA">PseudopcSETA</a>
<a class="EXT" href="pseudo.htm#PseudopcSETB">PseudopcSETB</a>
<a class="EXT" href="pseudo.htm#PseudopcSETC">PseudopcSETC</a>
<a class="EXT" href="pseudo.htm#PseudopcSETE">PseudopcSETE</a>
<a class="EXT" href="pseudo.htm#PseudopcSETL">PseudopcSETL</a>
<a class="EXT" href="pseudo.htm#PseudopcSETS">PseudopcSETS</a>
<a class="EXT" href="pseudo.htm#PseudopcSETX">PseudopcSETX</a>
<a class="EXT" href="reloc.htm#RelocPurge">RelocPurge</a>
<a class="EXT" href="src.htm#SrcCreate">SrcCreate</a>
<a class="EXT" href="sss.htm#SssGuessPurpose">SssGuessPurpose</a>
<a class="EXT" href="stm.htm#StmDestroy">StmDestroy</a>
<a class="EXT" href="stm.htm#StmExpandField">StmExpandField</a>
<a class="EXT" href="stm.htm#StmListing">StmListing</a>
<a class="EXT" href="sym.htm#SymCreate">SymCreate</a>
<a class="EXT" href="sym.htm#SymCreateLiteral">SymCreateLiteral</a>
<a class="EXT" href="var.htm#VarExpand">VarExpand</a>
<a class="EXT" href="var.htm#VarExpandField">VarExpandField</a>
<a class="EXT" href="var.htm#VarSuboperate">VarSuboperate</a>
</dd>
</dl><pre>
EaBufferRelease Procedure BufferPtr
       MOV ECX,[%BufferPtr]
       MOV EBX,[Ea.BufferStack]
       JECXZ .90:
       MOV ESI,[EBX+STACK.Ptr]
.10:   SUB ESI,[EBX+STACK.Size]
       CMP ESI,[EBX+STACK.Bottom]
       JB .90:
       CMP [ESI],ECX
       JNE .10:
       MOVD [ESI+4],0
.90:EndProcedure EaBufferRelease
</pre>

<dl id="EaBufferSort">
<dt><a href="#top">&uarr; EaBufferSort</a> PtrBuffer</dt>
<dd><dfn>EaBufferSort</dfn> will alphabetically sort objects whose pointers are provided in the buffer.
<!---->Objects may be <a class="EXT" href="sym.htm#SYM">SYM</a>, <a class="EXT" href="var.htm#VAR">VAR</a>,
<a class="EXT" href="mac.htm#MAC">MAC</a> or any other class which begins with .NamePtr and .NameSize.</dd>
<dt>Input</dt>
<dd><b>PtrBuffer</b> Pointer to a <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> filled with DWORD pointers to unsorted-yet objects.</dd>
<dt>Output</dt>
<dd>Objects in PtrBuffer are sorted by name.</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>See also</dt>
<dd><a class="EXT" href="../maclib/sort32.htm#ShellSort">ShellSort</a>.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfpe.htm#PfpeExportCreate">PfpeExportCreate</a>
<a class="EXT" href="pgm.htm#PgmListGlobals">PgmListGlobals</a>
<a class="EXT" href="pgm.htm#PgmOrderSymbols">PgmOrderSymbols</a>
</dd>
</dl><pre>
EaBufferSort Procedure PtrBuffer
     BufferRetrieve [%PtrBuffer]
     SAR ECX,2        ; PtrBuffer contains DWORD pointers. ECX is now the number of sorted objects.
     JZ .90:
     ShellSort ESI,ECX,4,.CmpObjNames

.CmpObjNames PROC1     ; Callback subprocedure to compare-by-name two objects,
                      ;     whose pointers are pointed to with ESI and EDI.
     PUSH EBX,ECX     ; ShellSort needs those registers preserved.
      MOV EBX,[ESI]   ; Pointer to the object 1.
      MOV EDX,[EDI]   ; Pointer to the object 2.
      TEST EBX
      JZ .C9:
      TEST EDX
      JZ .C9:
      MOV ECX,[EBX+4] ; Size of the .Name 1.
      CMP ECX,[EDX+4] ; Size of the .Name 2.
      JBE .C2:
      MOV ECX,[EDX+4]
 .C2: CLC             ; ECX is now the shorter size of both names.
      JECXZ .C9:      ; No swap if the names are empty.
      MOV EBX,[EBX]   ; Pointer to the .Name 1.
      MOV EDX,[EDX]   ; Pointer to the .Name 2.
      TEST EBX
      JZ .C9:
      TEST EDX
      JZ .C9:
 .C3: MOV AL,[EBX]    ; Load a character from .Name 1.
      MOV AH,[EDX]    ; Load a character from .Name 2.
      INC EBX         ; Prepare pointer to the next character.
      INC EDX         ; Prepare pointer to the next character.
      PUSH EAX        ; First compare case-insensitively.
        OR AX,0x2020  ; Simplified conversion to lowercase.
        CMP AH,AL     ; Compare case-insensitive first (C-I).
      POP EAX         ; Restore case.
      JB .C5:         ; If the C-I order requires swapping.
      JA .C9:         ; If the C-I order is compliant, return with CF=0.
      CMP AH,AL       ; Otherwise compare case-sensitively (C-S).
      JB .C5:         ; If the C-S order requires swapping.
      JA .C9:         ; If the C-S order is compliant, return with CF=0.
      LOOP .C3:       ; If not decided yet, go check the next characters.
      ; The shorter part of the name matched exactly.
      MOV EBX,[ESI]   ; Pointer to the object 1.
      MOV EDX,[EDI]   ; Pointer to the object 2.
      MOV ECX,[EBX+4] ; Name 1 size.
      CMP [EDX+4],ECX ; Compare with Name 2 size.
      JB .C5:         ; If the order requires swapping.
      JA  .C9:        ; If the order is compliant, return with CF=0.
      ; Both objects have identical names. This happens only when sorting global symbols. Compare by scope.
      MOV EAX,[EBX+SYM.Status]
      MOV ECX,[EDX+SYM.Status]
      AND EAX,symScopeMask
      AND ECX,symScopeMask
      CMP ECX,EAX
      JAE .C9:        ; If the order is compliant, return with CF=0.
 .C5: MOV EAX,[ESI]   ; Object names are not in ascending order, swap them.
      XCHG EAX,[EDI]
      MOV [ESI],EAX
      STC             ; Signalize to the caller that objects were swapped.
 .C9:POP ECX,EBX
     RET
     ENDP1 .CmpObjNames

.90:EndProcedure EaBufferSort
</pre>

<dl id="EaBufferAlign">
<dt><a href="#top">&uarr; EaBufferAlign</a> Buffer, Alignment</dt>
<dd>EaBufferAlign keeps storing NULL bytes to Buffer until its contents size is aligned.</dd>
<dt>Input</dt>
<dd><b>Buffer</b> is a pointer to <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> to align.
<br/><b>Alignment</b> is required alignment. 0..1=no alignment, 2=WORD, 4=DWORD etc.
<br/>Forced to 0 when the Aligment is not a power of two.</dd>
<dt>Output</dt>
<dd><b>EAX=</b> number of NULL bytes stored to Buffer.</dd>
<dt>Error</dt>
<dd><b>-</b></dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="exp.htm#ExpAlign">ExpAlign</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pf.htm#PfDrectveCreate">PfDrectveCreate</a>
<a class="EXT" href="pfmz.htm#PfmzCompile">PfmzCompile</a>
<a class="EXT" href="pfpe.htm#PfpeBaserelocFixup">PfpeBaserelocFixup</a>
<a class="EXT" href="pfpe.htm#PfpeCompile">PfpeCompile</a>
<a class="EXT" href="pfpe.htm#PfpeImportCreate">PfpeImportCreate</a>
<a class="EXT" href="pfrsrc.htm#PfrsrcLoadIconFile">PfrsrcLoadIconFile</a>
<a class="EXT" href="pfrsrc.htm#PfrsrcLoadPgm">PfrsrcLoadPgm</a>
</dd>
</dl><pre>
EaBufferAlign Procedure Buffer, Alignment
     MOV EBX,[%Buffer]
     BufferRetrieve EBX
     Invoke ExpAlign::,ECX,[%Alignment],0
     MOV [%ReturnEAX],ECX                        ; Number of stored NULL bytes.
     XOR EDX,EDX
     CMP ECX,EDX
     JZ .90:
     SHR ECX,1
     JNC .20:
     BufferStoreByte EBX,EDX
.20: SHR ECX,1
     JNC .40:
     BufferStoreWord EBX,EDX
.40: JECXZ .90:
.50: BufferStoreDword EBX,EDX
     LOOP .50:
.90:EndProcedure EaBufferAlign
</pre>

<dl id="EaStreamAlign">
<dt><a href="#top">&uarr; EaStreamAlign</a> Stream, Alignment, Stuff</dt>
<dd><dfn>EaStreamAlign</dfn> keeps storing Stuff bytes to Stream until its contents size is aligned.</dd>
<dt>Input</dt>
<dd><b>Stream</b> is a pointer to <a class="EXT" href="../maclib/memory32.htm#STREAM">STREAM</a> to align.
<br/><b>Alignment</b> is required alignment. 0..1=no alignment, 2=WORD, 4=DWORD etc. 0 when the Aligment is not a power of two.
<br/><b>Stuff</b> is a DWORD value whose four bytes will be used as aligment stuff. Usually 0 or 0x90909090.</dd>
<dt>Output</dt>
<dd><b>EAX=</b> number of stuff bytes stored to Stream.</dd>
<dt>Error</dt>
<dd><b>-</b></dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="exp.htm#ExpAlign">ExpAlign</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfelf.htm#PfelfHdrsStream">PfelfHdrsStream</a>
<a class="EXT" href="pflibomf.htm#PflibomfCompile">PflibomfCompile</a>
</dd>
</dl><pre>
EaStreamAlign Procedure Stream, Alignment, Stuff
     MOV EBX,[%Stream]
     StreamGetSize EBX
     Invoke ExpAlign::,EAX,[%Alignment],0  ; Returns ECX=stuff size.
     MOV [%ReturnEAX],ECX                  ; Number of stored stuff bytes.
     JECXZ .90:                            ; Done when %Stream is already aligned.
     MOV EDX,[%Stuff]
     SHR ECX,1
     JNC .20:
     StreamStoreByte EBX,DL
.20: SHR ECX,1
     JNC .40:
     StreamStoreWord EBX,DX
.40: JECXZ .90:
.50: StreamStoreDword EBX,EDX
     LOOP .50:
.90:EndProcedure EaStreamAlign
</pre>

<dl id="EaId2Fs">
<dt><a href="#top">&uarr; EaId2Fs</a> IdNamePtr, IdNameSize, OutBuffer</dt>
<dd>EaId2Fs converts an &euro;ASM identifier to a string which can be used as filename.
<br/>Question mark <kbd>?</kbd> is replaced with underscore <kbd>_</kbd>.</dd>
<dt>Input</dt>
<dd><b>IdNamePtr</b> Pointer to identifier.
<br/><b>IdNameSize</b> Number of characters in the identifier.
<br/><b>OutBuffer</b> ^<a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> allocated by caller, where the filename will be written to.</dd>
<dt>Output</dt>
<dd>Result is written to OutBuffer.</dd>
<dt>Error</dt>
<dd><b>-</b></dd>
<dt>See also</dt>
<dd><a href="#EaFs2Id">EaFs2Id</a>.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pgmopt.htm#PgmoptSetDefaults">PgmoptSetDefaults</a>
</dd>
</dl><pre>
EaId2Fs Procedure IdNamePtr, IdNameSize, OutBuffer
    MOV ECX,[%IdNameSize]
    MOV ESI,[%IdNamePtr]
    JECXZ .90:
.10:LODSB
    CMP AL,'?'
    JNE .20:
    MOV AL,"_" ; Replace question mark with underscore.
.20:BufferStoreByte [%OutBuffer],EAX
    LOOP .10:
.90:EndProcedure EaId2Fs
</pre>

<dl id="EaFs2Id">
<dt><a href="#top">&uarr; EaFs2Id</a> FsNamePtr, FsNameSize, OutBuffer</dt>
<dd>EaFs2Id converts a name with filesystem-permitted characters to a valid &euro;ASM identifier.
<br/>Nonalphanumeric characters are replaced with underscore <kbd>_</kbd> and if the filename 
<!---->does not start with a letter, grave <kbd>`</kbd> is prefixed to the name.</dd>
<dt>Input</dt>
<dd><b>FsNamePtr</b> Pointer to file name.
<br/><b>FsNameSize</b> Number of characters in the name.
<br/><b>OutBuffer</b> ^<a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> allocated by caller, where the identifier will be written to.</dd>
<dt>Output</dt>
<dd>Result is written to OutBuffer.</dd>
<dt>Error</dt>
<dd><b>-</b></dd>
<dt>See also</dt>
<dd><a href="#EaId2Fs">EaId2Fs</a>.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfcoff.htm#PfcoffLoadPgm">PfcoffLoadPgm</a>
<a class="EXT" href="pfelf.htm#PfelfLoadPgm">PfelfLoadPgm</a>
<a class="EXT" href="src.htm#SrcCreate">SrcCreate</a>
</dd>
</dl><pre>
EaFs2Id Procedure FsNamePtr, FsNameSize, OutBuffer
    MOV ECX,[%FsNameSize]
    MOV ESI,[%FsNamePtr]
    MOV EDI,[%OutBuffer]
    JECXZ .90:
    LEA EDX,[ESI+ECX]
    ExpClassify [ESI]
    TEST AH,expLetter|expFullstop
    JNZ .30:                                     ; Go and store a valid character from AL.
    TEST AH,expDigit                             ; Test if the filename begins with a digit '0'..'9'.
    JZ .30:
    MOV AL,"`"                                   ; Prefix the digit with leading letter (grave).
.20:BufferStoreByte EDI,EAX
.30:CMP ESI,EDX
    JNB .90:
    LODSB
    ExpClassify AL
    TEST AH,expLetter|expDigit|expFullstop
    JNZ .40:
    MOV AL,"_"                                   ; Replace unacceptable character with underscore.
.40:BufferStoreByte EDI,EAX
    JMP .30:
.90:EndProcedure EaFs2Id
</pre>

<dl id="EaIniAssemble">
<dt><a href="#top">&uarr; EaIniAssemble</a> IniPtr, IniEnd, Eaopt, Pgmopt</dt>
<dd>EaIniAssemble will assemble contents of <q>euroasm.ini</q> file to EAOPT and PGMOPT structures.</dd>
<dt>Input</dt>
<dd><b>IniPtr</b> Pointer to the start of text of unassembled contents of
<q>euroasm.ini</q> mapped in memory.
<br/><b>IniEnd</b> Pointer to the end of text.
<br/><b>Eaopt</b> Pointer to the target <a class="EXT" href="eaopt.htm#EAOPT">EAOPT</a> object.
<br/><b>Pgmopt</b> Pointer to the target <a class="EXT" href="pgmopt.htm#PGMOPT">PGMOPT</a> object.</dd>
<dt>Output</dt>
<dd>EAOPT and PGMOPT are modified with assembled options.</dd>
<dt>Error</dt>
<dd>Warnings W3701,W3705,W3720,W3730 are reported with macro 
<a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="dict.htm#DictLookup">DictLookup</a>
<a class="EXT" href="eaopt.htm#EaoptAssemble">EaoptAssemble</a>
<a class="EXT" href="exp.htm#ExpParseKeyName">ExpParseKeyName</a>
<a class="EXT" href="exp.htm#ExpParseKeyValue">ExpParseKeyValue</a>
<a class="EXT" href="pgmopt.htm#PgmoptAssemble">PgmoptAssemble</a>
<a class="EXT" href="stm.htm#StmCreate">StmCreate</a>
<a class="EXT" href="stm.htm#StmDestroy">StmDestroy</a>
</dd>
<dt>Invoked by</dt>
<dd><a href="#EaCreate">EaCreate</a>
<a href="#EaIniGlobal">EaIniGlobal</a>
<a href="#EaMain">EaMain</a>
<a class="EXT" href="src.htm#SrcCreate">SrcCreate</a>
</dd>
</dl><pre>
EaIniAssemble Procedure IniPtr, IniEnd, Eaopt, Pgmopt
ErrPar       LocalVar Size=8                     ; Parameter for error message.
EaIniStm     LocalVar Size=SIZE#STM              ; Temporary fake statement to provide position of error in ini file.
      EaStackCheck
      RstSt [Ea.Status],eaIniSectEUROASM | eaIniSectPROGRAM
      LEA ESI,[%EaIniStm]
      Invoke StmCreate::,ESI
      PUSHD [Src.CurrentStm::]                   ; Save the current pointer to statement in source and
      MOV [Src.CurrentStm::],ESI                 ;   replace it with a temporary one.
.10:  MOV EDI,[%IniPtr]
      LEA ESI,[%EaIniStm]
      MOV [ESI+STM.LinePtr],EDI                  ; Provide the line position for error message.
      MOV ECX,[%IniEnd]
      MOV ESI,EDI
      MOV AL,10
      SUB ECX,EDI
      JNA .90:
      REPNE SCASB
      MOV [%IniPtr],EDI                          ; ESI..EDI is the current line. %IniPtr specifies the start of the next line.
      LEA EDX,[%ErrPar]
      MOV EAX,EDI
      SUB EAX,ESI
      StripSpaces ESI,EAX
      MOV [EDX+0],ESI                            ; Prepare error message parameter.
      MOV [EDX+4],EAX
      TEST EAX
      JZ .10:
      CMP ESI,EDI                                ; The line at ESI can be a comment, [EUROASM], [PROGRAM], or Identifier=value.
      JNB .10:                                   ; Skipt empty line.
      LODSB
      CMP AL,'['
      JNE .50:
      RstSt [Ea.Status],eaIniSectEUROASM + eaIniSectPROGRAM
      MOV EDX,ESI                                ; Start of section name.
.30:  CMP ESI,EDI
      JBE .40:
.W3701:LEA ECX,[%ErrPar]
      Msg '3701',ECX                             ; Unknown section "!1S" in "euroasm.ini" file.
      JMP .10:
.40:  LODSB
      CMP AL,']'
      JNE .30:
      LEA EBX,[ESI-1]                            ; End of section name.
      SUB EBX,EDX                                ; String EDX..EBX is section name (PROGRAM or EUROASM).
      StripSpaces EDX,EBX
      LEA ECX,[%ErrPar]
      MOV [ECX+0],EDX
      MOV [ECX+4],EBX
      Invoke DictLookup::, DictIniSect::, EDX,EBX
      JC .W3701:
      SetSt [Ea.Status],EAX                      ; EAX is eaIniSectEUROASM or eaIniSectPROGRAM.
      JMP .10:
.50:  CMP AL,';'
      JE .10:
      CMP AL,'#'                                 ; Comment line in <q>euroasm.ini</q> may begin with <kbd>;</kbd> or <kbd>#</kbd>.
      JE .10:
      LEA EDX,[ESI-1]                            ; EDX points to "ident= value".
      Invoke ExpParseKeyName::,EDX,EDI           ; Returns EAX behind the equal sign.
      JNC .60:
.W3705:LEA ECX,[%ErrPar]
      Msg '3705',ECX                             ; Unexpected text "!1S" in "euroasm.ini" file.
      JMP .10:
.60:  Invoke ExpParseKeyValue::,EAX,EDI          ; Returns ESI,ECX value string.
      JC .W3705:
      DEC EAX
      SUB EAX,EDX                                ; EDX,EAX is now key name. ESI,ECX is key value.
      JSt [Ea.Status],eaIniSectEUROASM, .70:
      JSt [Ea.Status],eaIniSectPROGRAM, .80:
      LEA ECX,[%ErrPar]
      Msg '3710',ECX                             ; Option "!1S" is in undefined section of "euroasm.ini" file.
      JMP .10:
.70:  Invoke EaoptAssemble::,[%Eaopt],EDX,EAX,ESI,ECX
      JMP .10:                                   ; The next line.
.80:  Invoke DictLookup::, DictPgmopt::, EDX,EAX
      LEA EDX,[%ErrPar]
      Msg cc=C,'3730',EDX                        ; "!1S" is unknown option in [PROGRAM] section.
      JC .10:
      Invoke PgmoptAssemble::, [%Pgmopt],EAX,ESI,ECX,
      JMP .10:
.90:  LEA ESI,[%EaIniStm]
      Invoke StmDestroy::,ESI
      POPD [Src.CurrentStm::]                    ; Restore the current statement in source.
    EndProcedure EaIniAssemble
</pre>

<dl id="EaIniGlobal">
<dt><a href="#top">&uarr; EaIniGlobal</a></dt>
<dd>EaIniGlobal will update Ea.Eaopt from global <q>euroasm.ini</q>
<!---->and create this file if it didn't exist.
<br>Global <q>euroasm.ini</q> has a fixed name <code>%AppData%\eurotool\euroasm.ini</code> in MS Windows, or
<code>/etc/eurotool/euroasm.ini</code> in Linux.</dd>
<dt>Input</dt>
<dd>-</dd>
<dt>Output</dt>
<dd><b>CF=</b>0  Ea.Eaopt updated, copied to Ea.EaoptIni. Global file created.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invokes</dt>
<dd><a href="#EaBufferRelease">EaBufferRelease</a>
<a href="#EaBufferReserve">EaBufferReserve</a>
<a href="#EaIniAssemble">EaIniAssemble</a>
</dd>
<dt>Invoked by</dt>
<dd><a href="#EaMain">EaMain</a>
</dd>
</dl><pre>
EaIniGlobal Procedure
    Invoke EaBufferReserve::,%^PROC
    MOV EBX,EAX                                  ; Temporary buffer for the name of configuration file.
    %IF "%eaos" === "win"
      SysGetEnvironment =B"AppData",7,EBX
      BufferStore EBX,=B"\eurotool\euroasm.ini",22
    %ELSE
      BufferStore EBX,=B"/etc/eurotool/euroasm.ini",26
    %ENDIF
    BufferRetrieve EBX
    Invoke EaBufferRelease::,EBX
    MOV EBX,ESI
    SysMkDir Ea.IniFile
    SysOpenFileMap Ea.IniFile,EBX                ; Open the file with name in EBX.
    JC .50:
    Msg '0070',EBX                               ; Assembling global option file "!1$".
    ADD EAX,ESI
    Invoke EaIniAssemble,ESI,EAX, Ea.Eaopt, Ea.Pgmopt
    SysCloseFile Ea.IniFile
    JMP   .70:
.50:SysCreateFile Ea.IniFile,EBX                 ; Global euroasm.ini was not found, lets try to create it.
    JC .60:
    MOV ESI,EaIniFileDefault                     ; Factory-default.
    MOV ECX,EaIniFileDefaultEnd
    MOV EBX,Ea.IniFile
    SUB ECX,ESI
    SysWriteFile EBX,ESI,ECX                     ; Returns CF if the creation of global "euroasm.ini" failed.
    LEA EBX,[EBX+FILE.Name]
    Msg cc=NC,'0050',EBX                         ; Global option file "!1$" was created.
.60:Msg cc=C, '0060',EBX                         ; Global option file "!1$" could not be created.
    SysCloseFile Ea.IniFile
.70:CopyTo Ea.EaoptIni,Ea.Eaopt,Size=SIZE#EAOPT
   EndProcedure EaIniGlobal
</pre>

<pre>; The following are ad hoc debug subprograms. Not to be released.
</pre>

<dl id="EaDisplayPosition">
<dt>&uarr; <a href="#top">EaDisplayPosition</a> ProcName$Ptr, SourceName$Ptr, SourceLineNr</dt>
<dd>Diagnostic runtime procedure for debugging of EuroAssembler itself. It will be assembled
<!---->only when <code>EUROASM DEBUG=ENABLED</code>.</dd>
<dt>Input</dt>
<dd><b>ProcName$Ptr</b> is pointer to ASCIIZ name of current procedure where the procedure
<!---->EaDisplayPosition was invoked. Use literal <code>=B"%^Proc"</code> at invocation.
<br/><b>SourceName$Ptr</b> is pointer to ASCIIZ filename of source where the procedure
<!---->EaDisplayPosition was invoked. Use literal <code>=B"%^SourceName"</code> at invocation.
<br/><b>SourceLineNr</b> is physical line number of source where the procedure
<!---->EaDisplayPosition was invoked. Use <code>%^SourceLine"</code> at invocation.</dd>
<dt>Example</dt><dd class="PRE"><code> Invoke EaDisplayPosition::, =B"%^Proc", =B"%^SourceName", %^SourceLine</code></dd>
</dl><pre>
EaDisplayPosition Procedure ProcName$Ptr,SourceName$Ptr,SourceLineNr
   Msg '1900',[%ProcName$Ptr],[%SourceName$Ptr],[%SourceLineNr] ; Position "!1$" at "!2$"{!3D}
  EndProcedure EaDisplayPosition
</pre>

<dl id="EaDisplayPgm">
<dt>&uarr; <a href="#top">EaDisplayPgm</a> Pgm, SourceName$Ptr, SourceLineNr</dt>
<dd>Diagnostic runtime procedure for debugging of EuroAssembler itself. It will be assembled
<!---->only when <code>EUROASM DEBUG=ENABLED</code>.</dd>
<dt>Input</dt>
<dd><b>Pgm</b> is pointer to the displayed program.
<br/><b>SourceName$Ptr</b> is pointer to ASCIIZ filename of source where was the procedure
<!---->EaDisplayPgm invoked. Use literal <code>=B"%^SourceName"</code> at invocation.
<br/><b>SourceLineNr</b> is physical line number of source where was the procedure
<!---->EaDisplayPgm invoked. Use <code>%^SourceLine"</code> at invocation.</dd>
<dt>Example</dt><dd class="PRE"><code> Invoke EaDisplayPgm::, EBX, =B"%^SourceName", %^SourceLine</code></dd>
</dl><pre>
DebugInternal %IF %^DEBUG  ; Internal EuroAssembler debugging.
EaDisplayPgm Procedure Pgm  ,SourceName$Ptr,SourceLineNr ; Display program objects PGM,SYM,SSS,RELOC.
RelocTop LocalVar          ; End of RELOC array in current segment.
SssRange LocalVar Size=44  ; Va000000..FFFFFF(0123),Fa000000,Rva000000
                           ; 0....5...10...15...20...25...30...35...40..
    Msg '1000' ; Separator.
    MOV EBX,[%Pgm]
       ; 1920 PGM^!1H:St=!2H, base program ******** !3S ********   EaDisplayPgm at "!4$"{!5D}',0
    Msg '1920',EBX,[EBX+PGM.Status],EBX,[%SourceName$Ptr],[%SourceLineNr] ; Display the <b>base program</b> EBX.
    CALL .PgmDisplay:
    ListGetFirst [EBX+PGM.ModulePgmList]
    JZ .90:
.10:MOV EBX,EAX
       ; 1921 PGM^!1H:St=!2H,module **** !3S ****',0
    Msg '1921',EBX,[EBX+PGM.Status],EBX ; Display the <b>module program</b> EBX.
    CALL .PgmDisplay:
    ListGetNext EBX
    JNZ .10:
.90:EndProcedure EaDisplayPgm

EaDisplayPgm.PgmDisplay PROC ; Display program EBX.
    ListGetFirst [EBX+PGM.SymList]
    JZ .30:
.20:MOV ESI,[EAX+SYM.Section]                    ; Display the <b>symbol</b> EAX.
    MOV ECX,[EAX+SYM.Status]
    MOV DL,'X'
    JSt ECX,symExport,.25:
    MOV DL,'P'
    JSt ECX,symPublic,.25:
    MOV DL,'I'
    JSt ECX,symImport,.25:
    MOV DL,'E'
    JSt ECX,symExtern,.25:
    MOV DL,'G'
    JSt ECX,symGlobal | symGlobalRef,.25:
    MOV DL,'S'
.25:; LEA ECX,[EAX+SYM.DllNamePtr]
    MOV CL,[EAX+SYM.NameDynIndex]
    MOV CH,[EAX+SYM.NameIndex]
       ; 1922  SYM^!1H:Sc''!2Z'',St!3H,Se!4H,Sy!5H,Di!6W,!7S,[!8S]:!9H
    Msg '1922',EAX,EDX,[EAX+SYM.Status],ESI,[EAX+SYM.SymbPtr],ECX,EAX,ESI,[EAX+SYM.OffsetLow]
    ListGetNext EAX
    JNZ .20:                                     ; The next symbol.
.30:LEA EDI,[%SssRange]                          ; Preformat %SssRange.
    MOVW [EDI+00],'Va'
    MOVW [EDI+08],'..'
    MOVB [EDI+16],'('
    MOVD [EDI+21],'),Fa'
    MOVD [EDI+31],',Sva'
    MOVB [EDI+41],0
    ListGetFirst [EBX+PGM.SssList]
    JZ .80:
.40:PUSH EAX                                     ; Display the <b>SSS object</b> EAX.
      MOV ESI,EAX                                ; Prepare D1923 Bottom..Top(size),Fa in %SssRange.
      MOV EAX,[ESI+SSS.BottomLow]
      LEA EDI,[%SssRange+02]
      StoH EDI,Size=6
      MOV EAX,[ESI+SSS.TopLow]
      LEA EDI,[%SssRange+10]
      StoH EDI,Size=6
      MOV EAX,[ESI+SSS.TopLow]
      MOV EDX,[ESI+SSS.TopHigh]
      SUB EAX,[ESI+SSS.BottomLow]
      SBB EDX,[ESI+SSS.BottomHigh]
      LEA EDI,[%SssRange+17]
      StoH EDI,Size=4
      MOV EAX,[ESI+SSS.BottomFA]
      LEA EDI,[%SssRange+25]
      StoH EDI,Size=6
      LEA EDI,[%SssRange+35]
      MOV EAX,[ESI+SSS.SVA]
      StoH EDI,Size=6
    POP EAX
    LEA EDI,[%SssRange]
      ; '1923  SSS^!1H:St!2H,!3$,Sy!4H,Ni!5D,Si!6D,Sg!7H,Gr!8H',[!9S]
    Msg '1923',EAX,[EAX+SSS.Status],EDI,[EAX+SSS.SymPtr],[EAX+SSS.NameIndex],\
                  [EAX+SSS.SegmIndex],[EAX+SSS.SegmPtr],[EAX+SSS.GroupPtr],EAX
    BufferRetrieve [EAX+SSS.RelocBuffer]         ; Display <b>RELOC objects</b> of the segment EAX.
    LEA EDX,[ESI+ECX]
    MOV [%RelocTop],EDX
.50:CMP ESI,[%RelocTop]
    JNB .75:
    MOV EDX,ESI
    BufferRetrieve [EAX+SSS.EmitBuffer]          ; ESI,ECX=emitted contents.
    XCHG EDX,ESI                                 ; Restore ESI=^RELOC, EDX=^1st emitted byte.
    ADD EDX,[ESI+RELOC.OrgLow]
    MOV EDI,[EDX]                                ; EDI=relocated storage unit in emitted data (WORD|DWORD).
    MOV ECX,[ESI+RELOC.Status]
 type %FOR Para,AbsVA,AbsRVA,Rel,Far,Sym,Dyn,PLT,GOT,GOToff,GOTrel
         LEA EDX,[=B"%type"]
         JSt ECX,reloc%type,.60:
      %ENDFOR type
         LEA EDX,[=B"None"]
.60:JNSt ECX,relocWidth16,.65:
       ; RELOC^!1H:St!2H,Org!3H:!4H,Ad=!5H,Ob=!6W,Sym:!7H,!8S:!9$
    Msg '1924',ESI,[ESI+RELOC.Status],[ESI+RELOC.Section],[ESI+RELOC.OrgLow], \ 16bit
         [ESI+RELOC.AddendLow],EDI,[ESI+RELOC.Symbol],[ESI+RELOC.Symbol],EDX
    JMP .70:
.65:   ; RELOC^!1H:St!2H,Org!3H:!4H,Ad=!5H,Ob=!6H,Sym:!7H,!8S:!9$
    Msg '1925',ESI,[ESI+RELOC.Status],[ESI+RELOC.Section],[ESI+RELOC.OrgLow], \ 32bit
         [ESI+RELOC.AddendLow],EDI,[ESI+RELOC.Symbol],[ESI+RELOC.Symbol],EDX
.70:ADD ESI,SIZE# RELOC
    JMP .50:                                     ; The next RELOC.
.75:ListGetNext EAX
    JNZ .40:                                     ; The next SSS object.
.80:RET
   ENDPROC EaDisplayPgm.PgmDisplay:


EaPoolDisplay:: Procedure aPool,LinePtr ; Display <a class="EXT" href="../maclib/memory32.htm#POOL">pool</a> blocks.
    MOV EAX,[%LinePtr]
; 1912 Allocated memory pool at source line {!1D}:
    Msg '1912',EAX
    MOV EBX,[%aPool]
    SUB ECX,ECX
    MOV ESI,[EBX+POOL.Last]
.10:TEST ESI
    JZ .20:
    ADD ECX,[ESI]
    MOV ESI,[ESI+4]
    JMP .10:
.20:
; 1913 Pool=!1H, Gran=!2K, Total=!3H=!3K, Size=!4H=!4K
   Msg '1913',EBX,[EBX+POOL.Gran],ECX,[EBX-8]
   MOV EAX,[EBX-8]
   LEA EAX,[EBX+EAX-8]
; 1914 Pool.Prev=!1H, Last=!2H, Ptr=!3H, Top=!4H.
   Msg '1914',[EBX-4],[EBX+POOL.Last],[EBX+POOL.Ptr],EAX
   MOV EAX,[EBX+POOL.Last]
.50:TEST EAX
   JZ .90:
   MOV ESI,[EAX]   ; Size.
   LEA EDI,[EAX+4] ; Prev.
   LEA EDX,[EAX+4+ECX]
; 1915   Poolblock=!1H, Prev=!2H, bottom=!3H, top=!4H.
   Msg '1915',EAX,ESI,EDI,EDX
   MOV EAX,ESI
   JMP .50:
 .90:
   EndProcedure EaPoolDisplay
 %ENDIF DebugInternal
</pre>

<dl><dt id="atRTprocedures"><a href="#top">&uarr; @RTprocedures</a></dt>
<dd><p>Semiinline macros hired in EuroAssembler are for the first time dummy-expanded
<!---->here in the module <q>ea.htm</q>. Their @RTprocedures are declared as PUBLIC
<!---->in this module and they are declared as EXTERN in all other modules.</p>
<p>This prevents the runtime code from being repeatedly emitted
<!---->in each separately assembled module, which would unnecessarily blow up the final PE size.</p></dd>
<dt>See also</dt><dd><a class="EXT" href="euroasm.htm#ScopeSelection">%@RTprocedureList</a>.</dd></dl><pre>
   ; Dummy expansion of semiinline macros creates their runtime procedures here.
   BufferCreate 0,0,0
   BufferNew 0,0
   BufferResize 0,0,0
   BufferStore  0,0,0
   BufferStoreByte 0,0
   BufferStoreDword 0,0
   BufferStorePascalString 0,0
   BufferStoreQword 0,0
   BufferStoreWord 0,0
   Clear 0
   Compare 0,0,0
   CopyTo 0,0
   FileAssign 0,0
   FileClose 0
   FileCreate 0
   FileEach 0,0
   FileMapOpen 0
   FileMkDir 0
   FileNameParse 0
   FileWrite 0
   GetArg 0
   GetLength$ 0
   IiAbort 0
   IiAbortIfNotST0
   IiAllowLocking Operand1
   IiDataSize Operand1
   IiDispatchFormat
   IiDispatchLocation 0
   IiDispSize Operand1
   IiEmitImm Operand1,BYTE
   IiEmitImm2 Operand1
   IiEmitOpcode
   IiImmSize Operand1
   IiStringDestination Operand1
   IiStringSource Operand1
   ListCreate 0,0
   ListInsert 0,0,0
   ListNew 0
   ListRemove 0,0
   ListStore 0,0
   LodD
   PoolCreate Size=%EaPoolSize
   PoolDestroy 0
   PoolNew 0,0
   ShellSort 0,0,0,0
   StackCreate 0,0
   StackPush 0,0
   StoD
   StoH Align=left
   StoQD Align=left
   StreamCreate 0
   StreamDump 0,0
   StreamStore 0,
   SysGetFileSize 0
   SysGetFileTime 0
   SysGetEnvironment 0,0,0
</pre>

<pre>
 ENDPROGRAM ea
</pre><!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
