<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='mac.htm source file'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>mac.htm source file</title>
</head>
<body class='EASOURCE' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>mac.htm
<br/><i>Class</i>
<br/><a href="#MAC">MAC</a>
<br/><i>Encodings</i>
<br/><a href="#MacEnc">MacEnc</a>
<br/><i>Procedures</i>
<br/><a href="#MacCtxUpdate">MacCtxUpdate</a>
<br/><a href="#MacExpand">MaxExpand</a>
<br/><a href="#MacFind">MacFind</a>
<br/><a href="#MacListMerge">MacListMerge</a>
<br/><a href="#MacPrototype">MacPrototype</a>
</h1>
<p>Object MAC represents one macroinstruction.
<br/>Mac objects (macro definitions) are kept on PASS.MacList.
<br/>MacList is empty in the beginning of each pass. 
<br/>Macros defined in program pass are merged with parent program's macros when the last pass terminates.
<!---->Scope of macros and %variables begins with their definition and ends at the end of source.</p>
<p>When a macro is invoked (expanded), its arguments are stored to context,
<!---->and assembly is redirected to the macro prototype (%MACRO statement of invoked macro).
<!---->Assembly returns below the macro invocation when the coresponding %ENDMACRO has been assembled.</p>
<br class="CLEAR"/>
<dl id="MacObj"><dt>Macro expansion  <a class="EXT" href="index.htm#DOM">object model</a></dt>
<dd class="PRE"><kbd> SampleMacro %MACRO Ord1,Ord2,Ord3,Key1=Key1Val,Key2=Key2Val</kbd> ; Macro prototype statement.
               <kbd>; Body of SampleMacro goes here.</kbd>
            <kbd>%ENDMACRO SampleMacro</kbd>
<!---->
<!---->Macro definition above is parsed and ignored in <a class="EXT" href="ctx.htm#CtxEnc">ctxDefinition</a>, reference to prototype is saved to PASS.Maclist.
<!---->
<kbd> SampleLabel: SampleMacro Ord1Val,Ord2Val,,,Ord5Val,Key2=NewKey2Val,Key3=NewKey3Val</kbd>
<!---->
<!---->Macro invocation above is parsed, assembly context is redirected to the line where was the SampleMacro defined.
<!---->Prototype in ctxExpansion is parsed to Stm by <a class="EXT" href="./stm.htm#StmParse">StmParse</a>:
<!---->  Stm.OrdBuffer: Ord1,Ord2,Ord3
<!---->  Stm.KeyBuffer: Key1=Key1Val,Key2=Key2Val
<!---->
<!---->Parsed macro invocation is stored to the context object by <a href="#MacExpand">MacExpand</a > &gt;<a href="#MacCtxUpdate">MacCtxUpdate</a>:
<!---->  Ctx.ObjBuffer: SampleLabel,SampleMacro
<!---->  Ctx.OrdBuffer: Ord1Val,Ord2Val,,,Ord5Val
<!---->  Ctx.KeyBuffer: Key2=NewKey2Val,Key3=NewKey3Val ; Warn undeclared keyword Key3=
<!---->
<a href="#MacPrototype">MacPrototype</a> merges operands of invokation with operands of prototype:
<!---->  Ctx.FrmBuffer: Ord1=Ord1Val,Ord2=Ord2Val,Ord3=,=,=Ord5Val,Key1=Val1,Key2=NewKey2Val
<!---->
<!---->Values of automatic macro variables will be %set on demand in <a class="EXT" href="./var.htm#VarExpand">VarExpand</a>
<!---->  as if the following statements were virtually performed:
<!----> %:    %SET  SampleLabel ; Label actually used at invocation.
<!----> %*    %SET  Ord1Val,Ord2Val,,,Ord5Val ; Ordinals actually used at invocation.
<!----> %#    %SETA 5 ; Five ordinals actually used at invocation, though two of them are empty.
<!----> %=*   %SET  Key2=NewKey2Val,Key3=NewKey3Val
<!----> %=#   %SETA 2 ; Two keywords are actually used at invocation, though Key3= is undeclared and ignored.
<!----> %0    %SET SampleMacro ; 0th operand is the macro name.
<!----> %1    %SET Ord1Val ; The value used on macro invocation as 1st operand.
<!----> %3    %SET ; Empty, as no 3rd operand was used on macro invocation.
<!----> %5    %SET Ord5Val ; 5th operand used on macro invocation (though it was not explicitly declared in protoype).
<!----> %Key1 %SET Key1Val ; As Key1 wasn't mentioned in macro invocation, default from prototype is used.
<!----> %Key2 %SET NewKey2Val ; Default from prototype is rewritten with new value specified in macro invocation.
<!----> %Key3 %SET ; Empty because this keyword was not declared in prototype.
<!---->
<!---->When %ENDMACRO is encountered in ctxExpansion, assembly returns back just below the macro invokation statement
<!----> and ctxMACRO+ctxExpansion is discarded.
</dd></dl>
<pre>
mac PROGRAM FORMAT=COFF,MODEL=FLAT,WIDTH=32
    INCLUDEHEAD euroasm.htm, \  Interface (structures, symbols and macros) of other modules used in this source.
     ctx.htm,ea.htm,eaopt.htm,exp.htm,msg.htm,pass.htm,pgm.htm,pgmopt.htm,stm.htm
</pre><pre>
  mac HEAD ; Start of module interface.
</pre>

<dl id="MAC"><dt><a href="#top">&uarr; MAC</a></dt>
<dd>Object of this class represents a defined macro. 
</dd></dl><pre>
MAC STRUC
.NamePtr  D D ; Pointer to macro name.
.NameSize D D ; Size of macro name.
.LinePtr  D D ; Pointer to the first physical line of %MACRO statement (definition of the macro) or 0 when the macro was dropped.
.Status   D D ; Macro properties.
  ENDSTRUC MAC
</pre>
<dl id="MacEnc"><dt><a href="#top">&uarr; MacEnc</a></dt>
<dd>Encoding of flags used in MAC.Status.</dd></dl><pre>
macLabeled  = 0x00000001 ; Formal label %: occured at least once in some statement of macro definition.
</pre><pre>
  ENDHEAD mac ; End of module interface.
</pre>

<dl id="MacExpand">
<dt><a href="#top">&uarr; MacExpand</a> Stm</dt>
<dd>MaxExpand is statement handler for macroinstructions. Name of the macro is in
<code>Stm.OperationPtr/Size</code>.
<br/><code>Stm.OperationData</code> contains pointer to <a href="#MAC">MAC</a> object
<!---->and MAC.LinePtr points to the corresponding %MACRO statement with macro definition.
<br/>MacExpand creates <a class="EXT" href="ctx.htm#CTX">context</a> ctxMACRO+ctxExpansion.</dd>
<dt>Input</dt>
<dd><b>Stm</b> is pointer to the parsed STM statement.</dd>
<dt>Output</dt>
<dd>Context stack modified, prototype prepared.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ctx.htm#CtxCreate">CtxCreate</a>
<a href="#MacCtxUpdate">MacCtxUpdate</a>
<a class="EXT" href="stm.htm#StmCheckFields">StmCheckFields</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="stm.htm#StmExecute">StmExecute</a>
</dd>
</dl><pre>
[.text]
MacExpand Procedure Stm
     MOV EBX,[%Stm]
     Invoke StmCheckFields::,EBX,"*0**"
     StackPush [Src.CtxStack::],0
     LEA ECX,[EBX+STM.OperationPtr]
     Msg cc=C,'9312',ECX ; Allocation error expanding macro !1S.
     MOV ECX,ctxMACRO+ctxExpansion+ctxExpandable+ctxFormal+ctxPrototype
     ; Examine listing status.
     JNSt [Ea.Eaopt.Status::],eaoptLIST,.50:
     JNSt [Ea.Eaopt.Status::],eaoptLISTMACRO,.50:
     ; Indicate that macroexpansion should be +listed
     ; even when the macro is defined in included file and LISTINCLUDE=OFF:
     SetSt ECX,ctxMacExpList
 .50:Invoke CtxCreate::,EAX,ECX,EBX
     Invoke MacCtxUpdate,EAX,EBX       ; Copy macro operands to context buffers.
     MOV ECX,[EBX+STM.OperationData]   ; Pointer to MAC object with macro declaration.
     MOV EAX,[ECX+MAC.LinePtr]
     MOV [EBX+STM.LineNext],EAX        ; Continue assembly with macro prototype statement.
     MOVD [EBX+STM.ChunkNext],0
 .90:EndProcedure MacExpand
</pre>

<dl id="MacCtxUpdate">
<dt><a href="#top">&uarr; MacCtxUpdate</a> CtxPtr, StmPtr</dt>
<dd>Procedure <dfn>MacCtxUpdate</dfn> will copy macroinstruction operands from parsed statement (where they have limited lifetime)
<!---->to buffers from <a class="EXT" href="ctx.htm#CTX">CTX</a> object in order to
<!---->persistently store operand names and values until the macro is completely expanded
<!---->and %MACRO..%ENDMACRO block abandoned.</dd>
<dt>Input</dt>
<dd><b>CtxPtr</b> Pointer to <a class="EXT" href="ctx.htm#CTX">CTX</a> already created with
    <a class="EXT" href="./ctx.htm#CtxCreate">CtxCreate</a>.
<br/><b>StmPtr</b> Pointer to the parsed statement with macroinstruction.</dd>
<dt>Output</dt>
<dd>Context is updated, CTX.OrdBuffer and CTX.KeyBuffer filled, CTX.ValBuffer is used as persistent storage.
<!----> CTX.FrmBuffer is reserved but empty.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>See also</dt>
<dd><a href="#MacPrototype">MacPrototype</a>.</dd>
<dt>Invoked by</dt>
<dd><a href="#MacExpand">MacExpand</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t7215.htm">t7215</a>
</dd>
</dl><pre>
MacCtxUpdate Procedure CtxPtr, StmPtr
McuPassPool LocalVar ; Current program pass pool.
     MOV EBX,[%StmPtr]
     MOV EDX,[%CtxPtr]
     MOV EAX,[EBX+STM.Program]
     MOV ECX,[EAX+PGM.PassPtr]
     TEST ECX
     JNZ .05:
.F9312:LEA ECX,[EBX+STM.OperationPtr]
     Msg '9312',ECX ; Allocation error expanding macro !1S.
     STC
     JMP .90:
.05: MOV EAX,[ECX+PASS.Pool]
     TEST EAX
     MsgUnexpected cc=Z
     MOV [%McuPassPool],EAX
     MOV EAX,[EBX+STM.LineEnd] ; LinePtr to the statement which follows macro invocation.
     MOV EDI,[EBX+STM.ChunkPtr]
     SUB ECX,ECX
     MOV [EDX+CTX.LineNext],EAX ; Where to continue when the expansion is over.
     MOV [EDX+CTX.ChunkNext],EDI
     MOV [EDX+CTX.Shift],ECX
     ; Update context with MacPtr from statement and copy flag <code>MAC.Status:macLabeled</code> to <code>CTX.Status:ctxMacLabeled</code>
     ; in order to to indicate whether <kbd>%:</kbd> should be expanded implicitly.
     MOV ESI,[EBX+STM.OperationData] ; In case of macroinstruction it is ^MAC.
     MOV [EDX+CTX.MacPtr],ESI
     JNSt [ESI+MAC.Status],macLabeled,.10:
     SetSt [EDX+CTX.Status],ctxMacLabeled
.10: BufferRetrieve [EBX+STM.OrdBuffer] ; <b>Copy ordinal operands from invocation to context.OrdBuffer</b>.
     ; ESI,ECX is QWORDs (Ptr,Size) for each ordinal used in macro invocation. ECX is 0,8,16,24,...
     ; However their lifetime is limited to StmFlush.
     BufferStore [EDX+CTX.OrdBuffer],ESI,ECX
     JC .F9312:
     BufferRetrieve [EDX+CTX.OrdBuffer]
     ; Ordinal lifetime will be prolonged to the end of macroexpansion.
     JECXZ .30: ; All ordinals copied. 
.20: PoolStore [%McuPassPool],[ESI+0],[ESI+4] ; Make the ordinal value persistent till end of pass.
     JC .F9312:
     MOV [ESI+0],EAX
     ADD ESI,8
     SUB ECX,8
     JA .20: ; Next ordinal.
.30: BufferRetrieve [EBX+STM.KeyBuffer] ; <b>Copy keyword operands from invocation to context.KeyBuffer</b>.
     BufferStore [EDX+CTX.KeyBuffer],ESI,ECX
     JC .F9312:
     BufferRetrieve [EDX+CTX.KeyBuffer]
     ; ESI,ECX is four DWORDs (NamePtr,NameSize,ValPtr,ValSize) for each keyword used in macro invocation.
     ; Keywords will be made persistent to the end of expansion.
     JECXZ .50: ; All keywords copied.  ECX was 0,16,32,... 
.40: PoolStore [%McuPassPool],[ESI+0],[ESI+4] ; Make the keyword name persistent.
     JC .F9312:
     MOV [ESI+0],EAX
     PoolStore [%McuPassPool],[ESI+8],[ESI+12] ; Make the keyword value persistent.
     JC .F9312:
     MOV [ESI+8],EAX
     ADD ESI,16
     SUB ECX,16
     JG .40: ; Next keyword. 
.50: BufferNew [EDX+CTX.ObjBuffer],SIZE# CTX_MAC
     JC .F9312:
     MOV EDI,EAX ; ^<a class="EXT" href="ctx.htm#CTX_MAC">CTX_MAC</a> in CTX.ObjBuffer.
     MOV ESI,[EBX+STM.LabelPtr]
     MOV ECX,[EBX+STM.LabelSize]
     PoolStore [%McuPassPool],ESI,ECX
     JC .F9312:
 ; <b>Copy misc info from invocation to context.ObjBuffer</b> in the format <a class="EXT" href="ctx.htm#CTX_MAC">CTX_MAC</a>.
     MOV [EDI+CTX_MAC.LabelPtr],EAX   ; Label of macro invokation.
     MOV [EDI+CTX_MAC.LabelSize],ECX
     MOV ESI,[EBX+STM.OperationPtr]
     MOV ECX,[EBX+STM.OperationSize]
     PoolStore [%McuPassPool],ESI,ECX ; Make macroname persistent (it may be used to expand %0).
     JC .F9312:
     MOV [EDI+CTX_MAC.MacroNamePtr],EAX
     MOV [EDI+CTX_MAC.MacroNameSize],ECX
     MOV EAX,[EBX+STM.OperationData]
     MOV [EDI+CTX_MAC.ProtoLinePtr],EAX ; LinePtr to %MACRO prototype in source.
     MOV EAX,[EBX+STM.Status]
     MOV [EDI+CTX_MAC.InvokStmStatus],EAX ; STM.Status of macro invocation.
.90:EndProcedure MacCtxUpdate
</pre>

<dl id="MacPrototype">
<dt><a href="#top">&uarr; MacPrototype</a> CtxPtr, StmPtr</dt>
<dd>MacPrototype will merge operands of macroinstruction invocation with operands
<!---->of %MACRO prototype and prepare formal %variables in CTX.FrmBuffer.</dd>
<dt>Input</dt>
<dd><b>CtxPtr</b> Ptr to <a class="EXT" href="ctx.htm#CTX">CTX</a> which was pushed on invocation
<!---->of the macro with its actual operands in ObjBuffer,OrdBuffer,KeyBuffer.
<br/><b>StmPtr</b> Ptr to parsed <a class="EXT" href="./stm.htm#STM">STM</a> with 
<!---->prototype %MACRO statement which yields the default keyword values
<!---->and formal names of all operands in its .OrdBuffer and .KeyBuffer.</dd>
<dt>Output</dt>
<dd>FrmBuffer in CTX object will be updated with actual operands.
<!---->They will be used later to dynamically construct special macro %variables (%*,%#,%1 etc).</dd>
<dt>Error</dt>
<dd>Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>See also</dt>
<dd><a href="#MacCtxUpdate">MacCtxUpdate</a>.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pseudo.htm#PseudopcMACRO">PseudopcMACRO</a>
</dd>
</dl><pre>
MacPrototype Procedure CtxPtr, StmPtr
MpPassPool LocalVar
FrmVar     LocalVar Size=16 ; VarNamePtr,VarNameSize,VarValuePtr,VarValueSize
FrmMax     LocalVar ; Greater of ordinals length in STM.OrdBuffer and CTX.OrdBuffer. 0,8,16,,,
FrmNdx     LocalVar ; 0,8,16,...FrmMax-8
     MOV EBX,[%StmPtr] ; Statement with %MACRO (prototype).
     MOV EDX,[%CtxPtr] ; Context with invocation operands.
     MOV EAX,[EBX+STM.Program]
     MOV ECX,[EAX+PGM.PassPtr]
     TEST ECX
     JZ .F9312:
     MOV EAX,[ECX+PASS.Pool]
     TEST EAX
     JZ .F9312:
     MOV [%MpPassPool],EAX
     ; <b>Merge ordinal operands</b>.
     BufferRetrieve [EBX+STM.OrdBuffer]
     MOV [%FrmMax],ECX
     BufferRetrieve [EDX+CTX.OrdBuffer]
     CMP ECX,[%FrmMax]
     JBE .10:
     MOV [%FrmMax],ECX
 .10:SUB ECX,ECX
     MOV [%FrmNdx],ECX ; Start with the 1st ordinal.
 .20:LEA EDI,[%FrmVar] ; Loop .20: .. .50: ordinal operands.
     SUB EAX,EAX
     MOV ECX,4
     REP STOSD ; Clear FrmVar.
     MOV EDI,[%FrmNdx]
     CMP EDI,[%FrmMax]
     JNB .50:
     BufferRetrieve [EBX+STM.OrdBuffer]
     CMP EDI,ECX
     JNB .30:
     ; Make ordinal name persistent to the end of macro expansion.
     MOV ECX,[EDI+ESI+4]
     MOV ESI,[EDI+ESI+0]
     PoolStore [%MpPassPool],ESI,ECX
     JC .F9312:
     MOV [%FrmVar+0],EAX ; Persistent ordinal name ptr.
     MOV [%FrmVar+4],ECX ; Ordinal name size (may be 0 when the ordinal is unnamed).
 .30:BufferRetrieve [EDX+CTX.OrdBuffer]
     CMP EDI,ECX
     JNB .40:
     MOV ECX,[EDI+ESI+4] ; Ordinal value size.
     MOV ESI,[EDI+ESI+0] ; ValuePtr. It's already been made persistent in MacCtxUpdate.
     MOV [%FrmVar+8],ESI 
     MOV [%FrmVar+12],ECX
 .40:LEA ESI,[%FrmVar]
     BufferStore [EDX+CTX.FrmBuffer],ESI,16
     JC .F9312:
     ADDD [%FrmNdx],8
     JMP .20:
 .50:; <b>Merge keyword operands</b>. First store keywords from prototype with their default values.
     BufferRetrieve [EBX+STM.KeyBuffer]
     TEST ECX
     JZ .60:
 .52:PUSH ECX ; Loop .52: .. .60: keyword operands.
      MOV EDI,[ESI+0] ; NamePtr. 
      MOV ECX,[ESI+4] ; NameSize.
      PoolStore [%MpPassPool],EDI,ECX
      JC .F9312:
      MOV [%FrmVar+0],EAX ; Persistent ordinal name ptr.
      MOV [%FrmVar+4],ECX ; Ordinal name size.
      MOV EDI,[ESI+8] ; ValuePtr. 
      MOV ECX,[ESI+12] ; ValueSize.
      PoolStore [%MpPassPool],EDI,ECX
      MOV [%FrmVar+8],EAX ; Persistent default value ptr.
      MOV [%FrmVar+12],ECX ; Persistent default value size.
      LEA EDI,[%FrmVar]
      BufferStore [EDX+CTX.FrmBuffer],EDI,16 ; Save keyword with default value.
     POP ECX
     JNC .55:
.F9312:Msg '9312',EBX ; Allocation error expanding macro !1S.
     STC
     JMP .90:
 .55:ADD ESI,16
     SUB ECX,16
     JG .52:
 .60: ; <b>Each keyword in macro invocation</b> should be found in CTX.FrmBuffer, otherwise W2610,
      ; and its value <b>will update the stored key</b>.
     BufferRetrieve [EDX+CTX.KeyBuffer]
     JECXZ .90:
 .62:PUSH ECX,ESI
       MOV EDI,[ESI+0] ; Name ptr.
       MOV EAX,[ESI+4] ; Name size.
       ; Search for keyword EDI,EAX in CTX.FrmBuffer.
       BufferRetrieve [EDX+CTX.FrmBuffer]
       JECXZ .W2610: ; If keyword not found.
 .70:  Compare [ESI+0],[ESI+4],EDI,EAX
       JE .75: ; If keyword found.
       ADD ESI,16
       SUB ECX,16
       JG .70:
.W2610:MOV EAX,[ESP] ; ^QWORD keyword from CTX.KeyBuffer.
       Msg '2610',EAX,[EBX+STM.LinePtr]; Parameter "!1S=" was not specified in macro prototype at !2@. Ignored.       
       JMPS .80:
 .75:  ; Matching keyword in CTX.FrmBuffer is addressed with ESI,
       ; its <b>default value will be overwritten</b> with value from CTX.KeyBuffer.
       MOV EDI,[ESP] ; ^QWORD keyword from CTX.KeyBuffer.         
       MOV EAX,[EDI+8] ; Persistent new key value ptr.
       MOV ECX,[EDI+12] ; New key value size.
       MOV [ESI+8],EAX
       MOV [ESI+12],ECX
 .80:POP ESI,ECX
     ADD ESI,16
     SUB ECX,16
     JG .62:
.90:EndProcedure MacPrototype
</pre>

<dl id="MacFind">
<dt><a href="#top">&uarr; MacFind</a> NamePtr, NameSize</dt>
<dd>MacFind searches for macro with given name on Pass.MacList
<!---->belonging to all PROGRAMs on context stack, beginning with the last program.
<!---->The search is case sensitive.
<br/>If the macro name is found on MacList but its MAC.LinePtr is NULL, which happens
<!---->in %DROPMACRO, searching stops and does not continue with parent PROGRAMs.</dd>
<dt>Input</dt>
<dd><b>NamePtr</b> Pointer to macro name.
<br/><b>NameSize</b> Size of macro name.</dd>
<dt>Output</dt>
<dd><b>CF=0 EAX=</b> pointer to <a href="#MAC">MAC</a> structure which contains
<!---->macro name and LinePtr to the %MACRO definition statement.</dd>
<dt>Error</dt>
<dd><b>CF=1 EAX=0</b> Macro was not found.
<br/><b>CF=1 EAX=</b> ^MAC with this name, which was dropped.</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ctx.htm#CtxPeek">CtxPeek</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pseudo.htm#PseudopcDROPMACRO">PseudopcDROPMACRO</a>
<a class="EXT" href="pseudo.htm#PseudopcMACRO">PseudopcMACRO</a>
<a class="EXT" href="stm.htm#StmParse">StmParse</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t7232.htm">t7232</a>
</dd>
</dl><pre>
MacFind Procedure NamePtr, NameSize
       SUB EDI,EDI
       MOV [%ReturnEAX],EDI
 .10:  Invoke CtxPeek::,ctxPROGRAM,EDI
       JC .90:
       MOV EDI,EAX
       MOV EBX,[EAX+CTX.ObjPtr]
       TEST EBX
       JZ .10:
       MOV ECX,[EBX+PGM.PassPtr]
       JECXZ .10:
       MOV EDX,[ECX+PASS.MacList]
       ListGetLast EDX
 .50:  JZ .10:
       Compare [%NamePtr],[%NameSize],[EAX+MAC.NamePtr],[EAX+MAC.NameSize]
       JE .70:
       ListGetPrev EAX
       JMP .50:
 .70: MOV ECX,[EAX+MAC.LinePtr]
      STC
      JECXZ .90: ; Zero LinePtr signalizes that the macro was dropped.
      CLC
      MOV [%ReturnEAX],EAX
 .90:EndProcedure MacFind
</pre>

<dl id="MacListMerge">
<dt><a href="#top">&uarr; MacListMerge</a> ParentPass, ChildPass</dt>
<dd>MacListMerge copies macro names defined during ChildProgram.Pass to ParentProgram.Pass.MacList.
<br/>Names must be reallocated on ParentProgram.Pass.Pool because the ChildPass is about to end.</dd>
<dt>Input</dt>
<dd><b>ParentPass</b> Pointer to <a class="EXT" href="./pass.htm#PASS">PASS
</a> to whose .MacList the macros will be copied to.
<br/><b>ChildPass</b> Pointer to PASS whose .MacList contains source macro names
<!---->defined in this pass, including dropped macros.</dd>
<dt>Output</dt>
<dd>Macro names are copied.</dd>
<dt>Errors</dt>
<dd>not detected.</dd>
<dt>See also</dt>
<dd><a class="EXT" href="./var.htm#VarListMerge">VarListMerge</a>.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pseudo.htm#PseudoENDPROGRAM">PseudoENDPROGRAM</a>
</dd>
</dl><pre>
MacListMerge Procedure ParentPass, ChildPass
     MOV EBX,[%ParentPass]
     MOV EDX,[%ChildPass]
     ListGetFirst [EDX+PASS.MacList]
     JZ .90:
 .10 MOV ESI,EAX ; Ptr to MAC.
     PoolStore [EBX+PASS.Pool],[ESI+MAC.NamePtr],[ESI+MAC.NameSize]
     MOV [ESI+MAC.NamePtr],EAX ; Reallocated ptr to name.
     ListStore [EBX+PASS.MacList],ESI
     ListGetNext ESI
     JNZ .10:
 .90:EndProcedure MacListMerge
</pre>
<pre>
  ENDPROGRAM mac
</pre><!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
