<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='pflibcof.htm source file'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>pflibcof.htm source file</title>
</head>
<body class='EASOURCE' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>pflibcof.htm
<br/><i>Classes</i>
<br/><a href="#PFLIBCOF_ARCHIVE_MEMBER_HEADER">PFLIBCOF_ARCHIVE_MEMBER_HEADER</a>
<br/><a href="#PFLIBCOF_IMPORT_OBJECT_HEADER">PFLIBCOF_IMPORT_OBJECT_HEADER</a>
<br/><i>Encodings</i>
<br/><a href="#PflibcofObjectTypeEnc">PflibcofObjectTypeEnc</a>
<br/><a href="#PflibcofNameTypeEnc">PflibcofNameTypeEnc</a>
<br/><i>Procedures</i>
<br/><a href="#PflibcofCompile">PflibcofCompile</a>
<br/><a href="#PflibcofInitHeader">PflibcofInitHeader</a>
<br/><a href="#PflibcofInitImport">PflibcofInitImport</a>
<br/><a href="#PflibcofLoadImportModule">PflibcofLoadImportModule</a>
<br/><a href="#PflibcofLoadPgm">PflibcofLoadPgm</a>
<br/><a href="#PflibcofStoreImportModule">PflibcofStoreImportModule</a>
<br/><a href="#PflibcofStoreObjectModule">PflibcofStoreObjectModule</a>
</h1>
<p>This source PFLIB creates and imports object and import library in COFF standard.
</p>
<br class="CLEAR"/>
<pre>
         EUROASM NOWARN=2101
pflibcof PROGRAM FORMAT=COFF,MODEL=FLAT,WIDTH=32
         INCLUDEHEAD euroasm.htm, \  Interface (structures, symbols and macros) of other modules used in this source.
                     ea.htm,eaopt.htm,exp.htm,msg.htm,pf.htm,pfcoff.htm,pflibomf.htm,pgm.htm, \
                     pgmopt.htm,reloc.htm,sss.htm,stm.htm,sym.htm
</pre><pre>
 pflibcof HEAD ; Start module interface.
</pre>

<dl id="PFLIBCOF_ARCHIVE_MEMBER_HEADER"><dt><a href="#top">&uarr; PFLIBCOF_ARCHIVE_MEMBER_HEADER</a></dt>
<dd>Structure which describes object header in COFF library.
<br/>All structure members are in decimal human-readable characters, left aligned, padded with spaces (0x20).
<br/>Archive member headers in COFLIB file are word-aligned. Header is immediately followed with
<!---->the actual COFF object.
</dd></dl><pre>
PFLIBCOF_ARCHIVE_MEMBER_HEADER STRUC
.Name      D 16*B ; Member name terminated with <kbd>/</kbd>, padded with spaces.
.Date      D 12*B ; Time of member creation as seconds since Jan 1st, 1970 UTC, in decimal.
.UserId    D  6*B ; Unix  user ID in decimal, always <kbd>0</kbd>.
.GroupId   D  6*B ; Unix group ID in decimal, always <kbd>0</kbd>.
.Mode      D  8*B ; Unix filemode in octal, always <kbd>100666</kbd>.
.Size      D 10*B ; Size of following library member (COFF object) in decimal.
.EndHeader D  2*B ; Member header terminator <kbd>0x60,0x0A</kbd>.
ENDSTRUC PFLIBCOF_ARCHIVE_MEMBER_HEADER
</pre>

<dl id="PFLIBCOF_IMPORT_OBJECT_HEADER"><dt><a href="#top">&uarr; PFLIBCOF_IMPORT_OBJECT_HEADER</a></dt>
<dd>Structure which describes imported symbol header in COFF short import library.
<br/>The import object header is followed with two ASCIIZ strings:
<ol><li>imported symbol name</li><li>dynamic link library (DLL)  name from which it is imported.</li></ol>
</dd></dl><pre>
PFLIBCOF_IMPORT_OBJECT_HEADER STRUC
.Sig1          D W ; Signature 1, always 0x0000.
.Sig2          D W ; Signature 2, always 0xFFFF.
.Version       D W ; The structure version.
.Machine       D W ; Type of target machine CPU value in <a class="EXT" href="pfcoff.htm#PFCOFF_encodings">PFCOFF_encodings</a>.
.TimeDateStamp D D ; Time stamp as seconds since Jan 1st, 1970 UTC.
.SizeOfData    D D ; Brutto size of two ASCIIZ strings which follow the header.
.Ordinal       D W ; Import ordinal number or hint for the import.
.Type          D W ; Imported object type in <a href="#PflibcofObjectTypeEnc">PflibcofObjectTypeEnc</a>+<a href="#PflibcofNameTypeEnc">PflibcofNameTypeEnc</a>.
ENDSTRUC PFLIBCOF_IMPORT_OBJECT_HEADER
</pre>

<dl id="PflibcofObjectTypeEnc"><dt><a href="#top">&uarr; PflibcofObjectTypeEnc</a></dt>
<dd>Encoding of <a href="#PFLIBCOF_IMPORT_OBJECT_HEADER">PFLIBCOF_IMPORT_OBJECT_HEADER.Type</a>.
</dd></dl><pre>
pflibcofImportCode  = 000_000_00b ; Imported symbol is entry of executable procedure.
pflibcofImportData  = 000_000_01b ; Imported symbol represents static data.
pflibcofImportConst = 000_000_10b ; Imported symbol is a scalar value.
</pre>

<dl id="PflibcofNameTypeEnc"><dt><a href="#top">&uarr; PflibcofNameTypeEnc</a></dt>
<dd>Encoding of <a href="#PFLIBCOF_IMPORT_OBJECT_HEADER">PFLIBCOF_IMPORT_OBJECT_HEADER.NameType</a>.
</dd></dl><pre>
pflibcofImportOrdinal        = 000_000_00b ; Symbol is imported by <code>PFLIBCOF_IMPORT_OBJECT_HEADER.Ordinal</code> number.
pflibcofImportName           = 000_001_00b ; Internal import name is identical with the public name.
pflibcofImportNameNoprefix   = 000_010_00b ; Internal import name is public name without leading <kbd>?</kbd>, <kbd>@</kbd>, <kbd>_</kbd>.
pflibcofImportNameUndecorate = 000_011_00b ; As in pflibcofImportNameNoprefix and truncating at the first <kbd>@</kbd>.
</pre>
<pre>
 ENDHEAD pflibcof  ; End of module interface.
</pre>

<dl id="PflibcofLoadPgm">
<dt><a href="#top">&uarr; PflibcofLoadPgm</a> BasePgm, ObjBegin, ObjSize, FileNamePtr</dt>
<dd><dfn>PflibcofLoadPgm</dfn> reads the contents of COFF library and
<!---->converts each module to a fresh new program (PGM), which will be allocated on
<code>BasePgm.Pool</code> and stored on <code>BasePgm.ModulePgmList</code>.</dd>
<dt>Input</dt>
<dd><b>BasePgm</b> is pointer to an existing PGM to which the library will be linked.
<br/><b>ObjBegin</b> is pointer to the contents of library file mapped in memory by the caller.
<br/><b>ObjSize</b> is number of bytes in the file.
<br/><b>FileNamePtr</b> is pointer to zero-terminated file name (used in error reports).</dd>
<dt>Output</dt>
<dd>Imported modules in the form of <a class="EXT" href="pgm.htm#PGM">PGM</a> are stored on
<code>BasePgm.ModulePgmList</code>.</dd>
<dt>Error</dt>
<dd>Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invoked from</dt>
<dd><a class="EXT" href="pf.htm#PfLoad">PfLoad</a></dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="pfcoff.htm#PfcoffLoadModule">PfcoffLoadModule</a>
<a href="#PflibcofLoadImportModule">PflibcofLoadImportModule</a>
</dd>
</dl><pre>
PflibcofLoadPgm Procedure  BasePgm, ObjBegin, ObjSize, FileNamePtr
LongNames LocalVar                               ; Pointer to the 1st ASCIIZ longname in Longnames member.
ShortName LocalVar Size=16                       ; Room for short archive member name.
    MOV EDI,[%ObjBegin]
    MOV ECX,[%ObjSize]
    LEA EDX,[EDI+ECX]                            ; Pointer to the end of mapped library.
    ADD EDI,8 ; Skip LIBCOF signature <code>!&lt;arch&gt;</code>.
    ; <b>Linker dictionary members are not used by &euro;ASM</b>.
    CALL .SkipHeader:                            ; Skip the First Linker Member.
    JC .90:
    CALL .SkipHeader:                            ; Skip the Second Linker Member.
    JC .90:
    CALL .SkipHeader:                            ; Skip the Longnames Member.
    JC .90:
    MOV [%LongNames],ESI
    ; <b>Read and load all object and import members</b>.
.50:CMP EDI,EDX                                  ; Test the end of file.
    JNB .90:
    ; EDI now points to the header of COFF object module or short COFF import.
    CALL .SkipHeader:                            ; Skip the module header.
    JC .90:
    CMPD [ESI],0xFFFF_0000                       ; Is it <a href="#PFLIBCOF_IMPORT_OBJECT_HEADER">PFLIBCOF_IMPORT_OBJECT_HEADER</a>?
    JNE .60:                                     ; If it is an ordinary COFF object starting with <a class="EXT" href="pfcoff.htm#PFCOFF_FILE_HEADER">PFCOFF_FILE_HEADER</a>.
    ; Library member ESI,EAX is a short format COFF import.
    ; Its name will be identical with ASCIIZ imported symbol name which follows the import object header.
    Invoke PflibcofLoadImportModule,[%BasePgm],ESI,EAX,[%FileNamePtr]
    JMP .50:                                     ; The next library member.
.60:; Library member ESI,EAX is an ordinary COFF module. Its name is in archive member header in the form <code>ShortName/</code> or <code>/LongNameOffset</code>.
    LEA EBX,[ESI - SIZE# PFLIBCOF_ARCHIVE_MEMBER_HEADER]
    CMPB [EBX+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Name+0],'/'
    JE .75:
    ; Module name is short, terminated with <kbd>/</kbd>.
    SUB ECX,ECX                                  ; Name size.
.70:CMPB [EBX+ECX],'/'
    JE .80:
    INC ECX
    CMP CL,16
    JB .70:
    JMP .80:                                     ; EBX,ECX is now the module name.
.75:; Module name is long, stored in Longnames member.
    INC EBX
    PUSH EAX,EDI
      LodD EBX
      ADD EAX,[%LongNames]
      MOV EBX,EAX
      GetLength$ EBX                             ; EBX,ECX is now the long module name.
    POP EDI,EAX
.80:Invoke PfcoffLoadModule::,[%BasePgm],ESI,EAX,[%FileNamePtr],EBX,ECX,pgmoptLIBCOF
    JMP .50:                                     ; The next library member.
.SkipHeader:PROC ; Subprocedure to check the library member header.
  ; Input: EDI=^PFLIBCOF_ARCHIVE_MEMBER_HEADER, should be word aligned. EDX=^End of mapped file.
  ; Output:CF=0,EAX=module size, ESI=^module body, EDI=^PFLIBCOF_ARCHIVE_MEMBER_HEADER of the next member, word aligned.
  ; Error: CF=1, E7768 reported.
             TEST EDI,1
             JZ .L2:
             INC EDI
        .L2: LEA ESI,[EDI+SIZE# PFLIBCOF_ARCHIVE_MEMBER_HEADER]
             CMP ESI,EDX
             JB .L5:
      .E7768:SUB ESI,[%ObjBegin]
             Msg '7768',[%FileNamePtr],ESI       ; Invalid format of COFF library "!1$"[!2Hh].
             STC
             RET
         .L5:LEA ESI,[EDI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Size]
             LodD ESI                            ; Load decimal COFF module size to EAX.
             LEA ESI,[EDI+SIZE# PFLIBCOF_ARCHIVE_MEMBER_HEADER]
             JC .E7768:                          ; Invalid format of COFF library "!1$"[!2Hh].
             LEA EDI,[ESI+EAX]
             RET
            ENDP .SkipHeader:
.90:EndProcedure PflibcofLoadPgm
</pre>

<dl id="PflibcofInitHeader">
<dt><a href="#top">&uarr; PflibcofInitHeader</a> HeaderPtr, ModulePgm</dt>
<dd><dfn>PflibcofInitHeader</dfn> initializes Header members
<code>.Date, .UserId, .GroupId, .Mode</code>. Rest of the Header is filled with spaces.</dd>
<dt>Input</dt>
<dd><b>HeaderPtr</b> is pointer to <a href="#PFLIBCOF_ARCHIVE_MEMBER_HEADER">PFLIBCOF_ARCHIVE_MEMBER_HEADER
</a>, allocated by caller.
<br/><b>ModulePgm</b> is pointer to <a class="EXT" href="pgm.htm#PGM">PGM
</a> from which will be the archive member created.</dd>
<dt>Output</dt>
<dd>Header is initialized.</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>Invoked by</dt>
<dd><a href="#PflibcofCompile">PflibcofCompile</a>
<a href="#PflibcofStoreImportModule">PflibcofStoreImportModule</a>
<a href="#PflibcofStoreObjectModule">PflibcofStoreObjectModule</a>
</dd>
</dl><pre>
PflibcofInitHeader Procedure HeaderPtr, ModulePgm
     MOV EDI,[%HeaderPtr]
     MOV EBX,[%ModulePgm]
     Clear EDI,Size=SIZE#PFLIBCOF_ARCHIVE_MEMBER_HEADER,Filler=0x20
     MOVB [EDI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.UserId],'0'
     MOVB [EDI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.GroupId],'0'
     MOVD [EDI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Mode],'1006'
     MOVW [EDI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Mode+4],'66'
     MOVW [EDI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.EndHeader],0x0A60
     MOV EAX,[Ea.Eaopt.TimeStamp::]
     LEA EDI,[EDI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Date]
     StoD Signed=no
 EndProcedure PflibcofInitHeader
</pre>

<dl id="PflibcofInitImport">
<dt><a href="#top">&uarr; PflibcofInitImport</a> HeaderPtr, ModulePgm</dt>
<dd><dfn>PflibcofInitImport</dfn> clears and initializes import header members
<code>.Sig1, .Sig2, .Version, .Machine, TimeDateStamp</code>.</dd>
<dt>Input</dt>
<dd><b>HeaderPtr</b> is pointer to <a href="#PFLIBCOF_IMPORT_OBJECT_HEADER">PFLIBCOF_IMPORT_OBJECT_HEADER
</a>, allocated by caller.
<br/><b>ModulePgm</b> is pointer to <a class="EXT" href="pgm.htm#PGM">PGM
</a> from which will be the import created.</dd>
<dt>Output</dt>
<dd>Import header is initialized.</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>Invoked by</dt>
<dd><a href="#PflibcofStoreImportModule">PflibcofStoreImportModule</a>
</dd>
</dl><pre>
PflibcofInitImport Procedure HeaderPtr, ModulePgm
    MOV EDI,[%HeaderPtr]
    MOV EBX,[%ModulePgm]
    Clear EDI,Size=SIZE#PFLIBCOF_IMPORT_OBJECT_HEADER,Filler=0
    MOVW [EDI+PFLIBCOF_IMPORT_OBJECT_HEADER.Sig1],0
    MOVW [EDI+PFLIBCOF_IMPORT_OBJECT_HEADER.Sig2],-1
    MOV [EDI+PFLIBCOF_IMPORT_OBJECT_HEADER.Machine],pfcoffFILE_MACHINE_I386
    JNSt [EBX+PGM.Pgmopt.Status],pgmoptWidth64, .50:
    MOV [EDI+PFLIBCOF_IMPORT_OBJECT_HEADER.Machine],pfcoffFILE_MACHINE_AMD64
.50:MOV EAX,[EBX+PGM.Pgmopt.MajorLinkerVersion]
    MOV EDX,[Ea.Eaopt.TimeStamp::]
    MOV [EDI+PFLIBCOF_IMPORT_OBJECT_HEADER.Version],AX
    MOV [EDI+PFLIBCOF_IMPORT_OBJECT_HEADER.TimeDateStamp],EDX
 EndProcedure PflibcofInitImport
</pre>

<dl id="PflibcofLoadImportModule">
<dt><a href="#top">&uarr; PflibcofLoadImportModule</a> BasePgm, ImpBegin, ImpSize, FileNamePtr</dt>
<dd><p><dfn>PflibcofLoadImportModule</dfn> reads the contents of one import library member in short COFF format
<!---->and converts it to a fresh new program, which then will be stored on
<code>BasePgm.ModulePgmList</code>. The program contains no segments and just one import symbol.
</p></dd>
<dt>Input</dt>
<dd><b>BasePgm</b> is pointer to an existing <a class="EXT" href="pgm.htm#PGM">PGM
</a> to which the member is being loaded.
<br/><b>ImpBegin</b> is pointer to the short import library member in
<a href="pflibcof.htm#PFLIBCOF_IMPORT_OBJECT_HEADER">PFLIBCOF_IMPORT_OBJECT_HEADER
</a> form, immediately followed with two ASCIIZ strings with symbol name and DLL name.
<br/><b>ImpSize</b> is the size of import object header plus brutto size of both ASCIIZ strings.
<br/><b>FileNamePtr</b> is pointer to zero-terminated file name (used in error reports).</dd>
<dt>Output</dt>
<dd>Loaded program is stored on <code>BasePgm.ModulePgmList</code> as a new
<a class="EXT" href="pgm.htm#PGM">PGM</a> structure.</dd>
<dt>Error</dt>
<dd>Error E7766 reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invoked by</dt>
<dd><a href="#PflibcofLoadPgm">PflibcofLoadPgm</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="pgm.htm#PgmCreateImportModule">PgmCreateImportModule</a>
</dd>
</dl><pre>
PflibcofLoadImportModule Procedure BasePgm, ImpBegin, ImpSize, FileNamePtr
ImpEndPtr           LocalVar ; Pointer to end of import module.
SymbolDllNameSize   LocalVar
SymbolDllNamePtr    LocalVar
SymbolInterNamePtr  LocalVar
SymbolInterNameSize LocalVar
SymbolNamePtr       LocalVar
SymbolNameSize      LocalVar
SymbolStatus        LocalVar
SymbolOrdinal       LocalVar
    MOV ESI,[%ImpBegin]
    MOV ECX,[%ImpSize]
    ADD ECX,ESI
    MOV [%ImpEndPtr],ECX
    LEA EAX,[ESI+SIZE# PFLIBCOF_IMPORT_OBJECT_HEADER] ; EAX is now pointer to symbol name.
    GetLength$ EAX      ; ECX is now symbol name size.
    MOV [%SymbolNamePtr],EAX
    MOV [%SymbolNameSize],ECX
    MOV [%SymbolInterNamePtr],EAX
    MOV [%SymbolInterNameSize],ECX
    LEA EDX,[EAX+ECX+1] ; EDX is now pointer to DLL name.
    GetLength$ EDX
    MOV [%SymbolDllNamePtr],EDX
    MOV [%SymbolDllNameSize],ECX
    LEA EAX,[EDX+ECX+1]
    CMP EAX,[%ImpEndPtr]
    LEA EAX,[%SymbolNamePtr] ; Prepare Msg parameter !1S.
    Msg cc=A,'6952',EAX,[%FileNamePtr] ; Wrong import !1S in library "!2$".
    MOVZXW EAX,[ESI+PFLIBCOF_IMPORT_OBJECT_HEADER.Ordinal]
    MOV [%SymbolOrdinal],EAX
    MOVZXW EAX,[ESI+PFLIBCOF_IMPORT_OBJECT_HEADER.Type]
    MOV EDX,symImport+'N'
    JSt EAX,pflibcofImportConst,.10:
    MOV DL,'A'
.10:JSt EAX,pflibcofImportName|pflibcofImportNameNoprefix|pflibcofImportNameUndecorate,.20:
    SetSt EDX,symImportedByOrd
.20:MOV [%SymbolStatus],EDX
    SHR EAX,3 ; Shift out 2 bits of object type and the LSbit of name type.
    JZ .50: ; If pflibcofImportName (leave symbol Name identical with InterName).
    PUSHFD ; CF=0 if pflibcofImportNameNoprefix, CF=1 if pflibcofImportNameUndecorate.
      ; <b>Noprefix</b>. Remove the leading <kbd>?</kbd>, <kbd>@</kbd>, <kbd>_</kbd>.
      MOV ESI,[%SymbolInterNamePtr]
      MOV ECX,[%SymbolInterNameSize]
      LEA EDX,[ESI+ECX]
.25:  CMP ESI,EDX
      JNB .30:
      LODSB
      DEC ECX
      CMP AL,'@'
      JE .25:
      CMP AL,'?'
      JE .25:
      CMP AL,'_'
      JE .25:
      DEC ESI
      INC ECX
.30:  MOV [%SymbolInterNamePtr],ESI
      MOV [%SymbolInterNameSize],ECX
    POPFD
    JNC .50:
    ; <b>Undecorate</b>. Truncate at the first <kbd>@</kbd> after having removed the leading  <kbd>?</kbd>, <kbd>@</kbd>, <kbd>_</kbd>.
    MOV ESI,[%SymbolInterNamePtr]
    MOV ECX,[%SymbolInterNameSize]
    LEA EDX,[ESI+ECX]
.35:CMP ESI,EDX
    JNB .40:
    LODSB
    CMP AL,'@'
    JNE .35:
    DEC ESI
.40:SUB ESI,[%SymbolInterNamePtr]
    MOV [%SymbolInterNameSize],ESI
.50:Invoke PgmCreateImportModule::,[%BasePgm],[%SymbolDllNamePtr], [%SymbolDllNameSize],[%SymbolOrdinal], \
       [%SymbolStatus],[%SymbolNamePtr], [%SymbolNameSize],[%SymbolInterNamePtr], [%SymbolInterNameSize]
   EndProcedure PflibcofLoadImportModule
</pre>

<dl id="PflibcofStoreObjectModule">
<dt><a href="#top">&uarr; PflibcofStoreObjectModule</a> ModuleStream, TemporaryStream, ModulePgm,
<!---->SymbolBuffer, LongnameBuffer, ModuleIndex</dt>
<dd><dfn>PflibcofStoreObjectModule</dfn> creates library module in COFF format from ModulePgm,
<!---->and writes archive member header plus completed COFF-formated object to ModuleStream.
<br/>Header and object are incorporated into library only if it exports or publishes at least one symbol.
<br/>Offset and ModuleIndex of each module in ModuleStream are then stored to SymbolBuffer
<!---->for each published or exported symbol found in the module.
<br/>All streams and buffers must be allocated by the caller.</dd>
<dt>Input</dt>
<dd><b>ModuleStream</b> is pointer to a <a class="EXT" href="../maclib/memory32.htm#STREAM">STREAM
</a> where the archive header and COFF object module will be written.
<br/><b>TemporaryStream</b> is pointer to a reusable <a class="EXT" href="../maclib/memory32.htm#STREAM">STREAM
</a> where the COFF object module (file header, section headers, raw data,
<!---->symbol table, string table) will be constructed by
<a class="EXT" href="pfcoff.htm#PfcoffCompile">PfcoffCompile
</a>. Its contents will be restreamed later to ModuleStream
<!---->together with library member header.
<br/><b>ModulePgm</b> is pointer to an input <a class="EXT" href="pgm.htm#PGM">PGM
</a> from which the archive member is being created.
<br/><b>SymbolBuffer</b> is pointer to an output <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> where a <a class="EXT" href="pflibomf.htm#PFLIBOMF_SYMBOL">PFLIBOMF_SYMBOL
</a> record will be written for each public and exported symbol.
<br/><b>LongnameBuffer</b> is pointer to an output <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> where library member ASCIIZ name is stored when its size exceeds 15 characters.
<!---->Offset within this buffer is then stored to <code>PFLIBCOF_ARCHIVE_HEADER.Name
</code> as decimal number prefixed with slash <kbd>/</kbd>.
<br/><b>ModuleIndex</b> is number of modules previously stored in ModuleStream.
<!---->PflibcofStoreObjectModule will increment the number for each archive member stored in ModuleStream.
<br/>When there's no import/export/public symbol in ModulePgm, returned EDX=ModuleIndex.</dd>
<dt>Output</dt>
<dd><b>EDX=</b> is equal to ModuleIndex incremented for each stored library module.
<br/>SymbolBuffer is updated with import, export and public symbols which were stored to ModuleStream.</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>See also</dt>
<dd><a href="#PflibcofStoreImportModule">PflibcofStoreImportModule</a></dd>
<dt>Invoked by</dt>
<dd><a href="#PflibcofCompile">PflibcofCompile</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="pfcoff.htm#PfcoffCompile">PfcoffCompile</a>
<a href="#PflibcofInitHeader">PflibcofInitHeader</a>
</dd>
</dl><pre>
PflibcofStoreObjectModule Procedure ModuleStream, TemporaryStream, ModulePgm, \
                              SymbolBuffer, LongnameBuffer, ModuleIndex
ModHeader    LocalVar Size=SIZE#PFLIBCOF_ARCHIVE_MEMBER_HEADER
LibSymbol    LocalVar Size=SIZE#PFLIBOMF_SYMBOL
    MOV EDX,[%ModuleIndex]
    MOV [%ReturnEDX],EDX                         ; Prepare for the case of empty ModulePgm.
    MOV EBX,[%ModulePgm]
    SetSt [EBX+PGM.Status],pgmSelected           ; Store object module ebx only if there's at least one public/export symbol.
.24:ListGetFirst [EBX+PGM.SymList]
    JZ .90:
.25:JSt [EAX+SYM.Status],symPublic|symExport,.35:
.30:ListGetNext EAX
    JNZ .25:
    RstSt [EBX+PGM.Status],pgmSelected
    JMP .90:                                     ; Skip if there is nothing to publish/export.
.35:; <b>Store object module EBX to ModuleStream</b>.
    LEA EDI,[%ModHeader]
    Invoke PflibcofInitHeader,EDI,EBX
    LEA EDI,[EDI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Name]
    MOV ECX,[EBX+PGM.NameSize]                   ; Use PGM.Name as archive member name.
    CMP ECX,16
    JB .40:                                      ; If module name is short.
    PUSH ECX
      BufferRetrieve [%LongnameBuffer]
      MOV EAX,ECX ; Offset in LongnameBuffer.
    POP ECX
    MOV ESI,[EBX+PGM.NamePtr]                    ; ESI,ECX is long module name.
    BufferStore [%LongnameBuffer],ESI,ECX
    BufferStoreByte [%LongnameBuffer],0          ; Terminating zero.
    MOVB [EDI],'/'                               ; Long name in ModHeader looks like "/123" where 123 is offset in LongnameBuffer.
    INC EDI
    StoD EDI                                     ; Store offset of the module name in LongnameBuffer as a decadic number.
    JMP .50:
.40:MOV ESI,[EBX+PGM.NamePtr]                    ; ESI,ECX is short module name.
    REP MOVSB                                    ; Store the short name to archive member header directly.
    MOV AL,'/'                                   ; Short name in ModHeader looks like "ShortName/".
    STOSB
.50:LEA EDI,[%LibSymbol]
    StreamGetSize [%ModuleStream]                ; Size of all previously streamed hdr+modules (without 3 linker members).
    TEST AL,1
    JZ .60:
    INC EAX
    PUSH EAX
      StreamStoreByte [%ModuleStream],0x10       ; Align each library member to WORD.
    POP EAX
.60:MOV [EDI+PFLIBOMF_SYMBOL.ModPtr],EAX
    MOV EDX,[%ReturnEDX]
    INC EDX                                      ; ModuleIndex.
    MOV [%ReturnEDX],EDX
    MOV [EDI+PFLIBOMF_SYMBOL.ModIndex],EDX
    StreamClear [%TemporaryStream]
    ; <b>Create module body</b>, starting with PFCOFF_FILE_HEADER.
    Invoke PfcoffCompile::,[%TemporaryStream],EBX
    StreamGetSize [%TemporaryStream]
    LEA ESI,[%ModHeader]
    LEA EDI,[ESI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Size]
    StoD EDI                                     ; Member header ESI is now complete.
    StreamStore [%ModuleStream],ESI,SIZE# PFLIBCOF_ARCHIVE_MEMBER_HEADER
    StreamDump [%TemporaryStream], .Restream:    ; Copy TemporaryStream to ModuleStream.
.Restream:PROC1                                  ; Callback of StreamDump.
           StreamStore [%ModuleStream],ESI,ECX
           RET
          ENDPROC1 .Restream:
    LEA EDI,[%LibSymbol]
    ; Now <b>store PFLIBOMF_SYMBOL records for each published symbol</b>, with identical ModPtr and ModIndex.
    ListGetFirst [EBX+PGM.SymList]
.70:JNSt [EAX+SYM.Status],symPublic|symExport|symSe,.80:
    MOV ESI,[EAX+SYM.NamePtr]
    MOV ECX,[EAX+SYM.NameSize]
    MOV [EDI+PFLIBOMF_SYMBOL.NamePtr],ESI
    MOV [EDI+PFLIBOMF_SYMBOL.NameSize],ECX
    BufferStore [%SymbolBuffer],EDI,SIZE# PFLIBOMF_SYMBOL
.80:ListGetNext EAX
    JNZ .70:
.90:EndProcedure PflibcofStoreObjectModule
</pre>

<dl id="PflibcofStoreImportModule">
<dt><a href="#top">&uarr; PflibcofStoreImportModule</a> ModStream, ImportSymbol, BasePgm,
<!---->SymbolBuf, LongnameBuf, ModIndex</dt>
<dd><dfn>PflibcofStoreImportModule</dfn> creates import library module in short COFF format
<!---->from ImportSymbol, and stores archive member header + short COFF format to ModuleStream.
<br/>All streams and buffers must be allocated by the caller.</dd>
<dt>Input</dt>
<dd><b>ModStream</b> is pointer to a <a class="EXT" href="../maclib/memory32.htm#STREAM">STREAM
</a> where the archive header and COFF import module will be written.
<br/><b>ImportSymbol</b> is pointer to an import <a class="EXT" href="sym.htm#SYM">SYM
</a> from which the archive member is being created.
<br/><b>BasePgm</b> is pointer to <a class="EXT" href="pgm.htm#PGM">PGM</a> (compiled COFF library).
<br/><b>SymbolBuf</b> is pointer to an output <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> where a <a class="EXT" href="pflibomf.htm#PFLIBOMF_SYMBOL">PFLIBOMF_SYMBOL
</a> record will be written for the imported symbol.
<br/><b>LongnameBuf</b> is pointer to an output <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> where library member ASCIIZ name is stored when its size exceeds 15 characters.
<!---->Offset within this buffer is then stored to <code>PFLIBCOF_ARCHIVE_HEADER.Name
</code> as decimal number prefixed with slash <kbd>/</kbd>.
<br/><b>ModIndex</b> is number of modules previously stored in ModStream.</dd>
<dt>Output</dt>
<dd><b>EDX=</b> is equal to ModIndex incremented by one.
<br/>SymbolBuffer is updated with import symbol which was stored to ModStream.</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>See also</dt>
<dd><a href="#PflibcofStoreObjectModule">PflibcofStoreObjectModule</a></dd>
<dt>Invoked by</dt>
<dd><a href="#PflibcofCompile">PflibcofCompile</a>
</dd>
<dt>Invokes</dt>
<dd><a href="#PflibcofInitHeader">PflibcofInitHeader</a>
<a href="#PflibcofInitImport">PflibcofInitImport</a>
</dd>
</dl><pre>
PflibcofStoreImportModule Procedure ModStream, ImportSymbol, BasePgm, \
                                    SymbolBuf, LongnameBuf, ModIndex
ModHeader    LocalVar Size=SIZE#PFLIBCOF_ARCHIVE_MEMBER_HEADER
ImportHeader LocalVar Size=SIZE#PFLIBCOF_IMPORT_OBJECT_HEADER
LibSymbol    LocalVar Size=SIZE#PFLIBOMF_SYMBOL
    MOV EDX,[%ImportSymbol]
    LEA EDI,[%ModHeader]                         ; Create <b>archive member header</b>.
    Invoke PflibcofInitHeader,EDI,[%BasePgm]
    LEA EDI,[EDI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Name]
    MOV ECX,[EDX+SYM.NameSize]                   ; Use symbol name as archive member name.
    CMP ECX,16
    JB .S4:                                      ; If symbol name is short.
    PUSH ECX
      BufferRetrieve [%LongnameBuf]
      MOV EAX,ECX ; Offset in LongnameBuf.
    POP ECX
    MOV ESI,[EDX+SYM.NamePtr]
    BufferStore [%LongnameBuf],ESI,ECX
    BufferStoreByte [%LongnameBuf],0             ; Terminating zero.
    MOVB [EDI],'/'                               ; Long name in ModHeader looks like "/123" where 123 is offset in LongnameBuf.
    INC EDI
    StoD EDI                                     ; Store offset of the module name in LongnameBuf as a decadic number.
    JMP .S5:
.S4:MOV ESI,[EDX+SYM.NamePtr] ; ESI,ECX is short module/symbol name.
    REP MOVSB                                    ; Store the short name to archive member header directly.
    MOV AL,'/'                                   ; Short name in ModHeader looks like "ShortName/".
    STOSB
.S5:LEA EDI,[%LibSymbol]                         ; Create record for the future <b>library symbol</b>.
    StreamGetSize [%ModStream]                   ; Size of all previously streamed hdr+modules (without 3 linker members).
    TEST AL,1
    JZ .S6:
    INC EAX
    PUSH EAX
      StreamStoreByte [%ModStream],0x10          ; Align each library member to WORD.
    POP EAX
.S6:MOV [EDI+PFLIBOMF_SYMBOL.ModPtr],EAX
    MOV EAX,[%ReturnEDX]
    INC EAX ; ModIndex.
    MOV [%ReturnEDX],EAX
    MOV [EDI+PFLIBOMF_SYMBOL.ModIndex],EAX
    MOV ESI,[EDX+SYM.NamePtr]
    MOV ECX,[EDX+SYM.NameSize]
    MOV [EDI+PFLIBOMF_SYMBOL.NamePtr],ESI
    MOV [EDI+PFLIBOMF_SYMBOL.NameSize],ECX
    BufferStore [%SymbolBuf],EDI,SIZE# PFLIBOMF_SYMBOL
    LEA EDI,[%ModHeader]
    MOV EAX,[EDX+SYM.DllNameSize]
    TEST EAX
    JNZ .S7:
    MOV AL,%EuroasmDefaultDllNameSize
    MOV [EDX+SYM.DllNameSize],EAX
    MOVD [EDX+SYM.DllNamePtr],=B"%EuroasmDefaultDllName"
.S7:LEA EAX,[SIZE#PFLIBCOF_IMPORT_OBJECT_HEADER+ECX+1+EAX+1] ; ECX is symbol name size.
    MOV ESI,EDI
    LEA EDI,[EDI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Size]
    StoD EDI
    ; Archive member header is complete now.
    StreamStore [%ModStream],ESI,SIZE# PFLIBCOF_ARCHIVE_MEMBER_HEADER
    LEA EDI,[%ImportHeader]                      ; Create and store <b>import header of import symbol</b> EDX.
    Invoke PflibcofInitImport,EDI,[%BasePgm]
    MOV EAX,[EDX+SYM.NameSize]
    INC EAX ; Terminating zero.
    ADD EAX,[EDX+SYM.DllNameSize]
    INC EAX ; Terminating zero.
    MOV [EDI+PFLIBCOF_IMPORT_OBJECT_HEADER.SizeOfData],EAX
    MOV EAX,[EDX+SYM.OrdinalNr]
    MOV [EDI+PFLIBCOF_IMPORT_OBJECT_HEADER.Ordinal],AX
    MOV AX,pflibcofImportOrdinal
    JSt [EDX+SYM.Status],symImportedByOrd,.S8:
    MOV AX,pflibcofImportName
.S8:MOV ECX,[EDX+SYM.Section]
    TEST ECX
    JNZ .S9:
    OR AX,pflibcofImportConst
.S9:MOV [EDI+PFLIBCOF_IMPORT_OBJECT_HEADER.Type],AX
    ; <b>Store compiled library member to ModStream</b>.
    StreamStore [%ModStream],EDI,SIZE# PFLIBCOF_IMPORT_OBJECT_HEADER
    StreamStore [%ModStream],[EDX+SYM.NamePtr],[EDX+SYM.NameSize]
    StreamStoreByte [%ModStream],0
    StreamStore [%ModStream],[EDX+SYM.DllNamePtr],[EDX+SYM.DllNameSize]
    StreamStoreByte [%ModStream],0
.90:EndProcedure PflibcofStoreImportModule
</pre>

<dl id="PflibcofCompile">
<dt><a href="#top">&uarr; PflibcofCompile</a> OutputStream, Pgm</dt>
<dd><dfn>PflibcofCompile</dfn> is constructor of object/import library in linkable/importable format PECOFF
<!---->as specified in <a class="EXTL" href="../eadoc/links.htm#MS_PECOFF">[MS_PECOFF]</a>.
<br/>The base Pgm plus each module loaded on Pgm.ModulePgmList will create one member in the output library.</dd>
<dt>Input</dt>
<dd><b>OutputStream</b> is pointer to an empty
<a class="EXT" href="../maclib/memory32.htm#STREAM">STREAM</a> for the output file contents.
<br/><b>Pgm</b> is pointer to a base <a class="EXT" href="pgm.htm#PGM">PGM
</a> representing the completely assembled program with modules loaded in
<code>Pgm.ModulePgmList</code>.</dd>
<dt>Output</dt>
<dd>OutputStream is filled with output file contents.</dd>
<dt>Error</dt>
<dd>Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invoked from</dt>
<dd><a class="EXT" href="pf.htm#PfOutput">PfOutput</a></dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a href="#PflibcofInitHeader">PflibcofInitHeader</a>
<a href="#PflibcofStoreImportModule">PflibcofStoreImportModule</a>
<a href="#PflibcofStoreObjectModule">PflibcofStoreObjectModule</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t9050.htm">t9050</a>
</dd>
</dl><pre>
PflibcofCompile Procedure OutputStream, Pgm
ModStream     LocalVar ; ^Stream for linked module headers+members (but not 3 linker members).
TempStream    LocalVar ; ^Stream for one COFF module, used in PflibcofStoreObjectModule.
SymbolBuf     LocalVar ; ^Buffer for <a class="EXT" href="pflibomf.htm#PFLIBOMF_SYMBOL">PFLIBOMF_SYMBOL</a> records.
StringBuf     LocalVar ; ^Buffer for ASCIIZ strings with public names.
LongnameBuf   LocalVar ; ^Buffer for 3rd linker member with module names longer than 15.
LinkerOffsBuf LocalVar ; ^Buffer for linker member DWORD offsets. The 1st one is NrOfOffsets.
LinkerIndBuf  LocalVar ; ^Buffer for linker member WORD ordinals.  The 1st DWORD is NrOfOrdinals.
Linker1stBuf  LocalVar ; ^Buffer for the first linker member, including its header.
Linker2ndBuf  LocalVar ; ^Buffer for the second linker member, including its header.
Linker3rdBuf  LocalVar ; ^Buffer for the third linker member (longnames), including its header.
ModIndex      LocalVar ; Number of modules stored in the library.
Header        LocalVar Size=SIZE#PFLIBCOF_ARCHIVE_MEMBER_HEADER
    ; <b>Initialize local variables</b>.
    MOV EBX,[%Pgm]
    StreamCreate [EBX+PGM.Pool]
    MOV [%ModStream],EAX
    StreamCreate [EBX+PGM.Pool]
    MOV [%TempStream],EAX
    Invoke EaBufferReserve::,PflibcofCompile
    MOV [%SymbolBuf],EAX
    Invoke EaBufferReserve::,PflibcofCompile
    MOV [%StringBuf],EAX
    Invoke EaBufferReserve::,PflibcofCompile
    MOV [%LongnameBuf],EAX
    Invoke EaBufferReserve::,PflibcofCompile
    MOV [%LinkerOffsBuf],EAX
    Invoke EaBufferReserve::,PflibcofCompile
    MOV [%LinkerIndBuf],EAX
    Invoke EaBufferReserve::,PflibcofCompile
    MOV [%Linker1stBuf],EAX
    Invoke EaBufferReserve::,PflibcofCompile
    MOV [%Linker2ndBuf],EAX
    Invoke EaBufferReserve::,PflibcofCompile
    MOV [%Linker3rdBuf],EAX
    SUB EDX,EDX
    MOV [%ModIndex],EDX
    ; <b>Store short import module for each imported symbol from the base program EBX</b> to ModStream.
    ListGetFirst [EBX+PGM.SymList]
    JZ .09:
.02:JNSt [EAX+SYM.Status],symImport,.08:
    Invoke PflibcofStoreImportModule,[%ModStream],EAX,EBX,[%SymbolBuf],[%LongnameBuf],EDX
    MOV [%ModIndex],EDX
.08:ListGetNext EAX                              ; The next import symbol.
    JNZ .02:
.09:; <b>Store object module from the base program EBX</b> to ModStream.
    Invoke PflibcofStoreObjectModule::,[%ModStream],[%TempStream],EBX,[%SymbolBuf],[%LongnameBuf],EDX
    MOV [%ModIndex],EDX
    ; <b>Enumerate loaded programs </b> loaded to ModulePgmList of base program EBX.
    ListGetFirst [EBX+PGM.ModulePgmList]
    JZ .20:
.10:MOV EBX,EAX
    ; <b>Store short import module for each imported symbol from the loaded program EBX</b> to ModStream.
    ListGetFirst [EBX+PGM.SymList]
    JZ .14:
.11:JNSt [EAX+SYM.Status],symImport,.13:
    Invoke PflibcofStoreImportModule,[%ModStream],EAX,EBX,[%SymbolBuf],[%LongnameBuf],EDX
    MOV [%ModIndex],EDX
.13:ListGetNext EAX                              ; The next import symbol.
    JNZ .11:
.14:; <b>Store object module from the loaded program EBX</b> to ModStream.
    MOVB [EBX+PGM.Pgmopt.Status],pgmoptLIBCOF    ; Prevent creating <code>[.drectve]</code> in library module.
    Invoke PflibcofStoreObjectModule::,[%ModStream],[%TempStream],EBX,[%SymbolBuf],[%LongnameBuf],EDX
    MOV [%ModIndex],EDX
    ListGetNext EBX                              ; The next loaded module (program).
    JNZ .10:
    ; All library modules are now stored in ModStream. SymbolBuf identifies published and imported symbols in the library.
.20:; Compile <b>First Linker Member</b> to Linker1stBuf.
    BufferRetrieve [%SymbolBuf]
    LEA EDX,[ESI+ECX]                            ; End of PFLIBOMF_SYMBOL records, sorted by module offsets.
    BufferStoreDword [%LinkerOffsBuf],0          ; Number of symbols will be patched and BSWAPed later.
.30:CMP ESI,EDX
    JNB .40:                                     ; If no more symbols.
    MOV EAX,[ESI+PFLIBOMF_SYMBOL.ModPtr]         ; Order of elements in LinkerOffsBuf and StringBuf is synchronized.
    BufferStoreDword [%LinkerOffsBuf],EAX        ; To be elevated by the size of 3 linker members and BSWAPed later.
    BufferStore [%StringBuf],[ESI+PFLIBOMF_SYMBOL.NamePtr],[ESI+PFLIBOMF_SYMBOL.NameSize]
    BufferStoreByte [%StringBuf],0               ; Terminating zero.
    ADD ESI,SIZE#PFLIBOMF_SYMBOL
    JMP .30:
.40:BufferRetrieve [%LinkerOffsBuf]              ; Calculate First Linker Member size to EAX.
    MOV EAX,ECX
    SHR ECX,2
    DEC ECX
    MOV [ESI],ECX                                ; Patch the number of symbols in First Linker Member.
    BufferRetrieve [%StringBuf]
    TEST CL,1                                    ; Alignment test.
    JZ .45:
    BufferStoreByte [%StringBuf],0x0A            ; Linker members should be word aligned with LF.
    INC ECX
.45:ADD EAX,ECX                                  ; EAX is now the total size of First Linker Member without header.
    LEA ESI,[%Header]
    Invoke PflibcofInitHeader,ESI,EBX
    MOVB [ESI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Name],'/'
    LEA EDI,[ESI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Size]
    StoD EDI ; Store member body size EAX as decimal digits.
    BufferStore [%Linker1stBuf],ESI,SIZE# PFLIBCOF_ARCHIVE_MEMBER_HEADER
    BufferRetrieve [%LinkerOffsBuf]
    BufferStore [%Linker1stBuf],ESI,ECX
    BufferRetrieve [%StringBuf]
    BufferStore [%Linker1stBuf],ESI,ECX
    ; Compile <b>Second Linker Member</b> to Linker2ndBuf.
    BufferClear [%LinkerOffsBuf]                 ; Reuse buffers used for the First Linker Member.
    BufferClear [%StringBuf]
    BufferRetrieve [%SymbolBuf]
    LEA EDX,[ESI+ECX]                            ; End of PFLIBOMF_SYMBOL records, sorted by module index.
    SUB EDI,EDI                                  ; EDI will remember stored module index.
    BufferStoreDword [%LinkerOffsBuf],EDI        ; Number of members will be updated later.
    BufferStoreDword [%LinkerIndBuf], EDI        ; Number of symbols will be patched later.
.46:CMP ESI,EDX
    JNB .49:                                     ; If no more symbols.
    CMP EDI,[ESI+PFLIBOMF_SYMBOL.ModIndex]
    JE .48:                                      ; Skip if module with index EDI already is in LinkerOffsBuf.
    MOV EDI,[ESI+PFLIBOMF_SYMBOL.ModIndex]
    MOV EAX,[ESI+PFLIBOMF_SYMBOL.ModPtr]
    BufferStoreDword [%LinkerOffsBuf],EAX
.48:ADD ESI,SIZE#PFLIBOMF_SYMBOL
    JMP .46:
.49:BufferRetrieve [%SymbolBuf]
    MOV EAX,ECX                                  ; Size of SymbolBuf.
    MOV EDI,SIZE# PFLIBOMF_SYMBOL
    SUB EDX,EDX
    DIV EDI                                      ; Get number of records in SymbolBuf to EAX.
    ShellSort ESI,EAX,EDI,.BySymbolName:         ; <b>Sort by symbol names alphabetically</b>.
    BufferRetrieve [%SymbolBuf]                  ; Reread the sorted symbol buffer.
    LEA EDX,[ESI+ECX]                            ; End of PFLIBOMF_SYMBOL records, sorted alphabetically.
.50:CMP ESI,EDX
    JNB .60:                                     ; If no more symbols.
    MOV EAX,[ESI+PFLIBOMF_SYMBOL.ModIndex]
    BufferStoreWord [%LinkerIndBuf],EAX          ; Index buffer and string buffer are kept synchronized.
    BufferStore [%StringBuf],[ESI+PFLIBOMF_SYMBOL.NamePtr],[ESI+PFLIBOMF_SYMBOL.NameSize]
    BufferStoreByte [%StringBuf],0               ; Terminating zero.
    ADD ESI,SIZE#PFLIBOMF_SYMBOL
    JMP .50:                                     ; The next symbol.
.60:BufferRetrieve [%LinkerOffsBuf]              ; Calculate Second Linker Member size to EAX.
    MOV EAX,ECX
    SHR ECX,2
    DEC ECX
    MOV [ESI],ECX                                ; Patch the number of member offsets in Second Linker Member.
    BufferRetrieve [%LinkerIndBuf]
    ADD EAX,ECX
    SHR ECX,1
    DEC ECX
    DEC ECX
    MOV [ESI],ECX                                ; Patch the number of symbol indexes in Second Linker Member.
    BufferRetrieve [%StringBuf]
    TEST CL,1
    JZ .63:
    BufferStoreByte [%StringBuf],0x0A            ; Word alignment of linker member.
    INC ECX
.63:ADD EAX,ECX                                  ; EAX is now the total size of Second Linker Member without header.
    LEA ESI,[%Header]                            ; Prepare Second Linker Member header.
    Invoke PflibcofInitHeader,ESI,EBX
    MOVB [ESI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Name],'/'
    LEA EDI,[ESI+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Size]
    StoD EDI                                     ; Store member body size EAX as decimal digits.
    BufferStore [%Linker2ndBuf],ESI,SIZE# PFLIBCOF_ARCHIVE_MEMBER_HEADER
    BufferRetrieve [%LinkerOffsBuf]
    BufferStore [%Linker2ndBuf],ESI,ECX
    BufferRetrieve [%LinkerIndBuf]
    BufferStore [%Linker2ndBuf],ESI,ECX
    BufferRetrieve [%StringBuf]
    BufferStore [%Linker2ndBuf],ESI,ECX
    ; Compile <b>Third Linker Member (Longnames)</b> to Linker3rdBuf.
    LEA EDX,[%Header]
    Invoke PflibcofInitHeader,EDX,EBX
    MOVW [EDX+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Name],'//'
    LEA EDI,[EDX+PFLIBCOF_ARCHIVE_MEMBER_HEADER.Size]
    BufferRetrieve [%LongnameBuf]
    TEST ECX
    JNZ .65:
    BufferStoreByte  [%LongnameBuf],0
    INC ECX
.65:TEST CL,1
    JZ .67:
    BufferStoreByte  [%LongnameBuf],0x0A
.67:BufferRetrieve  [%LongnameBuf]
    MOV EAX,ECX
    StoD EDI
    BufferStore [%Linker3rdBuf],EDX,SIZE# PFLIBCOF_ARCHIVE_MEMBER_HEADER
    BufferStore [%Linker3rdBuf],ESI,EAX
    BufferRetrieve [%Linker1stBuf]               ; Three linker members are now stored in buffers. Get their total size.
    LEA EAX,[8+ECX]                              ; Signature + First Linker Member size.
    BufferRetrieve [%Linker2ndBuf]
    ADD EAX,ECX                                  ; + Second Linker Member Size.
    BufferRetrieve [%Linker3rdBuf]
    LEA EDX,[EAX+ECX]                            ; EDX is now total word-aligned size of signature plus three linker members.
    BufferRetrieve [%Linker1stBuf]               ; It will be used to elevate offsets in the First and Second Linker Member.
    ADD ESI,SIZE# PFLIBCOF_ARCHIVE_MEMBER_HEADER ; Skip the header.
    LODSD                                        ; Number of symbols.
    MOV ECX,EAX
    BSWAP EAX                                    ; Number of symbols in the First linker member is big-endian.
    MOV [ESI-4],EAX
    JECXZ .80:
.70:LODSD
    ADD EAX,EDX                                  ; Elevate file offset.
    BSWAP EAX                                    ; File offsets in the First Linker Member are big-endian.
    MOV [ESI-4],EAX
    LOOP .70:
.80:BufferRetrieve [%Linker2ndBuf]
    ADD ESI,SIZE# PFLIBCOF_ARCHIVE_MEMBER_HEADER ; Skip the header.
    LODSD                                        ; Number of members.
    MOV ECX,EAX
    JECXZ .85:
.83:LODSD
    ADD EAX,EDX                                  ; Elevate file offset.
    MOV [ESI-4],EAX
    LOOP .83:
.85:; <b>Compile LIBCOF file to OutputStream</b>.
    MOV EDI,[%OutputStream]
    ; Store <b>LIBCOF signature</b>.
    StreamStoreDword EDI,0x72613C21              ; '!&lt;ar'
    StreamStoreDword EDI,0x0A3E6863              ; 'ch&gt;\n'
    ; Store three <b>Linker Members</b>.
    BufferRetrieve [%Linker1stBuf]
    StreamStore EDI,ESI,ECX
    BufferRetrieve [%Linker2ndBuf]
    StreamStore EDI,ESI,ECX
    BufferRetrieve [%Linker3rdBuf]
    StreamStore EDI,ESI,ECX
    ; Store all <b>COFF modules</b> copying from ModStream.
    StreamDump [%ModStream],.Restream:

PflibcofCompile.Restream:PROC1                                  ; Callback of StreamDump.
            StreamStore [%OutputStream],ESI,ECX
            RET
          ENDPROC1 PflibcofCompile.Restream:

PflibcofCompile.BySymbolName:PROC1                              ; Callback to compare symbol names.
              ; ESI and EDI points to two PFOMFLIB_SYMBOL records, whose .Name are being compared.
               XCHG ESI,EDI                      ; Ascending order.
               PUSH ECX                          ; This register must be preserved in callback.
                MOV ECX,[ESI+PFLIBOMF_SYMBOL.NameSize]
                MOV EDX,[EDI+PFLIBOMF_SYMBOL.NameSize]
                CMP ECX,EDX
                JBE .B2:
                MOV ECX,EDX
           .B2: JECXZ .B9:                       ; ECX is now the size of shorter name.
                PUSH ESI,EDI
                 MOV ESI,[ESI+PFLIBOMF_SYMBOL.NamePtr]
                 MOV EDI,[EDI+PFLIBOMF_SYMBOL.NamePtr]
                 REPE CMPSB
                POP EDI,ESI
                JA .B9:                          ; Orded of records is OK. Return with CF=0.
                JB .B5:
                ; When names match but have different sizes, the longer one goes latter.
                MOV ECX,[ESI+PFLIBOMF_SYMBOL.NameSize]
                CMP ECX,[EDI+PFLIBOMF_SYMBOL.NameSize]
                JAE .B9:                         ; Orded of reocrd is OK. return with CF=0.
           .B5:                                  ; Swap is required.
             %i %SETA SIZE# PFLIBOMF_SYMBOL / 4  ; Number of DWORDs in the record (four).
                %WHILE %i
                  LODSD
                  MOV EDX,[EDI]
                  STOSD
                  MOV [ESI-4],EDX
             %i   %SETA %i-1
                %ENDWHILE                        ; Perform the dword swap four times.
                STC                              ; CF=1 signalizes that swap took place.
           .B9:POP ECX
               RET
              ENDP1 PflibcofCompile.BySymbolName:

    ; <b>Free all temporary buffers</b>.
    Invoke EaBufferRelease::,[%Linker3rdBuf]
    Invoke EaBufferRelease::,[%Linker2ndBuf]
    Invoke EaBufferRelease::,[%Linker1stBuf]
    Invoke EaBufferRelease::,[%LinkerIndBuf]
    Invoke EaBufferRelease::,[%LinkerOffsBuf]
    Invoke EaBufferRelease::,[%LongnameBuf]
    Invoke EaBufferRelease::,[%StringBuf]
    Invoke EaBufferRelease::,[%SymbolBuf]
  EndProcedure PflibcofCompile
</pre>

<pre>
  ENDPROGRAM pflibcof
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
