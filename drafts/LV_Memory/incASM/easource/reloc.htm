<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='reloc.htm source file'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>reloc.htm source file</title>
</head>
<body class='EASOURCE' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>reloc.htm
<br/><i>Classes</i>
<br/><a href="#RELOC">RELOC</a>
<br/><i>Relocation types</i>
<br/><a href="#Reloc_I386">I386 (32bit)</a>
<br/><a href="#Reloc_X86_64">X86_64 (64bit)</a>
<br/><i>Encodings</i>
<br/><a href="#RelocEnc">RelocEnc</a>
<br/><i>Procedures</i>
<br/><a href="#RelocCombine">RelocCombine</a>
<br/><a href="#RelocPurge">RelocPurge</a>
<br/><a href="#RelocRelocInBuffer">RelocRelocInBuffer</a>
<br/><a href="#RelocReportUnresolved">RelocReportUnresolved</a>
<br/><a href="#RelocResolve">RelocResolve</a>
</h1>
<p>Structure <dfn>RELOC</dfn> describes relocation in <em>storage unit</em>, which is a word, dword or qword memory variable in emitted code|data.
<!---->The address, which the instruction refers to, is called <em>target</em>.</p>
<p>Relocations loaded at link-time from object files in formats OMF, COFF, ELF are converted by Pf<em>format</em>Load
<!---->to this united internal structure RELOC, which does not depend on CPU architecture (AMD64, x86, v86) neither on object-file format.</p>
<p>RELOC objects are kept in <code>SSS.RelocBuffer</code>. Their properties are:
<br/><code>RELOC.Status</code> specifies the type of relocation and the size of relocated storage unit.
<br/><code>RELOC.Org</code> represents the offset of the storage unit from the beginning of its section|segment, which is identified by
<code>RELOC.Section</code> (<strong>P</strong>).
<br/><code>RELOC.Symbol</code> specifies the target. It points to <a class="EXT" href="sym.htm#SYM">SYM
</a> representing the bottom of (perhaps external) segment or group (frame).
<br/><code>RELOC.Addend</code> represents addend (<strong>A</strong>) to the value (<strong>R</strong>) in storage unit,
<!---->which was left in instruction encoding by the assembler at asm-time (and which is pointed to by <code>RELOC.Org
</code>). Addend will be added to the storage unit when the relocation is resolved.
<br/>Frame of absolute relocation is the target's segment|group bottom, addend is zero.
<br/>Frame of relative relocation is RIP, i.e. address of the following instruction. Addend is the difference between the address of storage unit and RIP,
<!---->for instance -2 when a word unit is relocated and this word is the last field of JMPN in 16bit mode.
</p>
<dl><dt>Example of absolute relocation</dt><dd class="PRE"><!---->|[CODE]                    |[CODE] SEGMENT WIDTH=16
<!---->|  ...
<!---->|0021:BA[0000]             |       MOV DX,Label  ; Load DX with the offset of external symbol Label.
</dd><dd><code>RELOC.Section=[CODE], RELOC.Org=0x0022, RELOC.Addend=0, RELOC.Symbol=Label, RELOC.Status=relocWidth16+relocAbsVA</code></dd>
</dl><dl><dt>Example of relative relocation</dt><dd class="PRE"><!---->|[.text]                  |[.text] SEGMENT WIDTH=64
<!---->|  ...
<!---->|00000012:48C705(00000000)23010000 |  MOV [QData],0x123,DATA=QWORD,ADDR=REL ; Store immeditate constant to an external variable QData.
</dd><dd><code>RELOC.Section=[.text], RELOC.Org=0x00000015, RELOC.Addend=-8, RELOC.Symbol=QData, RELOC.Status=relocWidth64+relocRel</code></dd>
</dl>
<p>Addend is 0 in absolute relocations. In relative relocations it is the negative distance between RELOC.Org and the start
<!---->of the next instruction (rIP). Addend may be modified later in <a href="#RelocResolve">RelocResolve</a></p>
<p>Relocation of FAR pointers uses two RELOC records (one for the offset, other for the paragraph address of target).</p>
<p>For the relation between symbols and segments in &euro;ASM see <a class="EXT" href="sym.htm#SymSssBinding">SymSssBinding</a>.</p>
<p>RELOC records are created by &euro;ASM at asm-time by <a class="EXT" href="ii.htm#IiFlush">IiFlush
</a> when a machine instruction is assembled, and by <a class="EXT" href="exp.htm#ExpEvalData">ExpEvalData</a> or
<a class="EXT" href="exp.htm#ExpStoreInstr">ExpStoreInstr</a> when a data definition is assembled.
<br/>RELOC record are also created at link-time when OMF|COFF|ELF object files are loaded.</p>
<p>Relative intrasection relocations (iiRelocDispRIP and iiRelocImmRIP) are resolved immediately in <a class="EXT" href="ii.htm#IiFlush">IiFlush</a>.
<br/>Relative intrasegment relocations and absolute relocations of scalars are resolved in <a class="EXT" href="reloc.htm#RelocResolve">RelocResolve
</a> when sections are marshaled to their segment.
<br/>Other relocations between segments and external symbols are resolved by the linker of executable formats
<!---->(Pf<em>format</em>Compile) or they are converted and stored in object output files.</p>
<br class="CLEAR"/><p>&nbsp;</p>
<strong>Evolution of <code>RELOC.Org</code> in multiple data definition (e.g. <code> DD 2*DWORD aPointer</code>) at assembly time:</strong>
<ul><li>When an address symbol is referred as a data value in ordinal operand of <code>D</code> statement (see
<a class="EXT" href="exp.htm#ExpEvalData">ExpEvalData</a>), <code>RELOC.Org</code> is related
<!---->to the data emited by one ordinal operand, which is 0 unless the data are duplicated.
<br/>RELOC record(s) are stored to the RelocBuffer provided for ExpEvalData.
</li><li>After assembly of each <code>D</code>'s operand (see <a class="EXT" href="pseudo.htm#PseudoData">PseudoData
</a>), origin in RelocBuffer is elevated
<!----> by the size of so far emitted data, giving offset relative to the start of the statement.
<br/>Reloc record is then stored to <code>Stm.RelocBuffer
</code>, so the origin is now relative to <code>$</code>.
</li><li>After <a class="EXT" href="stm.htm#StmExecute">StmExecute</a> the assembled data are listed by
<a class="EXT" href="stm.htm#StmListing">StmListing</a>, <code>RELOC.Org</code> still related to <code>$</code>.
</li><li>Finally, data are flushed to the section using <a class="EXT" href="stm.htm#StmFlush">StmFlush
</a>. Records from <code>Stm.RelocBuffer</code> are elevated by <code>Stm.Offset
</code> and stored to <code>Sss.RelocBuffer</code> of the section which is specified in
<code>Stm.Section</code>.</li></ul>
<dl><dt>Example</dt><dd class="PRE"><!---->aData  D  D 5, 2*D aBssSymbol
<!---->; EuroAssembler creates two RELOC records with origins 4 and 8 in Stm.RelocBuffer.
<!---->; Origins will be elevated to OFFSET#aData+4, OFFSET#aData+8 in <a class="EXT" href="stm.htm#StmFlush">StmFlush</a>.
<!---->; RELOC.Symbol points to symbol <b>.bss</b> representing the bottom of target segment <code>[.bss]</code>.
</dd></dl>
<strong>Evolution of <code>RELOC.Org</code> at marshal time:</strong>
<ul><li>At the end of the last pass are all sections marshaled (linked) to their base segment,
<!---->symbols are elevated by the section offset. Relocations are then resolved by <a href="#RelocResolve">RelocResolve</a>, if possible.</li>
</ul>
<strong>Evolution of <code>RELOC.Org</code> at combine time:</strong>
<ul><li>Sections no longer exist at combine time. Symbols from combined public segments
<!---->are elevated in <a class="EXT" href="sss.htm#SssCombine">SssCombine</a>.</li>
</ul>
<strong>Evolution of <code>RELOC.Org</code> at link time:</strong>
<ul><li>When the segments are linked to an executable image and their VA is fixed, relocations are resolved by
<a href="#RelocResolve">RelocResolve</a>. If the program is in linkable object format (OMF, COFF, ELF),
<!---->unresolved relocations are converted and stored in the appropriate format to the output file.</li>
</ul>
<h3 id="Shortcuts">Calculation method shortcuts:</h3>
<p><strong>A</strong> represents the value left by the compiler in relocated storage unit (word|dword|qword).
<!---->It is visible in the dump column of program listing.
<br/>The process of resolving a relocation will replace
<strong>A</strong> with the new relocated value <strong>R</strong>.</p>
<p><strong>B</strong> represents the base address at which a shared object has been loaded
<!---->into memory during execution. Generally, a shared object is built
<!---->with a zero-base virtual address, but the execution address will be different.
<!---->In &euro;ASM it is specified by <code>PROGRAM ImageBase=</code>.</p>
<p><strong>G</strong> represents the offset into the global offset table at which
<!---->the relocation entry’s symbol will reside during execution.</p>
<p><strong>GOT</strong> represents the VA (virtual address) of the global offset table.</p>
<p><strong>L</strong> represents the place (section offset or address)
<!---->of the Procedure Linkage Table entry for a symbol.</p>
<p><strong>O</strong> represents the offset of the target symbol, whose index resides in the relocation entry,
<!---->from the bottom of its segment. It becomes VA when the segment is finally linked to executable image.</p>
<p><strong>P</strong> represents VA
<!---->of the storage unit (word|dword|qword) which is being relocated (computed using
<code>PFELF_REL.r_offset</code> alias <code>RELOC.Org+SEGMENT#RELOC.Section</code>.</p>
<p><strong>R</strong> is the final value which will be written to the storage unit instead of
<strong>A</strong> as the result of resolving the relocation. This value is visible in debugger and in hexadecimal dump of output file.</p>
<p><strong>S</strong> represents the value (VA) of the target symbol, whose index resides in the relocation entry,
<!---->i.e. <code>RELOC.Symbol</code> (its offset + bottom of its segment).
<!---->When the symbol is scalar, its segment is NULL and <strong>S</strong> is its absolute value.</p>
<p><strong>V</strong> is number of bytes (<code>0..5</code>) betweeen the end of relocated word|dword|qword
<!---->and start of the next instruction (rIP). It is nonzero only when the relocated storage unit
<!---->is not the last field in instruction encoding, e.g. in <code>ADCD [Symbol],0x11</code> assembled as
<code>8315[00000000]11</code> is V=1, W=4.</p>
<p><strong>W</strong> represents the width of the relocated storage unit (word|dword|qword) in bytes, i.e.
<code>2|4|8</code>.</p>
<p><strong>Z</strong> represents the size of the symbol whose index resides in the relocation entry (SIZE# of
<code>RELOC.Symbol</code>).</p>
<h3>Calculation of A by compilers</h3>
<p>If the relocation is <b>absolute</b>:
<br/>&nbsp; &nbsp; <strong>A=O</strong>, i.e. offset of target or its absolute value.</p>
<p>If the relocation is <b>relative</b>, compilers compute this value according to the output format:
<br/>&nbsp; &nbsp; <strong>A=0</strong> in COFF Microsoft format,
<br/>&nbsp; &nbsp; <strong>A=B-P-W-V</strong> in COFFD DJ GPP format,
<br/>&nbsp; &nbsp; <strong>A=-W-V</strong> in ELF format.</p>
<h3>Calculation of R by linkers</h3>
<p>The following tables show <strong>transformation of relocation types</strong> to
<code>RELOC.Status</code> and back, together with their calculation methods:</p>
<table id="Reloc_I386"><caption>Relocation types for machine i386 (PROGRAM WIDTH=32)</caption>
<tr><th colspan="2">Internal &euro;ASM format</th><th>COFF, COFFD</th><th>ELF, ELFX, ELFSO</th></tr>
<tr><th><a href="#RELOC">RELOC.Status</a><br/><code>reloc*</code></th><th>Calculation<br/>method</th>
<th><a class="EXT" href="pfcoff.htm#PFCOFF_RELOCATION">PFCOFF_RELOCATION.Type</a><br/><code>IMAGE_REL_I386_*</code></th>
<th><a class="EXT" href="pfelf.htm#PFELF_REL32">PFELF_REL32.r_type</a><br/><code>pfelfR_386_*</code></th></tr>
<tr><td><code>None</code></td><td>R=A</td><td>0 <code>ABSOLUTE</code></td><td>0|5 <code>NONE|COPY</code></td></tr>
<tr><td><code>Width16+AbsVA</code></td><td>R=S+A</td><td>1 <code>DIR16</code></td><td></td></tr>
<tr><td><code>Width16+Rel</code></td><td>R=S-P+A</td><td>2 <code>REL16</code></td><td></td></tr>
<tr><td><code>Width32+AbsVA</code></td><td>R=S+A</td><td>6 <code>DIR32</code></td><td>1 <code>32</code></td></tr>
<tr><td><code>Width32+AbsRVA</code></td><td>R=S-B+A</td><td>7 <code>DIR32NB</code></td><td></td></tr>
<tr><td><code>Width32+Rel</code></td><td>R=S-P</td><td>20 <code>REL32</code></td><td>                   </td></tr>
<tr><td><code>Width32+Rel+COFFD</code></td><td>R=S+A</td><td>20 <code>REL32</code></td><td></td></tr>
<tr><td><code>Width32+Rel+ELF</code></td><td>R=S-P+A</td><td></td><td>2 <code>PC32</code></td></tr>
<tr><td><code>Width32+GOT</code></td><td>R=G-P+A</td><td></td><td>3 <code>GOT32</code></td></tr>
<tr><td><code>Width32+PLT</code></td><td>R=L-P+A</td><td></td><td>4 <code>PLT32</code></td></tr>
<tr><td><code>Width32+Sym</code></td><td>R=S</td><td></td><td>6|7 <code>GLOB_DAT|JMP_SLOT</code></td></tr>
<tr><td><code>Width32+Dyn</code></td><td>R=B+A</td><td></td><td>8 <code>RELATIVE</code></td></tr>
<tr><td><code>Width32+GOToff</code></td><td>R=S-GOT+A</td><td></td><td>9 <code>GOTOFF</code></td></tr>
<tr><td><code>Width32+GOTrel</code></td><td>R=GOT-P+A</td><td></td><td>10 <code>GOTPC</code></td></tr>
</table>

<table id="Reloc_X86_64"><caption>Relocation types for machine x86-64 (PROGRAM WIDTH=64)</caption>
<tr><th colspan="2">Internal &euro;ASM format</th><th>COFF, COFFD</th><th>ELF, ELFX, ELFSO</th></tr>
<tr><th><a href="#RELOC">RELOC.Status</a><br/><code>reloc*</code></th><th>Calculation<br/>method</th>
<th><a class="EXT" href="pfcoff.htm#PFCOFF_RELOCATION">PFCOFF_RELOCATION.Type</a><br/><code>IMAGE_REL_AMD64_*</code></th>
<th><a class="EXT" href="pfelf.htm#PFELF_REL64">PFELF_REL64.r_type</a><br/><code>pfelfR_X86_64_*</code></th></tr>
<tr><td><code>None</code></td><td>R=A</td><td>0 <code>ABSOLUTE</code></td><td>0|5 <code>NONE|COPY</code></td></tr>
<tr><td><code>Width64+AbsVA</code></td><td>R=S+A</td><td>1 <code>ADDR64</code></td><td>1 <code>64</code></td></tr>
<tr><td><code>Width32+AbsVA</code></td><td>R=S+A</td><td>2 <code>ADDR32</code></td><td>10 <code>32</code></td></tr>
<tr><td><code>Width32+AbsRVA</code></td><td>R=S-B+A</td><td>3 <code>ADDR32NB</code></td><td></td></tr>
<tr><td><code>Width32+Rel</code></td><td>R=S-P+A</td><td>4 <code>REL32</code></td><td>2 <code>PC32</code></td></tr>
<tr><td><code>Width32+Rel+RelDist1</code></td><td>R=S-P+V+A</td><td>5 <code>REL32_1</code></td><td></td></tr>
<tr><td><code>Width32+Rel+RelDist2</code></td><td>R=S-P+V+A</td><td>6 <code>REL32_2</code></td><td></td></tr>
<tr><td><code>Width32+Rel+RelDist3</code></td><td>R=S-P+V+A</td><td>7 <code>REL32_3</code></td><td></td></tr>
<tr><td><code>Width32+Rel+RelDist4</code></td><td>R=S-P+V+A</td><td>8 <code>REL32_4</code></td><td></td></tr>
<tr><td><code>Width32+Rel+RelDist5</code></td><td>R=S-P+V+A</td><td>9 <code>REL32_5</code></td><td></td></tr>
<tr><td><code>Width32+GOT</code></td><td>R=G+A</td><td></td><td>3 <code>GOT32</code></td></tr>
<tr><td><code>Width32+PLT</code></td><td>R=L-P+A</td><td></td><td>4 <code>PLT32</code></td></tr>
<tr><td><code>Width64+Sym</code></td><td>R=S</td><td></td><td>6|7 <code>GLOB_DAT|JMP_SLOT</code></td></tr>
<tr><td><code>Width64+Dyn</code></td><td>R=B+A</td><td></td><td>8 <code>RELATIVE</code></td></tr>
<tr><td><code>Width64+GOToff</code></td><td>R=S-GOT+A</td><td></td><td>25 <code>GOTOFF64</code></td></tr>
<tr><td><code>Width32+GOTrel</code></td><td>R=GOT-P+A</td><td></td><td>26 <code>GOTPC32</code></td></tr>
</table>

<br class="CLEAR"/>
<pre>
      euroasm nowarn=2101
reloc PROGRAM FORMAT=COFF,MODEL=FLAT,WIDTH=32
      INCLUDEHEAD euroasm.htm, \  Interface (structures, symbols and macros) of other modules used in this source.
                  dict.htm,ea.htm,eaopt.htm,exp.htm,msg.htm,pf.htm,pgm.htm,pgmopt.htm,sss.htm,sym.htm
</pre><pre>
 reloc HEAD  ; Start of module interface.
</pre>
<dl id="RELOC"><dt><a href="#top">&uarr; RELOC</a></dt>
<dd><p>Relocation record used internally by EuroAssembler describes one relocation, i.e.
<!---->a WORD, DWORD or QWORD in emitted code/data which needs to be patched at link-time or at load-time.</p>

<p>Special reloc type <code>relocDisp8
</code> does not represent a real relocation but only a hint how to
<a class="EXT" href="../eadoc/#DumpDecoration">decorate the scaled disp8*N
</a> in listing, if nonzero. Other bits in RELOC.Status should be zero when disp8*N is used.</p>
</dd>
</dl><pre>
RELOC STRUC  ; Relocation record.
.OrgLow     D D ; <strong>P</strong>: Origin, i.e. offset of fixed memory object (word|dword|qword)
.OrgHigh    D D ;   relative from the beginning of the section which hosts the fixed object.
.Section    D D ; ^SSS section or segment whose .EmitBuffer contains the fixed object.
.Status     D D ; Relocation properties, see below.

.AddendLow  D D ; <strong>A</strong>: Value to be added to the relocated word|dword|qword.
.AddendHigh D D
.Symbol     D D ; ^SYM representing the bottom of target's segment or an external symbol.
            D D ; not used
        ENDSTRUC RELOC ; SIZE# RELOC = 32 = 20h
</pre>

<dl id="RelocEnc"><dt><a href="#top">&uarr; RelocEnc</a></dt>
<dd>Encoding of flags used in RELOC.Status.
<br/><code>relocTypeMask</code> identifies the fundamental, format-independent relocation type.
<br/><code>relocWidthMask</code> specifies if the relocated object is WORD|DWORD|QWORD (<strong>W</strong>).
<br/><code>relocExtAttr</code> is used when <a class="EXT" href="../eadoc/#Attributes">attribute</a>
<!---->is applied to an external object, and its evaluation needs to be postponed to the link-time.
<br/><code>relocRelDist</code> specifies an additional distance of the relocated object in 64bit mode (<strong>V</strong>).
<!---->It is nonzero when the relocated DWORD displacement in instruction encoding is followed
<!---->by immediate value, for instance <code>MOV [MemoryVar],ImmConstant</code>.
<!---->In this case RIP is not only an address of relocated DWORD displacement+4, but it is must be enlarged
<!---->by the value in relocRelDist (usually 1,4,5). The corresponding
<a class="EXT" href="pfcoff.htm#PFCOFF_RELOCATION">PFCOFF_RELOCATION.Type</a> is then 0x0005,0x0008,0x0009.
<blockquote>Some other linkers keep <a class="EXT" href="pfcoff.htm#PFCOFF_RELOCATION">PFCOFF_RELOCATION.Type
</a> at fixed value 0x0004 (IMAGE_REL_AMD64_REL32) and decrement the relocated object in COFF text by 1,4,5 instead.
<br/>&euro;ASM could also achieve this with decrementing RELOC.Addend by 1,4,5 and having the type fixed at 0x0004,
<!---->but I preferred keeping the relocated DWORD unchanged in COFF object code.</blockquote></dd>
</dl>

<pre>
                             ; <b>Fundamental relocation types</b>.
relocNone      = 0x0000_0000 ; No relocation, same as relocResolved.
relocPara      = 0x0000_0001 ; Base relocation of paragraph address related to ImageBase.
relocAbsVA     = 0x0000_0002 ; Absolute relocation of  VA of the target <code>RELOC.Symbol</code>.
relocAbsRVA    = 0x0000_0004 ; Absolute relocation of RVA of the target <code>RELOC.Symbol</code>.
relocRel       = 0x0000_0008 ; Relative relocation of  VA related to rIP. May be set together with relocELF,relocCOFFD.
relocFar       = 0x0000_0010 ; Far absolute relocation (16+16 or 16+32).
               ; 0x0000_0020 ; Reserved.
relocSym       = 0x0000_0040 ; Related to the symbol.
relocDyn       = 0x0000_0080 ; Related to the runtime ImageBase of shared object.
relocPLT       = 0x0000_0100 ; Adressed via Procedure Linkage Table.
relocGOT       = 0x0000_0200 ; Related to the Global Offset Table.
relocGOToff    = 0x0000_0400 ; Adressed via entry in Global Offset Table.
relocGOTrel    = 0x0000_0800 ; Relative relocation addressed via GOT.
               ; 0x0000_1000 ; Reserved.
               ; 0x0000_2000 ; Reserved.
relocTypeMask  = 0x0000_3FFF ; Relocation type. Only one flag may be set.
relocCOFFD     = 0x0000_4000 ; Relocation was loaded from COFFD (DJ GPP) module.
relocELF       = 0x0000_8000 ; Relocation was loaded from ELF module.
                             ; Evaluation of <b>external symbol attributes</b> postponed to the link time.
relocExtAttr   = 0x000F_0000 ; <a class="EXT" href="dict.htm#DictEnc">DictAttr*</a> (0..9) synchronized with <a class="EXT" href="exp.htm#ExpEnc">expExtAttr</a>.
                             ; <b>W: Width of relocated object</b>.
relocWidth16   = 0x0010_0000 ;  WORD in memory is relocated.
relocWidth32   = 0x0020_0000 ; DWORD in memory is relocated.
relocWidth64   = 0x0040_0000 ; QWORD in memory is relocated.
relocWidthMask = relocWidth16|relocWidth32|relocWidth64
                             ; <b>V: correction of RIP-relative relocation</b>.
relocRelDist   = 0x0700_0000 ; Additional distance of RIP-relative relocation in 64bit mode (0..5).
                             ; <b>Miscellaneous properties</b>.
relocDisp8N    = 0x7000_0000 ; Disp8*N shift factor 1..6. Pseudorelocation used to decorate dumped listing.
relocResolved  = 0x8000_0000 ; This relocation has been already resolved and should be ignored.
relocIgnore    = relocResolved | relocDisp8N ; Do not relocate anything.
</pre><pre>
  ENDHEAD reloc ; End of module interface.
</pre>

<dl id="RelocRelocInBuffer">
<dt><a href="#top">&uarr; RelocRelocInBuffer</a> Buffer, Delta</dt>
<dd><dfn>RelocRelocInBuffer</dfn> will relocate origin of each RELOC record in Buffer by Delta.</dd>
<dt>Input</dt>
<dd><b>Buffer</b> is pointer to <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> which should contain zero or more <a href="#RELOC">RELOC</a> objects.
<br/><b>Delta</b> is signed 32bit integer which will be added to .Org of each RELOC object in the buffer.</dd>
<dt>Output</dt>
<dd>The contents of Buffer is changed.</dd>
<dt>Error</dt>
<dd><b>-</b></dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfomf.htm#PfomfLoadDataBlock">PfomfLoadDataBlock</a>
<a class="EXT" href="pfomf.htm#PfomfLoadModule">PfomfLoadModule</a>
</dd>
</dl><pre>
RelocRelocInBuffer Procedure Buffer,Delta
    BufferRetrieve [%Buffer]
    JECXZ .90:
    MOV EAX,[%Delta]
    MOV EBX,SIZE#RELOC
    CDQ
.10:ADD [ESI+RELOC.OrgLow],EAX
    ADC [ESI+RELOC.OrgHigh],EDX
    ADD ESI,EBX
    SUB ECX,EBX
    JA .10:
.90:EndProcedure RelocRelocInBuffer
</pre>

<dl id="RelocPurge">
<dt><a href="#top">&uarr; RelocPurge</a> Pgm</dt>
<dd><dfn>RelocPurge</dfn> sorts relocations in all segments of a given Pgm by their RELOC.Org ascending and then removes resolved and duplicated records.
<br/>It is invoked at link time, after <a class="EXT" href="pgm.htm#PgmCombine">PgmCombine
</a> and <a class="EXT" href="sss.htm#SssCreateImplicit">SssCreateImplicit</a>.</dd>
<dt>Input</dt>
<dd><b>Pgm</b> is pointer to the linked <a class="EXT" href="pgm.htm#PGM">PGM</a>.</dd>
<dt>Output</dt>
<dd>Relocations in all segments are purged and sorted.</dd>
<dt>Error</dt>
<dd><b>-</b></dd>
<dt>Expands</dt>
<dd><a class="EXT" href="../maclib/sort32.htm#ShellSort">ShellSort</a></dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pf.htm#PfOutput">PfOutput</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
</dd>
</dl><pre>
RelocPurge    Procedure Pgm
TopOrig LocalVar                          ; Pointer to the original top of RelocBuffer (behind the last RELOC record).
Top     LocalVar                          ; Pointer to the current top of RelocBuffer (behind the last RELOC record).
TempBuf LocalVar                          ; ^Temporary buffer for relocations.
    Invoke EaBufferReserve::,%^PROC
    MOV [%TempBuf],EAX
    MOV EBX,[%Pgm]
    MOV EDX,SIZE# RELOC
    ListGetFirst [EBX+PGM.SssList]
    JZ .90:
.10:JNSt [EAX+SSS.Status],sssSegment,.80:
    XOR EBX,EBX                           ; Counter of RELOC records in %TempBuf.
    BufferClear [%TempBuf]
    BufferRetrieve [EAX+SSS.RelocBuffer]
    ADD ECX,ESI
.20:CMP ESI,ECX
    JNB .40:                              ; If there are no more relocations in segment EAX.
    JSt [ESI+RELOC.Status],relocIgnore,.30:
    BufferStore [%TempBuf],ESI,EDX
    INC EBX
.30:ADD ESI,EDX
    JMP .20:
.40:BufferClear [EAX+SSS.RelocBuffer]
    BufferRetrieve [%TempBuf]             ; Sort the array of EBX records.
;;    ShellSort ESI,EBX,EDX,MemberUpdate.SortByOrg::
    ShellSort ESI,EBX,EDX,SortByOrg::

    BufferRetrieve [%TempBuf]             ; Omit duplicated relocations.
    ADD ECX,ESI                           ; ESI..ECX is an array of sorted RELOC records.
.50:CMP ESI,ECX
    JNB .80:
    BufferStore [EAX+SSS.RelocBuffer],ESI,EDX
.60:LEA EDI,[ESI+EDX]                     ; The next records following ESI.
    CMP EDI,ECX
    JNB .80:
    Compare ESI,EDX,EDI,EDX               ; Compare, preserving all GPR.
    MOV ESI,EDI
    JE .60:
    JMP .50:
.80:ListGetNext EAX ; The next segment.
    JNZ .10:
.90:Invoke EaBufferRelease::,[%TempBuf]
    EndProcedure RelocPurge
</pre>

<dl id="RelocCombine">
<dt><a href="#top">&uarr; RelocCombine</a> Relocation, BaseProg</dt>
<dd><dfn>RelocCombine</dfn> will update the Relocation in BasePgm when segments and symbols have already been combined to the base program.
<br/>Intrasegment relative relocation between public homonymous segments is finally resolved here.</dd>
<dt>Input</dt>
<dd><b>Relocation</b> points to <a href="#RELOC">RELOC</a> object in the base program, as it was copied from linked module.
<br/><b>BaseProg</b>  is pointer to a <a class="EXT" href="pgm.htm#PGM">PGM</a> which it is linked to.</dd>
<dt>Output</dt>
<dd>Relocation members <code>.Org, .Section, .Addend, .Symbol</code> are updated.</dd>
<dt>Error</dt>
<dd><b>-</b></dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pgm.htm#PgmCombine">PgmCombine</a>
</dd>
</dl><pre>
RelocCombine Procedure Relocation, BaseProg
    MOV EBX,[%Relocation]
    MOV ECX,[EBX+RELOC.Status]
    JSt ECX,relocIgnore,.90:
    ; <b>Update <code>RELOC.Section:RELOC.Org</code></b>, i.e. position of the relocated storage unit (word|dword).
    MOV ESI,[EBX+RELOC.Section]                  ; ^SSS where the relocated object is located.
    MOV EAX,[ESI+SSS.BottomLow]                  ; Bottom of its combined segment might have been elevated.
    MOV EDX,[ESI+SSS.BottomHigh]
    MOV EDI,[ESI+SSS.SegmPtr]
    SUB EAX,[EDI+SSS.BottomLow]
    SBB EDX,[EDI+SSS.BottomHigh]
    ADD [EBX+RELOC.OrgLow],EAX
    ADC [EBX+RELOC.OrgHigh],EDX
    MOV [EBX+RELOC.Section],EDI
    AND ECX,relocTypeMask
    Dispatch ECX,relocAbsVA,relocAbsRVA,relocRel
    JMP .90:

.relocRel:
    MOV EDI,[EBX+RELOC.Symbol]
    TEST EDI
    JZ .90:
    MOV ECX,[EDI+SYM.Section]
    JECXZ .90:
    MOV EAX,[ECX+SSS.BottomLow]
    MOV EDX,[ECX+SSS.BottomHigh]
    MOV EDI,[EDI+SYM.SymbPtr]
    TEST EDI
    JZ .90:
    MOV ECX,[EDI+SYM.Section]
    JECXZ .90:
    SUB EAX,[ECX+SSS.BottomLow]
    SBB EDX,[ECX+SSS.BottomHigh]
    ADD [EBX+RELOC.AddendLow],EAX
    ADC [EBX+RELOC.AddendHigh],EDX
    MOV [EBX+RELOC.Symbol],EDI
    JMP .90:

.relocAbsRVA:
.relocAbsVA:
    MOV ECX,[EBX+RELOC.Symbol]
    JECXZ .90:
    MOV EDI,[ECX+SYM.Section]
    TEST EDI
    JZ .90:
    MOV EAX,[EDI+SSS.BottomLow]
    MOV EDX,[EDI+SSS.BottomHigh]
    ADD [EBX+RELOC.AddendLow],EAX
    ADC [EBX+RELOC.AddendHigh],EDX
.90:
   EndProcedure RelocCombine
</pre>

<dl id="RelocReportUnresolved">
<dt><a href="#top">&uarr; RelocReportUnresolved</a> Pgm</dt>
<dd>Procedure reports warning W3835 <em>Relocation at [!1S]:!2H is not resolvable in this program format
</em> for each unresolved relocation left in program %Pgm.</dd>
<dt>Input</dt>
<dd><b>Pgm</b> points to a linked <a class="EXT" href="pgm.htm#PGM">PGM</a></dd>
<dt>Output</dt>
<dd>-</dd>
<dt>Error</dt>
<dd><b>W3835</b> if any relocation if left unresolved.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfbin.htm#PfbinCompile">PfbinCompile</a>
<a class="EXT" href="pfboot.htm#PfbootCompile">PfbootCompile</a>
<a class="EXT" href="pfcom.htm#PfcomCompile">PfcomCompile</a>
<a class="EXT" href="pfmz.htm#PfmzCompile">PfmzCompile</a>
</dd>
</dl><pre>
RelocReportUnresolved Procedure Pgm
    MOV EBX,[%Pgm]
    BufferRetrieve [EBX+PGM.SegOrdBuffer]               ; ESI,ECX is now an array of pointers to SSS.
    SAR ECX,2
    JZ .90:
.10:LODSD
    JNSt [EAX+SSS.Status],sssSegment,.80:
    PUSH ECX,ESI
      BufferRetrieve [EAX+SSS.RelocBuffer]
      JECXZ .70:
.20:  MOV EAX,[ESI+RELOC.Status]
      JSt EAX,relocResolved|relocIgnore,.60:
      JSt EAX,relocAbsVA,.E7733:
      JSt EAX,relocRel  ,.E7734:
.E7735: Msg '7735',EAX,[ESI+RELOC.Section],[ESI+RELOC.OrgLow] ; Relocation type 0x!1W at [!2S]:!3H is not resolvable in this program format.
      JMPS .60:
.E7733: Msg '7733',[ESI+RELOC.Section],[ESI+RELOC.OrgLow] ; Absolute relocation at [!2S]:!3H is not resolvable in this program format.
      JMPS .60:
.E7734: Msg '7734',[ESI+RELOC.Section],[ESI+RELOC.OrgLow] ; Relative relocation at [!2S]:!3H is not resolvable in this program format.
.60:  ADD ESI,SIZE# RELOC
      SUB ECX,SIZE# RELOC
      JA .20:
.70:POP ESI,ECX
.80:LOOP .10:
.90:EndProcedure RelocReportUnresolved
</pre>

<dl id="RelocResolve">
<dt><a href="#top">&uarr; RelocResolve</a> Relocation, BaseProgram</dt>
<dd><dfn>RelocResolve</dfn> will try to resolve one relocation.
<br/>It is invoked when an executable program is combined and linked, external symbols resolved and
<!-->virtual segment addresses fixed in image.</dd>
<dt>Input</dt>
<dd><b>Relocation</b> = ^RELOC.
<br/><b>BaseProgram</b> is pointer to <a class="EXT" href="pgm.htm#PGM">PGM</a>.</dd>
<dt>Output</dt>
<dd>Data or code in SSS.EmitBuffer is modified:
<!--> emited relocable Word/Dword/Fword pointed to by <code>Relocation.Org
</code> is fixed up according to the relocation type.
<br/>Resolved relocation in is then marked as relocResolved.</dd>
<dt>Error</dt>
<dd>-</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="sss.htm#SssRelocResolve">SssRelocResolve</a>
</dd>
</dl><pre>
RelocResolve Procedure Relocation, BaseProgram
EmittedBottom      LocalVar ; Pointer to the bottom of emitted data (withing the contents of SSS.EmitBuffer).
EmittedPtr         LocalVar ; Pointer to the relocated word|dword in emitted data. Always between %EmittedBottom and %EmittedTop.
EmittedTop         LocalVar ; Pointer to the top of emitted data.
Pgmopt             LocalVar ; Program format and model (cache copy of Program.Pgmopt.Status).
     MOV EBX,[%BaseProgram]
     MOV EAX,[EBX+PGM.Pgmopt.Status]
     MOV [%Pgmopt],EAX
     MOV ESI,[%Relocation]
     MOV EAX,[ESI+RELOC.Section]
     BufferRetrieve [EAX+SSS.EmitBuffer]         ; <b>Mark borders of emitted contents</b>.
     ADD ECX,ESI
     MOV [%EmittedBottom],ESI
     MOV [%EmittedTop],ECX
     MOV ESI,[%Relocation]
.20: MOV EDI,[ESI+RELOC.Status]
     JSt EDI,relocIgnore,.90:                    ; If relocation ESI is already resolved or if its a Disp8*N decoration.
     JNSt EDI,relocWidthMask,.E7920:             ; Invalid fixup at [!1S]:!2Hh.
     MOV EBX,[ESI+RELOC.Symbol]                  ; Target symbol of the relocation ESI.
     TEST EBX
     JNZ .30:
     MOV EAX,pgmoptFormatMask
     AND EAX,[%Pgmopt]
     Dispatch AL,pgmoptBIN,pgmoptBOOT
     JMP .90:
.pgmoptBIN:
.pgmoptBOOT:                                     ; Formats which allow absolute scalar target.
     SetSt [ESI+RELOC.Status],relocResolved
     JMP .50:
.30: MOV ECX,[EBX+SYM.SymbPtr]                   ; Is the external symbol EBX really resolved to public symbol ECX?
     JECXZ .40:
     MOV [ESI+RELOC.Symbol],ECX                  ; Replace external target EBX with its resolved public/PLT symbol ECX.
     MOV EBX,ECX
.40: MOV ECX,[EBX+SYM.Section]
     MOV EAX,relocExtAttr
     MOV EDX,ECX                                 ; Prepare registers for handlers of postponed attribute evaluation.
     AND EAX,EDI
     JZ .dictAttrNONE:
     SHR EAX,16                                  ; Convert relocExtAttr to <a class="EXT" href="dict.htm#DictEnc">dictAttr*</a> (1..9).
     Dispatch AL,dictAttrOFFSET,dictAttrSECTION,dictAttrSEGMENT,dictAttrGROUP,dictAttrPARA,dictAttrSIZE,dictAttrTYPE
     JMP .dictAttrNONE:                          ; Target symbol is not attributed.
     ; Attribute dispatching: EBX=^SYM target (never 0), ECX=EDX=^SSS of target symbol (0 when scalar), ESI=^RELOC.
.Scalar:
     XOR EBX,EBX
     JMP .50:
.dictAttrSECTION:
     JECXZ .Scalar:
     JSt [EBX+SYM.Status],symSe,.dictAttrNONE:
.D2: MOV EAX,[EDX+SSS.SymPtr]                     ; Replace the target symbol with section's bottom symbol (symSe).
     MOV [ESI+RELOC.Symbol],EAX
     JMP .dictAttrNONE:
.dictAttrSEGMENT:
     JECXZ .Scalar:
     MOV ECX,[EDX+SSS.SegmPtr]
     JECXZ .D2:
     MOV EDX,ECX
     JMP .D2:                                     ; Replace the target symbol with segment's bottom symbol (symSe).
.dictAttrGROUP:
     JECXZ .Scalar:
     MOV ECX,[EDX+SSS.SegmPtr]
     JECXZ .D2:
     MOV EDX,ECX
     MOV ECX,[EDX+SSS.GroupPtr]
     JECXZ .D2:
     MOV EDX,ECX
     JMP .D2:                                     ; Replace the target symbol with group's bottom symbol (symSe).
.dictAttrPARA:
     RstSt [ESI+RELOC.Status],relocTypeMask
     SetSt [ESI+RELOC.Status],relocPara
     JMP .dictAttrGROUP:                          ; Replace the target symbol with group's bottom symbol (symSe).
.dictAttrOFFSET:
     MOV EAX,[EBX+SYM.OffsetLow]
     JMP .D4:

.dictAttrTYPE:
     MOV EAX,[EBX+SYM.Status]
     AND EAX,symTypeMask
     JMP .D4:
.dictAttrSIZE:
     MOV EAX,[EBX+SYM.Size]
.D4: XOR EDX,EDX
     ADD [ESI+RELOC.AddendLow],EAX
     ADC [ESI+RELOC.AddendHigh],EDX
     MOV [ESI+RELOC.Symbol],EDX
.dictAttrNONE:
     MOV EDI,[ESI+RELOC.Status]
     MOV EBX,[ESI+RELOC.Symbol]
     XOR ECX,ECX
     TEST EBX                                    ; EBX=0 when the target is scalar.
     JZ .50:
     MOV ECX,[EBX+SYM.Section]
     ; EBX=^SYM of target (0 when ExtAttr resolved to scalar), ECX=^SSS of target symbol (0 when scalar),  ESI=^RELOC, EDI=RELOC.Status
.50: MOV EAX,[ESI+RELOC.AddendLow]
     MOV EDX,[ESI+RELOC.AddendHigh]
     AND EDI,relocTypeMask
     Dispatch EDI,relocRel,relocAbsVA,relocFar,relocPara,relocAbsRVA
.E7735:Msg '7735',EDI,[ESI+RELOC.Section],[ESI+RELOC.OrgLow] ; Relocation type 0x!1W at [!2S]:!3H is not resolvable in this program format.
     JMP .90::
.E7925: Msg '7925',EBX,[ESI+RELOC.Section],[ESI+RELOC.OrgLow] ; Unresolved relocation of symbol "!1S" at [!2S]:!3Hh.
     JMP .90::
.E7920: Msg '7920',[ESI+RELOC.Section],[ESI+RELOC.OrgLow] ; Invalid fixup at [!1S]:!2Hh.
     JMP .90::
.E7927: Msg '7927',[ESI+RELOC.Section],[ESI+RELOC.OrgLow] ; Relocation offset out of 4GB range at [!1S]:!2Hh.
     JMP .90::

.relocRel: ; <b>Relative relocation</b> is resolvable if target segment ECX=[ESI+RELOC.Section] or if both are sssLinked.
    MOV EDI,[ESI+RELOC.Section]
    CMP ECX,EDI
    JE .R2:                                              ; Resolve if intrasegment relative relocation.
    JNSt [%Pgmopt],pgmoptImage,.90:                ; Do not resolve when this format may be combined and linked into image later.
    TEST EBX
    JZ .R4:
    JNSt [EDI+SSS.Status],sssLinked,.90::          ; Ignore when this segment is not linked yet.
    JECXZ .R2:                                           ; Scalar target segment is treated as sssLinked.
    JNSt [ECX+SSS.Status],sssLinked,.90::          ; Ignore when target segment is not linked yet.
.R2:SetSt [ESI+RELOC.Status],relocResolved
    ADD EAX,[EBX+SYM.OffsetLow]
    ADC EDX,[EBX+SYM.OffsetHigh]
    JECXZ .R4:
    ADD EAX,[ECX+SSS.BottomLow]
    ADC EDX,[ECX+SSS.BottomHigh]
.R4:SUB EAX,[ESI+RELOC.OrgLow]
    SBB EDX,[ESI+RELOC.OrgHigh]
    MOV ECX,[ESI+RELOC.Section]
    SUB EAX,[ECX+SSS.BottomLow]
    SBB EDX,[ECX+SSS.BottomHigh]
    JMP .Apply:

.relocAbsRVA:  ; <b>ImageBase absolute relocation</b> is resolvable only if target segment is sssLinked.
     MOV EDI,[%BaseProgram]
     SUB EAX,[EDI+PGM.Pgmopt.ImageBaseLow]
     SBB EDX,[EDI+PGM.Pgmopt.ImageBaseHigh]
.relocAbsVA:   ; <b>Absolute relocation</b> is resolvable only if target segment ECX is sssLinked or none (scalar).
     CALL .Abs:
     JC .90::
     SetSt [ESI+RELOC.Status],relocResolved
     JMP .Apply:

.relocFar:  ; <b>Far relocation</b> is resolvable only if target segment is sssLinked.
            ; It is resolved in two parts: as relocAbsVA (relocWidth16|relocWidth32) and then as relocPara (relocWidth16).
     CALL .Abs:
     JC .90::
     JMP .Apply:                                 ; Apply the relocation of offset portion, then continue with relocPara.

.relocPara:  ; Frame of <b>paragraph relocation</b> is the group (if exists) or the segment of target.
     JECXZ .P2:
     JNSt [ECX+SSS.Status],sssLinked,.90:: ; Ignore when the target segment ECX is not linked yet.
     MOV EBX,[ECX+SSS.SymPtr]
     MOV ECX,[ECX+SSS.GroupPtr]
     JECXZ .P2:
     MOV EBX,[ECX+SSS.SymPtr]
.P2: MOV [ESI+RELOC.Symbol],EBX
     TEST EBX
     JZ .P3:
     MOV ECX,[EBX+SYM.Section]
     CMPB [%Pgmopt],pgmoptMZ                     ; Paragraph relocation in MZ executable will be fixed-up by the DOS loader.
     JE .P4:                                     ; relocPara will be finally resolved in PfmzCompile.
.P3: SetSt [ESI+RELOC.Status],relocResolved      ; Formats BIN, BOOT, COM are fixed-up here to the absolute paragraph address.
.P4: JECXZ .Apply:
     JSt [%Pgmopt],pgmoptFLAT,.Apply:            ; Let segment part 0 in FLAT model.
     ADD EAX,[ECX+SSS.BottomLow]
     ADC EDX,[ECX+SSS.BottomHigh]
     JNZ .E7927:                                 ; Relocation offset out of 4GB range at [!1S]:!2Hh.
;.P6: ;TEST AL,0x0F
     ;Msg cc=NZ,'7928',ECX,[ESI+RELOC.Section],[ESI+RELOC.OrgLow] ; Unaligned target segment [!1S] of relocation at [!2S]:!3Hh.
     SHR EAX,4                                   ; Convert linear address to the paragraph address.
     ;JMP .Apply:

.Apply:                                          ; Add EDX:EAX to the relocated object identified at ESI+RELOC.Org.
     MOV EDI,[ESI+RELOC.OrgLow]
     MOV ECX,[ESI+RELOC.OrgHigh]
     ADD EDI,[%EmittedBottom]                    ; EDI=pointer to the relocated object in emitted code.
     ADC ECX,0
     JNZ .E7927:                                 ; Relocation offset out of 4GB range at [!1S]:!2Hh.
     MOV ECX,[ESI+RELOC.Status]
     MOV EBX,ECX
     AND ECX,relocWidthMask
     SHR ECX,19                                  ; Convert relocWidth to the object size 2,4,8.
     ADD ECX,EDI
     CMP ECX,[%EmittedTop]                       ; Check if RELOC.Org is within the emitted code.
     JA .E7920:                                  ; Invalid fixup at [!1S]:!2Hh.
     JNSt EBX,relocWidth64,.W32:
     ADD [EDI+0],EAX
     ADC [EDI+4],EDX
     JMP .60:
.W32:JNSt EBX,relocWidth32,.W16:
     ADD [EDI],EAX
     JMP .60:
.W16:JNSt EBX,relocWidth16,.60:                  ; Ignore relocations with undefined width.
     ADD [EDI],AX
.60: JNSt [ESI+RELOC.Status],relocFar,.90::
     ADD [ESI+RELOC.OrgLow],2                    ; Offset part of FAR relocation was resolved. Change relocFar to unresolved 16bit relocPara.
     JNSt [ESI+RELOC.Status],relocWidth32,.70:
     ADD [ESI+RELOC.OrgLow],2                    ; Only when relocFar is 16:32 bits.
.70: RstSt [ESI+RELOC.Status],relocFar+relocWidth32+relocWidth64
     SetSt [ESI+RELOC.Status],relocPara+relocWidth16 ; Change relocFar to relocPara.
     JMP .20:                                    ; Resolve the same relocFar record once again, this time as relocPara.

.Abs:PROC1  ; Input: ESI=^RELOC; EBX=^SYM; ECX=^SSS; EDX:EAX=addend. Output: CF=not resolvable; EDX:EAX updated, ready to apply; EDI clobbered.
     JECXZ .A5:                                  ; Resolvable if EBX is a scalar symbol.
     JSt [ECX+SSS.Status],sssLinked,.A1:
     STC                                         ; Do not resolve when target segment is not linked yet.
     JMP .A9:
.A1: JSt [%Pgmopt],pgmoptFLAT,.A3:               ; Use VA (segment bottom) instead of SVA in FLAT model.
     MOV EDI,[ECX+SSS.GroupPtr]                  ; Frame whose PARA# is assumed in segment register.
     TEST EDI
     JNZ .A2:
     MOV EDI,[ECX+SSS.BottomLow]                 ; Bottom of segment ECX is used as the addressing frame.
     AND EDI,0x0000_000F
     ADD EAX,EDI
     ADC EDX,0
     JMP .A5:
.A2: SUB EAX,[EDI+SSS.BottomLow]
     SBB EDX,[EDI+SSS.BottomHigh]
     MOV EDI,[EDI+SSS.BottomLow]                 ; Bottom of group EDI is used as the addressing frame.
     AND EDI,0x0000_000F                         ; Correction when the relocation frame assumed in segment register was not OWORD aligned.
     ADD EAX,EDI
     ADC EDX,0
.A3: ADD EAX,[ECX+SSS.BottomLow]
     ADC EDX,[ECX+SSS.BottomHigh]
.A5: TEST EBX
   ;  STC
     JZ .A9:
     ADD EAX,[EBX+SYM.OffsetLow]
     ADC EDX,[EBX+SYM.OffsetHigh]
   ;  CLC
.A9: RET
     ENDP1 .Abs:

.90:EndProcedure RelocResolve
</pre>

<pre>
 ENDPROGRAM reloc
</pre><!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
