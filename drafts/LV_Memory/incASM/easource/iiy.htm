<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='iiy.htm source file'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>iiy.htm source file</title>
</head>
<body class='EASOURCE' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>iiy.htm
<br/><i>Enumerations</i>
<br/><a href="#IiyList">IiyList</a>
<br/><i>Instruction handlers</i><br/><span class="ILIST">
<a href="#IiyCLEVICT0">CLEVICT0</a>
<a href="#IiyCLEVICT1">CLEVICT1</a>
<a href="#IiyDELAY">DELAY</a>
<a href="#IiySPFLT">SPFLT</a>
<a href="#IiyTZCNTI">TZCNTI</a>
<a href="#IiyVADDNPD">VADDNPD</a>
<a href="#IiyVADDNPS">VADDNPS</a>
<a href="#IiyVADDSETSPS">VADDSETSPS</a>
<a href="#IiyVANDNPD">VANDNPD</a>
<a href="#IiyVANDNPS">VANDNPS</a>
<a href="#IiyVANDPD">VANDPD</a>
<a href="#IiyVANDPS">VANDPS</a>
<a href="#IiyVBLENDPD">VBLENDPD</a>
<a href="#IiyVBLENDPS">VBLENDPS</a>
<a href="#IiyVBLENDVPD">VBLENDVPD</a>
<a href="#IiyVBLENDVPS">VBLENDVPS</a>
<a href="#IiyVCVTFXPNTDQ2PS">VCVTFXPNTDQ2PS</a>
<a href="#IiyVCVTFXPNTPD2DQ">VCVTFXPNTPD2DQ</a>
<a href="#IiyVCVTFXPNTPD2UDQ">VCVTFXPNTPD2UDQ</a>
<a href="#IiyVCVTFXPNTPS2DQ">VCVTFXPNTPS2DQ</a>
<a href="#IiyVCVTFXPNTPS2UDQ">VCVTFXPNTPS2UDQ</a>
<a href="#IiyVCVTFXPNTUDQ2PS">VCVTFXPNTUDQ2PS</a>
<a href="#IiyVEXP223PS">VEXP223PS</a>
<a href="#IiyVEXP2PD">VEXP2PD</a>
<a href="#IiyVEXP2PS">VEXP2PS</a>
<a href="#IiyVFIXUPNANPD">VFIXUPNANPD</a>
<a href="#IiyVFIXUPNANPS">VFIXUPNANPS</a>
<a href="#IiyVGMAXABSPS">VGMAXABSPS</a>
<a href="#IiyVGMAXPD">VGMAXPD</a>
<a href="#IiyVGMAXPS">VGMAXPS</a>
<a href="#IiyVGMINPD">VGMINPD</a>
<a href="#IiyVGMINPS">VGMINPS</a>
<a href="#IiyVLDDQU">VLDDQU</a>
<a href="#IiyVLDMXCSR">VLDMXCSR</a>
<a href="#IiyVLDQQU">VLDQQU</a>
<a href="#IiyVLOADUNPACKHD">VLOADUNPACKHD</a>
<a href="#IiyVLOADUNPACKHPD">VLOADUNPACKHPD</a>
<a href="#IiyVLOADUNPACKHPS">VLOADUNPACKHPS</a>
<a href="#IiyVLOADUNPACKHQ">VLOADUNPACKHQ</a>
<a href="#IiyVLOADUNPACKLD">VLOADUNPACKLD</a>
<a href="#IiyVLOADUNPACKLPD">VLOADUNPACKLPD</a>
<a href="#IiyVLOADUNPACKLPS">VLOADUNPACKLPS</a>
<a href="#IiyVLOADUNPACKLQ">VLOADUNPACKLQ</a>
<a href="#IiyVLOG2PS">VLOG2PS</a>
<a href="#IiyVMASKMOVDQU">VMASKMOVDQU</a>
<a href="#IiyVMASKMOVPD">VMASKMOVPD</a>
<a href="#IiyVMASKMOVPS">VMASKMOVPS</a>
<a href="#IiyVORPD">VORPD</a>
<a href="#IiyVORPS">VORPS</a>
<a href="#IiyVPACKSSDW">VPACKSSDW</a>
<a href="#IiyVPACKSSWB">VPACKSSWB</a>
<a href="#IiyVPACKSTOREHD">VPACKSTOREHD</a>
<a href="#IiyVPACKSTOREHPD">VPACKSTOREHPD</a>
<a href="#IiyVPACKSTOREHPS">VPACKSTOREHPS</a>
<a href="#IiyVPACKSTOREHQ">VPACKSTOREHQ</a>
<a href="#IiyVPACKSTORELD">VPACKSTORELD</a>
<a href="#IiyVPACKSTORELPD">VPACKSTORELPD</a>
<a href="#IiyVPACKSTORELPS">VPACKSTORELPS</a>
<a href="#IiyVPACKSTORELQ">VPACKSTORELQ</a>
<a href="#IiyVPACKUSDW">VPACKUSDW</a>
<a href="#IiyVPACKUSWB">VPACKUSWB</a>
<a href="#IiyVPADCD">VPADCD</a>
<a href="#IiyVPADDSETCD">VPADDSETCD</a>
<a href="#IiyVPADDSETSD">VPADDSETSD</a>
<a href="#IiyVPALIGNR">VPALIGNR</a>
<a href="#IiyVPAND">VPAND</a>
<a href="#IiyVPANDD">VPANDD</a>
<a href="#IiyVPANDN">VPANDN</a>
<a href="#IiyVPANDND">VPANDND</a>
<a href="#IiyVPANDNQ">VPANDNQ</a>
<a href="#IiyVPANDQ">VPANDQ</a>
<a href="#IiyVPAVGB">VPAVGB</a>
<a href="#IiyVPAVGW">VPAVGW</a>
<a href="#IiyVPBLENDD">VPBLENDD</a>
<a href="#IiyVPBLENDVB">VPBLENDVB</a>
<a href="#IiyVPBLENDW">VPBLENDW</a>
<a href="#IiyVPBROADCASTMB2Q">VPBROADCASTMB2Q</a>
<a href="#IiyVPBROADCASTMW2D">VPBROADCASTMW2D</a>
<a href="#IiyVPCMPB">VPCMPB</a>
<a href="#IiyVPCMPD">VPCMPD</a>
<a href="#IiyVPCMPEQB">VPCMPEQB</a>
<a href="#IiyVPCMPEQD">VPCMPEQD</a>
<a href="#IiyVPCMPEQQ">VPCMPEQQ</a>
<a href="#IiyVPCMPEQUB">VPCMPEQUB</a>
<a href="#IiyVPCMPEQUD">VPCMPEQUD</a>
<a href="#IiyVPCMPEQUQ">VPCMPEQUQ</a>
<a href="#IiyVPCMPEQUW">VPCMPEQUW</a>
<a href="#IiyVPCMPEQW">VPCMPEQW</a>
<a href="#IiyVPCMPFALSEB">VPCMPFALSEB</a>
<a href="#IiyVPCMPFALSED">VPCMPFALSED</a>
<a href="#IiyVPCMPFALSEQ">VPCMPFALSEQ</a>
<a href="#IiyVPCMPFALSEUB">VPCMPFALSEUB</a>
<a href="#IiyVPCMPFALSEUD">VPCMPFALSEUD</a>
<a href="#IiyVPCMPFALSEUQ">VPCMPFALSEUQ</a>
<a href="#IiyVPCMPFALSEUW">VPCMPFALSEUW</a>
<a href="#IiyVPCMPFALSEW">VPCMPFALSEW</a>
<a href="#IiyVPCMPGTB">VPCMPGTB</a>
<a href="#IiyVPCMPGTD">VPCMPGTD</a>
<a href="#IiyVPCMPGTQ">VPCMPGTQ</a>
<a href="#IiyVPCMPGTW">VPCMPGTW</a>
<a href="#IiyVPCMPLEB">VPCMPLEB</a>
<a href="#IiyVPCMPLED">VPCMPLED</a>
<a href="#IiyVPCMPLEQ">VPCMPLEQ</a>
<a href="#IiyVPCMPLEUB">VPCMPLEUB</a>
<a href="#IiyVPCMPLEUD">VPCMPLEUD</a>
<a href="#IiyVPCMPLEUQ">VPCMPLEUQ</a>
<a href="#IiyVPCMPLEUW">VPCMPLEUW</a>
<a href="#IiyVPCMPLEW">VPCMPLEW</a>
<a href="#IiyVPCMPLTB">VPCMPLTB</a>
<a href="#IiyVPCMPLTD">VPCMPLTD</a>
<a href="#IiyVPCMPLTQ">VPCMPLTQ</a>
<a href="#IiyVPCMPLTUB">VPCMPLTUB</a>
<a href="#IiyVPCMPLTUD">VPCMPLTUD</a>
<a href="#IiyVPCMPLTUQ">VPCMPLTUQ</a>
<a href="#IiyVPCMPLTUW">VPCMPLTUW</a>
<a href="#IiyVPCMPLTW">VPCMPLTW</a>
<a href="#IiyVPCMPNEQB">VPCMPNEQB</a>
<a href="#IiyVPCMPNEQD">VPCMPNEQD</a>
<a href="#IiyVPCMPNEQQ">VPCMPNEQQ</a>
<a href="#IiyVPCMPNEQUB">VPCMPNEQUB</a>
<a href="#IiyVPCMPNEQUD">VPCMPNEQUD</a>
<a href="#IiyVPCMPNEQUQ">VPCMPNEQUQ</a>
<a href="#IiyVPCMPNEQUW">VPCMPNEQUW</a>
<a href="#IiyVPCMPNEQW">VPCMPNEQW</a>
<a href="#IiyVPCMPNLEB">VPCMPNLEB</a>
<a href="#IiyVPCMPNLED">VPCMPNLED</a>
<a href="#IiyVPCMPNLEQ">VPCMPNLEQ</a>
<a href="#IiyVPCMPNLEUB">VPCMPNLEUB</a>
<a href="#IiyVPCMPNLEUD">VPCMPNLEUD</a>
<a href="#IiyVPCMPNLEUQ">VPCMPNLEUQ</a>
<a href="#IiyVPCMPNLEUW">VPCMPNLEUW</a>
<a href="#IiyVPCMPNLEW">VPCMPNLEW</a>
<a href="#IiyVPCMPNLTB">VPCMPNLTB</a>
<a href="#IiyVPCMPNLTD">VPCMPNLTD</a>
<a href="#IiyVPCMPNLTQ">VPCMPNLTQ</a>
<a href="#IiyVPCMPNLTUB">VPCMPNLTUB</a>
<a href="#IiyVPCMPNLTUD">VPCMPNLTUD</a>
<a href="#IiyVPCMPNLTUQ">VPCMPNLTUQ</a>
<a href="#IiyVPCMPNLTUW">VPCMPNLTUW</a>
<a href="#IiyVPCMPNLTW">VPCMPNLTW</a>
<a href="#IiyVPCMPQ">VPCMPQ</a>
<a href="#IiyVPCMPTRUEB">VPCMPTRUEB</a>
<a href="#IiyVPCMPTRUED">VPCMPTRUED</a>
<a href="#IiyVPCMPTRUEQ">VPCMPTRUEQ</a>
<a href="#IiyVPCMPTRUEUB">VPCMPTRUEUB</a>
<a href="#IiyVPCMPTRUEUD">VPCMPTRUEUD</a>
<a href="#IiyVPCMPTRUEUQ">VPCMPTRUEUQ</a>
<a href="#IiyVPCMPTRUEUW">VPCMPTRUEUW</a>
<a href="#IiyVPCMPTRUEW">VPCMPTRUEW</a>
<a href="#IiyVPCMPUB">VPCMPUB</a>
<a href="#IiyVPCMPUD">VPCMPUD</a>
<a href="#IiyVPCMPUQ">VPCMPUQ</a>
<a href="#IiyVPCMPUW">VPCMPUW</a>
<a href="#IiyVPCMPW">VPCMPW</a>
<a href="#IiyVPCONFLICTD">VPCONFLICTD</a>
<a href="#IiyVPCONFLICTQ">VPCONFLICTQ</a>
<a href="#IiyVPERM2F128">VPERM2F128</a>
<a href="#IiyVPERM2I128">VPERM2I128</a>
<a href="#IiyVPERMB">VPERMB</a>
<a href="#IiyVPERMD">VPERMD</a>
<a href="#IiyVPERMF32X4">VPERMF32X4</a>
<a href="#IiyVPERMI2B">VPERMI2B</a>
<a href="#IiyVPERMI2D">VPERMI2D</a>
<a href="#IiyVPERMI2PD">VPERMI2PD</a>
<a href="#IiyVPERMI2PS">VPERMI2PS</a>
<a href="#IiyVPERMI2Q">VPERMI2Q</a>
<a href="#IiyVPERMI2W">VPERMI2W</a>
<a href="#IiyVPERMILPD">VPERMILPD</a>
<a href="#IiyVPERMILPS">VPERMILPS</a>
<a href="#IiyVPERMPD">VPERMPD</a>
<a href="#IiyVPERMPS">VPERMPS</a>
<a href="#IiyVPERMQ">VPERMQ</a>
<a href="#IiyVPERMT2B">VPERMT2B</a>
<a href="#IiyVPERMT2D">VPERMT2D</a>
<a href="#IiyVPERMT2PD">VPERMT2PD</a>
<a href="#IiyVPERMT2PS">VPERMT2PS</a>
<a href="#IiyVPERMT2Q">VPERMT2Q</a>
<a href="#IiyVPERMT2W">VPERMT2W</a>
<a href="#IiyVPERMW">VPERMW</a>
<a href="#IiyVPHADDD">VPHADDD</a>
<a href="#IiyVPHADDSW">VPHADDSW</a>
<a href="#IiyVPHADDW">VPHADDW</a>
<a href="#IiyVPHSUBD">VPHSUBD</a>
<a href="#IiyVPHSUBSW">VPHSUBSW</a>
<a href="#IiyVPHSUBW">VPHSUBW</a>
<a href="#IiyVPLZCNTD">VPLZCNTD</a>
<a href="#IiyVPLZCNTQ">VPLZCNTQ</a>
<a href="#IiyVPMADD231D">VPMADD231D</a>
<a href="#IiyVPMADD233D">VPMADD233D</a>
<a href="#IiyVPMADD52HUQ">VPMADD52HUQ</a>
<a href="#IiyVPMADD52LUQ">VPMADD52LUQ</a>
<a href="#IiyVPMADDUBSW">VPMADDUBSW</a>
<a href="#IiyVPMASKMOVD">VPMASKMOVD</a>
<a href="#IiyVPMASKMOVQ">VPMASKMOVQ</a>
<a href="#IiyVPMOVB2M">VPMOVB2M</a>
<a href="#IiyVPMOVD2M">VPMOVD2M</a>
<a href="#IiyVPMOVDB">VPMOVDB</a>
<a href="#IiyVPMOVDW">VPMOVDW</a>
<a href="#IiyVPMOVM2B">VPMOVM2B</a>
<a href="#IiyVPMOVM2D">VPMOVM2D</a>
<a href="#IiyVPMOVM2Q">VPMOVM2Q</a>
<a href="#IiyVPMOVM2W">VPMOVM2W</a>
<a href="#IiyVPMOVMSKB">VPMOVMSKB</a>
<a href="#IiyVPMOVQ2M">VPMOVQ2M</a>
<a href="#IiyVPMOVQB">VPMOVQB</a>
<a href="#IiyVPMOVQD">VPMOVQD</a>
<a href="#IiyVPMOVQW">VPMOVQW</a>
<a href="#IiyVPMOVSDB">VPMOVSDB</a>
<a href="#IiyVPMOVSDW">VPMOVSDW</a>
<a href="#IiyVPMOVSQB">VPMOVSQB</a>
<a href="#IiyVPMOVSQD">VPMOVSQD</a>
<a href="#IiyVPMOVSQW">VPMOVSQW</a>
<a href="#IiyVPMOVSWB">VPMOVSWB</a>
<a href="#IiyVPMOVSXBD">VPMOVSXBD</a>
<a href="#IiyVPMOVSXBQ">VPMOVSXBQ</a>
<a href="#IiyVPMOVSXBW">VPMOVSXBW</a>
<a href="#IiyVPMOVSXDQ">VPMOVSXDQ</a>
<a href="#IiyVPMOVSXWD">VPMOVSXWD</a>
<a href="#IiyVPMOVSXWQ">VPMOVSXWQ</a>
<a href="#IiyVPMOVUSDB">VPMOVUSDB</a>
<a href="#IiyVPMOVUSDW">VPMOVUSDW</a>
<a href="#IiyVPMOVUSQB">VPMOVUSQB</a>
<a href="#IiyVPMOVUSQD">VPMOVUSQD</a>
<a href="#IiyVPMOVUSQW">VPMOVUSQW</a>
<a href="#IiyVPMOVUSWB">VPMOVUSWB</a>
<a href="#IiyVPMOVW2M">VPMOVW2M</a>
<a href="#IiyVPMOVWB">VPMOVWB</a>
<a href="#IiyVPMOVZXBD">VPMOVZXBD</a>
<a href="#IiyVPMOVZXBQ">VPMOVZXBQ</a>
<a href="#IiyVPMOVZXBW">VPMOVZXBW</a>
<a href="#IiyVPMOVZXDQ">VPMOVZXDQ</a>
<a href="#IiyVPMOVZXWD">VPMOVZXWD</a>
<a href="#IiyVPMOVZXWQ">VPMOVZXWQ</a>
<a href="#IiyVPMULDQ">VPMULDQ</a>
<a href="#IiyVPMULHD">VPMULHD</a>
<a href="#IiyVPMULHRSW">VPMULHRSW</a>
<a href="#IiyVPMULHUD">VPMULHUD</a>
<a href="#IiyVPMULHUW">VPMULHUW</a>
<a href="#IiyVPMULHW">VPMULHW</a>
<a href="#IiyVPMULLD">VPMULLD</a>
<a href="#IiyVPMULLQ">VPMULLQ</a>
<a href="#IiyVPMULLW">VPMULLW</a>
<a href="#IiyVPMULTISHIFTQB">VPMULTISHIFTQB</a>
<a href="#IiyVPOR">VPOR</a>
<a href="#IiyVPORD">VPORD</a>
<a href="#IiyVPORQ">VPORQ</a>
<a href="#IiyVPREFETCH0">VPREFETCH0</a>
<a href="#IiyVPREFETCH1">VPREFETCH1</a>
<a href="#IiyVPREFETCH2">VPREFETCH2</a>
<a href="#IiyVPREFETCHE0">VPREFETCHE0</a>
<a href="#IiyVPREFETCHE1">VPREFETCHE1</a>
<a href="#IiyVPREFETCHE2">VPREFETCHE2</a>
<a href="#IiyVPREFETCHENTA">VPREFETCHENTA</a>
<a href="#IiyVPREFETCHNTA">VPREFETCHNTA</a>
<a href="#IiyVPROLD">VPROLD</a>
<a href="#IiyVPROLQ">VPROLQ</a>
<a href="#IiyVPROLVD">VPROLVD</a>
<a href="#IiyVPROLVQ">VPROLVQ</a>
<a href="#IiyVPRORD">VPRORD</a>
<a href="#IiyVPRORQ">VPRORQ</a>
<a href="#IiyVPRORVD">VPRORVD</a>
<a href="#IiyVPRORVQ">VPRORVQ</a>
<a href="#IiyVPSBBD">VPSBBD</a>
<a href="#IiyVPSBBRD">VPSBBRD</a>
<a href="#IiyVPSUBRD">VPSUBRD</a>
<a href="#IiyVPSUBRSETBD">VPSUBRSETBD</a>
<a href="#IiyVPSUBSETBD">VPSUBSETBD</a>
<a href="#IiyVPTERNLOGD">VPTERNLOGD</a>
<a href="#IiyVPTERNLOGQ">VPTERNLOGQ</a>
<a href="#IiyVPTESTMB">VPTESTMB</a>
<a href="#IiyVPTESTMD">VPTESTMD</a>
<a href="#IiyVPTESTMQ">VPTESTMQ</a>
<a href="#IiyVPTESTMW">VPTESTMW</a>
<a href="#IiyVPTESTNMB">VPTESTNMB</a>
<a href="#IiyVPTESTNMD">VPTESTNMD</a>
<a href="#IiyVPTESTNMQ">VPTESTNMQ</a>
<a href="#IiyVPTESTNMW">VPTESTNMW</a>
<a href="#IiyVPUNPCKHBW">VPUNPCKHBW</a>
<a href="#IiyVPUNPCKHDQ">VPUNPCKHDQ</a>
<a href="#IiyVPUNPCKHQDQ">VPUNPCKHQDQ</a>
<a href="#IiyVPUNPCKHWD">VPUNPCKHWD</a>
<a href="#IiyVPUNPCKLBW">VPUNPCKLBW</a>
<a href="#IiyVPUNPCKLDQ">VPUNPCKLDQ</a>
<a href="#IiyVPUNPCKLQDQ">VPUNPCKLQDQ</a>
<a href="#IiyVPUNPCKLWD">VPUNPCKLWD</a>
<a href="#IiyVPXOR">VPXOR</a>
<a href="#IiyVPXORD">VPXORD</a>
<a href="#IiyVPXORQ">VPXORQ</a>
<a href="#IiyVRANGEPD">VRANGEPD</a>
<a href="#IiyVRANGEPS">VRANGEPS</a>
<a href="#IiyVRANGESD">VRANGESD</a>
<a href="#IiyVRANGESS">VRANGESS</a>
<a href="#IiyVRCP14PD">VRCP14PD</a>
<a href="#IiyVRCP14PS">VRCP14PS</a>
<a href="#IiyVRCP14SD">VRCP14SD</a>
<a href="#IiyVRCP14SS">VRCP14SS</a>
<a href="#IiyVRCP23PS">VRCP23PS</a>
<a href="#IiyVRCP28PD">VRCP28PD</a>
<a href="#IiyVRCP28PS">VRCP28PS</a>
<a href="#IiyVRCP28SD">VRCP28SD</a>
<a href="#IiyVRCP28SS">VRCP28SS</a>
<a href="#IiyVRCPSS">VRCPSS</a>
<a href="#IiyVREDUCEPD">VREDUCEPD</a>
<a href="#IiyVREDUCEPS">VREDUCEPS</a>
<a href="#IiyVREDUCESD">VREDUCESD</a>
<a href="#IiyVREDUCESS">VREDUCESS</a>
<a href="#IiyVRNDFXPNTPD">VRNDFXPNTPD</a>
<a href="#IiyVRNDFXPNTPS">VRNDFXPNTPS</a>
<a href="#IiyVRNDSCALEPD">VRNDSCALEPD</a>
<a href="#IiyVRNDSCALEPS">VRNDSCALEPS</a>
<a href="#IiyVRNDSCALESD">VRNDSCALESD</a>
<a href="#IiyVRNDSCALESS">VRNDSCALESS</a>
<a href="#IiyVROUNDPD">VROUNDPD</a>
<a href="#IiyVROUNDPS">VROUNDPS</a>
<a href="#IiyVROUNDSD">VROUNDSD</a>
<a href="#IiyVROUNDSS">VROUNDSS</a>
<a href="#IiyVRSQRT14PD">VRSQRT14PD</a>
<a href="#IiyVRSQRT14PS">VRSQRT14PS</a>
<a href="#IiyVRSQRT14SD">VRSQRT14SD</a>
<a href="#IiyVRSQRT14SS">VRSQRT14SS</a>
<a href="#IiyVRSQRT23PS">VRSQRT23PS</a>
<a href="#IiyVRSQRT28PD">VRSQRT28PD</a>
<a href="#IiyVRSQRT28PS">VRSQRT28PS</a>
<a href="#IiyVRSQRT28SD">VRSQRT28SD</a>
<a href="#IiyVRSQRT28SS">VRSQRT28SS</a>
<a href="#IiyVRSQRTPS">VRSQRTPS</a>
<a href="#IiyVRSQRTSS">VRSQRTSS</a>
<a href="#IiyVSCALEFPD">VSCALEFPD</a>
<a href="#IiyVSCALEFPS">VSCALEFPS</a>
<a href="#IiyVSCALEFSD">VSCALEFSD</a>
<a href="#IiyVSCALEFSS">VSCALEFSS</a>
<a href="#IiyVSCALEPS">VSCALEPS</a>
<a href="#IiyVSQRTPD">VSQRTPD</a>
<a href="#IiyVSQRTPS">VSQRTPS</a>
<a href="#IiyVSQRTSD">VSQRTSD</a>
<a href="#IiyVSQRTSS">VSQRTSS</a>
<a href="#IiyVSTMXCSR">VSTMXCSR</a>
<a href="#IiyVSUBRPD">VSUBRPD</a>
<a href="#IiyVSUBRPS">VSUBRPS</a>
<a href="#IiyVUNPCKHPD">VUNPCKHPD</a>
<a href="#IiyVUNPCKHPS">VUNPCKHPS</a>
<a href="#IiyVUNPCKLPD">VUNPCKLPD</a>
<a href="#IiyVUNPCKLPS">VUNPCKLPS</a>
<a href="#IiyVXORPD">VXORPD</a>
<a href="#IiyVXORPS">VXORPS</a>
</span><!--IiyAList-->
</h1>
<dl id="IiyHandlers"><dt><a href="#top">&uarr; IiyHandlers</a> </dt>
<dd> assemble VEX-encodable <b>AVX</b> machine instructions.</dd>
<dt>See also</dt><dd><a class="EXT" href="ii.htm#IiHandlers">IiHandlers</a>,
<a class="EXT" href="../eadoc/links.htm#IntelVol2">[IntelVol2]</a>
<a class="EXT" href="../eadoc/links.htm#IntelAVX512">[IntelAVX512]</a>.</dd>
</dl><pre>
iiy PROGRAM FORMAT=COFF,MODEL=FLAT,WIDTH=32,MAXPASSES=64
    INCLUDEHEAD euroasm.htm, \  Interface (structures, symbols and macros) of other modules used in this source.
                ea.htm,eaopt.htm,exp.htm,ii.htm,msg.htm,pgm.htm,pgmopt.htm,sss.htm,stm.htm,sym.htm
</pre><br class="CLEAR"/><pre>
iiy HEAD ; Start of module interface.
</pre>

<dl id="IiyList"><dt><a href="#top">&uarr; %IiyList</a></dt><dd> enumerates machine instructions
<!---->of this family which &euro;ASM can assemble.
<br/>Each instruction declared in <code>%IiyList</code> requires the corresponding
<a href="#IiyHandlers">handler</a> in this file.</dd>
<dt>See also</dt><dd><a class="EXT" href="dict.htm#DictLookupIi">DictLookupIi</a></dd></dl><pre>
%IiyList %SET \
VANDPS, \
VANDNPS, \
VORPS, \
VXORPS, \
VANDPD, \
VANDNPD, \
VORPD, \
VXORPD, \
VSQRTSS, \
VSQRTSD, \
VSQRTPS, \
VSQRTPD, \
VRCP14SS, \
VRCP14SD, \
VRCP14PS, \
VRCP14PD, \
VRSQRT14SS, \
VRSQRT14SD, \
VRSQRT14PS, \
VRSQRT14PD, \
VRCP28SS, \
VRCP28SD, \
VRCP28PS, \
VRCP28PD, \
VRSQRT28SS, \
VRSQRT28SD, \
VRSQRT28PS, \
VRSQRT28PD, \
VEXP2PS, \
VEXP2PD, \
VPMOVUSWB, \
VPMOVUSDB, \
VPMOVUSQB, \
VPMOVUSDW, \
VPMOVUSQW, \
VPMOVUSQD, \
VPMOVSWB, \
VPMOVSDB, \
VPMOVSQB, \
VPMOVSDW, \
VPMOVSQW, \
VPMOVSQD, \
VPMOVWB, \
VPMOVDB, \
VPMOVQB, \
VPMOVDW, \
VPMOVQW, \
VPMOVQD, \
VPMOVSXBD, \
VPMOVSXBQ, \
VPMOVSXWD, \
VPMOVSXWQ, \
VPMOVSXDQ, \
VPMOVSXBW, \
VPMOVZXBW, \
VPMOVZXBD, \
VPMOVZXBQ, \
VPMOVZXWD, \
VPMOVZXWQ, \
VPMOVZXDQ, \
VPMULDQ, \
VPMULHRSW, \
VPMULHUW, \
VPMULHW, \
VPMULLD, \
VPMULLQ, \
VPMULLW, \
VPAVGB, \
VPAVGW, \
VPMASKMOVD, \
VPMASKMOVQ, \
VMASKMOVPS, \
VMASKMOVPD, \
VMASKMOVDQU, \
VPMOVMSKB, \
VPBLENDW, \
VPBLENDD, \
VBLENDPS, \
VBLENDPD, \
VBLENDVPS, \
VBLENDVPD, \
VPBLENDVB, \
VLDDQU, \
VLDQQU, \
VLDMXCSR, \
VSTMXCSR, \
VRSQRTSS, \
VRCPSS, \
VRSQRTPS, \
VRCPPS, \
VUNPCKLPS, \
VUNPCKHPS, \
VUNPCKLPD, \
VUNPCKHPD, \
VPUNPCKLBW, \
VPUNPCKLWD, \
VPUNPCKLDQ, \
VPUNPCKLQDQ, \
VPUNPCKHBW, \
VPUNPCKHWD, \
VPUNPCKHDQ, \
VPUNPCKHQDQ, \
VPACKSSWB, \
VPACKSSDW, \
VPACKUSWB, \
VPACKUSDW, \
VSCALEFSS, \
VSCALEFSD, \
VSCALEFPS, \
VSCALEFPD, \
VSCALEPS, \
VRNDSCALESS, \
VRNDSCALESD, \
VRNDSCALEPS, \
VRNDSCALEPD, \
VROUNDSS, \
VROUNDSD, \
VROUNDPS, \
VROUNDPD, \
VPMADDUBSW, \
VPMADD52LUQ, \
VPMADD52HUQ, \
VPHADDW, \
VPHADDD, \
VPHADDSW, \
VPHSUBW, \
VPHSUBD, \
VPHSUBSW, \
VPAND, \
VPANDD, \
VPANDQ, \
VPOR, \
VPORD, \
VPORQ, \
VPANDN, \
VPANDND, \
VPANDNQ, \
VPXOR, \
VPXORD, \
VPXORQ, \
VRANGESS, \
VRANGESD, \
VRANGEPS, \
VRANGEPD, \
VREDUCESS, \
VREDUCESD, \
VREDUCEPS, \
VREDUCEPD, \
VPRORVQ, \
VPRORVD, \
VPROLVD, \
VPROLVQ, \
VPRORD, \
VPROLD, \
VPRORQ, \
VPROLQ, \
VPERMI2B, \
VPERMI2D, \
VPERMI2Q, \
VPERMI2PS, \
VPERMI2PD, \
VPERMI2W, \
VPERMT2B, \
VPERMT2W, \
VPERMT2D, \
VPERMT2Q, \
VPERMT2PS, \
VPERMT2PD, \
VPERMB, \
VPERMW, \
VPERMD, \
VPERMQ, \
VPERMPS, \
VPERMPD, \
VPERMILPS, \
VPERMILPD, \
VPERM2F128, \
VPERM2I128, \
VPTESTMB, \
VPTESTMW, \
VPTESTMD, \
VPTESTMQ, \
VPTESTNMB, \
VPTESTNMW, \
VPTESTNMD, \
VPTESTNMQ, \
VPTERNLOGD, \
VPTERNLOGQ, \
VPALIGNR, \
VPCMPB, \
VPCMPUB, \
VPCMPW, \
VPCMPUW, \
VPCMPD, \
VPCMPUD, \
VPCMPQ, \
VPCMPUQ, \
VPCMPEQB, \
VPCMPLTB, \
VPCMPLEB, \
VPCMPFALSEB, \
VPCMPNEQB, \
VPCMPNLTB, \
VPCMPNLEB, \
VPCMPTRUEB, \
VPCMPEQUB, \
VPCMPLTUB, \
VPCMPLEUB, \
VPCMPFALSEUB, \
VPCMPNEQUB, \
VPCMPNLTUB, \
VPCMPNLEUB, \
VPCMPTRUEUB, \
VPCMPEQW, \
VPCMPLTW, \
VPCMPLEW, \
VPCMPFALSEW, \
VPCMPNEQW, \
VPCMPNLTW, \
VPCMPNLEW, \
VPCMPTRUEW, \
VPCMPEQUW, \
VPCMPLTUW, \
VPCMPLEUW, \
VPCMPFALSEUW, \
VPCMPNEQUW, \
VPCMPNLTUW, \
VPCMPNLEUW, \
VPCMPTRUEUW, \
VPCMPEQD, \
VPCMPLTD, \
VPCMPLED, \
VPCMPFALSED, \
VPCMPNEQD, \
VPCMPNLTD, \
VPCMPNLED, \
VPCMPTRUED, \
VPCMPEQUD, \
VPCMPLTUD, \
VPCMPLEUD, \
VPCMPFALSEUD, \
VPCMPNEQUD, \
VPCMPNLTUD, \
VPCMPNLEUD, \
VPCMPTRUEUD, \
VPCMPEQQ, \
VPCMPLTQ, \
VPCMPLEQ, \
VPCMPFALSEQ, \
VPCMPNEQQ, \
VPCMPNLTQ, \
VPCMPNLEQ, \
VPCMPTRUEQ, \
VPCMPEQUQ, \
VPCMPLTUQ, \
VPCMPLEUQ, \
VPCMPFALSEUQ, \
VPCMPNEQUQ, \
VPCMPNLTUQ, \
VPCMPNLEUQ, \
VPCMPTRUEUQ, \
VPCMPGTW, \
VPCMPGTD, \
VPCMPGTQ, \
VPCMPGTB, \
VPMOVM2B, \
VPMOVM2W, \
VPMOVM2D, \
VPMOVM2Q, \
VPMOVB2M, \
VPMOVW2M, \
VPMOVD2M, \
VPMOVQ2M, \
VPBROADCASTMW2D, \
VPBROADCASTMB2Q, \
VPCONFLICTD, \
VPCONFLICTQ, \
VPMULTISHIFTQB, \
VLOADUNPACKLD, \
VLOADUNPACKLPS, \
VLOADUNPACKHD, \
VLOADUNPACKHPS, \
VLOADUNPACKLQ, \
VLOADUNPACKLPD, \
VLOADUNPACKHQ, \
VLOADUNPACKHPD, \
VPACKSTORELD, \
VPACKSTORELPS, \
VPACKSTOREHD, \
VPACKSTOREHPS, \
VPACKSTORELQ, \
VPACKSTORELPD, \
VPACKSTOREHQ, \
VPACKSTOREHPD, \
VCVTFXPNTUDQ2PS, \
VCVTFXPNTDQ2PS, \
VCVTFXPNTPS2UDQ, \
VCVTFXPNTPS2DQ, \
VCVTFXPNTPD2UDQ, \
VCVTFXPNTPD2DQ, \
VRNDFXPNTPS, \
VRNDFXPNTPD, \
VPERMF32X4, \
VPADCD, \
VPADDSETCD, \
VPSBBD, \
VPSUBRSETBD, \
VPSUBSETBD, \
VPSUBRD, \
VPSBBRD, \
VPMULHUD, \
VPMULHD, \
VFIXUPNANPS, \
VPMADD231D, \
VADDNPS, \
VADDNPD, \
VPADDSETSD, \
VGMAXABSPS, \
VGMINPS, \
VGMAXPS, \
VSUBRPS, \
VADDSETSPS, \
VSUBRPD, \
VGMINPD, \
VGMAXPD, \
VFIXUPNANPD, \
VLOG2PS, \
VEXP223PS, \
VRCP23PS, \
VRSQRT23PS, \
VPLZCNTD, \
VPLZCNTQ, \
VPMADD233D, \
VPREFETCHENTA, \
VPREFETCH0, \
VPREFETCH1, \
VPREFETCH2, \
VPREFETCHE0, \
VPREFETCHE1, \
VPREFETCHE2, \
VPREFETCHNTA, \
CLEVICT0, \
CLEVICT1, \
DELAY, \
SPFLT, \
TZCNTI, \
<!--IiyList-->
;
</pre><pre>
  ENDHEAD iiy ; End of module interface.
</pre>

<dl id="IiyVANDPS">
<dt><a href="#IiyHandlers">&uarr; VANDPS</a></dt>
<dd>Bitwise Logical AND of Packed Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VANDPS xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.0F 54 /r 
</td></tr>
<tr><th>VANDPS ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.0F 54 /r 
</td></tr>
<tr><th>VANDPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.0F.W0 54 /r
</td></tr>
<tr><th>VANDPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.0F.W0 54 /r 
</td></tr>
<tr><th>VANDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.0F.W0 54 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,logical</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wps</dd>
<dt>Opcode</dt>
<dd>0x0F54 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5650.htm">t5650</a>
</dd>
</dl><pre>
IiyVANDPS:: PROC
    IiEmitOpcode 0x54
.op:IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.0F, EVEX.NDS.128.0F.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.0F, EVEX.NDS.256.0F.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.0F.W0
    RET
  ENDP IiyVANDPS::
</pre>

<dl id="IiyVANDNPS">
<dt><a href="#IiyVANDPS">&uarr; VANDNPS</a></dt>
<dd>Bitwise Logical AND NOT of Packed Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VANDNPS xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.0F 55 /r 
</td></tr>
<tr><th>VANDNPS ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.0F 55 /r 
</td></tr>
<tr><th>VANDNPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.0F.W0 55 /r 
</td></tr>
<tr><th>VANDNPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.0F.W0 55 /r 
</td></tr>
<tr><th>VANDNPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.0F.W0 55 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,logical</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wps</dd>
<dt>Opcode</dt>
<dd>0x0F55 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5650.htm">t5650</a>
</dd>
</dl><pre>
IiyVANDNPS:: PROC
    IiEmitOpcode 0x55
    JMP IiyVANDPS.op:
  ENDP IiyVANDNPS::
</pre>

<dl id="IiyVORPS">
<dt><a href="#IiyVANDPS">&uarr; VORPS</a></dt>
<dd>Bitwise Logical OR of Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VORPS xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.0F 56 /r 
</td></tr>
<tr><th>VORPS ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.0F 56 /r 
</td></tr>
<tr><th>VORPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.0F.W0 56 /r 
</td></tr>
<tr><th>VORPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.0F.W0 56 /r 
</td></tr>
<tr><th>VORPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.0F.W0 56 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,logical</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wps</dd>
<dt>Opcode</dt>
<dd>0x0F56 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5650.htm">t5650</a>
</dd>
</dl><pre>
IiyVORPS:: PROC
    IiEmitOpcode 0x56
    JMP IiyVANDPS.op:
  ENDP IiyVORPS::
</pre>

<dl id="IiyVXORPS">
<dt><a href="#IiyVANDPS">&uarr; VXORPS</a></dt>
<dd>Bitwise Logical XOR for Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VXORPS xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.0F.WIG 57 /r
</td></tr>
<tr><th>VXORPS ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.0F.WIG 57 /r
</td></tr>
<tr><th>VXORPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.0F.W0 57 /r 
</td></tr>
<tr><th>VXORPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.0F.W0 57 /r 
</td></tr>
<tr><th>VXORPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.0F.W0 57 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,logical</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wps</dd>
<dt>Opcode</dt>
<dd>0x0F57 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5650.htm">t5650</a>
</dd>
</dl><pre>
IiyVXORPS:: PROC
    IiEmitOpcode 0x57
    JMP IiyVANDPS.op:
  ENDP IiyVXORPS::
</pre>

<dl id="IiyVANDPD">
<dt><a href="#IiyHandlers">&uarr; VANDPD</a></dt>
<dd>Bitwise Logical AND of Packed Double-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VANDPD xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F 54 /r 
</td></tr>
<tr><th>VANDPD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F 54 /r 
</td></tr>
<tr><th>VANDPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F.W1 54 /r 
</td></tr>
<tr><th>VANDPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F.W1 54 /r 
</td></tr>
<tr><th>VANDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</th><td>EVEX.NDS.512.66.0F.W1 54 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse2,pcksclr,logical</dd>
<dt>Operands</dt>
<dd><b>Vpd</b>,Wpd</dd>
<dt>Opcode</dt>
<dd>0x660F54 /r</dd>
<dt>CPU</dt>
<dd>P4+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5652.htm">t5652</a>
</dd>
</dl><pre>
IiyVANDPD:: PROC
    IiEmitOpcode 0x54
.op:IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F, EVEX.NDS.128.66.0F.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F, EVEX.NDS.256.66.0F.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.W1
    RET
  ENDP IiyVANDPD::
</pre>

<dl id="IiyVANDNPD">
<dt><a href="#IiyVANDPD">&uarr; VANDNPD</a></dt>
<dd>Bitwise Logical AND NOT of Packed Double-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VANDNPD xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F 55 /r 
</td></tr>
<tr><th>VANDNPD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F 55 /r 
</td></tr>
<tr><th>VANDNPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F.W1 55 /r 
</td></tr>
<tr><th>VANDNPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F.W1 55 /r 
</td></tr>
<tr><th>VANDNPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F.W1 55 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse2,pcksclr,logical</dd>
<dt>Operands</dt>
<dd><b>Vpd</b>,Wpd</dd>
<dt>Opcode</dt>
<dd>0x660F55 /r</dd>
<dt>CPU</dt>
<dd>P4+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5652.htm">t5652</a>
</dd>
</dl><pre>
IiyVANDNPD:: PROC
    IiEmitOpcode 0x55
    JMP IiyVANDPD.op:
  ENDP IiyVANDNPD::
</pre>

<dl id="IiyVORPD">
<dt><a href="#IiyVANDPD">&uarr; VORPD</a></dt>
<dd>Bitwise Logical OR of Double-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VORPD xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F 56 /r 
</td></tr>
<tr><th>VORPD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F 56 /r 
</td></tr>
<tr><th>VORPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F.W1 56 /r 
</td></tr>
<tr><th>VORPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F.W1 56 /r 
</td></tr>
<tr><th>VORPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F.W1 56 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse2,pcksclr,logical</dd>
<dt>Operands</dt>
<dd><b>Vpd</b>,Wpd</dd>
<dt>Opcode</dt>
<dd>0x660F56 /r</dd>
<dt>CPU</dt>
<dd>P4+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5652.htm">t5652</a>
</dd>
</dl><pre>
IiyVORPD:: PROC
    IiEmitOpcode 0x56
    JMP IiyVANDPD.op:
  ENDP IiyVORPD::
</pre>

<dl id="IiyVXORPD">
<dt><a href="#IiyVANDPD">&uarr; VXORPD</a></dt>
<dd>Bitwise Logical XOR for Double-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VXORPD xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 57 /r 
</td></tr>
<tr><th>VXORPD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 57 /r 
</td></tr>
<tr><th>VXORPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F.W1 57 /r 
</td></tr>
<tr><th>VXORPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F.W1 57 /r 
</td></tr>
<tr><th>VXORPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F.W1 57 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse2,pcksclr,logical</dd>
<dt>Operands</dt>
<dd><b>Vpd</b>,Wpd</dd>
<dt>Opcode</dt>
<dd>0x660F57 /r</dd>
<dt>CPU</dt>
<dd>P4+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5652.htm">t5652</a>
</dd>
</dl><pre>
IiyVXORPD:: PROC
    IiEmitOpcode 0x57
    JMP IiyVANDPD.op:
  ENDP IiyVXORPD::
</pre>

<dl id="IiyVSQRTSS">
<dt><a href="#IiyHandlers">&uarr; VSQRTSS</a></dt>
<dd>Compute Square Root of Scalar Single-FP Value</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSQRTSS xmm1, xmm2, xmm3/m32
</th><td>VEX.NDS.128.F3.0F.WIG 51 /r 
</td></tr>
<tr><th>VSQRTSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}
</th><td>EVEX.NDS.LIG.F3.0F.W0 51 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,arith</dd>
<dt>Operands</dt>
<dd><b>Vss</b>,Wss</dd>
<dt>Opcode</dt>
<dd>0xF30F51 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5654.htm">t5654</a>
</dd>
</dl><pre>
IiyVSQRTSS:: PROC
    IiAllowModifier MASK
    IiAllowRounding Register=xmm
    IiEmitOpcode 0x51
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX T1S32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.F3.0F.WIG, EVEX.NDS.LIG.F3.0F.W0
    RET
  ENDP IiyVSQRTSS::
</pre>

<dl id="IiyVSQRTSD">
<dt><a href="#IiyHandlers">&uarr; VSQRTSD</a></dt>
<dd>Compute Square Root of Scalar Double-FP Value</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSQRTSD xmm1,xmm2, xmm3/m64
</th><td>VEX.NDS.128.F2.0F.WIG 51 /r 
</td></tr>
<tr><th>VSQRTSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}
</th><td>EVEX.NDS.LIG.F2.0F.W1 51 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse2,pcksclr,arith</dd>
<dt>Operands</dt>
<dd><b>Vsd</b>,Wsd</dd>
<dt>Opcode</dt>
<dd>0xF20F51 /r</dd>
<dt>CPU</dt>
<dd>P4+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5654.htm">t5654</a>
</dd>
</dl><pre>
IiyVSQRTSD:: PROC
    IiAllowModifier MASK
    IiAllowRounding Register=xmm
    IiEmitOpcode 0x51
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX T1S64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.F2.0F.WIG, EVEX.NDS.LIG.F2.0F.W1
    RET
  ENDP IiyVSQRTSD::
</pre>

<dl id="IiyVSQRTPS">
<dt><a href="#IiyHandlers">&uarr; VSQRTPS</a></dt>
<dd>Compute Square Roots of Packed Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSQRTPS xmm1, xmm2/m128
</th><td>VEX.128.0F.WIG 51 /r 
</td></tr>
<tr><th>VSQRTPS ymm1, ymm2/m256
</th><td>VEX.256.0F.WIG 51 /r 
</td></tr>
<tr><th>VSQRTPS xmm1 {k1}{z}, xmm2/m128/m32bcst
</th><td>EVEX.128.0F.W0 51 /r 
</td></tr>
<tr><th>VSQRTPS ymm1 {k1}{z}, ymm2/m256/m32bcst
</th><td>EVEX.256.0F.W0 51 /r 
</td></tr>
<tr><th>VSQRTPS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}
</th><td>EVEX.512.0F.W0 51 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,arith</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wps</dd>
<dt>Opcode</dt>
<dd>0x0F51 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5654.htm">t5654</a>
</dd>
</dl><pre>
IiyVSQRTPS:: PROC
    IiAllowModifier MASK
    IiAllowRounding
    IiAllowBroadcasting DWORD
    IiEmitOpcode 0x51
    IiOpEn RM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm, xmm.mem, ymm.ymm, ymm.mem, zmm.zmm, zmm.mem
.xmm.xmm:
.xmm.mem:
    IiEmitPrefix VEX.128.0F.WIG, EVEX.128.0F.W0
    RET
.ymm.ymm:
.ymm.mem:
    IiEmitPrefix VEX.256.0F.WIG, EVEX.256.0F.W0
    RET
.zmm.zmm:
.zmm.mem:
    IiEmitPrefix EVEX.512.0F.W0
    RET
  ENDP IiyVSQRTPS::
</pre>

<dl id="IiyVSQRTPD">
<dt><a href="#IiyHandlers">&uarr; VSQRTPD</a></dt>
<dd>Compute Square Roots of Packed Double-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSQRTPD xmm1, xmm2/m128
</th><td>VEX.128.66.0F.WIG 51 /r 
</td></tr>
<tr><th>VSQRTPD ymm1, ymm2/m256
</th><td>VEX.256.66.0F.WIG 51 /r 
</td></tr>
<tr><th>VSQRTPD xmm1 {k1}{z}, xmm2/m128/m32bcst
</th><td>EVEX.128.66.0F.W1 51 /r
</td></tr>
<tr><th>VSQRTPD ymm1 {k1}{z}, ymm2/m256/m32bcst
</th><td>EVEX.256.66.0F.W1 51 /r 
</td></tr>
<tr><th>VSQRTPD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}
</th><td>EVEX.512.66.0F.W1 51 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse2,pcksclr,arith</dd>
<dt>Operands</dt>
<dd><b>Vpd</b>,Wpd</dd>
<dt>Opcode</dt>
<dd>0x660F51 /r</dd>
<dt>CPU</dt>
<dd>P4+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5654.htm">t5654</a>
</dd>
</dl><pre>
IiyVSQRTPD:: PROC
    IiAllowModifier MASK
    IiAllowRounding
    IiAllowBroadcasting QWORD
    IiEmitOpcode 0x51
    IiOpEn RM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm, xmm.mem, ymm.ymm, ymm.mem, zmm.zmm, zmm.mem
.xmm.xmm:
.xmm.mem:
    IiEmitPrefix VEX.128.66.0F.WIG, EVEX.128.66.0F.W1
    RET
.ymm.ymm:
.ymm.mem:
    IiEmitPrefix VEX.256.66.0F.WIG, EVEX.256.66.0F.W1
    RET
.zmm.zmm:
.zmm.mem:
    IiEmitPrefix EVEX.512.66.0F.W1
    RET
  ENDP IiyVSQRTPD::
</pre>

<dl id="IiyVRCP14SS">
<dt><a href="#IiyHandlers">&uarr; VRCP14SS</a></dt>
<dd>Compute Approximate Reciprocal of Scalar Float32 Value</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRCP14SS xmm1 {k1}{z}, xmm2, xmm3/m32
</th><td>EVEX.NDS.LIG.66.0F38.W0 4D /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x4D</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5656.htm">t5656</a>
</dd>
</dl><pre>
IiyVRCP14SS:: PROC
    IiEmitOpcode 0x4D
.op:IiAllowModifier MASK
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX T1S32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.LIG.66.0F38.W0
    RET
  ENDP IiyVRCP14SS::
</pre>

<dl id="IiyVRCP14SD">
<dt><a href="#IiyHandlers">&uarr; VRCP14SD</a></dt>
<dd>Compute Approximate Reciprocal of Scalar Float64 Value</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRCP14SD xmm1 {k1}{z}, xmm2, xmm3/m64
</th><td>EVEX.NDS.LIG.66.0F38.W1 4D /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x4D</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5656.htm">t5656</a>
</dd>
</dl><pre>
IiyVRCP14SD:: PROC
    IiEmitOpcode 0x4D
.op:IiAllowModifier MASK
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX T1S64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.LIG.66.0F38.W1
    RET
  ENDP IiyVRCP14SD::
</pre>

<dl id="IiyVRCP14PS">
<dt><a href="#IiyHandlers">&uarr; VRCP14PS</a></dt>
<dd>Compute Approximate Reciprocals of Packed Float32 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRCP14PS xmm1 {k1}{z}, xmm2/m128/m32bcst
</th><td>EVEX.128.66.0F38.W0 4C /r 
</td></tr>
<tr><th>VRCP14PS ymm1 {k1}{z}, ymm2/m256/m32bcst
</th><td>EVEX.256.66.0F38.W0 4C /r 
</td></tr>
<tr><th>VRCP14PS zmm1 {k1}{z}, zmm2/m512/m32bcst
</th><td>EVEX.512.66.0F38.W0 4C /r 
</td></tr>
</table></dd>
<dt>Operands</dt>
<dd>0x4C</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5656.htm">t5656</a>
</dd>
</dl><pre>
IiyVRCP14PS:: PROC
    IiEmitOpcode 0x4C
.op:IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiOpEn RM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm, xmm.mem, ymm.ymm, ymm.mem, zmm.zmm, zmm.mem
.xmm.xmm:
.xmm.mem:
    IiEmitPrefix EVEX.128.66.0F38.W0
    RET
.ymm.ymm:
.ymm.mem:
    IiEmitPrefix EVEX.256.66.0F38.W0
    RET
.zmm.zmm:
.zmm.mem:
    IiEmitPrefix EVEX.512.66.0F38.W0
    RET
  ENDP IiyVRCP14PS::
</pre>

<dl id="IiyVRCP14PD">
<dt><a href="#IiyHandlers">&uarr; VRCP14PD</a></dt>
<dd>Compute Approximate Reciprocals of Packed Float64 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRCP14PD xmm1 {k1}{z}, xmm2/m128/m64bcst
</th><td>EVEX.128.66.0F38.W1 4C /r 
</td></tr>
<tr><th>VRCP14PD ymm1 {k1}{z}, ymm2/m256/m64bcst
</th><td>EVEX.256.66.0F38.W1 4C /r 
</td></tr>
<tr><th>VRCP14PD zmm1 {k1}{z}, zmm2/m512/m64bcst
</th><td>EVEX.512.66.0F38.W1 4C /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x4C</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5656.htm">t5656</a>
</dd>
</dl><pre>
IiyVRCP14PD:: PROC
    IiEmitOpcode 0x4C
.op:IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiOpEn RM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm, xmm.mem, ymm.ymm, ymm.mem, zmm.zmm, zmm.mem
.xmm.xmm:
.xmm.mem:
    IiEmitPrefix EVEX.128.66.0F38.W1
    RET
.ymm.ymm:
.ymm.mem:
    IiEmitPrefix EVEX.256.66.0F38.W1
    RET
.zmm.zmm:
.zmm.mem:
    IiEmitPrefix EVEX.512.66.0F38.W1
    RET
  ENDP IiyVRCP14PD::
</pre>

<dl id="IiyVRSQRT14SS">
<dt><a href="#IiyVRCP14SS">&uarr; VRSQRT14SS</a></dt>
<dd>Compute Approximate Reciprocal of Square Root of Scalar Float32 Value</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRSQRT14SS xmm1 {k1}{z}, xmm2, xmm3/m32
</th><td>EVEX.NDS.LIG.66.0F38.W0 4F /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x4F</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5658.htm">t5658</a>
</dd>
</dl><pre>
IiyVRSQRT14SS:: PROC
    IiEmitOpcode 0x4F
    JMP IiyVRCP14SS.op:
  ENDP IiyVRSQRT14SS::
</pre>

<dl id="IiyVRSQRT14SD">
<dt><a href="#IiyVRCP14SD">&uarr; VRSQRT14SD</a></dt>
<dd>Compute Approximate Reciprocal of Square Root of Scalar Float64 Value</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRSQRT14SD xmm1 {k1}{z}, xmm2, xmm3/m64
</th><td>EVEX.NDS.LIG.66.0F38.W1 4F /r 
</table></dd>
<dt>Opcode</dt>
<dd>0x4F</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5658.htm">t5658</a>
</dd>
</dl><pre>
IiyVRSQRT14SD:: PROC
    IiEmitOpcode 0x4F
    JMP IiyVRCP14SD.op:
  ENDP IiyVRSQRT14SD::
</pre>

<dl id="IiyVRSQRT14PS">
<dt><a href="#IiyVRCP14PS">&uarr; VRSQRT14PS</a></dt>
<dd>Compute Approximate Reciprocals of Square Roots of Packed Float32 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRSQRT14PS xmm1 {k1}{z}, xmm2/m128/m32bcst
</th><td>EVEX.128.66.0F38.W0 4E /r 
</td></tr>
<tr><th>VRSQRT14PS ymm1 {k1}{z}, ymm2/m256/m32bcst
</th><td>EVEX.256.66.0F38.W0 4E /r 
</td></tr>
<tr><th>VRSQRT14PS zmm1 {k1}{z}, zmm2/m512/m32bcst
</th><td>EVEX.512.66.0F38.W0 4E /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x4E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5658.htm">t5658</a>
</dd>
</dl><pre>
IiyVRSQRT14PS:: PROC
    IiEmitOpcode 0x4E
    JMP IiyVRCP14PS.op:
  ENDP IiyVRSQRT14PS::
</pre>

<dl id="IiyVRSQRT14PD">
<dt><a href="#IiyVRCP14PD">&uarr; VRSQRT14PD</a></dt>
<dd>Compute Approximate Reciprocals of Square Roots of Packed Float64 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRSQRT14PD xmm1 {k1}{z}, xmm2/m128/m64bcst
</th><td>EVEX.128.66.0F38.W1 4E /r 
</td></tr>
<tr><th>VRSQRT14PD ymm1 {k1}{z}, ymm2/m256/m64bcst
</th><td>EVEX.256.66.0F38.W1 4E /r 
</td></tr>
<tr><th>VRSQRT14PD zmm1 {k1}{z}, zmm2/m512/m64bcst
</th><td>EVEX.512.66.0F38.W1 4E /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x4E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5658.htm">t5658</a>
</dd>
</dl><pre>
IiyVRSQRT14PD:: PROC
    IiEmitOpcode 0x4E
    JMP IiyVRCP14PD.op:
  ENDP IiyVRSQRT14PD::
</pre>

<dl id="IiyVRCP28SS">
<dt><a href="#IiyHandlers">&uarr; VRCP28SS</a></dt>
<dd>Approximation to the Reciprocal of Scalar Single-Precision Floating-Point Value  with Less Than 2^-28 Relative Error</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRCP28SS xmm1 {k1}{z}, xmm2, xmm3/m32 {sae}
</th><td>EVEX.NDS.LIG.66.0F38.W0 CB /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCB</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5660.htm">t5660</a>
</dd>
</dl><pre>
IiyVRCP28SS:: PROC
    IiEmitOpcode 0xCB
.op:IiAllowModifier MASK
    IiAllowSuppressing Register=xmm
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX T1S32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.LIG.66.0F38.W0
    RET
  ENDP IiyVRCP28SS::
</pre>

<dl id="IiyVRCP28SD">
<dt><a href="#IiyHandlers">&uarr; VRCP28SD</a></dt>
<dd>Approximation to the Reciprocal of Scalar Double-Precision Floating-Point Value  with Less Than 2^-28 Relative Error</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRCP28SD xmm1 {k1}{z}, xmm2, xmm3/m64 {sae}
</th><td>EVEX.NDS.LIG.66.0F38.W1 CB /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCB</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5660.htm">t5660</a>
</dd>
</dl><pre>
IiyVRCP28SD:: PROC
    IiEmitOpcode 0xCB
.op:IiAllowModifier MASK
    IiAllowSuppressing Register=xmm
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX T1S64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.LIG.66.0F38.W1
    RET
  ENDP IiyVRCP28SD::
</pre>

<dl id="IiyVRCP28PS">
<dt><a href="#IiyHandlers">&uarr; VRCP28PS</a></dt>
<dd>Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values  with Less Than 2^-28 Relative Error</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRCP28PS zmm1 {k1}{z}, zmm2/m512/m32bcst {sae}
</th><td>EVEX.512.66.0F38.W0 CA /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCA</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5660.htm">t5660</a>
</dd>
</dl><pre>
IiyVRCP28PS:: PROC
    IiEmitOpcode 0xCA
.op:IiAllowModifier MASK
    IiAllowSuppressing 
    IiAllowBroadcasting DWORD
    IiOpEn RM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  zmm.zmm, zmm.mem
.zmm.zmm:
.zmm.mem:
    IiEmitPrefix EVEX.512.66.0F38.W0
    RET
  ENDP IiyVRCP28PS::
</pre>

<dl id="IiyVRCP28PD">
<dt><a href="#IiyHandlers">&uarr; VRCP28PD</a></dt>
<dd>Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values  with Less Than 2^-28 Relative Error</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRCP28PD zmm1 {k1}{z}, zmm2/m512/m64bcst {sae}</th><td>EVEX.512.66.0F38.W1 CA /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCA</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5660.htm">t5660</a>
</dd>
</dl><pre>
IiyVRCP28PD:: PROC
    IiEmitOpcode 0xCA
.op:IiAllowModifier MASK
    IiAllowSuppressing
    IiAllowBroadcasting QWORD
    IiOpEn RM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  zmm.zmm, zmm.mem
.zmm.zmm:
.zmm.mem:
    IiEmitPrefix EVEX.512.66.0F38.W1
    RET
  ENDP IiyVRCP28PD::
</pre>

<dl id="IiyVRSQRT28SS">
<dt><a href="#IiyVRCP28SS">&uarr; VRSQRT28SS</a></dt>
<dd>Approximation to the Reciprocal Square Root of Scalar Single-Precision Floating- Point Value with Less Than 2^-28 Relative Error</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRSQRT28SS xmm1 {k1}{z}, xmm2, xmm3/m32 {sae}
</th><td>EVEX.NDS.LIG.66.0F38.W0 CD /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCD</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5662.htm">t5662</a>
</dd>
</dl><pre>
IiyVRSQRT28SS:: PROC
    IiEmitOpcode 0xCD
    JMP IiyVRCP28SS.op:
  ENDP IiyVRSQRT28SS::
</pre>

<dl id="IiyVRSQRT28SD">
<dt><a href="#IiyVRCP28SD">&uarr; VRSQRT28SD</a></dt>
<dd>Approximation to the Reciprocal Square Root of Scalar Double-Precision  Floating-Point Value with Less Than 2^-28 Relative Error</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRSQRT28SD xmm1 {k1}{z}, xmm2, xmm3/m64 {sae}
</th><td>EVEX.NDS.LIG.66.0F38.W1 CD /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCD</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5662.htm">t5662</a>
</dd>
</dl><pre>
IiyVRSQRT28SD:: PROC
    IiEmitOpcode 0xCD
    JMP IiyVRCP28SD.op:
  ENDP IiyVRSQRT28SD::
</pre>

<dl id="IiyVRSQRT28PS">
<dt><a href="#IiyVRCP28PS">&uarr; VRSQRT28PS</a></dt>
<dd>Approximation to the Reciprocal Square Root of Packed Single-Precision  Floating-Point Values with Less Than 2^-28 Relative Error</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRSQRT28PS zmm1 {k1}{z}, zmm2/m512/m32bcst {sae}
</th><td>EVEX.512.66.0F38.W0 CC /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCC</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5662.htm">t5662</a>
</dd>
</dl><pre>
IiyVRSQRT28PS:: PROC
    IiEmitOpcode 0xCC
    JMP IiyVRCP28PS.op:
  ENDP IiyVRSQRT28PS::
</pre>

<dl id="IiyVRSQRT28PD">
<dt><a href="#IiyVRCP28PD">&uarr; VRSQRT28PD</a></dt>
<dd>Approximation to the Reciprocal Square Root of Packed Double-Precision  Floating-Point Values with Less Than 2^-28 Relative Error</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRSQRT28PD zmm1 {k1}{z}, zmm2/m512/m64bcst {sae}
</th><td>EVEX.512.66.0F38.W1 CC /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCC</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5662.htm">t5662</a>
</dd>
</dl><pre>
IiyVRSQRT28PD:: PROC
    IiEmitOpcode 0xCC
    JMP IiyVRCP28PD.op:
  ENDP IiyVRSQRT28PD::
</pre>

<dl id="IiyVEXP2PS">
<dt><a href="#IiyVRCP28PS">&uarr; VEXP2PS</a></dt>
<dd>Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point  Values with Less Than 2^-23 Relative Error</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VEXP2PS zmm1 {k1}{z}, zmm2/m512/m32bcst {sae}</th><td>EVEX.512.66.0F38.W0 C8 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xC8</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5664.htm">t5664</a>
</dd>
</dl><pre>
IiyVEXP2PS:: PROC
    IiEmitOpcode 0xC8
    JMP IiyVRCP28PS.op:
  ENDP IiyVEXP2PS::
</pre>

<dl id="IiyVEXP2PD">
<dt><a href="#IiyVRCP28PD">&uarr; VEXP2PD</a></dt>
<dd>Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point  Values with Less Than 2^-23 Relative Error</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VEXP2PD zmm1 {k1}{z}, zmm2/m512/m64bcst {sae}</th><td>EVEX.512.66.0F38.W1 C8 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xC8</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5664.htm">t5664</a>
</dd>
</dl><pre>
IiyVEXP2PD:: PROC
    IiEmitOpcode 0xC8
    JMP IiyVRCP28PD.op:
  ENDP IiyVEXP2PD::
</pre>

<dl id="IiyVPMOVUSWB">
<dt><a href="#IiyHandlers">&uarr; VPMOVUSWB</a></dt>
<dd>Down Convert Unsigned Word to Byte using unsigned saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVUSWB xmm1/m64 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 10 /r
</td></tr>
<tr><th>VPMOVUSWB xmm1/m128 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 10 /r
</td></tr>
<tr><th>VPMOVUSWB ymm1/m256 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 10 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x10</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5670.htm">t5670</a>
</dd>
</dl><pre>
IiyVPMOVUSWB:: PROC
     IiEmitOpcode 0x10
.HVM:IiDisp8EVEX HVM
     IiAllowModifier MASK
     IiOpEn MR
     IiModRM /r
     IiDispatchFormat  xmm.xmm, mem.xmm, xmm.ymm, mem.ymm, ymm.zmm, mem.zmm
.xmm.xmm:
.mem.xmm:
    IiEncoding DATA=QWORD
    IiEmitPrefix EVEX.128.F3.0F38.W0
    RET
.xmm.ymm:
.mem.ymm:
    IiEncoding DATA=OWORD
    IiEmitPrefix EVEX.256.F3.0F38.W0
    RET
.ymm.zmm:
.mem.zmm:
    IiEncoding DATA=YWORD
    IiEmitPrefix EVEX.512.F3.0F38.W0
    RET
  ENDP IiyVPMOVUSWB::
</pre>

<dl id="IiyVPMOVUSDB">
<dt><a href="#IiyHandlers">&uarr; VPMOVUSDB</a></dt>
<dd>Down Convert Unsigned DWord to Byte using unsigned saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVUSDB xmm1/m32 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 11 /r
</td></tr>
<tr><th>VPMOVUSDB xmm1/m64 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 11 /r
</td></tr>
<tr><th>VPMOVUSDB xmm1/m128 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 11 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x11</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5670.htm">t5670</a>
</dd>
</dl><pre>
IiyVPMOVUSDB:: PROC
     IiEmitOpcode 0x11
.QVM:IiDisp8EVEX QVM
     IiAllowModifier MASK
     IiOpEn MR
     IiModRM /r
     IiDispatchFormat  xmm.xmm, mem.xmm, xmm.ymm, mem.ymm, xmm.zmm, mem.zmm
.xmm.xmm:
.mem.xmm:
    IiEncoding DATA=DWORD
    IiEmitPrefix EVEX.128.F3.0F38.W0
    RET
.xmm.ymm:
.mem.ymm:
    IiEncoding DATA=QWORD
    IiEmitPrefix EVEX.256.F3.0F38.W0
    RET
.xmm.zmm:
.mem.zmm:
    IiEncoding DATA=OWORD
    IiEmitPrefix EVEX.512.F3.0F38.W0
    RET
  ENDP IiyVPMOVUSDB::
</pre>

<dl id="IiyVPMOVUSQB">
<dt><a href="#IiyHandlers">&uarr; VPMOVUSQB</a></dt>
<dd>Down Convert Unsigned QWord to Byte using unsigned saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVUSQB xmm1/m16 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 12 /r
</td></tr>
<tr><th>VPMOVUSQB xmm1/m32 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 12 /r
</td></tr>
<tr><th>VPMOVUSQB xmm1/m64 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 12 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x12</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5670.htm">t5670</a>
</dd>
</dl><pre>
IiyVPMOVUSQB:: PROC
     IiEmitOpcode 0x12
.OVM:IiDisp8EVEX OVM
     IiAllowModifier MASK
     IiOpEn MR
     IiModRM /r
     IiDispatchFormat  xmm.xmm, mem.xmm, xmm.ymm, mem.ymm, xmm.zmm, mem.zmm
.xmm.xmm:
.mem.xmm:
    IiEncoding DATA=WORD
    IiEmitPrefix EVEX.128.F3.0F38.W0
    RET
.xmm.ymm:
.mem.ymm:
    IiEncoding DATA=DWORD
    IiEmitPrefix EVEX.256.F3.0F38.W0
    RET
.xmm.zmm:
.mem.zmm:
    IiEncoding DATA=QWORD
    IiEmitPrefix EVEX.512.F3.0F38.W0
    RET
  ENDP IiyVPMOVUSQB::
</pre>

<dl id="IiyVPMOVUSDW">
<dt><a href="#IiyVPMOVUSWB">&uarr; VPMOVUSDW</a></dt>
<dd>Down Convert Unsigned DWord to Word using unsigned saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVUSDW xmm1/m64 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 13 /r
</td></tr>
<tr><th>VPMOVUSDW xmm1/m128 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 13 /r
</td></tr>
<tr><th>VPMOVUSDW ymm1/m256 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 13 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x13</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5670.htm">t5670</a>
</dd>
</dl><pre>
IiyVPMOVUSDW:: PROC
    IiEmitOpcode 0x13
    JMP IiyVPMOVUSWB.HVM:
  ENDP IiyVPMOVUSDW::
</pre>

<dl id="IiyVPMOVUSQW">
<dt><a href="#IiyVPMOVUSDB">&uarr; VPMOVUSQW</a></dt>
<dd>Down Convert Unsigned QWord to Word using unsigned saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVUSQW xmm1/m32 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 14 /r
</td></tr>
<tr><th>VPMOVUSQW xmm1/m64 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 14 /r
</td></tr>
<tr><th>VPMOVUSQW xmm1/m128 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 14 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x14</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5670.htm">t5670</a>
</dd>
</dl><pre>
IiyVPMOVUSQW:: PROC
    IiEmitOpcode 0x14
    JMP IiyVPMOVUSDB.QVM:
  ENDP IiyVPMOVUSQW::
</pre>

<dl id="IiyVPMOVUSQD">
<dt><a href="#IiyVPMOVUSWB">&uarr; VPMOVUSQD</a></dt>
<dd>Down Convert Unsigned QWord to DWord using unsigned saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVUSQD xmm1/m64 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 15 /r
</td></tr>
<tr><th>VPMOVUSQD xmm1/m128 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 15 /r
</td></tr>
<tr><th>VPMOVUSQD ymm1/m256 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 15 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x15</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5670.htm">t5670</a>
</dd>
</dl><pre>
IiyVPMOVUSQD:: PROC
    IiEmitOpcode 0x15
    JMP IiyVPMOVUSWB.HVM:
  ENDP IiyVPMOVUSQD::
</pre>

<dl id="IiyVPMOVSWB">
<dt><a href="#IiyVPMOVUSWB">&uarr; VPMOVSWB</a></dt>
<dd>Down Convert Signed Word to Byte using signed saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSWB xmm1/m64 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 20 /r
</td></tr>
<tr><th>VPMOVSWB xmm1/m128 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 20 /r
</td></tr>
<tr><th>VPMOVSWB ymm1/m256 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 20 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x20</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5672.htm">t5672</a>
</dd>
</dl><pre>
IiyVPMOVSWB:: PROC
    IiEmitOpcode 0x20
    JMP IiyVPMOVUSWB.HVM:
  ENDP IiyVPMOVSWB::
</pre>

<dl id="IiyVPMOVSDB">
<dt><a href="#IiyVPMOVUSDB">&uarr; VPMOVSDB</a></dt>
<dd>Down Convert Signed DWord to Byte using signed saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSDB xmm1/m32 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 21 /r
</td></tr>
<tr><th>VPMOVSDB xmm1/m64 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 21 /r
</td></tr>
<tr><th>VPMOVSDB xmm1/m128 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 21 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x21</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5672.htm">t5672</a>
</dd>
</dl><pre>
IiyVPMOVSDB:: PROC
    IiEmitOpcode 0x21
    JMP IiyVPMOVUSDB.QVM:
  ENDP IiyVPMOVSDB::
</pre>

<dl id="IiyVPMOVSQB">
<dt><a href="#IiyVPMOVUSQB">&uarr; VPMOVSQB</a></dt>
<dd>Down Convert Signed QWord to Byte using signed saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSQB xmm1/m16 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 22 /r
</td></tr>
<tr><th>VPMOVSQB xmm1/m32 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 22 /r
</td></tr>
<tr><th>VPMOVSQB xmm1/m64 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 22 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x22</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5672.htm">t5672</a>
</dd>
</dl><pre>
IiyVPMOVSQB:: PROC
    IiEmitOpcode 0x22
    JMP IiyVPMOVUSQB.OVM:
  ENDP IiyVPMOVSQB::
</pre>

<dl id="IiyVPMOVSDW">
<dt><a href="#IiyVPMOVUSWB">&uarr; VPMOVSDW</a></dt>
<dd>Down Convert Signed DWord to Word using signed saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSDW xmm1/m64 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 23 /r
</td></tr>
<tr><th>VPMOVSDW xmm1/m128 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 23 /r
</td></tr>
<tr><th>VPMOVSDW ymm1/m256 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 23 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x23</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5672.htm">t5672</a>
</dd>
</dl><pre>
IiyVPMOVSDW:: PROC
    IiEmitOpcode 0x23
    JMP IiyVPMOVUSWB.HVM:
  ENDP IiyVPMOVSDW::
</pre>

<dl id="IiyVPMOVSQW">
<dt><a href="#IiyVPMOVUSDB">&uarr; VPMOVSQW</a></dt>
<dd>Down Convert Signed QWord to Word using signed saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSQW xmm1/m32 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 24 /r
</td></tr>
<tr><th>VPMOVSQW xmm1/m64 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 24 /r
</td></tr>
<tr><th>VPMOVSQW xmm1/m128 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 24 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x24</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5672.htm">t5672</a>
</dd>
</dl><pre>
IiyVPMOVSQW:: PROC
    IiEmitOpcode 0x24
    JMP IiyVPMOVUSDB.QVM:
  ENDP IiyVPMOVSQW::
</pre>

<dl id="IiyVPMOVSQD">
<dt><a href="#IiyVPMOVUSWB">&uarr; VPMOVSQD</a></dt>
<dd>Down Convert Signed QWord to DWord using signed saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSQD xmm1/m64 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 25 /r
</td></tr>
<tr><th>VPMOVSQD xmm1/m128 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 25 /r
</td></tr>
<tr><th>VPMOVSQD ymm1/m256 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 25 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x25</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5672.htm">t5672</a>
</dd>
</dl><pre>
IiyVPMOVSQD:: PROC
    IiEmitOpcode 0x25
    JMP IiyVPMOVUSWB.HVM:
  ENDP IiyVPMOVSQD::
</pre>

<dl id="IiyVPMOVWB">
<dt><a href="#IiyVPMOVUSWB">&uarr; VPMOVWB</a></dt>
<dd>Down Convert Word to Byte with truncation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVWB xmm1/m64 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 30 /r
</td></tr>
<tr><th>VPMOVWB xmm1/m128 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 30 /r
</td></tr>
<tr><th>VPMOVWB ymm1/m256 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 30 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x30</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5674.htm">t5674</a>
</dd>
</dl><pre>
IiyVPMOVWB:: PROC
    IiEmitOpcode 0x30
    JMP IiyVPMOVUSWB.HVM:
  ENDP IiyVPMOVWB::
</pre>

<dl id="IiyVPMOVDB">
<dt><a href="#IiyVPMOVUSDB">&uarr; VPMOVDB</a></dt>
<dd>Down Convert DWord to Byte with truncation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVDB xmm1/m32 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 31 /r
</td></tr>
<tr><th>VPMOVDB xmm1/m64 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 31 /r
</td></tr>
<tr><th>VPMOVDB xmm1/m128 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 31 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x31</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5674.htm">t5674</a>
</dd>
</dl><pre>
IiyVPMOVDB:: PROC
    IiEmitOpcode 0x31
    JMP IiyVPMOVUSDB.QVM:
  ENDP IiyVPMOVDB::
</pre>

<dl id="IiyVPMOVQB">
<dt><a href="#IiyVPMOVUSQB">&uarr; VPMOVQB</a></dt>
<dd>Down Convert QWord to Byte with truncation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVQB xmm1/m16 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 32 /r
</td></tr>
<tr><th>VPMOVQB xmm1/m32 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 32 /r
</td></tr>
<tr><th>VPMOVQB xmm1/m64 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 32 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x32</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5674.htm">t5674</a>
</dd>
</dl><pre>
IiyVPMOVQB:: PROC
    IiEmitOpcode 0x32
    JMP IiyVPMOVUSQB.OVM:
  ENDP IiyVPMOVQB::
</pre>

<dl id="IiyVPMOVDW">
<dt><a href="#IiyVPMOVUSWB">&uarr; VPMOVDW</a></dt>
<dd>Down Convert DWord to Word with truncation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVDW xmm1/m64 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 33 /r
</td></tr>
<tr><th>VPMOVDW xmm1/m128 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 33 /r
</td></tr>
<tr><th>VPMOVDW ymm1/m256 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 33 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x33</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5674.htm">t5674</a>
</dd>
</dl><pre>
IiyVPMOVDW:: PROC
    IiEmitOpcode 0x33
    JMP IiyVPMOVUSWB.HVM:
  ENDP IiyVPMOVDW::
</pre>

<dl id="IiyVPMOVQW">
<dt><a href="#IiyVPMOVUSDB">&uarr; VPMOVQW</a></dt>
<dd>Down Convert QWord to Word with truncation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVQW xmm1/m32 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 34 /r
</td></tr>
<tr><th>VPMOVQW xmm1/m64 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 34 /r
</td></tr>
<tr><th>VPMOVQW xmm1/m128 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 34 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x34</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5674.htm">t5674</a>
</dd>
</dl><pre>
IiyVPMOVQW:: PROC
    IiEmitOpcode 0x34
    JMP IiyVPMOVUSDB.QVM:
  ENDP IiyVPMOVQW::
</pre>

<dl id="IiyVPMOVQD">
<dt><a href="#IiyVPMOVUSWB">&uarr; VPMOVQD</a></dt>
<dd>Down Convert QWord to DWord with truncation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVQD xmm1/m128 {k1}{z}, xmm2
</th><td>EVEX.128.F3.0F38.W0 35 /r
</td></tr>
<tr><th>VPMOVQD xmm1/m128 {k1}{z}, ymm2
</th><td>EVEX.256.F3.0F38.W0 35 /r
</td></tr>
<tr><th>VPMOVQD ymm1/m256 {k1}{z}, zmm2
</th><td>EVEX.512.F3.0F38.W0 35 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x35</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5674.htm">t5674</a>
</dd>
</dl><pre>
IiyVPMOVQD:: PROC
    IiEmitOpcode 0x35
    JMP IiyVPMOVUSWB.HVM:
  ENDP IiyVPMOVQD::
</pre>

<dl id="IiyVPMOVSXBW">
<dt><a href="#IiyHandlers">&uarr; VPMOVSXBW</a></dt>
<dd>Packed Move with Sign Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSXBW xmm1, xmm2/m64
</th><td>VEX.128.66.0F38.WIG 20 /r 
</td></tr>
<tr><th>VPMOVSXBW ymm1, xmm2/m128
</th><td>VEX.256.66.0F38.WIG 20 /r 
</td></tr>
<tr><th>VPMOVSXBW xmm1 {k1}{z}, xmm2/m64
</th><td>EVEX.128.66.0F38.WIG 20 /r 
</td></tr>
<tr><th>VPMOVSXBW ymm1 {k1}{z}, xmm2/m128
</th><td>EVEX.256.66.0F38.WIG 20 /r 
</td></tr>
<tr><th>VPMOVSXBW zmm1 {k1}{z}, ymm2/m256
</th><td>EVEX.512.66.0F38.WIG 20 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Mq | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3820 /r | 0x660F3820 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5676.htm">t5676</a>
</dd>
</dl><pre>
IiyVPMOVSXBW:: PROC
     IiEmitOpcode 0x20
.HVM:IiDisp8EVEX HVM
     IiAllowModifier MASK
     IiOpEn RM
     IiModRM /r
     IiDispatchFormat  xmm.xmm, xmm.mem, ymm.xmm, ymm.mem, zmm.ymm, zmm.mem
.xmm.xmm:
.xmm.mem:
    IiEncoding DATA=QWORD
    IiEmitPrefix VEX.128.66.0F38.WIG, EVEX.128.66.0F38.WIG
    RET
.ymm.xmm:
.ymm.mem:
    IiEncoding DATA=OWORD
    IiEmitPrefix VEX.256.66.0F38.WIG, EVEX.256.66.0F38.WIG
    RET
.zmm.ymm:
.zmm.mem:
    IiEncoding DATA=YWORD
    IiEmitPrefix EVEX.512.66.0F38.WIG
    RET
  ENDP IiyVPMOVSXBW::
</pre>  

<dl id="IiyVPMOVSXBD">
<dt><a href="#IiyHandlers">&uarr; VPMOVSXBD</a></dt>
<dd>Packed Move with Sign Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSXBD xmm1, xmm2/m32
</th><td>VEX.128.66.0F38.WIG 21 /r 
</td></tr>
<tr><th>VPMOVSXBD ymm1, xmm2/m64
</th><td>VEX.256.66.0F38.WIG 21 /r 
</td></tr>
<tr><th>VPMOVSXBD xmm1 {k1}{z}, xmm2/m32
</th><td>EVEX.128.66.0F38.WIG 21 /r 
</td></tr>
<tr><th>VPMOVSXBD ymm1 {k1}{z}, xmm2/m64
</th><td>EVEX.256.66.0F38.WIG 21 /r 
</td></tr>
<tr><th>VPMOVSXBD zmm1 {k1}{z}, xmm2/m128
</th><td>EVEX.512.66.0F38.WIG 21 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Md | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3821 /r | 0x660F3821 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5676.htm">t5676</a>
</dd>
</dl><pre>
IiyVPMOVSXBD:: PROC
     IiEmitOpcode 0x21
.QVM:IiDisp8EVEX QVM
     IiAllowModifier MASK
     IiOpEn RM
     IiModRM /r
     IiDispatchFormat  xmm.xmm, xmm.mem, ymm.xmm, ymm.mem, zmm.xmm, zmm.mem
.xmm.xmm:
.xmm.mem:
    IiEncoding DATA=DWORD
    IiEmitPrefix VEX.128.66.0F38.WIG, EVEX.128.66.0F38.WIG
    RET
.ymm.xmm:
.ymm.mem:
    IiEncoding DATA=QWORD
    IiEmitPrefix VEX.256.66.0F38.WIG, EVEX.256.66.0F38.WIG
    RET
.zmm.xmm:
.zmm.mem:
    IiEncoding DATA=OWORD
    IiEmitPrefix EVEX.512.66.0F38.WIG
    RET
  ENDP IiyVPMOVSXBD::
</pre>

<dl id="IiyVPMOVSXBQ">
<dt><a href="#IiyHandlers">&uarr; VPMOVSXBQ</a></dt>
<dd>Packed Move with Sign Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSXBQ xmm1, xmm2/m16
</th><td>VEX.128.66.0F38.WIG 22 /r
</td></tr>
<tr><th>VPMOVSXBQ ymm1, xmm2/m32
</th><td>VEX.256.66.0F38.WIG 22 /r 
</td></tr>
<tr><th>VPMOVSXBQ xmm1 {k1}{z}, xmm2/m16
</th><td>EVEX.128.66.0F38.WIG 22 /r 
</td></tr>
<tr><th>VPMOVSXBQ ymm1 {k1}{z}, xmm2/m32
</th><td>EVEX.256.66.0F38.WIG 22 /r 
</td></tr>
<tr><th>VPMOVSXBQ zmm1 {k1}{z}, xmm2/m64
</th><td>EVEX.512.66.0F38.WIG 22 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Mw | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3822 /r | 0x660F3822 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5676.htm">t5676</a>
</dd>
</dl><pre>
IiyVPMOVSXBQ:: PROC
     IiEmitOpcode 0x22
.OVM:IiDisp8EVEX OVM
     IiAllowModifier MASK
     IiOpEn RM
     IiModRM /r
     IiDispatchFormat  xmm.xmm, xmm.mem, ymm.xmm, ymm.mem, zmm.xmm, zmm.mem
.xmm.xmm:
.xmm.mem:
    IiEncoding DATA=WORD
    IiEmitPrefix VEX.128.66.0F38.WIG, EVEX.128.66.0F38.WIG
    RET
.ymm.xmm:
.ymm.mem:
    IiEncoding DATA=DWORD
    IiEmitPrefix VEX.256.66.0F38.WIG, EVEX.256.66.0F38.WIG
    RET
.zmm.xmm:
.zmm.mem:
    IiEncoding DATA=QWORD
    IiEmitPrefix EVEX.512.66.0F38.WIG
    RET
  ENDP IiyVPMOVSXBQ::
</pre>

<dl id="IiyVPMOVSXWD">
<dt><a href="#IiyVPMOVSXBW">&uarr; VPMOVSXWD</a></dt>
<dd>Packed Move with Sign Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSXWD xmm1, xmm2/m64
</th><td>VEX.128.66.0F38.WIG 23 /r 
</td></tr>
<tr><th>VPMOVSXWD ymm1, xmm2/m128
</th><td>VEX.256.66.0F38.WIG 23 /r 
</td></tr>
<tr><th>VPMOVSXWD xmm1 {k1}{z}, xmm2/m64
</th><td>EVEX.128.66.0F38.WIG 23 /r 
</td></tr>
<tr><th>VPMOVSXWD ymm1 {k1}{z}, xmm2/m128
</th><td>EVEX.256.66.0F38.WIG 23 /r 
</td></tr>
<tr><th>VPMOVSXWD zmm1 {k1}{z}, ymm2/m256
</th><td>EVEX.512.66.0F38.WIG 23 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Mq | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3823 /r | 0x660F3823 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5676.htm">t5676</a>
</dd>
</dl><pre>
IiyVPMOVSXWD:: PROC
     IiEmitOpcode 0x23
     JMP IiyVPMOVSXBW.HVM:
  ENDP IiyVPMOVSXWD::
</pre>

<dl id="IiyVPMOVSXWQ">
<dt><a href="#IiyVPMOVSXBD">&uarr; VPMOVSXWQ</a></dt>
<dd>Packed Move with Sign Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSXWQ xmm1, xmm2/m32
</th><td>VEX.128.66.0F38.WIG 24 /r 
</td></tr>
<tr><th>VPMOVSXWQ ymm1, xmm2/m64
</th><td>VEX.256.66.0F38.WIG 24 /r 
</td></tr>
<tr><th>VPMOVSXWQ xmm1 {k1}{z}, xmm2/m32
</th><td>EVEX.128.66.0F38.WIG 24 /r 
</td></tr>
<tr><th>VPMOVSXWQ ymm1 {k1}{z}, xmm2/m64
</th><td>EVEX.256.66.0F38.WIG 24 /r 
</td></tr>
<tr><th>VPMOVSXWQ zmm1 {k1}{z}, xmm2/m128
</th><td>EVEX.512.66.0F38.WIG 24 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Md | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3824 /r | 0x660F3824 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5676.htm">t5676</a>
</dd>
</dl><pre>
IiyVPMOVSXWQ:: PROC
    IiEmitOpcode 0x24
    JMP IiyVPMOVSXBD.QVM:
  ENDP IiyVPMOVSXWQ::
</pre>

<dl id="IiyVPMOVSXDQ">
<dt><a href="#IiyVPMOVSXBW">&uarr; VPMOVSXDQ</a></dt>
<dd>Packed Move with Sign Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVSXDQ xmm1, xmm2/m64
</th><td>VEX.128.66.0F38.WIG 25 /r 
</td></tr>
<tr><th>VPMOVSXDQ ymm1, xmm2/m128
</th><td>VEX.256.66.0F38.WIG 25 /r 
</td></tr>
<tr><th>VPMOVSXDQ xmm1 {k1}{z}, xmm2/m64
</th><td>EVEX.128.66.0F38.W0 25 /r 
</td></tr>
<tr><th>VPMOVSXDQ ymm1 {k1}{z}, xmm2/m128
</th><td>EVEX.256.66.0F38.W0 25 /r 
</td></tr>
<tr><th>VPMOVSXDQ zmm1 {k1}{z}, ymm2/m256
</th><td>EVEX.512.66.0F38.W0 25 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Mq | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3825 /r | 0x660F3825 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5676.htm">t5676</a>
</dd>
</dl><pre>
IiyVPMOVSXDQ:: PROC
    IiEmitOpcode 0x25
    JMP IiyVPMOVSXBW.HVM:
  ENDP IiyVPMOVSXDQ::
</pre>

<dl id="IiyVPMOVZXBW">
<dt><a href="#IiyVPMOVSXBW">&uarr; VPMOVZXBW</a></dt>
<dd>Packed Move with Zero Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVZXBW xmm1, xmm2/m64
</th><td>VEX.128.66.0F38.WIG 30 /r 
</td></tr>
<tr><th>VPMOVZXBW ymm1, xmm2/m128
</th><td>VEX.256.66.0F38.WIG 30 /r 
</td></tr>
<tr><th>VPMOVZXBW xmm1 {k1}{z}, xmm2/m64 
</th><td>EVEX.128.66.0F38.WIG 30 /r 
</td></tr>
<tr><th>VPMOVZXBW ymm1 {k1}{z}, xmm2/m128
</th><td>EVEX.256.66.0F38.WIG 30 /r
</td></tr>
<tr><th>VPMOVZXBW zmm1 {k1}{z}, ymm2/m256
</th><td>EVEX.512.66.0F38.WIG 30 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Mq | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3830 /r | 0x660F3830 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5678.htm">t5678</a>
</dd>
</dl><pre>
IiyVPMOVZXBW:: PROC
    IiEmitOpcode 0x30
    JMP IiyVPMOVSXBW.HVM:
  ENDP IiyVPMOVZXBW::
</pre>

<dl id="IiyVPMOVZXBD">
<dt><a href="#IiyVPMOVSXBD">&uarr; VPMOVZXBD</a></dt>
<dd>Packed Move with Zero Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVZXBD xmm1, xmm2/m32
</th><td>VEX.128.66.0F38.WIG 31 /r 
</td></tr>
<tr><th>VPMOVZXBD ymm1, xmm2/m64
</th><td>VEX.256.66.0F38.WIG 31 /r 
</td></tr>
<tr><th>VPMOVZXBD xmm1 {k1}{z}, xmm2/m32 
</th><td>EVEX.128.66.0F38.WIG 31 /r 
</td></tr>
<tr><th>VPMOVZXBD ymm1 {k1}{z}, xmm2/m64 
</th><td>EVEX.256.66.0F38.WIG 31 /r 
</td></tr>
<tr><th>VPMOVZXBD zmm1 {k1}{z}, xmm2/m128
</th><td>EVEX.512.66.0F38.WIG 31 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Md | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3831 /r | 0x660F3831 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5678.htm">t5678</a>
</dd>
</dl><pre>
IiyVPMOVZXBD:: PROC
    IiEmitOpcode 0x31
    JMP IiyVPMOVSXBD.QVM:
  ENDP IiyVPMOVZXBD::
</pre>

<dl id="IiyVPMOVZXBQ">
<dt><a href="#IiyVPMOVSXBQ">&uarr; VPMOVZXBQ</a></dt>
<dd>Packed Move with Zero Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVZXBQ xmm1, xmm2/m16
</th><td>VEX.128.66.0F38.WIG 32 /r 
</td></tr>
<tr><th>VPMOVZXBQ ymm1, xmm2/m32
</th><td>VEX.256.66.0F38.WIG 32 /r 
</td></tr>
<tr><th>VPMOVZXBQ xmm1 {k1}{z}, xmm2/m16 
</th><td>EVEX.128.66.0F38.WIG 32 /r 
</td></tr>
<tr><th>VPMOVZXBQ ymm1 {k1}{z}, xmm2/m32 
</th><td>EVEX.256.66.0F38.WIG 32 /r 
</td></tr>
<tr><th>VPMOVZXBQ zmm1 {k1}{z}, xmm2/m64
</th><td>EVEX.512.66.0F38.WIG 32 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Mw | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3832 /r | 0x660F3832 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5678.htm">t5678</a>
</dd>
</dl><pre>
IiyVPMOVZXBQ:: PROC
    IiEmitOpcode 0x32
    JMP IiyVPMOVSXBQ.OVM:
  ENDP IiyVPMOVZXBQ::
</pre>

<dl id="IiyVPMOVZXWD">
<dt><a href="#IiyVPMOVSXBW">&uarr; VPMOVZXWD</a></dt>
<dd>Packed Move with Zero Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVZXWD xmm1, xmm2/m64
</th><td>VEX.128.66.0F38.WIG 33 /r 
</td></tr>
<tr><th>VPMOVZXWD ymm1, xmm2/m128
</th><td>VEX.256.66.0F38.WIG 33 /r 
</td></tr>
<tr><th>VPMOVZXWD xmm1 {k1}{z}, xmm2/m64 
</th><td>EVEX.128.66.0F38.WIG 33 /r 
</td></tr>
<tr><th>VPMOVZXWD ymm1 {k1}{z}, xmm2/m128
</th><td>EVEX.256.66.0F38.WIG 33 /r 
</td></tr>
<tr><th>VPMOVZXWD zmm1 {k1}{z}, ymm2/m256
</th><td>EVEX.512.66.0F38.WIG 33 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Mq | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3833 /r | 0x660F3833 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5678.htm">t5678</a>
</dd>
</dl><pre>
IiyVPMOVZXWD:: PROC
    IiEmitOpcode 0x33
    JMP IiyVPMOVSXBW.HVM:
  ENDP IiyVPMOVZXWD::
</pre>

<dl id="IiyVPMOVZXWQ">
<dt><a href="#IiyVPMOVSXBD">&uarr; VPMOVZXWQ</a></dt>
<dd>Packed Move with Zero Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVZXWQ xmm1, xmm2/m32
</th><td>VEX.128.66.0F38.WIG 34 /r 
</td></tr>
<tr><th>VPMOVZXWQ ymm1, xmm2/m64
</th><td>VEX.256.66.0F38.WIG 34 /r 
</td></tr>
<tr><th>VPMOVZXWQ xmm1 {k1}{z}, xmm2/m32
</th><td>EVEX.128.66.0F38.WIG 34 /r 
</td></tr>
<tr><th>VPMOVZXWQ ymm1 {k1}{z}, xmm2/m64 
</th><td>EVEX.256.66.0F38.WIG 34 /r 
</td></tr>
<tr><th>VPMOVZXWQ zmm1 {k1}{z}, xmm2/m128
</th><td>EVEX.512.66.0F38.WIG 34 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Md | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3834 /r | 0x660F3834 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5678.htm">t5678</a>
</dd>
</dl><pre>
IiyVPMOVZXWQ:: PROC
    IiEmitOpcode 0x34
    JMP IiyVPMOVSXBD.QVM:
   ENDP IiyVPMOVZXWQ::
</pre>

<dl id="IiyVPMOVZXDQ">
<dt><a href="#IiyVPMOVSXBW">&uarr; VPMOVZXDQ</a></dt>
<dd>Packed Move with Zero Extend</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVZXDQ xmm1, xmm2/m64
</th><td>VEX.128.66.0F38.WIG 35 /r 
</td></tr>
<tr><th>VPMOVZXDQ ymm1, xmm2/m128
</th><td>VEX.256.66.0F38.WIG 35 /r 
</td></tr>
<tr><th>VPMOVZXDQ xmm1 {k1}{z}, xmm2/m64 
</th><td>EVEX.128.66.0F38.W0 35 /r 
</td></tr>
<tr><th>VPMOVZXDQ ymm1 {k1}{z}, xmm2/m128
</th><td>EVEX.256.66.0F38.W0 35 /r 
</td></tr>
<tr><th>VPMOVZXDQ zmm1 {k1}{z}, ymm2/m256
</th><td>EVEX.512.66.0F38.W0 35 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Mq | <b>Vdq</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x660F3835 /r | 0x660F3835 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5678.htm">t5678</a>
</dd>
</dl><pre>
IiyVPMOVZXDQ:: PROC
    IiEmitOpcode 0x35
    JMP IiyVPMOVSXBW.HVM:
  ENDP IiyVPMOVZXDQ::
</pre>

<dl id="IiyVPMULDQ">
<dt><a href="#IiyHandlers">&uarr; VPMULDQ</a></dt>
<dd>Multiply Packed Signed Dword Integers</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMULDQ xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.WIG 28 /r 
</td></tr>
<tr><th>VPMULDQ ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.WIG 28 /r
</td></tr>
<tr><th>VPMULDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F38.W1 28 /r 
</td></tr>
<tr><th>VPMULDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F38.W1 28 /r 
</td></tr>
<tr><th>VPMULDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F38.W1 28 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,arith</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x660F3828 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5680.htm">t5680</a>
</dd>
</dl><pre>
IiyVPMULDQ:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiEmitOpcode 0x28
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38.WIG, EVEX.NDS.128.66.0F38.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38.WIG, EVEX.NDS.256.66.0F38.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W1
    RET
  ENDP IiyVPMULDQ::
</pre>

<dl id="IiyVPMULHRSW">
<dt><a href="#IiyHandlers">&uarr; VPMULHRSW</a></dt>
<dd>Packed Multiply High with Round and Scale</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMULHRSW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38 0B /r 
</td></tr>
<tr><th>VPMULHRSW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38 0B /r 
</td></tr>
<tr><th>VPMULHRSW xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F38.WIG 0B /r 
</td></tr>
<tr><th>VPMULHRSW ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F38.WIG 0B /r 
</td></tr>
<tr><th>VPMULHRSW zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F38.WIG 0B /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>ssse3,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F380B /r | 0x660F380B /r</dd>
<dt>CPU</dt>
<dd>C2+</dd>
</dl><pre>
IiyVPMULHRSW:: PROC
    IiAllowModifier MASK
    IiEmitOpcode 0x0B
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38, EVEX.NDS.128.66.0F38.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38, EVEX.NDS.256.66.0F38.WIG
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.WIG
    RET
  ENDP IiyVPMULHRSW::
</pre>

<dl id="IiyVPMULHUW">
<dt><a href="#IiyHandlers">&uarr; VPMULHUW</a></dt>
<dd>Multiply Packed Unsigned Integers and Store High Result</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMULHUW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F E4 /r 
</td></tr>
<tr><th>VPMULHUW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F E4 /r 
</td></tr>
<tr><th>VPMULHUW xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG E4 /r 
</td></tr>
<tr><th>VPMULHUW ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG E4 /r 
</td></tr>
<tr><th>VPMULHUW zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG E4 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0FE4 /r | 0x660FE4 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
</dl><pre>
IiyVPMULHUW:: PROC
    IiAllowModifier MASK
    IiEmitOpcode 0xE4
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F, EVEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F, EVEX.NDS.256.66.0F.WIG
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.WIG
    RET
  ENDP IiyVPMULHUW::
</pre>

<dl id="IiyVPMULHW">
<dt><a href="#IiyHandlers">&uarr; VPMULHW</a></dt>
<dd>Multiply Packed Signed Integers and Store High Result</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMULHW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F E5 /r 
</td></tr>
<tr><th>VPMULHW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F E5 /r 
</td></tr>
<tr><th>VPMULHW xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG E5 /r 
</td></tr>
<tr><th>VPMULHW ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG E5 /r 
</td></tr>
<tr><th>VPMULHW zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG E5 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,arith</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0FE5 /r | 0x660FE5 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
</dl><pre>
IiyVPMULHW:: PROC
    IiAllowModifier MASK
    IiEmitOpcode 0xE5
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F, EVEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F, EVEX.NDS.256.66.0F.WIG
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.WIG
    RET
  ENDP IiyVPMULHW::
</pre>

<dl id="IiyVPMULLD">
<dt><a href="#IiyHandlers">&uarr; VPMULLD</a></dt>
<dd>Multiply Packed Signed Dword Integers and Store Low Result</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMULLD xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.WIG 40 /r 
</td></tr>
<tr><th>VPMULLD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.WIG 40 /r 
</td></tr>
<tr><th>VPMULLD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F38.W0 40 /r 
</td></tr>
<tr><th>VPMULLD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F38.W0 40 /r 
</td></tr>
<tr><th>VPMULLD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F38.W0 40 /r 
</td></tr>
<tr><th>VPMULLD zmm1 {k1}, zmm2, zmm3/m512/m32bcst
</th><td>MVEX.NDS.512.66.0F38.W0 40 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,arith</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x660F3840 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5680.htm">t5680</a>
</dd>
</dl><pre>
IiyVPMULLD:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiEmitOpcode 0x40
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDisp8MVEX Si32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38.WIG, EVEX.NDS.128.66.0F38.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38.WIG, EVEX.NDS.256.66.0F38.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W0, MVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPMULLD::
</pre>

<dl id="IiyVPMULLQ">
<dt><a href="#IiyHandlers">&uarr; VPMULLQ</a></dt>
<dd>Multiply Packed QWORD Signed Integers and Store Low Result</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMULLQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F38.W1 40 /r 
</td></tr>
<tr><th>VPMULLQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F38.W1 40 /r 
</td></tr>
<tr><th>VPMULLQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F38.W1 40 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x40</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5680.htm">t5680</a>
</dd>
</dl><pre>                    array(),
IiyVPMULLQ:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiEmitOpcode 0x40
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W1
    RET
  ENDP IiyVPMULLQ::
</pre>

<dl id="IiyVPMULLW">
<dt><a href="#IiyHandlers">&uarr; VPMULLW</a></dt>
<dd>Multiply Packed Signed Integers and Store Low Result</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMULLW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F D5 /r 
</td></tr>
<tr><th>VPMULLW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F D5 /r 
</td></tr>
<tr><th>VPMULLW xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG D5 /r 
</td></tr>
<tr><th>VPMULLW ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG D5 /r 
</td></tr>
<tr><th>VPMULLW zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG D5 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,arith</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0FD5 /r | 0x660FD5 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
</dl><pre>
IiyVPMULLW:: PROC
    IiAllowModifier MASK
    IiEmitOpcode 0xD5
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F, EVEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F, EVEX.NDS.256.66.0F.WIG
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.WIG
    RET
  ENDP IiyVPMULLW::
</pre>

<dl id="IiyVPAVGB">
<dt><a href="#IiyHandlers">&uarr; VPAVGB</a></dt>
<dd>Average Packed unsigned BYTE Integers</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPAVGB xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F E0 /r 
</td></tr>
<tr><th>VPAVGB ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F E0 /r    
</td></tr>
<tr><th>VPAVGB xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG E0 /r 
</td></tr>
<tr><th>VPAVGB ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG E0 /r 
</td></tr>
<tr><th>VPAVGB zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG E0 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0FE0 /r | 0x660FE0 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5684.htm">t5684</a>
</dd>
</dl><pre>
IiyVPAVGB:: PROC
    IiEncoding DATA=BYTE
    IiAllowModifier MASK
    IiEmitOpcode 0xE0
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F, EVEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F, EVEX.NDS.256.66.0F.WIG
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.WIG
    RET
  ENDP IiyVPAVGB::
</pre>

<dl id="IiyVPAVGW">
<dt><a href="#IiyHandlers">&uarr; VPAVGW</a></dt>
<dd>Average Packed unsigned WORD Integers</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPAVGW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F E3 /r 
</td></tr>
<tr><th>VPAVGW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F E3 /r 
</td></tr>
<tr><th>VPAVGW xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG E3 /r 
</td></tr>
<tr><th>VPAVGW ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG E3 /r 
</td></tr>
<tr><th>VPAVGW zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG E3 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0FE3 /r | 0x660FE3 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5684.htm">t5684</a>
</dd>
</dl><pre>
IiyVPAVGW:: PROC
    IiEncoding DATA=WORD
    IiAllowModifier MASK
    IiEmitOpcode 0xE3
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F, EVEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F, EVEX.NDS.256.66.0F.WIG
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.WIG
    RET
  ENDP IiyVPAVGW::
</pre>

<dl id="IiyVPMASKMOVD">
<dt><a href="#IiyHandlers">&uarr; VPMASKMOVD</a></dt>
<dd>Conditional SIMD Integer Packed Loads and Stores</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMASKMOVD xmm1, xmm2, m128
</th><td>VEX.NDS.128.66.0F38.W0 8C /r 
</td></tr>
<tr><th>VPMASKMOVD ymm1, ymm2, m256
</th><td>VEX.NDS.256.66.0F38.W0 8C /r 
</td></tr>
<tr><th>VPMASKMOVD m128, xmm1, xmm2
</th><td>VEX.NDS.128.66.0F38.W0 8E /r 
</td></tr>
<tr><th>VPMASKMOVD m256, ymm1, ymm2
</th><td>VEX.NDS.256.66.0F38.W0 8E /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x8C | 0x8E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5468.htm">t5468</a>
<a class="EXT" href="../eatests/t5668.htm">t5668</a>
</dd>
</dl><pre>
IiyVPMASKMOVD:: PROC
    IiModRM /r
    CMP DL,mem
    JE .M:
    IiEmitOpcode 0x8E
    IiOpEn MVR
    IiDispatchFormat mem.xmm.xmm, mem.ymm.ymm
.M: IiEmitOpcode 0x8C ; The last operand is in memory.
    IiOpEn RVM
    IiDispatchFormat  xmm.xmm.mem, ymm.ymm.mem
.xmm.xmm.mem:
.mem.xmm.xmm:
    IiEmitPrefix VEX.NDS.128.66.0F38.W0
    RET
.ymm.ymm.mem:
.mem.ymm.ymm:
    IiEmitPrefix VEX.NDS.256.66.0F38.W0
    RET
  ENDP IiyVPMASKMOVD::
</pre>

<dl id="IiyVPMASKMOVQ">
<dt><a href="#IiyHandlers">&uarr; VPMASKMOVQ</a></dt>
<dd>Conditional SIMD Integer Packed Loads and Stores</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMASKMOVQ xmm1, xmm2, m128
</th><td>VEX.NDS.128.66.0F38.W1 8C /r 
</td></tr>
<tr><th>VPMASKMOVQ ymm1, ymm2, m256
</th><td>VEX.NDS.256.66.0F38.W1 8C /r 
</td></tr>
<tr><th>VPMASKMOVQ m128, xmm1, xmm2
</th><td>VEX.NDS.128.66.0F38.W1 8E /r 
</td></tr>
<tr><th>VPMASKMOVQ m256, ymm1, ymm2
</th><td>VEX.NDS.256.66.0F38.W1 8E /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x8C | 0x8E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5468.htm">t5468</a>
<a class="EXT" href="../eatests/t5668.htm">t5668</a>
</dd>
</dl><pre>
IiyVPMASKMOVQ:: PROC
    IiModRM /r
    CMP DL,mem
    JE .M:
    IiEmitOpcode 0x8E
    IiOpEn MVR
    IiDispatchFormat mem.xmm.xmm, mem.ymm.ymm
.M: IiEmitOpcode 0x8C ; The last operand is in memory.
    IiOpEn RVM
    IiDispatchFormat  xmm.xmm.mem, ymm.ymm.mem
.xmm.xmm.mem:
.mem.xmm.xmm:
    IiEmitPrefix VEX.NDS.128.66.0F38.W1
    RET
.ymm.ymm.mem:
.mem.ymm.ymm:
    IiEmitPrefix VEX.NDS.256.66.0F38.W1
    RET
  ENDP IiyVPMASKMOVQ::
</pre>

<dl id="IiyVMASKMOVPS">
<dt><a href="#IiyHandlers">&uarr; VMASKMOVPS</a></dt>
<dd>Conditional SIMD Packed Loads and Stores</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VMASKMOVPS xmm1, xmm2, m128
</th><td>VEX.NDS.128.66.0F38.W0 2C /r
</td></tr>
<tr><th>VMASKMOVPS ymm1, ymm2, m256
</th><td>VEX.NDS.256.66.0F38.W0 2C /r
</td></tr>
<tr><th>VMASKMOVPS m128,xmm1, xmm2
</th><td>VEX.NDS.128.66.0F38.W0 2E /r
</td></tr>
<tr><th>VMASKMOVPS m256,ymm1, ymm2
</th><td>VEX.NDS.256.66.0F38.W0 2E /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x2C | 0x2E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5668.htm">t5668</a>
</dd>
</dl><pre>
IiyVMASKMOVPS:: PROC
    IiModRM /r
    CMP DL,mem
    JE .M:
    IiEmitOpcode 0x2E
    IiOpEn MVR
    IiDispatchFormat  mem.xmm.xmm, mem.ymm.ymm
.M: IiEmitOpcode 0x2C
    IiOpEn RVM
    IiDispatchFormat  xmm.xmm.mem, ymm.ymm.mem
.mem.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38.W0
    RET
.mem.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38.W0
    RET
  ENDP IiyVMASKMOVPS::
</pre>

<dl id="IiyVMASKMOVPD">
<dt><a href="#IiyHandlers">&uarr; VMASKMOVPD</a></dt>
<dd>Conditional SIMD Packed Loads and Stores</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VMASKMOVPD xmm1, xmm2, m128
</th><td>VEX.NDS.128.66.0F38.W0 2D /r
</td></tr>
<tr><th>VMASKMOVPD ymm1, ymm2, m256
</th><td>VEX.NDS.256.66.0F38.W0 2D /r
</td></tr>
<tr><th>VMASKMOVPD m128, xmm1, xmm2
</th><td>VEX.NDS.128.66.0F38.W0 2F /r
</td></tr>
<tr><th>VMASKMOVPD m256, ymm1, ymm2
</th><td>VEX.NDS.256.66.0F38.W0 2F /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x2D | 0x2F</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5668.htm">t5668</a>
</dd>
</dl><pre>
IiyVMASKMOVPD:: PROC
    IiModRM /r
    CMP DL,mem
    JE .M:
    IiEmitOpcode 0x2F
    IiOpEn MVR
    IiDispatchFormat  mem.xmm.xmm, mem.ymm.ymm
.M: IiEmitOpcode 0x2D
    IiOpEn RVM
    IiDispatchFormat  xmm.xmm.mem, ymm.ymm.mem
.mem.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38.W0
    RET
.mem.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38.W0
    RET
  ENDP IiyVMASKMOVPD::
</pre>

<dl id="IiyVMASKMOVDQU">
<dt><a href="#IiyHandlers">&uarr; VMASKMOVDQU</a></dt>
<dd>Store Selected Bytes of Double Quadword</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VMASKMOVDQU xmm1, xmm2
</th><td>VEX.128.66.0F.WIG F7 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse2,cachect</dd>
<dt>Operands</dt>
<dd><b><i><span title="nr: -, group: -, type: dq, address: BD">BDdq</span>
</i></b>,Vdq,Udq</dd>
<dt>Opcode</dt>
<dd>0x660FF7 /r</dd>
<dt>CPU</dt>
<dd>P4+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5668.htm">t5668</a>
</dd>
</dl><pre>
IiyVMASKMOVDQU:: PROC
    IiEmitOpcode 0xF7
    IiOpEn RM
    IiModRM /r
    IiDispatchFormat  xmm.xmm
.xmm.xmm:
    IiEmitPrefix VEX.128.66.0F.WIG
    RET
  ENDP IiyVMASKMOVDQU::
</pre>

<dl id="IiyVPMOVMSKB">
<dt><a href="#IiyHandlers">&uarr; VPMOVMSKB</a></dt>
<dd>Move Byte Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVMSKB reg, xmm1
</th><td>VEX.128.66.0F.WIG D7 /r
</td></tr>
<tr><th>VPMOVMSKB reg, ymm1
</th><td>VEX.256.66.0F.WIG D7 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdint</dd>
<dt>Operands</dt>
<dd><b>Gdqp</b>,Nq | <b>Gdqp</b>,Udq</dd>
<dt>Opcode</dt>
<dd>0x0FD7 /r | 0x660FD7 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5668.htm">t5668</a>
</dd>
</dl><pre>
IiyVPMOVMSKB:: PROC
    IiEmitOpcode 0xD7
    IiOpEn RM
    IiModRM /r
    IiDispatchFormat  r32.xmm, r32.ymm, r64.xmm, r64.ymm
.r32.xmm:
.r64.xmm:
    IiEmitPrefix VEX.128.66.0F.WIG
    RET
.r32.ymm:
.r64.ymm:
    IiEmitPrefix VEX.256.66.0F.WIG
    RET
  ENDP IiyVPMOVMSKB::
</pre>

<dl id="IiyVPBLENDW">
<dt><a href="#IiyHandlers">&uarr; VPBLENDW</a></dt>
<dd>Blend Packed Words</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPBLENDW xmm1, xmm2, xmm3/m128, imm8
</th><td>VEX.NDS.128.66.0F3A.WIG 0E /r ib
</td></tr>
<tr><th>VPBLENDW ymm1, ymm2, ymm3/m256, imm8</th><td>VEX.NDS.256.66.0F3A.WIG 0E /r ib
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,datamov</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Wdq,Ib</dd>
<dt>Opcode</dt>
<dd>0x660F3A0E /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5256.htm">t5256</a>
</dd>
</dl><pre>
IiyVPBLENDW:: PROC
    IiEmitOpcode 0x0E
.op:IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm, ymm.ymm.ymm.imm, ymm.ymm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix VEX.NDS.128.66.0F3A.WIG
    RET
.ymm.ymm.ymm.imm:
.ymm.ymm.mem.imm:
    IiEmitPrefix VEX.NDS.256.66.0F3A.WIG
    RET
  ENDP IiyVPBLENDW::
</pre>

<dl id="IiyVPBLENDD">
<dt><a href="#IiyVPBLENDW">&uarr; VPBLENDD</a></dt>
<dd>Blend Packed Dwords</dd>
<dt>Description</dt>
<dd><a class="EXTW" href="http://www.felixcloutier.com/x86/VPBLENDD.html">VPBLENDD</a></dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPBLENDD xmm1, xmm2, xmm3/m128, imm8
</th><td>VEX.NDS.128.66.0F3A.W0 02 /r ib 
</td></tr>
<tr><th>VPBLENDD ymm1, ymm2, ymm3/m256, imm8</th><td>VEX.NDS.256.66.0F3A.W0 02 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x02</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5256.htm">t5256</a>
</dd>
</dl><pre>
IiyVPBLENDD:: PROC
    IiEmitOpcode 0x02
    JMP IiyVPBLENDW.op:
  ENDP IiyVPBLENDD::
</pre>

<dl id="IiyVBLENDPS">
<dt><a href="#IiyVPBLENDW">&uarr; VBLENDPS</a></dt>
<dd>Blend Packed Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VBLENDPS xmm1, xmm2, xmm3/m128, imm8
</th><td>VEX.NDS.128.66.0F3A.WIG 0C /r ib
</td></tr>
<tr><th>VBLENDPS ymm1, ymm2, ymm3/m256, imm8
</th><td>VEX.NDS.256.66.0F3A.WIG 0C /r ib
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdfp,datamov</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wps,Ib</dd>
<dt>Opcode</dt>
<dd>0x660F3A0C /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5256.htm">t5256</a>
</dd>
</dl><pre>
IiyVBLENDPS:: PROC
    IiEmitOpcode 0x0C
    JMP IiyVPBLENDW.op:
  ENDP IiyVBLENDPS::
</pre>

<dl id="IiyVBLENDPD">
<dt><a href="#IiyVPBLENDW">&uarr; VBLENDPD</a></dt>
<dd>Blend Packed Double-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VBLENDPD xmm1, xmm2, xmm3/m128, imm8
</th><td>VEX.NDS.128.66.0F3A.WIG 0D /r ib
</td></tr>
<tr><th>VBLENDPD ymm1, ymm2, ymm3/m256, imm8
</th><td>VEX.NDS.256.66.0F3A.WIG 0D /r ib
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdfp,datamov</dd>
<dt>Operands</dt>
<dd><b>Vpd</b>,Wpd,Ib</dd>
<dt>Opcode</dt>
<dd>0x660F3A0D /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5256.htm">t5256</a>
</dd>
</dl><pre>
IiyVBLENDPD:: PROC
    IiEmitOpcode 0x0D
    JMP IiyVPBLENDW.op:
  ENDP IiyVBLENDPD::
</pre>

<dl id="IiyVBLENDVPS">
<dt><a href="#IiyHandlers">&uarr; VBLENDVPS</a></dt>
<dd>Variable Blend Packed Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VBLENDVPS xmm1, xmm2, xmm3/m128, xmm4
</th><td>VEX.NDS.128.66.0F3A.W0 4A /r /is4
</td></tr>
<tr><th>VBLENDVPS ymm1, ymm2, ymm3/m256, ymm4
</th><td>VEX.NDS.256.66.0F3A.W0 4A /r /is4
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,datamov</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wps,<i><span title="nr: 0, group: xmm, type: -, address: -">XMM0</span></i></dd>
<dt>Opcode</dt>
<dd>0x660F3814 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5258.htm">t5258</a>
</dd>
</dl><pre>
IiyVBLENDVPS:: PROC
    IiEmitOpcode 0x4A
.op:IiOpEn RVM
    IiModRM /r
    IiIs4 Operand4
    IiDispatchFormat  xmm.xmm.xmm.xmm, xmm.xmm.mem.xmm, ymm.ymm.ymm.ymm, ymm.ymm.mem.ymm
.xmm.xmm.xmm.xmm:
.xmm.xmm.mem.xmm:
    IiEmitPrefix VEX.NDS.128.66.0F3A.W0
    RET
.ymm.ymm.ymm.ymm:
.ymm.ymm.mem.ymm:
    IiEmitPrefix VEX.NDS.256.66.0F3A.W0
    RET
  ENDP IiyVBLENDVPS::
</pre>

<dl id="IiyVBLENDVPD">
<dt><a href="#IiyVBLENDVPS">&uarr; VBLENDVPD</a></dt>
<dd>Variable Blend Packed Double-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VBLENDVPD xmm1, xmm2, xmm3/m128, xmm4
</th><td>VEX.NDS.128.66.0F3A.W0 4B /r /is4
</td></tr>
<tr><th>VBLENDVPD ymm1, ymm2, ymm3/m256, ymm4</th>
<td>VEX.NDS.256.66.0F3A.W0 4B /r /is4
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,datamov</dd>
<dt>Operands</dt>
<dd><b>Vpd</b>,Wpd,<i><span title="nr: 0, group: xmm, type: -, address: -">XMM0</span></i></dd>
<dt>Opcode</dt>
<dd>0x660F3815 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5258.htm">t5258</a>
</dd>
</dl><pre>
IiyVBLENDVPD:: PROC
    IiEmitOpcode 0x4B
    JMP IiyVBLENDVPS.op:
  ENDP IiyVBLENDVPD::
</pre>

<dl id="IiyVPBLENDVB">
<dt><a href="#IiyVBLENDVPS">&uarr; VPBLENDVB</a></dt>
<dd>Variable Blend Packed Bytes</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPBLENDVB xmm1, xmm2, xmm3/m128, xmm4
</th><td>VEX.NDS.128.66.0F3A.W0 4C /r /is4
</td></tr>
<tr><th>VPBLENDVB ymm1, ymm2, ymm3/m256, ymm4</th><td>VEX.NDS.256.66.0F3A.W0 4C /r /is4
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,datamov</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Wdq,<i><span title="nr: 0, group: xmm, type: -, address: -">XMM0</span></i></dd>
<dt>Opcode</dt>
<dd>0x660F3810 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5258.htm">t5258</a>
</dd>
</dl><pre>
IiyVPBLENDVB:: PROC
    IiEmitOpcode 0x4C
    JMP IiyVBLENDVPS.op:
  ENDP IiyVPBLENDVB::
</pre>

<dl id="IiyVLDDQU">
<dt><a href="#IiyHandlers">&uarr; VLDDQU</a></dt>
<dd>Load Unaligned Integer 128 Bits</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLDDQU xmm1, m128
</th><td>VEX.128.F2.0F.WIG F0 /r
</td></tr>
<tr><th>VLDDQU ymm1, m256</th><td>VEX.256.F2.0F.WIG F0 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse3,cachect</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Mdq</dd>
<dt>Opcode</dt>
<dd>0xF20FF0 /r</dd>
<dt>CPU</dt>
<dd>P4++</dd>
<dt>See also</dt>
<dd><a href="#IiyVLDQQU">VLDQQU</a>.</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5470.htm">t5470</a>
</dd>
</dl><pre>
IiyVLDDQU:: PROC
    IiEmitOpcode 0xF0
    IiOpEn RM
    IiModRM /r
    IiDispatchFormat  xmm.mem, ymm.mem
.xmm.mem:
    IiEmitPrefix VEX.128.F2.0F.WIG
    RET
.ymm.mem:
    IiEmitPrefix VEX.256.F2.0F.WIG
    RET
  ENDP IiyVLDDQU::
</pre>

<dl id="IiyVLDQQU">
<dt><a href="#IiyHandlers">&uarr; VLDQQU</a></dt>
<dd>Load Unaligned Integer 256 Bits</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLDQQU ymm1, m256</th><td>VEX.256.F2.0F.WIG F0 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xF0</dd>
<dt>Documented</dt>
<dd>UNDOC, see <a class="EXTW" href="https://sourceforge.net/p/nasm/mailman/message/27102219/">NASM</a></dd>
<dt>See also</dt>
<dd><a href="#IiyVLDDQU">VLDDQU</a>.</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5470.htm">t5470</a>
</dd>
</dl><pre>
IiyVLDQQU:: PROC
    IiRequire UNDOC
    IiDispatchFormat  ymm.mem
.ymm.mem: JMP IiyVLDDQU:
  ENDP IiyVLDQQU::
</pre>

<dl id="IiyVLDMXCSR">
<dt><a href="#IiyHandlers">&uarr; VLDMXCSR</a></dt>
<dd>Load MXCSR Register</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLDMXCSR m32</th><td>VEX.LZ.0F.WIG AE /2
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,mxcsrsm</dd>
<dt>Operands</dt>
<dd>Md</dd>
<dt>Opcode</dt>
<dd>0x0FAE /2</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t3700.htm">t3700</a>
</dd>
</dl><pre>
IiyVLDMXCSR:: PROC
    IiEmitOpcode 0xAE
    IiOpEn M
    IiModRM /2
    IiDispatchFormat  mem 
.mem:
    IiEmitPrefix VEX.LZ.0F.WIG
    RET
  ENDP IiyVLDMXCSR::
</pre>

<dl id="IiyVSTMXCSR">
<dt><a href="#IiyHandlers">&uarr; VSTMXCSR</a></dt>
<dd>Store MXCSR Register State</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSTMXCSR m32</th><td>VEX.LZ.0F.WIG AE /3
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,mxcsrsm</dd>
<dt>Operands</dt>
<dd><b>Md</b></dd>
<dt>Opcode</dt>
<dd>0x0FAE /3</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t3700.htm">t3700</a>
</dd>
</dl><pre>
IiyVSTMXCSR:: PROC
    IiEmitOpcode 0xAE
    IiOpEn M
    IiModRM /3
    IiDispatchFormat  mem
.mem:
    IiEmitPrefix VEX.LZ.0F.WIG
    RET
  ENDP IiyVSTMXCSR::
</pre>

<dl id="IiyVRSQRTSS">
<dt><a href="#IiyHandlers">&uarr; VRSQRTSS</a></dt>
<dd>Compute Recipr. of Square Root of Scalar Single-FP Value</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRSQRTSS xmm1, xmm2, xmm3/m32
</th><td>VEX.NDS.LIG.F3.0F.WIG 52 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,arith</dd>
<dt>Operands</dt>
<dd><b>Vss</b>,Wss</dd>
<dt>Opcode</dt>
<dd>0xF30F52 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5655.htm">t5655</a>
</dd>
</dl><pre>
IiyVRSQRTSS:: PROC
    IiEmitOpcode 0x52
.op:IiOpEn RVM
    IiModRM /r
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.LIG.F3.0F.WIG
    RET
  ENDP IiyVRSQRTSS::
</pre>

<dl id="IiyVRCPSS">
<dt><a href="#IiyVRSQRTSS">&uarr; VRCPSS</a></dt>
<dd>Compute Reciprocal of Scalar Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRCPSS xmm1, xmm2, xmm3/m32
</th><td>VEX.NDS.LIG.F3.0F.WIG 53 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,arith</dd>
<dt>Operands</dt>
<dd><b>Vss</b>,Wss</dd>
<dt>Opcode</dt>
<dd>0xF30F53 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5655.htm">t5655</a>
</dd>
</dl><pre>
IiyVRCPSS:: PROC
    IiEmitOpcode 0x53
    JMP IiyVRSQRTSS.op:
  ENDP IiyVRCPSS::
</pre>

<dl id="IiyVRSQRTPS">
<dt><a href="#IiyHandlers">&uarr; VRSQRTPS</a></dt>
<dd>Compute Recipr. of Square Roots of Packed Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRSQRTPS xmm1, xmm2/m128
</th><td>VEX.128.0F.WIG 52 /r
</td></tr>
<tr><th>VRSQRTPS ymm1, ymm2/m256
</th><td>VEX.256.0F.WIG 52 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,arith</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wps</dd>
<dt>Opcode</dt>
<dd>0x0F52 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5655.htm">t5655</a>
</dd>
</dl><pre>
IiyVRSQRTPS:: PROC
    IiEmitOpcode 0x52
.op:IiOpEn RM
    IiModRM /r
    IiDispatchFormat  xmm.xmm, xmm.mem, ymm.ymm, ymm.mem
.xmm.xmm:
.xmm.mem:
    IiEmitPrefix VEX.128.0F.WIG
    RET
.ymm.ymm:
.ymm.mem:
    IiEmitPrefix VEX.256.0F.WIG
    RET
  ENDP IiyVRSQRTPS::
</pre>

<dl id="IiyVRCPPS">
<dt><a href="#IiyVRSQRTPS">&uarr; VRCPPS</a></dt>
<dd>Compute Reciprocals of Packed Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRCPPS xmm1, xmm2/m128
</th><td>VEX.128.0F.WIG 53 /r
</td></tr>
<tr><th>VRCPPS ymm1, ymm2/m256
</th><td>VEX.256.0F.WIG 53 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,arith</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wps</dd>
<dt>Opcode</dt>
<dd>0x0F53 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5655.htm">t5655</a>
</dd>
</dl><pre>
IiyVRCPPS:: PROC
    IiEmitOpcode 0x53
    JMP IiyVRSQRTPS.op:
  ENDP IiyVRCPPS::
</pre>

<dl id="IiyVUNPCKLPS">
<dt><a href="#IiyHandlers">&uarr; VUNPCKLPS</a></dt>
<dd>Unpack and Interleave Low Packed Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VUNPCKLPS xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.0F.WIG 14 /r 
</td></tr>
<tr><th>VUNPCKLPS ymm1,ymm2,ymm3/m256
</th><td>VEX.NDS.256.0F.WIG 14 /r 
</td></tr>
<tr><th>VUNPCKLPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.0F.W0 14 /r 
</td></tr>
<tr><th>VUNPCKLPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.0F.W0 14 /r 
</td></tr>
<tr><th>VUNPCKLPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.0F.W0 14 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,shunpck</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wq</dd>
<dt>Opcode</dt>
<dd>0x0F14 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
</dl><pre>
IiyVUNPCKLPS:: PROC
    IiEmitOpcode 0x14
.op:IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.0F.WIG, EVEX.NDS.128.0F.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.0F.WIG, EVEX.NDS.256.0F.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.0F.W0
    RET
  ENDP IiyVUNPCKLPS::
</pre>

<dl id="IiyVUNPCKHPS">
<dt><a href="#IiyVUNPCKLPS">&uarr; VUNPCKHPS</a></dt>
<dd>Unpack and Interleave High Packed Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VUNPCKHPS xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.0F.WIG 15 /r 
</td></tr>
<tr><th>VUNPCKHPS ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.0F.WIG 15 /r 
</td></tr>
<tr><th>VUNPCKHPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.0F.W0 15 /r 
</td></tr>
<tr><th>VUNPCKHPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.0F.W0 15 /r 
</td></tr>
<tr><th>VUNPCKHPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.0F.W0 15 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,simdfp,shunpck</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wq</dd>
<dt>Opcode</dt>
<dd>0x0F15 /r</dd>
<dt>CPU</dt>
<dd>P3+</dd>
</dl><pre>
IiyVUNPCKHPS:: PROC
    IiEmitOpcode 0x15
    JMP IiyVUNPCKLPS.op:
  ENDP IiyVUNPCKHPS::
</pre>

<dl id="IiyVUNPCKLPD">
<dt><a href="#IiyHandlers">&uarr; VUNPCKLPD</a></dt>
<dd>Unpack and Interleave Low Packed Double-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VUNPCKLPD xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 14 /r 
</td></tr>
<tr><th>VUNPCKLPD ymm1,ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 14 /r 
</td></tr>
<tr><th>VUNPCKLPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F.W1 14 /r 
</td></tr>
<tr><th>VUNPCKLPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F.W1 14 /r 
</td></tr>
<tr><th>VUNPCKLPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F.W1 14 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse2,pcksclr,shunpck</dd>
<dt>Operands</dt>
<dd><b>Vpd</b>,Wpd</dd>
<dt>Opcode</dt>
<dd>0x660F14 /r</dd>
<dt>CPU</dt>
<dd>P4+</dd>
</dl><pre>
IiyVUNPCKLPD:: PROC
    IiEmitOpcode 0x14
.op:IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F.WIG, EVEX.NDS.128.66.0F.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F.WIG, EVEX.NDS.256.66.0F.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.W1
    RET
  ENDP IiyVUNPCKLPD::
</pre>

<dl id="IiyVUNPCKHPD">
<dt><a href="#IiyVUNPCKLPD">&uarr; VUNPCKHPD</a></dt>
<dd>Unpack and Interleave High Packed Double-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VUNPCKHPD xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 15 /r 
</td></tr>
<tr><th>VUNPCKHPD ymm1,ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 15 /r 
</td></tr>
<tr><th>VUNPCKHPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F.W1 15 /r 
</td></tr>
<tr><th>VUNPCKHPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F.W1 15 /r 
</td></tr>
<tr><th>VUNPCKHPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F.W1 15 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse2,pcksclr,shunpck</dd>
<dt>Operands</dt>
<dd><b>Vpd</b>,Wpd</dd>
<dt>Opcode</dt>
<dd>0x660F15 /r</dd>
<dt>CPU</dt>
<dd>P4+</dd>
</dl><pre>
IiyVUNPCKHPD:: PROC
    IiEmitOpcode 0x15
    JMP IiyVUNPCKLPD.op:
  ENDP IiyVUNPCKHPD::
</pre>

<dl id="IiyVPUNPCKLBW">
<dt><a href="#IiyHandlers">&uarr; VPUNPCKLBW</a></dt>
<dd>Unpack Low Data</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPUNPCKLBW xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 60 /r 
</td></tr>
<tr><th>VPUNPCKLBW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 60 /r 
</td></tr>
<tr><th>VPUNPCKLBW xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG 60 /r 
</td></tr>
<tr><th>VPUNPCKLBW ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG 60 /r 
</td></tr>
<tr><th>VPUNPCKLBW zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG 60 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,unpack</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qd | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F60 /r | 0x660F60 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5692.htm">t5692</a>
</dd>
</dl><pre>
IiyVPUNPCKLBW:: PROC
    IiEmitOpcode 0x60
.op:IiAllowModifier MASK
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F.WIG, EVEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F.WIG, EVEX.NDS.256.66.0F.WIG
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.WIG
    RET
  ENDP IiyVPUNPCKLBW::
</pre>

<dl id="IiyVPUNPCKLWD">
<dt><a href="#IiyVPUNPCKLBW">&uarr; VPUNPCKLWD</a></dt>
<dd>Unpack Low Data</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPUNPCKLWD xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 61 /r 
</td></tr>
<tr><th>VPUNPCKLWD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 61 /r 
</td></tr>
<tr><th>VPUNPCKLWD xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG 61 /r 
</td></tr>
<tr><th>VPUNPCKLWD ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG 61 /r 
</td></tr>
<tr><th>VPUNPCKLWD zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG 61 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,unpack</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qd | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F61 /r | 0x660F61 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5692.htm">t5692</a>
</dd>
</dl><pre>
IiyVPUNPCKLWD:: PROC
    IiEmitOpcode 0x61
    JMP IiyVPUNPCKLBW.op:
  ENDP IiyVPUNPCKLWD::
</pre>

<dl id="IiyVPUNPCKLDQ">
<dt><a href="#IiyVUNPCKLPS">&uarr; VPUNPCKLDQ</a></dt>
<dd>Unpack Low Data</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPUNPCKLDQ xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 62 /r 
</td></tr>
<tr><th>VPUNPCKLDQ ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 62 /r 
</td></tr>
<tr><th>VPUNPCKLDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F.W0 62 /r 
</td></tr>
<tr><th>VPUNPCKLDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F.W0 62 /r 
</td></tr>
<tr><th>VPUNPCKLDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F.W0 62 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,unpack</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qd | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F62 /r | 0x660F62 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5692.htm">t5692</a>
</dd>
</dl><pre>
IiyVPUNPCKLDQ:: PROC
    IiEmitOpcode 0x62
.op:IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F.WIG, EVEX.NDS.128.66.0F.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F.WIG, EVEX.NDS.256.66.0F.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.W0
    RET
  ENDP IiyVPUNPCKLDQ::
</pre>

<dl id="IiyVPUNPCKLQDQ">
<dt><a href="#IiyVUNPCKLPD">&uarr; VPUNPCKLQDQ</a></dt>
<dd>Unpack Low Data</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPUNPCKLQDQ xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 6C /r 
</td></tr>
<tr><th>VPUNPCKLQDQ ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 6C /r 
</td></tr>
<tr><th>VPUNPCKLQDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F.W1 6C /r 
</td></tr>
<tr><th>VPUNPCKLQDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F.W1 6C /r 
</td></tr>
<tr><th>VPUNPCKLQDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F.W1 6C /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse2,simdint,shunpck</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x660F6C /r</dd>
<dt>CPU</dt>
<dd>P4+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5692.htm">t5692</a>
</dd>
</dl><pre>
IiyVPUNPCKLQDQ:: PROC
    IiEmitOpcode 0x6C
    JMP IiyVUNPCKLPD.op:
  ENDP IiyVPUNPCKLQDQ::
</pre>

<dl id="IiyVPUNPCKHBW">
<dt><a href="#IiyVPUNPCKLBW">&uarr; VPUNPCKHBW</a></dt>
<dd>Unpack High Data</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPUNPCKHBW xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 68 /r 
</td></tr>
<tr><th>VPUNPCKHBW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 68 /r 
</td></tr>
<tr><th>VPUNPCKHBW xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG 68 /r 
</td></tr>
<tr><th>VPUNPCKHBW ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG 68 /r 
</td></tr>
<tr><th>VPUNPCKHBW zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG 68 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,unpack</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F68 /r | 0x660F68 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5694.htm">t5694</a>
</dd>
</dl><pre>
IiyVPUNPCKHBW:: PROC
    IiEmitOpcode 0x68
    JMP IiyVPUNPCKLBW.op:
  ENDP IiyVPUNPCKHBW::
</pre>

<dl id="IiyVPUNPCKHWD">
<dt><a href="#IiyVPUNPCKLBW">&uarr; VPUNPCKHWD</a></dt>
<dd>Unpack High Data</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPUNPCKHWD xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 69 /r 
</td></tr>
<tr><th>VPUNPCKHWD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 69 /r 
</td></tr>
<tr><th>VPUNPCKHWD xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG 69 /r 
</td></tr>
<tr><th>VPUNPCKHWD ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG 69 /r 
</td></tr>
<tr><th>VPUNPCKHWD zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG 69 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,unpack</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F69 /r | 0x660F69 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5694.htm">t5694</a>
</dd>
</dl><pre>
IiyVPUNPCKHWD:: PROC
    IiEmitOpcode 0x69
    JMP IiyVPUNPCKLBW.op:
  ENDP IiyVPUNPCKHWD::
</pre>

<dl id="IiyVPUNPCKHDQ">
<dt><a href="#IiyVPUNPCKLDQ">&uarr; VPUNPCKHDQ</a></dt>
<dd>Unpack High Data</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPUNPCKHDQ xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 6A /r 
</td></tr>
<tr><th>VPUNPCKHDQ ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 6A /r 
</td></tr>
<tr><th>VPUNPCKHDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F.W0 6A /r
</td></tr>
<tr><th>VPUNPCKHDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F.W0 6A /r 
</td></tr>
<tr><th>VPUNPCKHDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F.W0 6A /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,unpack</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F6A /r | 0x660F6A /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5694.htm">t5694</a>
</dd>
</dl><pre>
IiyVPUNPCKHDQ:: PROC
    IiEmitOpcode 0x6A
    JMP IiyVPUNPCKLDQ.op:
  ENDP IiyVPUNPCKHDQ::
</pre>

<dl id="IiyVPUNPCKHQDQ">
<dt><a href="#IiyVUNPCKLPD">&uarr; VPUNPCKHQDQ</a></dt>
<dd>Unpack High Data</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPUNPCKHQDQ xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 6D /r 
</td></tr>
<tr><th>VPUNPCKHQDQ ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 6D /r 
</td></tr>
<tr><th>VPUNPCKHQDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F.W1 6D /r 
</td></tr>
<tr><th>VPUNPCKHQDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F.W1 6D /r 
</td></tr>
<tr><th>VPUNPCKHQDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F.W1 6D /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse2,simdint,shunpck</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x660F6D /r</dd>
<dt>CPU</dt>
<dd>P4+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5694.htm">t5694</a>
</dd>
</dl><pre>
IiyVPUNPCKHQDQ:: PROC
    IiEmitOpcode 0x6D
    JMP IiyVUNPCKLPD.op:
  ENDP IiyVPUNPCKHQDQ::
</pre>

<dl id="IiyVPACKSSWB">
<dt><a href="#IiyVPUNPCKLBW">&uarr; VPACKSSWB</a></dt>
<dd>Pack with Signed Saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKSSWB xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F 63 /r
</td></tr>
<tr><th>VPACKSSWB ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F 63 /r
</td></tr>
<tr><th>VPACKSSWB xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG 63 /r
</td></tr>
<tr><th>VPACKSSWB ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG 63 /r
</td></tr>
<tr><th>VPACKSSWB zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG 63 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,conver</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qd | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F63 /r | 0x660F63 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5696.htm">t5696</a>
</dd>
</dl><pre>
IiyVPACKSSWB:: PROC
    IiEmitOpcode 0x63
    JMP IiyVPUNPCKLBW.op:
  ENDP IiyVPACKSSWB::
</pre>

<dl id="IiyVPACKSSDW">
<dt><a href="#IiyVPUNPCKLDQ">&uarr; VPACKSSDW</a></dt>
<dd>Pack with Signed Saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKSSDW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F 6B /r
</td></tr>
<tr><th>VPACKSSDW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F 6B /r
</td></tr>
<tr><th>VPACKSSDW xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F.W0 6B /r
</td></tr>
<tr><th>VPACKSSDW ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F.W0 6B /r 
</td></tr>
<tr><th>VPACKSSDW zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F.W0 6B /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,conver</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F6B /r | 0x660F6B /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5696.htm">t5696</a>
</dd>
</dl><pre>
IiyVPACKSSDW:: PROC
    IiEmitOpcode 0x6B
    JMP IiyVPUNPCKLDQ.op:
  ENDP IiyVPACKSSDW::
</pre>

<dl id="IiyVPACKUSWB">
<dt><a href="#IiyVPUNPCKLBW">&uarr; VPACKUSWB</a></dt>
<dd>Pack with Unsigned Saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKUSWB xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F 67 /r 
</td></tr>
<tr><th>VPACKUSWB ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F 67 /r 
</td></tr>
<tr><th>VPACKUSWB xmm1{k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG 67 /r 
</td></tr>
<tr><th>VPACKUSWB ymm1{k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG 67 /r 
</td></tr>
<tr><th>VPACKUSWB zmm1{k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG 67 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,conver</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F67 /r | 0x660F67 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5696.htm">t5696</a>
</dd>
</dl><pre>
IiyVPACKUSWB:: PROC
    IiEmitOpcode 0x67
    JMP IiyVPUNPCKLBW.op:
  ENDP IiyVPACKUSWB::
</pre>

<dl id="IiyVPACKUSDW">
<dt><a href="#IiyHandlers">&uarr; VPACKUSDW</a></dt>
<dd>Pack with Unsigned Saturation</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKUSDW xmm1,xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38 2B /r 
</td></tr>
<tr><th>VPACKUSDW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38 2B /r
</td></tr>
<tr><th>VPACKUSDW xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F38.W0 2B /r 
</td></tr>
<tr><th>VPACKUSDW ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F38.W0 2B /r 
</td></tr>
<tr><th>VPACKUSDW zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F38.W0 2B /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdint,conver</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x660F382B /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5696.htm">t5696</a>
</dd>
</dl><pre>
IiyVPACKUSDW:: PROC
    IiRequire SSE4.1
    IiEmitOpcode 0x2B
    IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38, EVEX.NDS.128.66.0F38.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38, EVEX.NDS.256.66.0F38.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPACKUSDW::
</pre>

<dl id="IiyVSCALEFSS">
<dt><a href="#IiyHandlers">&uarr; VSCALEFSS</a></dt>
<dd>Scale Scalar Float32 Value With Float32 Value</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSCALEFSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}
</th><td>EVEX.NDS.LIG.66.0F38.W0 2D /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x2D</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5710.htm">t5710</a>
</dd>
</dl><pre>
IiyVSCALEFSS:: PROC
    IiAllowModifier MASK
    IiAllowRounding Register=xmm
    IiEmitOpcode 0x2D
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX T1S32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.LIG.66.0F38.W0
    RET
  ENDP IiyVSCALEFSS::
</pre>

<dl id="IiyVSCALEFSD">
<dt><a href="#IiyHandlers">&uarr; VSCALEFSD</a></dt>
<dd>Scale Scalar Float64 Values With Float64 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSCALEFSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}
</th><td>EVEX.NDS.LIG.66.0F38.W1 2D /r T
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x2D</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5710.htm">t5710</a>
</dd>
</dl><pre>
IiyVSCALEFSD:: PROC
    IiAllowModifier MASK
    IiAllowRounding Register=xmm
    IiEmitOpcode 0x2D
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX T1S64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.LIG.66.0F38.W1
    RET
  ENDP IiyVSCALEFSD::
</pre>

<dl id="IiyVSCALEFPS">
<dt><a href="#IiyHandlers">&uarr; VSCALEFPS</a></dt>
<dd>Scale Packed Float32 Values With Float32 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSCALEFPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F38.W0 2C /r 
</td></tr>
<tr><th>VSCALEFPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F38.W0 2C /r 
</td></tr>
<tr><th>VSCALEFPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}
</th><td>EVEX.NDS.512.66.0F38.W0 2C /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x2C</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5710.htm">t5710</a>
</dd>
</dl><pre>
IiyVSCALEFPS:: PROC
    IiAllowModifier MASK
    IiAllowRounding
    IiAllowBroadcasting DWORD
    IiEmitOpcode 0x2C
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVSCALEFPS::
</pre>

<dl id="IiyVSCALEFPD">
<dt><a href="#IiyHandlers">&uarr; VSCALEFPD</a></dt>
<dd>Scale Packed Float64 Values With Float64 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSCALEFPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F38.W1 2C /r 
</td></tr>
<tr><th>VSCALEFPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F38.W1 2C /r 
</td></tr>
<tr><th>VSCALEFPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}
</th><td>EVEX.NDS.512.66.0F38.W1 2C /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x2C</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5710.htm">t5710</a>
</dd>
</dl><pre>
IiyVSCALEFPD:: PROC
    IiAllowModifier MASK
    IiAllowRounding
    IiAllowBroadcasting QWORD
    IiEmitOpcode 0x2C
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W1
    RET
  ENDP IiyVSCALEFPD::
</pre>

<dl id="IiyVRNDSCALESS">
<dt><a href="#IiyHandlers">&uarr; VRNDSCALESS</a></dt>
<dd>Round Scalar Float32 Value To Include A Given Number Of Fraction Bits</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRNDSCALESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8
</th><td>EVEX.NDS.LIG.66.0F3A.W0 0A /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x0A</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5712.htm">t5712</a>
</dd>
</dl><pre>
IiyVRNDSCALESS:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH, Register=xmm
    IiEmitOpcode 0x0A
    IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE
    IiDisp8EVEX T1S32
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.LIG.66.0F3A.W0
    RET
  ENDP IiyVRNDSCALESS::
</pre>

<dl id="IiyVRNDSCALESD">
<dt><a href="#IiyHandlers">&uarr; VRNDSCALESD</a></dt>
<dd>Round Scalar Float64 Value To Include A Given Number Of Fraction Bits</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRNDSCALESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8
</th><td>EVEX.NDS.LIG.66.0F3A.W1 0B /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x0B</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5712.htm">t5712</a>
</dd>
</dl><pre>
IiyVRNDSCALESD:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH, Register=xmm
    IiEmitOpcode 0x0B 
    IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE
    IiDisp8EVEX T1S64
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.LIG.66.0F3A.W1
    RET
  ENDP IiyVRNDSCALESD::
</pre>

<dl id="IiyVRNDSCALEPS">
<dt><a href="#IiyHandlers">&uarr; VRNDSCALEPS</a></dt>
<dd>Round Packed Float32 Values To Include A Given Number Of Fraction Bits</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRNDSCALEPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8
</th><td>EVEX.128.66.0F3A.W0 08 /r ib 
</td></tr>
<tr><th>VRNDSCALEPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8
</th><td>EVEX.256.66.0F3A.W0 08 /r ib 
</td></tr>
<tr><th>VRNDSCALEPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, imm8
</th><td>EVEX.512.66.0F3A.W0 08 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x08</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5712.htm">t5712</a>
</dd>
</dl><pre>
IiyVRNDSCALEPS:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH
    IiAllowBroadcasting DWORD, Operand=DH
    IiEmitOpcode 0x08
    IiOpEn RM
    IiModRM /r
    IiEmitImm Operand3, BYTE
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.imm, xmm.mem.imm, ymm.ymm.imm, ymm.mem.imm, zmm.zmm.imm, zmm.mem.imm
.xmm.xmm.imm:
.xmm.mem.imm:
    IiEmitPrefix EVEX.128.66.0F3A.W0
    RET
.ymm.ymm.imm:
.ymm.mem.imm:
    IiEmitPrefix EVEX.256.66.0F3A.W0
    RET
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix EVEX.512.66.0F3A.W0
    RET
  ENDP IiyVRNDSCALEPS::
</pre>

<dl id="IiyVRNDSCALEPD">
<dt><a href="#IiyHandlers">&uarr; VRNDSCALEPD</a></dt>
<dd>Round Packed Float64 Values To Include A Given Number Of Fraction Bits</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRNDSCALEPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8
</th><td>EVEX.128.66.0F3A.W1 09 /r ib 
</td></tr>
<tr><th>VRNDSCALEPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8
</th><td>EVEX.256.66.0F3A.W1 09 /r ib 
</td></tr>
<tr><th>VRNDSCALEPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, imm8</th><td>EVEX.512.66.0F3A.W1 09 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x09</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5712.htm">t5712</a>
</dd>
</dl><pre>
IiyVRNDSCALEPD:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH 
    IiAllowBroadcasting QWORD, Operand=DH
    IiEmitOpcode 0x09
    IiOpEn RM
    IiModRM /r
    IiEmitImm Operand3, BYTE
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.imm, xmm.mem.imm, ymm.ymm.imm, ymm.mem.imm, zmm.zmm.imm, zmm.mem.imm
.xmm.xmm.imm:
.xmm.mem.imm:
    IiEmitPrefix EVEX.128.66.0F3A.W1
    RET
.ymm.ymm.imm:
.ymm.mem.imm:
    IiEmitPrefix EVEX.256.66.0F3A.W1
    RET
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix EVEX.512.66.0F3A.W1
    RET
  ENDP IiyVRNDSCALEPD::
</pre>

<dl id="IiyVROUNDSS">
<dt><a href="#IiyHandlers">&uarr; VROUNDSS</a></dt>
<dd>Round Scalar Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VROUNDSS xmm1, xmm2, xmm3/m32, imm8
</th><td>VEX.NDS.LIG.66.0F3A.WIG 0A /r ib
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdfp,conver</dd>
<dt>Operands</dt>
<dd><b>Vss</b>,Wss,Ib</dd>
<dt>Opcode</dt>
<dd>0x660F3A0A /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5714.htm">t5714</a>
</dd>
</dl><pre>
IiyVROUNDSS:: PROC
    IiEmitOpcode 0x0A
    IiEncoding DATA=DWORD
.op:IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE, Max=15
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix VEX.NDS.LIG.66.0F3A.WIG
    RET
  ENDP IiyVROUNDSS::
</pre>

<dl id="IiyVROUNDSD">
<dt><a href="#IiyVROUNDSS">&uarr; VROUNDSD</a></dt>
<dd>Round Scalar Double-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VROUNDSD xmm1, xmm2, xmm3/m64, imm8
</th><td>VEX.NDS.LIG.66.0F3A.WIG 0B /r ib
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdfp,conver</dd>
<dt>Operands</dt>
<dd><b>Vsd</b>,Wsd,Ib</dd>
<dt>Opcode</dt>
<dd>0x660F3A0B /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5714.htm">t5714</a>
</dd>
</dl><pre>
IiyVROUNDSD:: PROC
    IiEncoding DATA=QWORD
    IiEmitOpcode 0x0B
    JMP IiyVROUNDSS.op:
  ENDP IiyVROUNDSD::
</pre>

<dl id="IiyVROUNDPS">
<dt><a href="#IiyHandlers">&uarr; VROUNDPS</a></dt>
<dd>Round Packed Single-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VROUNDPS xmm1, xmm2/m128, imm8
</th><td>VEX.128.66.0F3A.WIG 08 /r ib
</td></tr>
<tr><th>VROUNDPS ymm1, ymm2/m256, imm8
</th><td>VEX.256.66.0F3A.WIG 08 /r ib
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdfp,conver</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wps,Ib</dd>
<dt>Opcode</dt>
<dd>0x660F3A08 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5714.htm">t5714</a>
</dd>
</dl><pre>
IiyVROUNDPS:: PROC
    IiEmitOpcode 0x08
.op:IiOpEn RM
    IiModRM /r
    IiEmitImm Operand3, BYTE, Max=15
    IiDispatchFormat  xmm.xmm.imm, xmm.mem.imm, ymm.ymm.imm, ymm.mem.imm
.xmm.xmm.imm:
.xmm.mem.imm:
    IiEmitPrefix VEX.128.66.0F3A.WIG
    RET
.ymm.ymm.imm:
.ymm.mem.imm:
    IiEmitPrefix VEX.256.66.0F3A.WIG
    RET
  ENDP IiyVROUNDPS::
</pre>

<dl id="IiyVROUNDPD">
<dt><a href="#IiyVROUNDPS">&uarr; VROUNDPD</a></dt>
<dd>Round Packed Double-FP Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VROUNDPD xmm1, xmm2/m128, imm8
</th><td>VEX.128.66.0F3A.WIG 09 /r ib
</td></tr>
<tr><th>VROUNDPD ymm1, ymm2/m256, imm8
</th><td>VEX.256.66.0F3A.WIG 09 /r ib
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse41,simdfp,conver</dd>
<dt>Operands</dt>
<dd><b>Vps</b>,Wpd,Ib</dd>
<dt>Opcode</dt>
<dd>0x660F3A09 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5714.htm">t5714</a>
</dd>
</dl><pre>
IiyVROUNDPD:: PROC
    IiEmitOpcode 0x09
    JMP IiyVROUNDPS.op:
  ENDP IiyVROUNDPD::
</pre>

<dl id="IiyVPMADDUBSW">
<dt><a href="#IiyHandlers">&uarr; VPMADDUBSW</a></dt>
<dd>Multiply and Add Packed Signed and Unsigned Bytes</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMADDUBSW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38 04 /r 
</td></tr>
<tr><th>VPMADDUBSW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38 04 /r 
</td></tr>
<tr><th>VPMADDUBSW xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F38.WIG 04 /r 
</td></tr>
<tr><th>VPMADDUBSW ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F38.WIG 04 /r 
</td></tr>
<tr><th>VPMADDUBSW zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F38.WIG 04 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>ssse3,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F3804 /r | 0x660F3804 /r</dd>
<dt>CPU</dt>
<dd>C2+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5722.htm">t5722</a>
</dd>
</dl><pre>
IiyVPMADDUBSW:: PROC
    IiAllowModifier MASK
    IiEmitOpcode 0x04
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38, EVEX.NDS.128.66.0F38.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38, EVEX.NDS.256.66.0F38.WIG
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.WIG
    RET
  ENDP IiyVPMADDUBSW::
</pre>

<dl id="IiyVPMADD52LUQ">
<dt><a href="#IiyHandlers">&uarr; VPMADD52LUQ</a></dt>
<dd>Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products  to Qword Accumulators</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMADD52LUQ xmm1 {k1}{z}, xmm2,xmm3/m128/m64bcst
</th><td>EVEX.DDS.128.66.0F38.W1 B4 /r
</td></tr>
<tr><th>VPMADD52LUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.DDS.256.66.0F38.W1 B4 /r
</td></tr>
<tr><th>VPMADD52LUQ zmm1 {k1}{z}, zmm2,zmm3/m512/m64bcst
</th><td>EVEX.DDS.512.66.0F38.W1 B4 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xB4</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5722.htm">t5722</a>
</dd>
</dl><pre>
IiyVPMADD52LUQ:: PROC
    IiEmitOpcode 0xB4
.op:IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.DDS.128.66.0F38.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.DDS.256.66.0F38.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.DDS.512.66.0F38.W1
    RET
  ENDP IiyVPMADD52LUQ::
</pre>

<dl id="IiyVPMADD52HUQ">
<dt><a href="#IiyVPMADD52LUQ">&uarr; VPMADD52HUQ</a></dt>
<dd>Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit  Products to 64-bit Accumulators</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMADD52HUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.DDS.128.66.0F38.W1 B5 /r
</td></tr>
<tr><th>VPMADD52HUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.DDS.256.66.0F38.W1 B5 /r
</td></tr>
<tr><th>VPMADD52HUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.DDS.512.66.0F38.W1 B5 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xB5</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5722.htm">t5722</a>
</dd>
</dl><pre>
IiyVPMADD52HUQ:: PROC
    IiEmitOpcode 0xB5
    JMP IiyVPMADD52LUQ.op:
  ENDP IiyVPMADD52HUQ::
</pre>

<dl id="IiyVPHADDW">
<dt><a href="#IiyHandlers">&uarr; VPHADDW</a></dt>
<dd>Packed Horizontal Add</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPHADDW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.WIG 01 /r
</td></tr>
<tr><th>VPHADDW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.WIG 01 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>ssse3,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F3801 /r | 0x660F3801 /r</dd>
<dt>CPU</dt>
<dd>C2+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5724.htm">t5724</a>
</dd>
</dl><pre>
IiyVPHADDW:: PROC
    IiEmitOpcode 0x01
    IiEncoding DATA=WORD
.op:IiOpEn RVM
    IiModRM /r
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38.WIG
    RET
  ENDP IiyVPHADDW::
</pre>

<dl id="IiyVPHADDD">
<dt><a href="#IiyVPHADDW">&uarr; VPHADDD</a></dt>
<dd>Packed Horizontal Add</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPHADDD xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.WIG 02 /r
</td></tr>
<tr><th>VPHADDD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.WIG 02 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>ssse3,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F3802 /r | 0x660F3802 /r</dd>
<dt>CPU</dt>
<dd>C2+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5724.htm">t5724</a>
</dd>
</dl><pre>
IiyVPHADDD:: PROC
    IiEncoding DATA=DWORD
    IiEmitOpcode 0x02
    JMP IiyVPHADDW.op:
  ENDP IiyVPHADDD::
</pre>

<dl id="IiyVPHADDSW">
<dt><a href="#IiyVPHADDW">&uarr; VPHADDSW</a></dt>
<dd>Packed Horizontal Add and Saturate</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPHADDSW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.WIG 03 /r
</td></tr>
<tr><th>VPHADDSW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.WIG 03 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>ssse3,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F3803 /r | 0x660F3803 /r</dd>
<dt>CPU</dt>
<dd>C2+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5724.htm">t5724</a>
</dd>
</dl><pre>
IiyVPHADDSW:: PROC
    IiEncoding DATA=WORD
    IiEmitOpcode 0x03
    JMP IiyVPHADDW.op:
  ENDP IiyVPHADDSW::
</pre>

<dl id="IiyVPHSUBW">
<dt><a href="#IiyVPHADDW">&uarr; VPHSUBW</a></dt>
<dd>Packed Horizontal Subtract</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPHSUBW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.WIG 05 /r
</td></tr>
<tr><th>VPHSUBW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.WIG 05 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>ssse3,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F3805 /r | 0x660F3805 /r</dd>
<dt>CPU</dt>
<dd>C2+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5724.htm">t5724</a>
</dd>
</dl><pre>
IiyVPHSUBW:: PROC
    IiEncoding DATA=WORD
    IiEmitOpcode 0x05
    JMP IiyVPHADDW.op:
  ENDP IiyVPHSUBW::
</pre>

<dl id="IiyVPHSUBD">
<dt><a href="#IiyVPHADDW">&uarr; VPHSUBD</a></dt>
<dd>Packed Horizontal Subtract</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPHSUBD xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.WIG 06 /r
</td></tr>
<tr><th>VPHSUBD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.WIG 06 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>ssse3,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F3806 /r | 0x660F3806 /r</dd>
<dt>CPU</dt>
<dd>C2+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5724.htm">t5724</a>
</dd>
</dl><pre>
IiyVPHSUBD:: PROC
    IiEncoding DATA=DWORD
    IiEmitOpcode 0x06
    JMP IiyVPHADDW.op:
  ENDP IiyVPHSUBD::
</pre>

<dl id="IiyVPHSUBSW">
<dt><a href="#IiyVPHADDW">&uarr; VPHSUBSW</a></dt>
<dd>Packed Horizontal Subtract and Saturate</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPHSUBSW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.WIG 07 /r
</td></tr>
<tr><th>VPHSUBSW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.WIG 07 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>ssse3,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F3807 /r | 0x660F3807 /r</dd>
<dt>CPU</dt>
<dd>C2+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5724.htm">t5724</a>
</dd>
</dl><pre>
IiyVPHSUBSW:: PROC
    IiEncoding DATA=WORD
    IiEmitOpcode 0x07
    JMP IiyVPHADDW.op:
  ENDP IiyVPHSUBSW::
</pre>

<dl id="IiyVPAND">
<dt><a href="#IiyHandlers">&uarr; VPAND</a></dt>
<dd>Logical AND</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPAND xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG DB /r
</td></tr>
<tr><th>VPAND ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG DB /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,logical</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qd | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0FDB /r | 0x660FDB /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5730.htm">t5730</a>
</dd>
</dl><pre>
IiyVPAND:: PROC
    IiEmitOpcode 0xDB
.op:IiOpEn RVM
    IiModRM /r
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F.WIG
    RET
  ENDP IiyVPAND::
</pre>

<dl id="IiyVPANDD">
<dt><a href="#IiyHandlers">&uarr; VPANDD</a></dt>
<dd>Bitwise AND Int32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPANDD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F.W0 DB /r 
</td></tr>
<tr><th>VPANDD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F.W0 DB /r 
</td></tr>
<tr><th>VPANDD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F.W0 DB /r
</td></tr>
<tr><th>VPANDD zmm1 {k1}, zmm2, zmm3/m512/m32bcst
</th><td>MVEX.NDS.512.66.0F.W0 DB /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xDB</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5730.htm">t5730</a>
</dd>
</dl><pre>
IiyVPANDD:: PROC
    IiEmitOpcode 0xDB
.op:IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDisp8MVEX Si32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.W0, MVEX.NDS.512.66.0F.W0
    RET
  ENDP IiyVPANDD::
</pre>

<dl id="IiyVPANDQ">
<dt><a href="#IiyHandlers">&uarr; VPANDQ</a></dt>
<dd>Bitwise AND Int64 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPANDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F.W1 DB /r 
</td></tr>
<tr><th>VPANDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F.W1 DB /r 
</td></tr>
<tr><th>VPANDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F.W1 DB /r
</td></tr>
<tr><th>VPANDQ zmm1 {k1}, zmm2, zmm3/m512/m64bcst
</th><td>MVEX.NDS.512.66.0F.W1 DB /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xDB</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5730.htm">t5730</a>
</dd>
</dl><pre>
IiyVPANDQ:: PROC
    IiEmitOpcode 0xDB
.op:IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDisp8MVEX Ub64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.W1, MVEX.NDS.512.66.0F.W1
    RET
  ENDP IiyVPANDQ::
</pre>

<dl id="IiyVPOR">
<dt><a href="#IiyVPAND">&uarr; VPOR</a></dt>
<dd>Bitwise Logical OR</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPOR xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG EB /r 
</td></tr>
<tr><th>VPOR ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG EB /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,logical</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0FEB /r | 0x660FEB /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5732.htm">t5732</a>
</dd>
</dl><pre>
IiyVPOR:: PROC
    IiEmitOpcode 0xEB
    JMP IiyVPAND.op:
  ENDP IiyVPOR::
</pre>

<dl id="IiyVPORD">
<dt><a href="#IiyVPANDD">&uarr; VPORD</a></dt>
<dd>Bitwise OR Int32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPORD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst 
</th><td>EVEX.NDS.128.66.0F.W0 EB /r 
</td></tr>
<tr><th>VPORD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst 
</th><td>EVEX.NDS.256.66.0F.W0 EB /r 
</td></tr>
<tr><th>VPORD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst 
</th><td>EVEX.NDS.512.66.0F.W0 EB /r 
</td></tr>
<tr><th>VPORD zmm1 {k1}, zmm2, zmm3/m512/m32bcst
</th><td>MVEX.NDS.512.66.0F.W0 EB /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xEB</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5732.htm">t5732</a>
</dd>
</dl><pre>
IiyVPORD:: PROC
    IiEmitOpcode 0xEB
    JMP IiyVPANDD.op:
  ENDP IiyVPORD::
</pre>

<dl id="IiyVPORQ">
<dt><a href="#IiyVPANDQ">&uarr; VPORQ</a></dt>
<dd>Bitwise OR Int64 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPORQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F.W1 EB /r 
</td></tr>
<tr><th>VPORQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F.W1 EB /r 
</td></tr>
<tr><th>VPORQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F.W1 EB /r 
</td></tr>
<tr><th>VPORQ zmm1 {k1}, zmm2, zmm3/m512/m64bcst
</th><td>MVEX.NDS.512.66.0F.W1 EB /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xEB</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5732.htm">t5732</a>
</dd>
</dl><pre>
IiyVPORQ:: PROC
    IiEmitOpcode 0xEB
    JMP IiyVPANDQ.op:
  ENDP IiyVPORQ::
</pre>

<dl id="IiyVPANDN">
<dt><a href="#IiyVPAND">&uarr; VPANDN</a></dt>
<dd>Logical AND NOT</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPANDN xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG DF /r 
</td></tr>
<tr><th>VPANDN ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG DF /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,logical</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0FDF /r | 0x660FDF /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5734.htm">t5734</a>
</dd>
</dl><pre>
IiyVPANDN:: PROC
    IiEmitOpcode 0xDF
    JMP IiyVPAND.op:
  ENDP IiyVPANDN::
</pre>

<dl id="IiyVPANDND">
<dt><a href="#IiyVPANDD">&uarr; VPANDND</a></dt>
<dd>Bitwise AND NOT Int32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPANDND xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst 
</th><td>EVEX.NDS.128.66.0F.W0 DF /r 
</td></tr>
<tr><th>VPANDND ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst 
</th><td>EVEX.NDS.256.66.0F.W0 DF /r 
</td></tr>
<tr><th>VPANDND zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst 
</th><td>EVEX.NDS.512.66.0F.W0 DF /r 
</td></tr>
<tr><th>VPANDND zmm1 {k1}, zmm2, zmm3/m512/m32bcst
</th><td>MVEX.NDS.512.66.0F.W0 DF /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xDF</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5734.htm">t5734</a>
</dd>
</dl><pre>
IiyVPANDND:: PROC
    IiEmitOpcode 0xDF
    JMP IiyVPANDD.op:
  ENDP IiyVPANDND::
</pre>

<dl id="IiyVPANDNQ">
<dt><a href="#IiyVPANDQ">&uarr; VPANDNQ</a></dt>
<dd>Bitwise AND NOT Int64 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPANDNQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst 
</th><td>EVEX.NDS.128.66.0F.W1 DF /r 
</td></tr>
<tr><th>VPANDNQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst 
</th><td>EVEX.NDS.256.66.0F.W1 DF /r 
</td></tr>
<tr><th>VPANDNQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst 
</th><td>EVEX.NDS.512.66.0F.W1 DF /r 
</td></tr>
<tr><th>VPANDNQ zmm1 {k1}, zmm2, zmm3/m512/m64bcst
</th><td>MVEX.NDS.512.66.0F.W1 DF /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xDF</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5734.htm">t5734</a>
</dd>
</dl><pre>
IiyVPANDNQ:: PROC
    IiEmitOpcode 0xDF
    JMP IiyVPANDQ.op:
  ENDP IiyVPANDNQ::
</pre>

<dl id="IiyVPXOR">
<dt><a href="#IiyVPAND">&uarr; VPXOR</a></dt>
<dd>Logical Exclusive OR</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPXOR xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG EF /r 
</td></tr>
<tr><th>VPXOR ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG EF /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,logical</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0FEF /r | 0x660FEF /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5736.htm">t5736</a>
</dd>
</dl><pre>
IiyVPXOR:: PROC
    IiEmitOpcode 0xEF
    JMP IiyVPAND.op:
  ENDP IiyVPXOR::
</pre>

<dl id="IiyVPXORD">
<dt><a href="#IiyVPANDD">&uarr; VPXORD</a></dt>
<dd>Bitwise XOR Int32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPXORD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst 
</th><td>EVEX.NDS.128.66.0F.W0 EF /r 
</td></tr>
<tr><th>VPXORD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst 
</th><td>EVEX.NDS.256.66.0F.W0 EF /r 
</td></tr>
<tr><th>VPXORD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst 
</th><td>EVEX.NDS.512.66.0F.W0 EF /r 
</td></tr>
<tr><th>VPXORD zmm1 {k1}, zmm2, zmm3/m512/m32bcst
</th><td>MVEX.NDS.512.66.0F.W0 EF /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xEF</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5736.htm">t5736</a>
</dd>
</dl><pre>
IiyVPXORD:: PROC
    IiEmitOpcode 0xEF
    JMP IiyVPANDD.op:
  ENDP IiyVPXORD::
</pre>

<dl id="IiyVPXORQ">
<dt><a href="#IiyVPANDQ">&uarr; VPXORQ</a></dt>
<dd>Bitwise XOR Int64 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPXORQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst 
</th><td>EVEX.NDS.128.66.0F.W1 EF /r 
</td></tr>
<tr><th>VPXORQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst 
</th><td>EVEX.NDS.256.66.0F.W1 EF /r 
</td></tr>
<tr><th>VPXORQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst 
</th><td>EVEX.NDS.512.66.0F.W1 EF /r 
</td></tr>
<tr><th>VPXORQ zmm1 {k1}, zmm2, zmm3/m512/m64bcst
</th><td>MVEX.NDS.512.66.0F.W1 EF /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xEF</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5736.htm">t5736</a>
</dd>
</dl><pre>
IiyVPXORQ:: PROC
    IiEmitOpcode 0xEF
    JMP IiyVPANDQ.op:
  ENDP IiyVPXORQ::
</pre>

<dl id="IiyVRANGESS">
<dt><a href="#IiyHandlers">&uarr; VRANGESS</a></dt>
<dd>Range Restriction Calculation From a Pair of Scalar Float32 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRANGESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8
</th><td>EVEX.NDS.LIG.66.0F3A.W0 51 /r ib
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x51</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5716.htm">t5716</a>
</dd>
</dl><pre>
IiyVRANGESS:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH, Register=xmm
    IiEmitOpcode 0x51
    IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE, Max=15
    IiDisp8EVEX T1S32
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.LIG.66.0F3A.W0
    RET
  ENDP IiyVRANGESS::
</pre>

<dl id="IiyVRANGESD">
<dt><a href="#IiyHandlers">&uarr; VRANGESD</a></dt>
<dd>Range Restriction Calculation From a pair of Scalar Float64 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRANGESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8
</th><td>EVEX.NDS.LIG.66.0F3A.W1 51 /r ib
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x51</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5716.htm">t5716</a>
</dd>
</dl><pre>
IiyVRANGESD:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH, Register=xmm
    IiEmitOpcode 0x51
    IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE, Max=15
    IiDisp8EVEX T1S64
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.LIG.66.0F3A.W1
    RET
  ENDP IiyVRANGESD::
</pre>

<dl id="IiyVRANGEPS">
<dt><a href="#IiyHandlers">&uarr; VRANGEPS</a></dt>
<dd>Range Restriction Calculation For Packed Pairs of Float32 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRANGEPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, imm8
</th><td>EVEX.NDS.128.66.0F3A.W0 50 /r ib 
</td></tr>
<tr><th>VRANGEPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, imm8
</th><td>EVEX.NDS.256.66.0F3A.W0 50 /r ib 
</td></tr>
<tr><th>VRANGEPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}, imm8
</th><td>EVEX.NDS.512.66.0F3A.W0 50 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x50</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5716.htm">t5716</a>
</dd>
</dl><pre>
IiyVRANGEPS:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH
    IiAllowBroadcasting DWORD, Operand=DH
    IiEmitOpcode 0x50
    IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE, Max=15
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm, ymm.ymm.ymm.imm, ymm.ymm.mem.imm, zmm.zmm.zmm.imm, zmm.zmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.128.66.0F3A.W0
    RET
.ymm.ymm.ymm.imm:
.ymm.ymm.mem.imm:
    IiEmitPrefix EVEX.NDS.256.66.0F3A.W0
    RET
.zmm.zmm.zmm.imm:
.zmm.zmm.mem.imm:
    IiEmitPrefix EVEX.NDS.512.66.0F3A.W0
    RET
  ENDP IiyVRANGEPS::
</pre>

<dl id="IiyVRANGEPD">
<dt><a href="#IiyHandlers">&uarr; VRANGEPD</a></dt>
<dd>Range Restriction Calculation For Packed Pairs of Float64 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRANGEPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, imm8
</th><td>EVEX.NDS.128.66.0F3A.W1 50 /r ib 
</td></tr>
<tr><th>VRANGEPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, imm8
</th><td>EVEX.NDS.256.66.0F3A.W1 50 /r ib 
</td></tr>
<tr><th>VRANGEPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}, imm8
</th><td>EVEX.NDS.512.66.0F3A.W1 50 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x50</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5716.htm">t5716</a>
</dd>
</dl><pre>
IiyVRANGEPD:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH
    IiAllowBroadcasting QWORD, Operand=DH
    IiEmitOpcode 0x50
    IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE, Max=15
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm, ymm.ymm.ymm.imm, ymm.ymm.mem.imm, zmm.zmm.zmm.imm, zmm.zmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.128.66.0F3A.W1
    RET
.ymm.ymm.ymm.imm:
.ymm.ymm.mem.imm:
    IiEmitPrefix EVEX.NDS.256.66.0F3A.W1
    RET
.zmm.zmm.zmm.imm:
.zmm.zmm.mem.imm:
    IiEmitPrefix EVEX.NDS.512.66.0F3A.W1
    RET
  ENDP IiyVRANGEPD::
</pre>

<dl id="IiyVREDUCESS">
<dt><a href="#IiyHandlers">&uarr; VREDUCESS</a></dt>
<dd>Perform a Reduction Transformation on a Scalar Float32 Value</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VREDUCESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8
</th><td>EVEX.NDS.LIG.66.0F3A.W0 57 /r /ib
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x57</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5718.htm">t5718</a>
</dd>
</dl><pre>
IiyVREDUCESS:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH, Register=xmm
    IiEmitOpcode 0x57
    IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE
    IiDisp8EVEX T1S32
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.LIG.66.0F3A.W0
    RET
  ENDP IiyVREDUCESS::
</pre>

<dl id="IiyVREDUCESD">
<dt><a href="#IiyHandlers">&uarr; VREDUCESD</a></dt>
<dd>Perform a Reduction Transformation on a Scalar Float64 Value</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VREDUCESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8
</th><td>EVEX.NDS.LIG.66.0F3A.W1 57 /r imm
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x57</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5718.htm">t5718</a>
</dd>
</dl><pre>
IiyVREDUCESD:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH, Register=xmm
    IiEmitOpcode 0x57
    IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.LIG.66.0F3A.W1
    RET
  ENDP IiyVREDUCESD::
</pre>

<dl id="IiyVREDUCEPS">
<dt><a href="#IiyHandlers">&uarr; VREDUCEPS</a></dt>
<dd>Perform Reduction Transformation on Packed Float32 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VREDUCEPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8
</th><td>EVEX.128.66.0F3A.W0 56 /r ib 
</td></tr>
<tr><th>VREDUCEPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8
</th><td>EVEX.256.66.0F3A.W0 56 /r ib 
</td></tr>
<tr><th>VREDUCEPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, imm8
</th><td>EVEX.512.66.0F3A.W0 56 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x56</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5718.htm">t5718</a>
</dd>
</dl><pre>
IiyVREDUCEPS:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH
    IiAllowBroadcasting DWORD, Operand=DH
    IiEmitOpcode 0x56
    IiOpEn RM
    IiModRM /r
    IiEmitImm Operand3, BYTE
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.imm, xmm.mem.imm, ymm.ymm.imm, ymm.mem.imm, zmm.zmm.imm, zmm.mem.imm
.xmm.xmm.imm:
.xmm.mem.imm:
    IiEmitPrefix EVEX.128.66.0F3A.W0
    RET
.ymm.ymm.imm:
.ymm.mem.imm:
    IiEmitPrefix EVEX.256.66.0F3A.W0
    RET
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix EVEX.512.66.0F3A.W0
    RET
  ENDP IiyVREDUCEPS::
</pre>

<dl id="IiyVREDUCEPD">
<dt><a href="#IiyHandlers">&uarr; VREDUCEPD</a></dt>
<dd>Perform Reduction Transformation on Packed Float64 Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VREDUCEPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8
</th><td>EVEX.128.66.0F3A.W1 56 /r ib 
</td></tr>
<tr><th>VREDUCEPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8
</th><td>EVEX.256.66.0F3A.W1 56 /r ib 
</td></tr>
<tr><th>VREDUCEPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, imm8
</th><td>EVEX.512.66.0F3A.W1 56 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x56</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5718.htm">t5718</a>
</dd>
</dl><pre>
IiyVREDUCEPD:: PROC
    IiAllowModifier MASK
    IiAllowSuppressing Operand=DH
    IiAllowBroadcasting QWORD, Operand=DH
    IiEmitOpcode 0x56
    IiOpEn RM
    IiModRM /r
    IiEmitImm Operand3, BYTE
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.imm, xmm.mem.imm, ymm.ymm.imm, ymm.mem.imm, zmm.zmm.imm, zmm.mem.imm
.xmm.xmm.imm:
.xmm.mem.imm:
    IiEmitPrefix EVEX.128.66.0F3A.W1
    RET
.ymm.ymm.imm:
.ymm.mem.imm:
    IiEmitPrefix EVEX.256.66.0F3A.W1
    RET
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix EVEX.512.66.0F3A.W1
    RET
  ENDP IiyVREDUCEPD::
</pre>

<dl id="IiyVPRORVD">
<dt><a href="#IiyHandlers">&uarr; VPRORVD</a></dt>
<dd>Bit Rotate DWORDS Right</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPRORVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F38.W0 14 /r 
</td></tr>
<tr><th>VPRORVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F38.W0 14 /r 
</td></tr>
<tr><th>VPRORVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F38.W0 14 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x14</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5628.htm">t5628</a>
</dd>
</dl><pre>
IiyVPRORVD:: PROC
    IiEmitOpcode 0x14
.op:IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPRORVD::
</pre>

<dl id="IiyVPROLVD">
<dt><a href="#IiyVPRORVD">&uarr; VPROLVD</a></dt>
<dd>Bit Rotate DWORDS Left</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPROLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F38.W0 15 /r 
</td></tr>
<tr><th>VPROLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F38.W0 15 /r
</td></tr>
<tr><th>VPROLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F38.W0 15 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x15</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5628.htm">t5628</a>
</dd>
</dl><pre>
IiyVPROLVD:: PROC
    IiEmitOpcode 0x15
    JMP IiyVPRORVD.op:
  ENDP IiyVPROLVD::
</pre>

<dl id="IiyVPRORVQ">
<dt><a href="#IiyHandlers">&uarr; VPRORVQ</a></dt>
<dd>Bit Rotate QWORDS Right</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPRORVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F38.W1 14 /r
</td></tr>
<tr><th>VPRORVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F38.W1 14 /r
</td></tr>
<tr><th>VPRORVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F38.W1 14 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x14</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5628.htm">t5628</a>
</dd>
</dl><pre>
IiyVPRORVQ:: PROC
    IiEmitOpcode 0x14
.op:IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W1
    RET
  ENDP IiyVPRORVQ::
</pre>

<dl id="IiyVPROLVQ">
<dt><a href="#IiyVPRORVQ">&uarr; VPROLVQ</a></dt>
<dd>Bit Rotate QWORDS Left</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPROLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F38.W1 15 /r 
</td></tr>
<tr><th>VPROLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F38.W1 15 /r 
</td></tr>
<tr><th>VPROLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F38.W1 15 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x15</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5628.htm">t5628</a>
</dd>
</dl><pre>
IiyVPROLVQ:: PROC
    IiEmitOpcode 0x15
    JMP IiyVPRORVQ.op:
  ENDP IiyVPROLVQ::
</pre>

<dl id="IiyVPRORD">
<dt><a href="#IiyHandlers">&uarr; VPRORD</a></dt>
<dd>Bit Rotate DWORDS Right</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPRORD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8
</th><td>EVEX.NDD.128.66.0F.W0 72 /0 ib 
</td></tr>
<tr><th>VPRORD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8
</th><td>EVEX.NDD.256.66.0F.W0 72 /0 ib 
</td></tr>
<tr><th>VPRORD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8
</th><td>EVEX.NDD.512.66.0F.W0 72 /0 ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x72</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5630.htm">t5630</a>
</dd>
</dl><pre>
IiyVPRORD:: PROC
    IiModRM /0
.di:IiAllowModifier MASK
    IiAllowBroadcasting DWORD, Operand=DH
    IiEmitOpcode 0x72
    IiOpEn VM
    IiEmitImm Operand3, BYTE
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.imm, xmm.mem.imm, ymm.ymm.imm, ymm.mem.imm, zmm.zmm.imm, zmm.mem.imm
.xmm.xmm.imm:
.xmm.mem.imm:
    IiEmitPrefix EVEX.NDD.128.66.0F.W0
    RET
.ymm.ymm.imm:
.ymm.mem.imm:
    IiEmitPrefix EVEX.NDD.256.66.0F.W0
    RET
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix EVEX.NDD.512.66.0F.W0
    RET
  ENDP IiyVPRORD::
</pre>

<dl id="IiyVPROLD">
<dt><a href="#IiyVPRORD">&uarr; VPROLD</a></dt>
<dd>Bit Rotate DWORDS Left</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPROLD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8
</th><td>EVEX.NDD.128.66.0F.W0 72 /1 ib 
</td></tr>
<tr><th>VPROLD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8
</th><td>EVEX.NDD.256.66.0F.W0 72 /1 ib 
</td></tr>
<tr><th>VPROLD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8
</th><td>EVEX.NDD.512.66.0F.W0 72 /1 ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x72</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5630.htm">t5630</a>
</dd>
</dl><pre>
IiyVPROLD:: PROC
    IiModRM /1
    JMP IiyVPRORD.di:
  ENDP IiyVPROLD::
</pre>

<dl id="IiyVPRORQ">
<dt><a href="#IiyHandlers">&uarr; VPRORQ</a></dt>
<dd>Bit Rotate QWORDS Right</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPRORQ xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8
</th><td>EVEX.NDD.128.66.0F.W1 72 /0 ib 
</td></tr>
<tr><th>VPRORQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8
</th><td>EVEX.NDD.256.66.0F.W1 72 /0 ib 
</td></tr>
<tr><th>VPRORQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8
</th><td>EVEX.NDD.512.66.0F.W1 72 /0 ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x72</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5630.htm">t5630</a>
</dd>
</dl><pre>
IiyVPRORQ:: PROC
    IiModRM /0
.di:IiAllowModifier MASK
    IiAllowBroadcasting QWORD, Operand=DH
    IiEmitOpcode 0x72
    IiOpEn VM
    IiEmitImm Operand3, BYTE
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.imm, xmm.mem.imm, ymm.ymm.imm, ymm.mem.imm, zmm.zmm.imm, zmm.mem.imm
.xmm.xmm.imm:
.xmm.mem.imm:
    IiEmitPrefix EVEX.NDD.128.66.0F.W1
    RET
.ymm.ymm.imm:
.ymm.mem.imm:
    IiEmitPrefix EVEX.NDD.256.66.0F.W1
    RET
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix EVEX.NDD.512.66.0F.W1
    RET
  ENDP IiyVPRORQ::
</pre>

<dl id="IiyVPROLQ">
<dt><a href="#IiyVPRORQ">&uarr; VPROLQ</a></dt>
<dd>Bit Rotate QWORDS Left</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPROLQ xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8
</th><td>EVEX.NDD.128.66.0F.W1 72 /1 ib 
</td></tr>
<tr><th>VPROLQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8
</th><td>EVEX.NDD.256.66.0F.W1 72 /1 ib 
</td></tr>
<tr><th>VPROLQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8
</th><td>EVEX.NDD.512.66.0F.W1 72 /1 ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x72</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5630.htm">t5630</a>
</dd>
</dl><pre>
IiyVPROLQ:: PROC
    IiModRM /1
    JMP IiyVPRORQ.di:
  ENDP IiyVPROLQ::
</pre>

<dl id="IiyVPERMI2B">
<dt><a href="#IiyHandlers">&uarr; VPERMI2B</a></dt>
<dd>Full Permute of BYTEs From Two Tables Overwriting the Index</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMI2B xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.DDS.128.66.0F38.W0 75 /r 
</td></tr>
<tr><th>VPERMI2B ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.DDS.256.66.0F38.W0 75 /r 
</td></tr>
<tr><th>VPERMI2B zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.DDS.512.66.0F38.W0 75 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x75</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5740.htm">t5740</a>
</dd>
</dl><pre>
IiyVPERMI2B:: PROC
    IiEmitOpcode 0x75
.op:IiEncoding DATA=BYTE
    IiAllowModifier MASK
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.DDS.128.66.0F38.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.DDS.256.66.0F38.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.DDS.512.66.0F38.W0
    RET
  ENDP IiyVPERMI2B::
</pre>

<dl id="IiyVPERMI2W">
<dt><a href="#IiyHandlers">&uarr; VPERMI2W</a></dt>
<dd>Full Permute WORDs From Two Tables Overwriting the Index</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMI2W xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.DDS.128.66.0F38.W1 75 /r
</td></tr>
<tr><th>VPERMI2W ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.DDS.256.66.0F38.W1 75 /r
</td></tr>
<tr><th>VPERMI2W zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.DDS.512.66.0F38.W1 75 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x75</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5740.htm">t5740</a>
</dd>
</dl><pre>
IiyVPERMI2W:: PROC
    IiEmitOpcode 0x75
.op:IiEncoding DATA=WORD
    IiAllowModifier MASK
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.DDS.128.66.0F38.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.DDS.256.66.0F38.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.DDS.512.66.0F38.W1
    RET
  ENDP IiyVPERMI2W::
</pre>

<dl id="IiyVPERMI2D">
<dt><a href="#IiyHandlers">&uarr; VPERMI2D</a></dt>
<dd>Full Permute DWORDs From Two Tables Overwriting the Index</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMI2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.DDS.128.66.0F38.W0 76 /r 
</td></tr>
<tr><th>VPERMI2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.DDS.256.66.0F38.W0 76 /r 
</td></tr>
<tr><th>VPERMI2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.DDS.512.66.0F38.W0 76 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x76</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5740.htm">t5740</a>
</dd>
</dl><pre>
IiyVPERMI2D:: PROC
    IiEmitOpcode 0x76
.op:IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.DDS.128.66.0F38.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.DDS.256.66.0F38.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.DDS.512.66.0F38.W0
    RET
  ENDP IiyVPERMI2D::
</pre>

<dl id="IiyVPERMI2Q">
<dt><a href="#IiyHandlers">&uarr; VPERMI2Q</a></dt>
<dd>Full Permute of QWORDS From Two Tables Overwriting the Index</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMI2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.DDS.128.66.0F38.W1 76 /r 
</td></tr>
<tr><th>VPERMI2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.DDS.256.66.0F38.W1 76 /r 
</td></tr>
<tr><th>VPERMI2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.DDS.512.66.0F38.W1 76 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x76</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5740.htm">t5740</a>
</dd>
</dl><pre>
IiyVPERMI2Q:: PROC
    IiEmitOpcode 0x76
.op:IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.DDS.128.66.0F38.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.DDS.256.66.0F38.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.DDS.512.66.0F38.W1
    RET
  ENDP IiyVPERMI2Q::
</pre>

<dl id="IiyVPERMI2PS">
<dt><a href="#IiyVPERMI2D">&uarr; VPERMI2PS</a></dt>
<dd>Full Permute of single-precision FP From Two Tables Overwriting the Index</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMI2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.DDS.128.66.0F38.W0 77 /r 
</td></tr>
<tr><th>VPERMI2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.DDS.256.66.0F38.W0 77 /r 
</td></tr>
<tr><th>VPERMI2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.DDS.512.66.0F38.W0 77 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x77</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5740.htm">t5740</a>
</dd>
</dl><pre>
IiyVPERMI2PS:: PROC
    IiEmitOpcode 0x77
    JMP IiyVPERMI2D.op:
  ENDP IiyVPERMI2PS::
</pre>

<dl id="IiyVPERMI2PD">
<dt><a href="#IiyVPERMI2Q">&uarr; VPERMI2PD</a></dt>
<dd>Full Permute of double-precission FP From Two Tables Overwriting the Index</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMI2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.DDS.128.66.0F38.W1 77 /r 
</td></tr>
<tr><th>VPERMI2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.DDS.256.66.0F38.W1 77 /r 
</td></tr>
<tr><th>VPERMI2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.DDS.512.66.0F38.W1 77 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x77</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5740.htm">t5740</a>
</dd>
</dl><pre>
IiyVPERMI2PD:: PROC
    IiEmitOpcode 0x77
    JMP IiyVPERMI2Q.op:
  ENDP IiyVPERMI2PD::
</pre>

<dl id="IiyVPERMT2B">
<dt><a href="#IiyVPERMI2B">&uarr; VPERMT2B</a></dt>
<dd>Full Permute BYTEs From Two Tables Overwriting a Table</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMT2B xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.DDS.128.66.0F38.W0 7D /r 
</td></tr>
<tr><th>VPERMT2B ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F38.W0 7D /r 
</td></tr>
<tr><th>VPERMT2B zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F38.W0 7D /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x7D</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5742.htm">t5742</a>
</dd>
</dl><pre>
IiyVPERMT2B:: PROC
    IiEmitOpcode 0x7D
    JMP IiyVPERMI2B.op:
  ENDP IiyVPERMT2B::
</pre>

<dl id="IiyVPERMT2W">
<dt><a href="#IiyVPERMI2W">&uarr; VPERMT2W</a></dt>
<dd>Full Permute WORDs from Two Tables Overwriting one Table</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMT2W xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.DDS.128.66.0F38.W1 7D /r
</td></tr>
<tr><th>VPERMT2W ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.DDS.256.66.0F38.W1 7D /r
</td></tr>
<tr><th>VPERMT2W zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.DDS.512.66.0F38.W1 7D /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x7D</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5742.htm">t5742</a>
</dd>
</dl><pre>
IiyVPERMT2W:: PROC
    IiEmitOpcode 0x7D
    JMP IiyVPERMI2W.op:
  ENDP IiyVPERMT2W::
</pre>

<dl id="IiyVPERMT2D">
<dt><a href="#IiyVPERMI2D">&uarr; VPERMT2D</a></dt>
<dd>Full Permute DWORDs from Two Tables Overwriting one Table</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMT2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.DDS.128.66.0F38.W0 7E /r 
</td></tr>
<tr><th>VPERMT2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.DDS.256.66.0F38.W0 7E /r 
</td></tr>
<tr><th>VPERMT2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.DDS.512.66.0F38.W0 7E /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x7E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5742.htm">t5742</a>
</dd>
</dl><pre>
IiyVPERMT2D:: PROC
    IiEmitOpcode 0x7E
    JMP IiyVPERMI2D.op:
  ENDP IiyVPERMT2D::
</pre>

<dl id="IiyVPERMT2Q">
<dt><a href="#IiyVPERMI2Q">&uarr; VPERMT2Q</a></dt>
<dd>Full Permute QWORDs from Two Tables Overwriting one Table</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMT2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.DDS.128.66.0F38.W1 7E /r 
</td></tr>
<tr><th>VPERMT2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.DDS.256.66.0F38.W1 7E /r 
</td></tr>
<tr><th>VPERMT2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.DDS.512.66.0F38.W1 7E /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x7E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5742.htm">t5742</a>
</dd>
</dl><pre>
IiyVPERMT2Q:: PROC
    IiEmitOpcode 0x7E
    JMP IiyVPERMI2Q.op:
  ENDP IiyVPERMT2Q::
</pre>

<dl id="IiyVPERMT2PS">
<dt><a href="#IiyVPERMI2D">&uarr; VPERMT2PS</a></dt>
<dd>Full Permute single-precission FP from Two Tables Overwriting one Table</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMT2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.DDS.128.66.0F38.W0 7F /r 
</td></tr>
<tr><th>VPERMT2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.DDS.256.66.0F38.W0 7F /r 
</td></tr>
<tr><th>VPERMT2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.DDS.512.66.0F38.W0 7F /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x7F</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5742.htm">t5742</a>
</dd>
</dl><pre>
IiyVPERMT2PS:: PROC
    IiEmitOpcode 0x7F
    JMP IiyVPERMI2D.op:
  ENDP IiyVPERMT2PS::
</pre>

<dl id="IiyVPERMT2PD">
<dt><a href="#IiyVPERMI2Q">&uarr; VPERMT2PD</a></dt>
<dd>Full Permute double-precission FP from Two Tables Overwriting one Table</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMT2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.DDS.128.66.0F38.W1 7F /r 
</td></tr>
<tr><th>VPERMT2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.DDS.256.66.0F38.W1 7F /r 
</td></tr>
<tr><th>VPERMT2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.DDS.512.66.0F38.W1 7F /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x7F</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5742.htm">t5742</a>
</dd>
</dl><pre>
IiyVPERMT2PD:: PROC
    IiEmitOpcode 0x7F
    JMP IiyVPERMI2Q.op:
  ENDP IiyVPERMT2PD::
</pre>

<dl id="IiyVPERMB">
<dt><a href="#IiyHandlers">&uarr; VPERMB</a></dt>
<dd>Permute Packed Bytes Elements</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMB xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F38.W0 8D /r 
</td></tr>
<tr><th>VPERMB ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F38.W0 8D /r 
</td></tr>
<tr><th>VPERMB zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F38.W0 8D /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x8D</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5744.htm">t5744</a>
</dd>
</dl><pre>
IiyVPERMB:: PROC
    IiAllowModifier MASK
    IiEmitOpcode 0x8D
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPERMB::
</pre>

<dl id="IiyVPERMW">
<dt><a href="#IiyHandlers">&uarr; VPERMW</a></dt>
<dd>Permute Packed Words Elements</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMW xmm1 {k1}{z}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F38.W1 8D /r 
</td></tr>
<tr><th>VPERMW ymm1 {k1}{z}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F38.W1 8D /r 
</td></tr>
<tr><th>VPERMW zmm1 {k1}{z}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F38.W1 8D /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x8D</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5744.htm">t5744</a>
</dd>
</dl><pre>
IiyVPERMW:: PROC
    IiAllowModifier MASK
    IiEmitOpcode 0x8D
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W1
    RET
  ENDP IiyVPERMW::
</pre>

<dl id="IiyVPERMD">
<dt><a href="#IiyHandlers">&uarr; VPERMD</a></dt>
<dd>Permute Packed Doublewords Elements</dd>
<dt>Description</dt>
<dd><a class="EXTW" href="http://www.felixcloutier.com/x86/VPERMD:VPERMW.html">VPERMD</a></dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.W0 36 /r 
</td></tr>
<tr><th>VPERMD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F38.W0 36 /r 
</td></tr>
<tr><th>VPERMD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F38.W0 36 /r 
</td></tr>
<tr><th>VPERMD zmm1 {k1}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F38.W0 36 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x36</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5744.htm">t5744</a>
</dd>
</dl><pre>
IiyVPERMD:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiEmitOpcode 0x36
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDisp8MVEX Di64
    IiDispatchFormat  ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38.W0, EVEX.NDS.256.66.0F38.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W0, MVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPERMD::
</pre>

<dl id="IiyVPERMQ">
<dt><a href="#IiyHandlers">&uarr; VPERMQ</a></dt>
<dd>Qwords Element Permutation</dd>
<dt>Description</dt>
<dd><a class="EXTW" href="http://www.felixcloutier.com/x86/VPERMQ.html">VPERMQ</a></dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMQ ymm1, ymm2/m256, imm8
</th><td>VEX.256.66.0F3A.W1 00 /r ib 
</td></tr>
<tr><th>VPERMQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8
</th><td>EVEX.256.66.0F3A.W1 00 /r ib
</td></tr>
<tr><th>VPERMQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8
</th><td>EVEX.512.66.0F3A.W1 00 /r ib 
</td></tr>
<tr><th>VPERMQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F38.W1 36 /r 
</td></tr>
<tr><th>VPERMQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F38.W1 36 /r  
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x00 | 0x36</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5744.htm">t5744</a>
</dd>
</dl><pre>
IiyVPERMQ:: PROC
    MOV AL,0x00
    MOV BL,0x36
.op:IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiModRM /r
    IiDisp8EVEX FV64
    CMP DL,imm
    JE .I:
    IiAllowBroadcasting QWORD
    IiOpEn RVM
    IiEmitOpcode EBX
    IiDispatchFormat  ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.ymm.ymm.ymm:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W1
    RET
.ymm.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W1
    RET
.I: IiAllowBroadcasting QWORD, Operand=DH
    IiOpEn RM
    IiEmitOpcode EAX
    IiEmitImm Operand3, BYTE
    IiDispatchFormat  ymm.ymm.imm, ymm.mem.imm, zmm.zmm.imm, zmm.mem.imm
.ymm.ymm.imm:
.ymm.mem.imm:
    IiEmitPrefix VEX.256.66.0F3A.W1, EVEX.256.66.0F3A.W1
    RET
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix EVEX.512.66.0F3A.W1
    RET
  ENDP IiyVPERMQ::
</pre>

<dl id="IiyVPERMPS">
<dt><a href="#IiyHandlers">&uarr; VPERMPS</a></dt>
<dd>Permute Single-Precision Floating-Point Elements</dd>
<dt>Description</dt>
<dd><a class="EXTW" href="http://www.felixcloutier.com/x86/VPERMPS.html">VPERMPS</a></dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMPS ymm1, ymm2, ymm3/m256
</th><td>VEX.256.66.0F38.W0 16 /r 
</td></tr>
<tr><th>VPERMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F38.W0 16 /r 
</td></tr>
<tr><th>VPERMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F38.W0 16 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0X16</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5746.htm">t5746</a>
</dd>
</dl><pre>
IiyVPERMPS:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiEmitOpcode 0x16
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.256.66.0F38.W0, EVEX.NDS.256.66.0F38.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPERMPS::
</pre>

<dl id="IiyVPERMPD">
<dt><a href="#IiyVPERMQ">&uarr; VPERMPD</a></dt>
<dd>Permute Double-Precision Floating-Point Elements</dd>
<dt>Description</dt>
<dd><a class="EXTW" href="http://www.felixcloutier.com/x86/VPERMPD.html">VPERMPD</a></dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F38.W1 16 /r
</td></tr>
<tr><th>VPERMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F38.W1 16 /r
</td></tr>
<tr><th>VPERMPD ymm1, ymm2/m256, imm8
</th><td>VEX.256.66.0F3A.W1 01 /r ib 
</td></tr>
<tr><th>VPERMPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8
</th><td>EVEX.256.66.0F3A.W1 01 /r ib 
</td></tr>
<tr><th>VPERMPD zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8
</th><td>EVEX.512.66.0F3A.W1 01 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0X01 | 0X16</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5746.htm">t5746</a>
</dd>
</dl><pre>
IiyVPERMPD:: PROC
    MOV AL,0x01
    MOV BL,0x16
    JMP IiyVPERMQ.op:
  ENDP IiyVPERMPD::
</pre>

<dl id="IiyVPERMILPS">
<dt><a href="#IiyHandlers">&uarr; VPERMILPS</a></dt>
<dd>Permute In-Lane of Quadruples of Single-Precision Floating-Point Values</dd>
<dt>Description</dt>
<dd><a class="EXTW" href="http://www.felixcloutier.com/x86/VPERMILPS.html">VPERMILPS</a></dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMILPS xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.W0 0C /r  
</td></tr>
<tr><th>VPERMILPS ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.W0 0C /r  
</td></tr>
<tr><th>VPERMILPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F38.W0 0C /r  
</td></tr>
<tr><th>VPERMILPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F38.W0 0C /r  
</td></tr>
<tr><th>VPERMILPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F38.W0 0C /r  
</td></tr>
<tr><th>VPERMILPS xmm1, xmm2/m128, imm8
</th><td>VEX.128.66.0F3A.W0 04 /r ib 
</td></tr>
<tr><th>VPERMILPS ymm1, ymm2/m256, imm8
</th><td>VEX.256.66.0F3A.W0 04 /r ib 
</td></tr>
<tr><th>VPERMILPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8
</th><td>EVEX.128.66.0F3A.W0 04 /r ib 
</td></tr>
<tr><th>VPERMILPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8
</th><td>EVEX.256.66.0F3A.W0 04 /r ib 
</td></tr>
<tr><th>VPERMILPS zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8
</th><td>EVEX.512.66.0F3A.W0 04 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x0C | 0x04</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5746.htm">t5746</a>
</dd>
</dl><pre>
IiyVPERMILPS:: PROC
    IiAllowModifier MASK
    IiModRM /r
    IiDisp8EVEX FV32
    CMP DL,imm
    JE .I:
    IiAllowBroadcasting DWORD
    IiOpEn RVM
    IiEmitOpcode 0x0C
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38.W0, EVEX.NDS.128.66.0F38.W0
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38.W0, EVEX.NDS.256.66.0F38.W0
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W0
    RET
.I: IiAllowBroadcasting DWORD, Operand=DH
    IiOpEn RM
    IiEmitOpcode 0x04
    IiEmitImm Operand3, BYTE
    IiDispatchFormat xmm.xmm.imm, xmm.mem.imm, ymm.ymm.imm, ymm.mem.imm, zmm.zmm.imm, zmm.mem.imm
.xmm.xmm.imm:
.xmm.mem.imm:
    IiEmitPrefix VEX.128.66.0F3A.W0, EVEX.128.66.0F3A.W0
    RET
.ymm.ymm.imm:
.ymm.mem.imm:
    IiEmitPrefix VEX.256.66.0F3A.W0, EVEX.256.66.0F3A.W0
    RET
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix EVEX.512.66.0F3A.W0
    RET
  ENDP IiyVPERMILPS::
</pre>

<dl id="IiyVPERMILPD">
<dt><a href="#IiyHandlers">&uarr; VPERMILPD</a></dt>
<dd>Permute In-Lane of Pairs of Double-Precision Floating-Point Values</dd>
<dt>Description</dt>
<dd><a class="EXTW" href="http://www.felixcloutier.com/x86/VPERMILPD.html">VPERMILPD</a></dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMILPD xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.W0 0D /r 
</td></tr>
<tr><th>VPERMILPD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.W0 0D /r 
</td></tr>
<tr><th>VPERMILPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F38.W1 0D /r 
</td></tr>
<tr><th>VPERMILPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F38.W1 0D /r 
</td></tr>
<tr><th>VPERMILPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F38.W1 0D /r  
</td></tr>
<tr><th>VPERMILPD xmm1, xmm2/m128, imm8
</th><td>VEX.128.66.0F3A.W0 05 /r ib 
</td></tr>
<tr><th>VPERMILPD ymm1, ymm2/m256, imm8
</th><td>VEX.256.66.0F3A.W0 05 /r ib 
</td></tr>
<tr><th>VPERMILPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8
</th><td>EVEX.128.66.0F3A.W1 05 /r ib 
</td></tr>
<tr><th>VPERMILPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8
</th><td>EVEX.256.66.0F3A.W1 05 /r ib 
</td></tr>
<tr><th>VPERMILPD zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8
</th><td>EVEX.512.66.0F3A.W1 05 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x0D | 0x05</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5746.htm">t5746</a>
</dd>
</dl><pre>
IiyVPERMILPD:: PROC
    IiAllowModifier MASK
    IiModRM /r
    IiDisp8EVEX FV64
    CMP DL,imm
    JE .I:
    IiAllowBroadcasting QWORD
    IiOpEn RVM
    IiEmitOpcode 0x0D
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38.W0, EVEX.NDS.128.66.0F38.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38.W0, EVEX.NDS.256.66.0F38.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W1
    RET
.I: IiAllowBroadcasting QWORD, Operand=DH
    IiOpEn RM
    IiEmitOpcode 0x05
    IiEmitImm Operand3, BYTE
    IiDispatchFormat xmm.xmm.imm, xmm.mem.imm, ymm.ymm.imm, ymm.mem.imm, zmm.zmm.imm, zmm.mem.imm
.xmm.xmm.imm:
.xmm.mem.imm:
    IiEmitPrefix VEX.128.66.0F3A.W0, EVEX.128.66.0F3A.W1
    RET
.ymm.ymm.imm:
.ymm.mem.imm:
    IiEmitPrefix VEX.256.66.0F3A.W0, EVEX.256.66.0F3A.W1
    RET
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix EVEX.512.66.0F3A.W1
    RET
  ENDP IiyVPERMILPD::
</pre>

<dl id="IiyVPERM2F128">
<dt><a href="#IiyHandlers">&uarr; VPERM2F128</a></dt>
<dd>Permute Floating-Point Values</dd>
<dt>Description</dt>
<dd><a class="EXTW" href="http://www.felixcloutier.com/x86/VPERM2F128.html">VPERM2F128</a></dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERM2F128 ymm1, ymm2, ymm3/m256, imm8
</th><td>VEX.NDS.256.66.0F3A.W0 06 /r ib
</td></tr>
</table></dd>
<dt>Operands</dt>
<dd>0x06</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5748.htm">t5748</a>
</dd>
</dl><pre>
IiyVPERM2F128:: PROC
    IiEmitOpcode 0x06
.op:IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE
    IiDispatchFormat  ymm.ymm.ymm.imm, ymm.ymm.mem.imm
.ymm.ymm.ymm.imm:
.ymm.ymm.mem.imm:
    IiEmitPrefix VEX.NDS.256.66.0F3A.W0
    RET
  ENDP IiyVPERM2F128::
</pre>

<dl id="IiyVPERM2I128">
<dt><a href="#IiyHandlers">&uarr; VPERM2I128</a></dt>
<dd>Permute Integer Values</dd>
<dt>Description</dt>
<dd><a class="EXTW" href="http://www.felixcloutier.com/x86/VPERM2I128.html">VPERM2I128</a></dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERM2I128 ymm1, ymm2, ymm3/m256, imm8
</th><td>VEX.NDS.256.66.0F3A.W0 46 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x46</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5748.htm">t5748</a>
</dd>
</dl><pre>
IiyVPERM2I128:: PROC
    IiEmitOpcode 0x46
    JMP IiyVPERM2F128.op:
  ENDP IiyVPERM2I128::
</pre>

<dl id="IiyVPTESTMB">
<dt><a href="#IiyHandlers">&uarr; VPTESTMB</a></dt>
<dd>Logical AND and Set Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPTESTMB k2 {k1}, xmm2, xmm3/m128 
</th><td>EVEX.NDS.128.66.0F38.W0 26 /r F
</td></tr>
<tr><th>VPTESTMB k2 {k1}, ymm2, ymm3/m256 
</th><td>EVEX.NDS.256.66.0F38.W0 26 /r F
</td></tr>
<tr><th>VPTESTMB k2 {k1}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F38.W0 26 /r F
</td></tr>
</table></dd>
<dt>Operands</dt>
<dd>0x26</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5760.htm">t5760</a>
</dd>
</dl><pre>
IiyVPTESTMB:: PROC
    IiEncoding DATA=BYTE
    IiDisp8EVEX FVM
    IiEmitOpcode 0x26
    IiAllowMaskMerging
    IiOpEn RVM
    IiModRM /r
    IiDispatchFormat  krg.xmm.xmm, krg.xmm.mem, krg.ymm.ymm, krg.ymm.mem, krg.zmm.zmm, krg.zmm.mem
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W0
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W0
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPTESTMB::
</pre>

<dl id="IiyVPTESTMW">
<dt><a href="#IiyHandlers">&uarr; VPTESTMW</a></dt>
<dd>Logical AND and Set Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPTESTMW k2 {k1}, xmm2, xmm3/m128 
</th><td>EVEX.NDS.128.66.0F38.W1 26 /r F
</td></tr>
<tr><th>VPTESTMW k2 {k1}, ymm2, ymm3/m256 
</th><td>EVEX.NDS.256.66.0F38.W1 26 /r F
</td></tr>
<tr><th>VPTESTMW k2 {k1}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F38.W1 26 /r F
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x26</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5760.htm">t5760</a>
</dd>
</dl><pre>
IiyVPTESTMW:: PROC
    IiEncoding DATA=WORD
    IiDisp8EVEX FVM
    IiEmitOpcode 0x26
.op:IiAllowMaskMerging
    IiOpEn RVM
    IiModRM /r
    IiDispatchFormat  krg.xmm.xmm, krg.xmm.mem, krg.ymm.ymm, krg.ymm.mem, krg.zmm.zmm, krg.zmm.mem
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W1
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W1
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W1
    RET
  ENDP IiyVPTESTMW::
</pre>

<dl id="IiyVPTESTMD">
<dt><a href="#IiyVPTESTMB">&uarr; VPTESTMD</a></dt>
<dd>Logical AND and Set Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPTESTMD k2 {k1}, xmm2, xmm3/m128/m32bcst 
</th><td>EVEX.NDS.128.66.0F38.W0 27 /r 
</td></tr>
<tr><th>VPTESTMD k2 {k1}, ymm2, ymm3/m256/m32bcst 
</th><td>EVEX.NDS.256.66.0F38.W0 27 /r 
</td></tr>
<tr><th>VPTESTMD k2 {k1}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F38.W0 27 /r 
</td></tr>
<tr><th>VPTESTMD k2 {k1}, zmm2, zmm3/m512/m32bcst
</th><td>MVEX.NDS.512.66.0F38.W0 27 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x27</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5760.htm">t5760</a>
</dd>
</dl><pre>
IiyVPTESTMD:: PROC
    IiAllowBroadcasting DWORD
    IiDisp8EVEX FV32
    IiDisp8MVEX Si32
    IiEmitOpcode 0x27
    IiAllowMaskMerging
    IiOpEn RVM
    IiModRM /r
    IiDispatchFormat  krg.xmm.xmm, krg.xmm.mem, krg.ymm.ymm, krg.ymm.mem, krg.zmm.zmm, krg.zmm.mem
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W0
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W0
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W0, MVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPTESTMD::
</pre>

<dl id="IiyVPTESTMQ">
<dt><a href="#IiyVPTESTMW">&uarr; VPTESTMQ</a></dt>
<dd>Logical AND and Set Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPTESTMQ k2 {k1}, xmm2, xmm3/m128/m64bcst 
</th><td>EVEX.NDS.128.66.0F38.W1 27 /r F
</td></tr>
<tr><th>VPTESTMQ k2 {k1}, ymm2, ymm3/m256/m64bcst 
</th><td>EVEX.NDS.256.66.0F38.W1 27 /r F
</td></tr>
<tr><th>VPTESTMQ k2 {k1}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F38.W1 27 /r F
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x27</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5760.htm">t5760</a>
</dd>
</dl><pre>
IiyVPTESTMQ:: PROC
    IiAllowBroadcasting QWORD
    IiDisp8EVEX FV64
    IiEmitOpcode 0x27
    JMP IiyVPTESTMW.op:
  ENDP IiyVPTESTMQ::
</pre>

<dl id="IiyVPTESTNMB">
<dt><a href="#IiyHandlers">&uarr; VPTESTNMB</a></dt>
<dd>Logical NAND and Set</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPTESTNMB k2 {k1}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.F3.0F38.W0 26 /r
</td></tr>
<tr><th>VPTESTNMB k2 {k1}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.F3.0F38.W0 26 /r
</td></tr>
<tr><th>VPTESTNMB k2 {k1}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.F3.0F38.W0 26 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x26</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5762.htm">t5762</a>
</dd>
</dl><pre>
IiyVPTESTNMB:: PROC
    IiEncoding DATA=BYTE
    IiDisp8EVEX FVM
    IiEmitOpcode 0x26
.op:IiAllowMaskMerging
    IiOpEn RVM
    IiModRM /r
    IiDispatchFormat  krg.xmm.xmm, krg.xmm.mem, krg.ymm.ymm, krg.ymm.mem, krg.zmm.zmm, krg.zmm.mem
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.F3.0F38.W0
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.F3.0F38.W0
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.F3.0F38.W0
    RET
  ENDP IiyVPTESTNMB::
</pre>

<dl id="IiyVPTESTNMW">
<dt><a href="#IiyHandlers">&uarr; VPTESTNMW</a></dt>
<dd>Logical NAND and Set</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPTESTNMW k2 {k1}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.F3.0F38.W1 26 /r
</td></tr>
<tr><th>VPTESTNMW k2 {k1}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.F3.0F38.W1 26 /r
</td></tr>
<tr><th>VPTESTNMW k2 {k1}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.F3.0F38.W1 26 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x26</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5762.htm">t5762</a>
</dd>
</dl><pre>
IiyVPTESTNMW:: PROC
    IiEncoding DATA=WORD
    IiDisp8EVEX FVM
    IiEmitOpcode 0x26
.op:IiAllowMaskMerging
    IiOpEn RVM
    IiModRM /r
    IiDispatchFormat  krg.xmm.xmm, krg.xmm.mem, krg.ymm.ymm, krg.ymm.mem, krg.zmm.zmm, krg.zmm.mem
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.F3.0F38.W1
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.F3.0F38.W1
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.F3.0F38.W1
    RET
  ENDP IiyVPTESTNMW::
</pre>

<dl id="IiyVPTESTNMD">
<dt><a href="#IiyVPTESTNMB">&uarr; VPTESTNMD</a></dt>
<dd>Logical NAND and Set</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPTESTNMD k2 {k1}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.F3.0F38.W0 27 /r
</td></tr>
<tr><th>VPTESTNMD k2 {k1}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.F3.0F38.W0 27 /r
</td></tr>
<tr><th>VPTESTNMD k2 {k1}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.F3.0F38.W0 27 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x27</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5762.htm">t5762</a>
</dd>
</dl><pre>
IiyVPTESTNMD:: PROC
    IiAllowBroadcasting DWORD
    IiDisp8EVEX FV32
    IiEmitOpcode 0x27
    JMP IiyVPTESTNMB.op:
  ENDP IiyVPTESTNMD::
</pre>

<dl id="IiyVPTESTNMQ">
<dt><a href="#IiyVPTESTNMW">&uarr; VPTESTNMQ</a></dt>
<dd>Logical NAND and Set</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPTESTNMQ k2 {k1}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.F3.0F38.W1 27 /r
</td></tr>
<tr><th>VPTESTNMQ k2 {k1}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.F3.0F38.W1 27 /r
</td></tr>
<tr><th>VPTESTNMQ k2 {k1}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.F3.0F38.W1 27 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x27</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5762.htm">t5762</a>
</dd>
</dl><pre>
IiyVPTESTNMQ:: PROC
    IiAllowBroadcasting QWORD
    IiDisp8EVEX FV64
    IiEmitOpcode 0x27
    JMP IiyVPTESTNMW.op:
  ENDP IiyVPTESTNMQ::
</pre>

<dl id="IiyVPTERNLOGD">
<dt><a href="#IiyHandlers">&uarr; VPTERNLOGD</a></dt>
<dd>Bitwise Ternary Logic</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPTERNLOGD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, imm8
</th><td>EVEX.DDS.128.66.0F3A.W0 25 /r ib 
</td></tr>
<tr><th>VPTERNLOGD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, imm8
</th><td>EVEX.DDS.256.66.0F3A.W0 25 /r ib 
</td></tr>
<tr><th>VPTERNLOGD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst, imm8
</th><td>EVEX.DDS.512.66.0F3A.W0 25 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x25</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5780.htm">t5780</a>
</dd>
</dl><pre>
IiyVPTERNLOGD:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting DWORD, Operand=DH
    IiEmitOpcode 0x25
    IiOpEn RVM
    IiModRM /r
    IiEmitImm Operand4, BYTE
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm, ymm.ymm.ymm.imm, ymm.ymm.mem.imm, zmm.zmm.zmm.imm, zmm.zmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix EVEX.DDS.128.66.0F3A.W0
    RET
.ymm.ymm.ymm.imm:
.ymm.ymm.mem.imm:
    IiEmitPrefix EVEX.DDS.256.66.0F3A.W0
    RET
.zmm.zmm.zmm.imm:
.zmm.zmm.mem.imm:
    IiEmitPrefix EVEX.DDS.512.66.0F3A.W0
    RET
  ENDP IiyVPTERNLOGD::
</pre>

<dl id="IiyVPTERNLOGQ">
<dt><a href="#IiyHandlers">&uarr; VPTERNLOGQ</a></dt>
<dd>Bitwise Ternary Logic</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPTERNLOGQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, imm8
</th><td>EVEX.DDS.128.66.0F3A.W1 25 /r ib 
</td></tr>
<tr><th>VPTERNLOGQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, imm8
</th><td>EVEX.DDS.256.66.0F3A.W1 25 /r ib 
</td></tr>
<tr><th>VPTERNLOGQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst, imm8
</th><td>EVEX.DDS.512.66.0F3A.W1 25 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x25</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5780.htm">t5780</a>
</dd>
</dl><pre>
IiyVPTERNLOGQ:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting QWORD, Operand=DH
    IiEmitOpcode 0x25
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiEmitImm Operand4, BYTE
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm, ymm.ymm.ymm.imm, ymm.ymm.mem.imm, zmm.zmm.zmm.imm, zmm.zmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix EVEX.DDS.128.66.0F3A.W1
    RET
.ymm.ymm.ymm.imm:
.ymm.ymm.mem.imm:
    IiEmitPrefix EVEX.DDS.256.66.0F3A.W1
    RET
.zmm.zmm.zmm.imm:
.zmm.zmm.mem.imm:
    IiEmitPrefix EVEX.DDS.512.66.0F3A.W1
    RET
  ENDP IiyVPTERNLOGQ::
</pre>

<dl id="IiyVPALIGNR">
<dt><a href="#IiyHandlers">&uarr; VPALIGNR</a></dt>
<dd>Packed Align Right</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPALIGNR xmm1, xmm2, xmm3/m128, imm8
</th><td>VEX.NDS.128.66.0F3A 0F /r ib 
</td></tr>
<tr><th>VPALIGNR ymm1, ymm2, ymm3/m256, imm8
</th><td>VEX.NDS.256.66.0F3A 0F /r ib 
</td></tr>
<tr><th>VPALIGNR xmm1 {k1}{z}, xmm2, xmm3/m128, imm8
</th><td>EVEX.NDS.128.66.0F3A.WIG 0F /r ib 
</td></tr>
<tr><th>VPALIGNR ymm1 {k1}{z}, ymm2, ymm3/m256, imm8
</th><td>EVEX.NDS.256.66.0F3A.WIG 0F /r ib 
</td></tr>
<tr><th>VPALIGNR zmm1 {k1}{z}, zmm2, zmm3/m512, imm8
</th><td>EVEX.NDS.512.66.0F3A.WIG 0F /r ib 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>ssse3,simdint</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qq | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F3A0F /r | 0x660F3A0F /r</dd>
<dt>CPU</dt>
<dd>C2+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5780.htm">t5780</a>
</dd>
</dl><pre>
IiyVPALIGNR:: PROC
    IiRequire SSSE3
    IiAllowModifier MASK
    IiEmitOpcode 0x0F
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiEmitImm Operand4, BYTE
    IiDispatchFormat  xmm.xmm.xmm.imm, xmm.xmm.mem.imm, ymm.ymm.ymm.imm, ymm.ymm.mem.imm, zmm.zmm.zmm.imm, zmm.zmm.mem.imm
.xmm.xmm.xmm.imm:
.xmm.xmm.mem.imm:
    IiEmitPrefix VEX.NDS.128.66.0F3A, EVEX.NDS.128.66.0F3A.WIG
    RET
.ymm.ymm.ymm.imm:
.ymm.ymm.mem.imm:
    IiEmitPrefix VEX.NDS.256.66.0F3A, EVEX.NDS.256.66.0F3A.WIG
    RET
.zmm.zmm.zmm.imm:
.zmm.zmm.mem.imm:
    IiEmitPrefix EVEX.NDS.512.66.0F3A.WIG
    RET
  ENDP IiyVPALIGNR::
</pre>

<dl id="IiyVPCMPB">
<dt><a href="#IiyHandlers">&uarr; VPCMPB</a></dt>
<dd>Compare Packed Signed BYTE Values Into Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPB k1 {k2}, xmm2, xmm3/m128, imm8
</th><td>EVEX.NDS.128.66.0F3A.W0 3F /r ib 
</td></tr>
<tr><th>VPCMPB k1 {k2}, ymm2, ymm3/m256, imm8
</th><td>EVEX.NDS.256.66.0F3A.W0 3F /r ib 
</td></tr>
<tr><th>VPCMPB k1 {k2}, zmm2, zmm3/m512, imm8
</th><td>EVEX.NDS.512.66.0F3A.W0 3F /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x3F</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5790.htm">t5790</a>
</dd>
</dl><pre>
IiyVPCMPB:: PROC
    MOV AL,0x3F
.op:IiEmitOpcode EAX
    IiAllowModifier CODE
    IiAllowMaskMerging
    IiEncoding CODE=LONG,DATA=BYTE
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiEmitImm Operand4, BYTE, Max=7
    IiDispatchFormat  krg.xmm.xmm.imm, krg.xmm.mem.imm, krg.ymm.ymm.imm, krg.ymm.mem.imm, krg.zmm.zmm.imm, krg.zmm.mem.imm
.cc:SHL EDX,8 ; This entry is called with format krg,regmm,regmm/mem (no immediate).
    MOV DL,imm ; Convert that format to krg,regmm,regmm/mem,imm. 
    MOV [EDI+II.Operand4+EXP.Low],CL ; Create imm value from cc mnemonic (0..7).
    MOVB [EDI+II.Operand4+EXP.Status],'N'
    JMP IiyVPCMPB.op: ; Continue as if the condition were specified by imm value.    
.krg.xmm.xmm.imm:
.krg.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.128.66.0F3A.W0
    RET
.krg.ymm.ymm.imm:
.krg.ymm.mem.imm:
    IiEmitPrefix EVEX.NDS.256.66.0F3A.W0
    RET
.krg.zmm.zmm.imm:
.krg.zmm.mem.imm:
    IiEmitPrefix EVEX.NDS.512.66.0F3A.W0
    RET
  ENDP IiyVPCMPB::
</pre>

<dl id="IiyVPCMPUB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPUB</a></dt>
<dd>Compare Packed Unsigned BYTE Values Into Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPUB k1 {k2}, xmm2, xmm3/m128, imm8
</th><td>EVEX.NDS.128.66.0F3A.W0 3E /r ib 
</td></tr>
<tr><th>VPCMPUB k1 {k2}, ymm2, ymm3/m256, imm8
</th><td>EVEX.NDS.256.66.0F3A.W0 3E /r ib 
</td></tr>
<tr><th>VPCMPUB k1 {k2}, zmm2, zmm3/m512, imm8
</th><td>EVEX.NDS.512.66.0F3A.W0 3E /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x3E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5790.htm">t5790</a>
</dd>
</dl><pre>
IiyVPCMPUB:: PROC
    MOV AL,0x3E
    JMP IiyVPCMPB.op:
  ENDP IiyVPCMPUB::
</pre>

<dl id="IiyVPCMPW">
<dt><a href="#IiyHandlers">&uarr; VPCMPW</a></dt>
<dd>Compare Packed Signed WORD Values Into Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPW k1 {k2}, xmm2, xmm3/m128, imm8
</th><td>EVEX.NDS.128.66.0F3A.W1 3F /r ib 
</td></tr>
<tr><th>VPCMPW k1 {k2}, ymm2, ymm3/m256, imm8
</th><td>EVEX.NDS.256.66.0F3A.W1 3F /r ib 
</td></tr>
<tr><th>VPCMPW k1 {k2}, zmm2, zmm3/m512, imm8
</th><td>EVEX.NDS.512.66.0F3A.W1 3F /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x3F</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5790.htm">t5790</a>
</dd>
</dl><pre>
IiyVPCMPW:: PROC
    MOV AL,0x3F
.op:IiEmitOpcode EAX
    IiAllowModifier CODE
    IiAllowMaskMerging
    IiEncoding CODE=LONG,DATA=WORD
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiEmitImm Operand4, BYTE, Max=7
    IiDispatchFormat  krg.xmm.xmm.imm, krg.xmm.mem.imm, krg.ymm.ymm.imm, krg.ymm.mem.imm, krg.zmm.zmm.imm, krg.zmm.mem.imm
.cc:SHL EDX,8 ; This entry is called with format krg,regmm,regmm/mem (no immediate).
    MOV DL,imm ; Convert that format to krg,regmm,regmm/mem,imm. 
    MOV [EDI+II.Operand4+EXP.Low],CL ; Create imm value from cc mnemonic (0..7).
    MOVB [EDI+II.Operand4+EXP.Status],'N'
    JMP IiyVPCMPW.op: ; Continue as if the condition were specified by imm value.    
.krg.xmm.xmm.imm:
.krg.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.128.66.0F3A.W1
    RET
.krg.ymm.ymm.imm:
.krg.ymm.mem.imm:
    IiEmitPrefix EVEX.NDS.256.66.0F3A.W1
    RET
.krg.zmm.zmm.imm:
.krg.zmm.mem.imm:
    IiEmitPrefix EVEX.NDS.512.66.0F3A.W1
    RET
  ENDP IiyVPCMPW::
</pre>

<dl id="IiyVPCMPUW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPUW</a></dt>
<dd>Compare Packed Unsigned WORD Values Into Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPUW k1 {k2}, xmm2, xmm3/m128, imm8
</th><td>EVEX.NDS.128.66.0F3A.W1 3E /r ib 
</td></tr>
<tr><th>VPCMPUW k1 {k2}, ymm2, ymm3/m256, imm8
</th><td>EVEX.NDS.256.66.0F3A.W1 3E /r ib 
</td></tr>
<tr><th>VPCMPUW k1 {k2}, zmm2, zmm3/m512, imm8
</th><td>EVEX.NDS.512.66.0F3A.W1 3E /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x3E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5790.htm">t5790</a>
</dd>
</dl><pre>
IiyVPCMPUW:: PROC
    MOV AL,0x3E
    JMP IiyVPCMPW.op:
  ENDP IiyVPCMPUW::
</pre>

<dl id="IiyVPCMPD">
<dt><a href="#IiyHandlers">&uarr; VPCMPD</a></dt>
<dd>Compare Packed Signed Integer DWORD Values into Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPD k1 {k2}, xmm2, xmm3/m128/m32bcst, imm8
</th><td>EVEX.NDS.128.66.0F3A.W0 1F /r ib 
</td></tr>
<tr><th>VPCMPD k1 {k2}, ymm2, ymm3/m256/m32bcst, imm8
</th><td>EVEX.NDS.256.66.0F3A.W0 1F /r ib 
</td></tr>
<tr><th>VPCMPD k1 {k2}, zmm2, zmm3/m512/m32bcst, imm8
</th><td>EVEX.NDS.512.66.0F3A.W0 1F /r ib 
</td></tr>
<tr><th>VPCMPD k1 {k2}, zmm2, zmm3/m512/m32bcst, imm8
</th><td>MVEX.NDS.512.66.0F3A.W0 1F /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x1F</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5792.htm">t5792</a>
</dd>
</dl><pre>
IiyVPCMPD:: PROC
    MOV AL,0x1F
.op:IiEmitOpcode EAX
    IiAllowModifier CODE
    IiEncoding CODE=LONG
    IiAllowMaskMerging
    IiAllowBroadcasting DWORD, Operand=DH
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDisp8MVEX Si32
    IiEmitImm Operand4, BYTE, Max=7
    IiDispatchFormat  krg.xmm.xmm.imm, krg.xmm.mem.imm, krg.ymm.ymm.imm, krg.ymm.mem.imm, krg.zmm.zmm.imm, krg.zmm.mem.imm
.cc:SHL EDX,8 ; This entry is called with format xmm/krg,xmm,xmm/mem (no immediate).
    MOV DL,imm ; Convert that format to xmm/krg,xmm,xmm/mem,imm. 
    MOV [EDI+II.Operand4+EXP.Low],CL ; Create imm value from cc mnemonic (0..31).
    MOVB [EDI+II.Operand4+EXP.Status],'N'
    JMP IiyVPCMPD.op: ; Continue as if the condition were specified by imm value.    
.krg.xmm.xmm.imm:
.krg.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.128.66.0F3A.W0
    RET
.krg.ymm.ymm.imm:
.krg.ymm.mem.imm:
    IiEmitPrefix EVEX.NDS.256.66.0F3A.W0
    RET
.krg.zmm.zmm.imm:
.krg.zmm.mem.imm:
    IiEmitPrefix EVEX.NDS.512.66.0F3A.W0, MVEX.NDS.512.66.0F3A.W0
    RET
  ENDP IiyVPCMPD::
</pre>

<dl id="IiyVPCMPUD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPUD</a></dt>
<dd>Compare Packed Unsigned Integer DWORD Values into Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPUD k1 {k2}, xmm2, xmm3/m128/m32bcst, imm8
</th><td>EVEX.NDS.128.66.0F3A.W0 1E /r ib 
</td></tr>
<tr><th>VPCMPUD k1 {k2}, ymm2, ymm3/m256/m32bcst, imm8
</th><td>EVEX.NDS.256.66.0F3A.W0 1E /r ib 
</td></tr>
<tr><th>VPCMPUD k1 {k2}, zmm2, zmm3/m512/m32bcst, imm8
</th><td>EVEX.NDS.512.66.0F3A.W0 1E /r ib 
</td></tr>
<tr><th>VPCMPUD k1 {k2}, zmm2, zmm3/m512/m32bcst, imm8
</th><td>MVEX.NDS.512.66.0F3A.W0 1E /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x1E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5792.htm">t5792</a>
</dd>
</dl><pre>
IiyVPCMPUD:: PROC
    MOV AL,0x1E
    JMP IiyVPCMPD.op:
  ENDP IiyVPCMPUD::
</pre>

<dl id="IiyVPCMPQ">
<dt><a href="#IiyHandlers">&uarr; VPCMPQ</a></dt>
<dd>Compare Packed Unsigned Integer QWORD Values into Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPQ k1 {k2}, xmm2, xmm3/m128/m64bcst, imm8
</th><td>EVEX.NDS.128.66.0F3A.W1 1F /r ib 
</td></tr>
<tr><th>VPCMPQ k1 {k2}, ymm2, ymm3/m256/m64bcst, imm8
</th><td>EVEX.NDS.256.66.0F3A.W1 1F /r ib 
</td></tr>
<tr><th>VPCMPQ k1 {k2}, zmm2, zmm3/m512/m64bcst, imm8</th><td>EVEX.NDS.512.66.0F3A.W1 1F /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x1F</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5792.htm">t5792</a>
</dd>
</dl><pre>
IiyVPCMPQ:: PROC
    MOV AL,0x1F
.op:IiEmitOpcode EAX
    IiAllowModifier CODE
    IiEncoding CODE=LONG
    IiAllowMaskMerging
    IiAllowBroadcasting QWORD, Operand=DH
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiEmitImm Operand4, BYTE, Max=7
    IiDispatchFormat  krg.xmm.xmm.imm, krg.xmm.mem.imm, krg.ymm.ymm.imm, krg.ymm.mem.imm, krg.zmm.zmm.imm, krg.zmm.mem.imm
.cc:SHL EDX,8 ; This entry is called with format xmm/krg,xmm,xmm/mem (no immediate).
    MOV DL,imm ; Convert that format to xmm/krg,xmm,xmm/mem,imm. 
    MOV [EDI+II.Operand4+EXP.Low],CL ; Create imm value from cc mnemonic (0..31).
    MOVB [EDI+II.Operand4+EXP.Status],'N'
    JMP IiyVPCMPQ.op: ; Continue as if the condition were specified by imm value.    
.krg.xmm.xmm.imm:
.krg.xmm.mem.imm:
    IiEmitPrefix EVEX.NDS.128.66.0F3A.W1
    RET
.krg.ymm.ymm.imm:
.krg.ymm.mem.imm:
    IiEmitPrefix EVEX.NDS.256.66.0F3A.W1
    RET
.krg.zmm.zmm.imm:
.krg.zmm.mem.imm:
    IiEmitPrefix EVEX.NDS.512.66.0F3A.W1
    RET
  ENDP IiyVPCMPQ::
</pre>

<dl id="IiyVPCMPUQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPUQ</a></dt>
<dd>Compare Packed Unsigned Integer QWORD Values into Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPUQ k1 {k2}, xmm2, xmm3/m128/m64bcst, imm8
</th><td>EVEX.NDS.128.66.0F3A.W1 1E /r ib 
</td></tr>
<tr><th>VPCMPUQ k1 {k2}, ymm2, ymm3/m256/m64bcst, imm8
</th><td>EVEX.NDS.256.66.0F3A.W1 1E /r ib 
</td></tr>
<tr><th>VPCMPUQ k1 {k2}, zmm2, zmm3/m512/m64bcst, imm8
</th><td>EVEX.NDS.512.66.0F3A.W1 1E /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x1E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5792.htm">t5792</a>
</dd>
</dl><pre>
IiyVPCMPUQ:: PROC
    MOV AL,0x1E
    JMP IiyVPCMPQ.op:
  ENDP IiyVPCMPUQ::
</pre>

<dl id="IiyVPCMPEQB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPEQB</a></dt>
<dd>Compare if Equal Packed signed BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPEQB xmm1, xmm2, xmm3 /m128
</th><td>VEX.NDS.128.66.0F.WIG 74 /r
</td></tr>
<tr><th>VPCMPEQB ymm1, ymm2, ymm3 /m256
</th><td>VEX.NDS.256.66.0F.WIG 74 /r
</td></tr>
<tr><th>VPCMPEQB k1 {k2}, xmm2, xmm3 /m128
</th><td>EVEX.NDS.128.66.0F.WIG 74 /r
</td></tr>
<tr><th>VPCMPEQB k1 {k2}, ymm2, ymm3 /m256
</th><td>EVEX.NDS.256.66.0F.WIG 74 /r
</td></tr>
<tr><th>VPCMPEQB k1 {k2}, zmm2, zmm3 /m512
</th><td>EVEX.NDS.512.66.0F.WIG 74 /r
</td></tr>
<tr><th>VPCMPEQB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3F /r 00 
</td></tr>
<tr><th>VPCMPEQB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3F /r 00 
</td></tr>
<tr><th>VPCMPEQB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3F /r 00
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x00</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
<a class="EXT" href="../eatests/t5797.htm">t5797</a>
</dd>
</dl><pre>
IiyVPCMPEQB:: PROC
    MOV AL,0x3F
    MOV CL,0x00
    PUSH EBX
     MOV EBX,EDX
     SHR EBX,16
     CMP BL,krg
    POP EBX
    JNE .S:
    IiDispatchCode SHORT= .S:, LONG=IiyVPCMPB.cc:
.S: IiEncoding CODE=SHORT,DATA=BYTE
    IiAllowModifier CODE
    IiAllowMaskMerging
    IiEmitOpcode 0x74
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat xmm.xmm.xmm,xmm.xmm.mem,ymm.ymm.ymm,ymm.ymm.mem, \
          krg.xmm.xmm,krg.xmm.mem,krg.ymm.ymm,krg.ymm.mem,krg.zmm.zmm,krg.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F.WIG
    RET
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F.WIG
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F.WIG
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.WIG
    RET
   ENDP IiyVPCMPEQB::
</pre>

<dl id="IiyVPCMPLTB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPLTB</a></dt>
<dd>Compare if Less Than Packed signed BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLTB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3F /r 01 
</td></tr>
<tr><th>VPCMPLTB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3F /r 01 
</td></tr>
<tr><th>VPCMPLTB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3F /r 01 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x01</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPLTB:: PROC
    MOV AL,0x3F
    MOV CL,0x01
    JMP IiyVPCMPB.cc:
 ENDP IiyVPCMPLTB::
</pre>

<dl id="IiyVPCMPLEB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPLEB</a></dt>
<dd>Compare if Less than or Equal Packed signed BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLEB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3F /r 02 
</td></tr>
<tr><th>VPCMPLEB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3F /r 02 
</td></tr>
<tr><th>VPCMPLEB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3F /r 02 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x02</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPLEB:: PROC
    MOV AL,0x3F
    MOV CL,0x02
    JMP IiyVPCMPB.cc:
 ENDP IiyVPCMPLEB::
</pre>

<dl id="IiyVPCMPFALSEB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPFALSEB</a></dt>
<dd>Compare if False Packed signed BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPFALSEB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3F /r 03 
</td></tr>
<tr><th>VPCMPFALSEB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3F /r 03 
</td></tr>
<tr><th>VPCMPFALSEB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3F /r 03 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x03</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPFALSEB:: PROC
    MOV AL,0x3F
    MOV CL,0x03
    JMP IiyVPCMPB.cc:
 ENDP IiyVPCMPFALSEB::
</pre>

<dl id="IiyVPCMPNEQB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPNEQB</a></dt>
<dd>Compare if Not Equal Packed signed BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNEQB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3F /r 04 
</td></tr>
<tr><th>VPCMPNEQB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3F /r 04 
</td></tr>
<tr><th>VPCMPNEQB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3F /r 04 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x04</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNEQB:: PROC
    MOV AL,0x3F
    MOV CL,0x04
    JMP IiyVPCMPB.cc:
 ENDP IiyVPCMPNEQB::
</pre>

<dl id="IiyVPCMPNLTB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPNLTB</a></dt>
<dd>Compare if Not Less Than Packed signed BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLTB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3F /r 05 
</td></tr>
<tr><th>VPCMPNLTB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3F /r 05 
</td></tr>
<tr><th>VPCMPNLTB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3F /r 05 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x05</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNLTB:: PROC
    MOV AL,0x3F
    MOV CL,0x05
    JMP IiyVPCMPB.cc:
 ENDP IiyVPCMPNLTB::
</pre>

<dl id="IiyVPCMPNLEB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPNLEB</a></dt>
<dd>Compare if Not Less than or Equal Packed signed BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLEB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3F /r 06 
</td></tr>
<tr><th>VPCMPNLEB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3F /r 06 
</td></tr>
<tr><th>VPCMPNLEB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3F /r 06 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x06</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNLEB:: PROC
    MOV AL,0x3F
    MOV CL,0x06
    JMP IiyVPCMPB.cc:
 ENDP IiyVPCMPNLEB::
</pre>

<dl id="IiyVPCMPTRUEB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPTRUEB</a></dt>
<dd>Compare if True Packed signed BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPTRUEB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3F /r 07 
</td></tr>
<tr><th>VPCMPTRUEB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3F /r 07 
</td></tr>
<tr><th>VPCMPTRUEB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3F /r 07 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x07</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPTRUEB:: PROC
    MOV AL,0x3F
    MOV CL,0x07
    JMP IiyVPCMPB.cc:
 ENDP IiyVPCMPTRUEB::
</pre>

<dl id="IiyVPCMPEQUB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPEQUB</a></dt>
<dd>Compare if Equal Packed Unsigned BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPEQUB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3E /r 00 
</td></tr>
<tr><th>VPCMPEQUB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3E /r 00 
</td></tr>
<tr><th>VPCMPEQUB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3E /r 00 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x00</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPEQUB:: PROC
    MOV AL,0x3E
    MOV CL,0x00
    JMP IiyVPCMPB.cc
 ENDP IiyVPCMPEQUB::
</pre>

<dl id="IiyVPCMPLTUB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPLTUB</a></dt>
<dd>Compare if Less Than Packed Unsigned BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLTUB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3E /r 01 
</td></tr>
<tr><th>VPCMPLTUB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3E /r 01 
</td></tr>
<tr><th>VPCMPLTUB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3E /r 01 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x01</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPLTUB:: PROC
    MOV AL,0x3E
    MOV CL,0x01
    JMP IiyVPCMPB.cc
 ENDP IiyVPCMPLTUB::
</pre>

<dl id="IiyVPCMPLEUB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPLEUB</a></dt>
<dd>Compare if Less than or Equal Packed Unsigned BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLEUB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3E /r 02 
</td></tr>
<tr><th>VPCMPLEUB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3E /r 02 
</td></tr>
<tr><th>VPCMPLEUB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3E /r 02 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x02</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPLEUB:: PROC
    MOV AL,0x3E
    MOV CL,0x02
    JMP IiyVPCMPB.cc
 ENDP IiyVPCMPLEUB::
</pre>

<dl id="IiyVPCMPFALSEUB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPFALSEUB</a></dt>
<dd>Compare if False Packed Unsigned BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPFALSEUB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3E /r 03 
</td></tr>
<tr><th>VPCMPFALSEUB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3E /r 03 
</td></tr>
<tr><th>VPCMPFALSEUB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3E /r 03 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x03</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPFALSEUB:: PROC
    MOV AL,0x3E
    MOV CL,0x03
    JMP IiyVPCMPB.cc
 ENDP IiyVPCMPFALSEUB::
</pre>

<dl id="IiyVPCMPNEQUB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPNEQUB</a></dt>
<dd>Compare if Not Equal Packed Unsigned BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNEQUB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3E /r 04 
</td></tr>
<tr><th>VPCMPNEQUB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3E /r 04
</td></tr>
<tr><th>VPCMPNEQUB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3E /r 04 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x04</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNEQUB:: PROC
    MOV AL,0x3E
    MOV CL,0x04
    JMP IiyVPCMPB.cc
 ENDP IiyVPCMPNEQUB::
</pre>

<dl id="IiyVPCMPNLTUB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPNLTUB</a></dt>
<dd>Compare if Not Less Than Packed Unsigned BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLTUB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3E /r 05 
</td></tr>
<tr><th>VPCMPNLTUB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3E /r 05 
</td></tr>
<tr><th>VPCMPNLTUB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3E /r 05 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x05</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNLTUB:: PROC
    MOV AL,0x3E
    MOV CL,0x05
    JMP IiyVPCMPB.cc
 ENDP IiyVPCMPNLTUB::
</pre>

<dl id="IiyVPCMPNLEUB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPNLEUB</a></dt>
<dd>Compare if Not Less than or Equal Packed Unsigned BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLEUB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3E /r 06 
</td></tr>
<tr><th>VPCMPNLEUB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3E /r 06 
</td></tr>
<tr><th>VPCMPNLEUB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3E /r 06 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x06</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNLEUB:: PROC
    MOV AL,0x3E
    MOV CL,0x06
    JMP IiyVPCMPB.cc
 ENDP IiyVPCMPNLEUB::
</pre>

<dl id="IiyVPCMPTRUEUB">
<dt><a href="#IiyVPCMPB">&uarr; VPCMPTRUEUB</a></dt>
<dd>Compare if True Packed Unsigned BYTE values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPTRUEUB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 3E /r 07 
</td></tr>
<tr><th>VPCMPTRUEUB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 3E /r 07 
</td></tr>
<tr><th>VPCMPTRUEUB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 3E /r 07 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x07</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPTRUEUB:: PROC
    MOV AL,0x3E
    MOV CL,0x07
    JMP IiyVPCMPB.cc
 ENDP IiyVPCMPTRUEUB::
</pre>

<dl id="IiyVPCMPEQW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPEQW</a></dt>
<dd>Compare if Equal Packed signed WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPEQW xmm1, xmm2, xmm3 /m128
</th><td>VEX.NDS.128.66.0F.WIG 75 /r
</td></tr>
<tr><th>VPCMPEQW ymm1, ymm2, ymm3 /m256
</th><td>VEX.NDS.256.66.0F.WIG 75 /r
</td></tr>
<tr><th>VPCMPEQW k1 {k2}, xmm2, xmm3 /m128
</th><td>EVEX.NDS.128.66.0F.WIG 75 /r
</td></tr>
<tr><th>VPCMPEQW k1 {k2}, ymm2, ymm3 /m256
</th><td>EVEX.NDS.256.66.0F.WIG 75 /r
</td></tr>
<tr><th>VPCMPEQW k1 {k2}, zmm2, zmm3 /m512
</th><td>EVEX.NDS.512.66.0F.WIG 75 /r
</td></tr>
<tr><th>VPCMPEQW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3F /r 00 
</td></tr>
<tr><th>VPCMPEQW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3F /r 00 
</td></tr>
<tr><th>VPCMPEQW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3F /r 00 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x00</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
<a class="EXT" href="../eatests/t5797.htm">t5797</a>
</dd>
</dl><pre>
IiyVPCMPEQW:: PROC
    MOV EBX,EDX
    MOV AL,0x3F
    MOV CL,0x00
    SHR EBX,16
    CMP BL,krg
    JNE .S:
    IiDispatchCode SHORT= .S:, LONG=IiyVPCMPW.cc:
.S: IiEncoding CODE=SHORT,DATA=WORD
    IiAllowModifier CODE
    IiAllowMaskMerging
    IiEmitOpcode 0x75
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat xmm.xmm.xmm,xmm.xmm.mem,ymm.ymm.ymm,ymm.ymm.mem, \
          krg.xmm.xmm,krg.xmm.mem,krg.ymm.ymm,krg.ymm.mem,krg.zmm.zmm,krg.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F.WIG
    RET
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F.WIG
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F.WIG
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.WIG
    RET
  ENDP IiyVPCMPEQW::
</pre>

<dl id="IiyVPCMPLTW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPLTW</a></dt>
<dd>Compare if Less Than Packed signed WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLTW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3F /r 01 
</td></tr>
<tr><th>VPCMPLTW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3F /r 01 
</td></tr>
<tr><th>VPCMPLTW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3F /r 01
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x01</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPLTW:: PROC
    MOV AL,0x3F
    MOV CL,0x01
    JMP IiyVPCMPW.cc:
 ENDP IiyVPCMPLTW::
</pre>

<dl id="IiyVPCMPLEW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPLEW</a></dt>
<dd>Compare if Less than or Equal Packed signed WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLEW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3F /r 02 
</td></tr>
<tr><th>VPCMPLEW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3F /r 02 
</td></tr>
<tr><th>VPCMPLEW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3F /r 02 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x02</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPLEW:: PROC
    MOV AL,0x3F
    MOV CL,0x02
    JMP IiyVPCMPW.cc:
 ENDP IiyVPCMPLEW::
</pre>

<dl id="IiyVPCMPFALSEW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPFALSEW</a></dt>
<dd>Compare if False Packed signed WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPFALSEW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3F /r 03 
</td></tr>
<tr><th>VPCMPFALSEW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3F /r 03 
</td></tr>
<tr><th>VPCMPFALSEW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3F /r 03 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x03</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPFALSEW:: PROC
    MOV AL,0x3F
    MOV CL,0x03
    JMP IiyVPCMPW.cc:
 ENDP IiyVPCMPFALSEW::
</pre>

<dl id="IiyVPCMPNEQW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPNEQW</a></dt>
<dd>Compare if Not Equal Packed signed WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNEQW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3F /r 04 
</td></tr>
<tr><th>VPCMPNEQW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3F /r 04 
</td></tr>
<tr><th>VPCMPNEQW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3F /r 04 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x04</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNEQW:: PROC
    MOV AL,0x3F
    MOV CL,0x04
    JMP IiyVPCMPW.cc:
 ENDP IiyVPCMPNEQW::
</pre>

<dl id="IiyVPCMPNLTW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPNLTW</a></dt>
<dd>Compare if Not Less Than Packed signed WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLTW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3F /r 05 
</td></tr>
<tr><th>VPCMPNLTW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3F /r 05 
</td></tr>
<tr><th>VPCMPNLTW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3F /r 05 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x05</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNLTW:: PROC
    MOV AL,0x3F
    MOV CL,0x05
    JMP IiyVPCMPW.cc:
 ENDP IiyVPCMPNLTW::
</pre>

<dl id="IiyVPCMPNLEW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPNLEW</a></dt>
<dd>Compare if Not Less than or Equal Packed signed WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLEW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3F /r 06 
</td></tr>
<tr><th>VPCMPNLEW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3F /r 06 
</td></tr>
<tr><th>VPCMPNLEW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3F /r 06 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x06</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNLEW:: PROC
    MOV AL,0x3F
    MOV CL,0x06
    JMP IiyVPCMPW.cc:
 ENDP IiyVPCMPNLEW::
</pre>

<dl id="IiyVPCMPTRUEW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPTRUEW</a></dt>
<dd>Compare if True Packed signed WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPTRUEW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3F /r 07 
</td></tr>
<tr><th>VPCMPTRUEW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3F /r 07 
</td></tr>
<tr><th>VPCMPTRUEW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3F /r 07 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3F /r 0x07</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPTRUEW:: PROC
    MOV AL,0x3F
    MOV CL,0x07
    JMP IiyVPCMPW.cc:
 ENDP IiyVPCMPTRUEW::
</pre>

<dl id="IiyVPCMPEQUW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPEQUW</a></dt>
<dd>Compare if Equal Packed Unsigned WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPEQUW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3E /r 00 
</td></tr>
<tr><th>VPCMPEQUW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3E /r 00 
</td></tr>
<tr><th>VPCMPEQUW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3E /r 00 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x00</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPEQUW:: PROC
    MOV AL,0x3E
    MOV CL,0x00
    JMP IiyVPCMPW.cc
 ENDP IiyVPCMPEQUW::
</pre>

<dl id="IiyVPCMPLTUW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPLTUW</a></dt>
<dd>Compare if Less Than Packed Unsigned WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLTUW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3E /r 01 
</td></tr>
<tr><th>VPCMPLTUW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3E /r 01 
</td></tr>
<tr><th>VPCMPLTUW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3E /r 01 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x01</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPLTUW:: PROC
    MOV AL,0x3E
    MOV CL,0x01
    JMP IiyVPCMPW.cc
 ENDP IiyVPCMPLTUW::
</pre>

<dl id="IiyVPCMPLEUW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPLEUW</a></dt>
<dd>Compare if Less than or Equal Packed Unsigned WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLEUW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3E /r 02 
</td></tr>
<tr><th>VPCMPLEUW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3E /r 02 
</td></tr>
<tr><th>VPCMPLEUW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3E /r 02 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x02</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPLEUW:: PROC
    MOV AL,0x3E
    MOV CL,0x02
    JMP IiyVPCMPW.cc
 ENDP IiyVPCMPLEUW::
</pre>

<dl id="IiyVPCMPFALSEUW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPFALSEUW</a></dt>
<dd>Compare if False Packed Unsigned WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPFALSEUW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3E /r 03 
</td></tr>
<tr><th>VPCMPFALSEUW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3E /r 03 
</td></tr>
<tr><th>VPCMPFALSEUW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3E /r 03 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x03</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPFALSEUW:: PROC
    MOV AL,0x3E
    MOV CL,0x03
    JMP IiyVPCMPW.cc
 ENDP IiyVPCMPFALSEUW::
</pre>

<dl id="IiyVPCMPNEQUW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPNEQUW</a></dt>
<dd>Compare if Not Equal Packed Unsigned WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNEQUW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3E /r 04 
</td></tr>
<tr><th>VPCMPNEQUW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3E /r 04 
</td></tr>
<tr><th>VPCMPNEQUW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3E /r 04 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x04</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNEQUW:: PROC
    MOV AL,0x3E
    MOV CL,0x04
    JMP IiyVPCMPW.cc
 ENDP IiyVPCMPNEQUW::
</pre>

<dl id="IiyVPCMPNLTUW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPNLTUW</a></dt>
<dd>Compare if Not Less Than Packed Unsigned WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLTUW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3E /r 05 
</td></tr>
<tr><th>VPCMPNLTUW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3E /r 05 
</td></tr>
<tr><th>VPCMPNLTUW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3E /r 05
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x05</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNLTUW:: PROC
    MOV AL,0x3E
    MOV CL,0x05
    JMP IiyVPCMPW.cc
 ENDP IiyVPCMPNLTUW::
</pre>

<dl id="IiyVPCMPNLEUW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPNLEUW</a></dt>
<dd>Compare if Not Less than or Equal Packed Unsigned WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLEUW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3E /r 06 
</td></tr>
<tr><th>VPCMPNLEUW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3E /r 06 
</td></tr>
<tr><th>VPCMPNLEUW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3E /r 06 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x06</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPNLEUW:: PROC
    MOV AL,0x3E
    MOV CL,0x06
    JMP IiyVPCMPW.cc
 ENDP IiyVPCMPNLEUW::
</pre>

<dl id="IiyVPCMPTRUEUW">
<dt><a href="#IiyVPCMPW">&uarr; VPCMPTRUEUW</a></dt>
<dd>Compare if True Packed Unsigned WORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPTRUEUW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 3E /r 07 
</td></tr>
<tr><th>VPCMPTRUEUW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 3E /r 07 
</td></tr>
<tr><th>VPCMPTRUEUW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 3E /r 07 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>3E /r 0x07</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5794.htm">t5794</a>
</dd>
</dl><pre>
IiyVPCMPTRUEUW:: PROC
    MOV AL,0x3E
    MOV CL,0x07
    JMP IiyVPCMPW.cc
 ENDP IiyVPCMPTRUEUW::
</pre>

<dl id="IiyVPCMPEQD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPEQD</a></dt>
<dd>Compare if Equal Packed signed DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPEQD xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 76 /r
</td></tr> 
<tr><th>VPCMPEQD ymm1, ymm2, ymm3 /m256
</th><td>VEX.NDS.256.66.0F.WIG 76 /r
</td></tr> 
<tr><th>VPCMPEQD k1 {k2}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F.W0 76 /r
</td></tr> 
<tr><th>VPCMPEQD k1 {k2}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F.W0 76 /r
</td></tr> 
<tr><th>VPCMPEQD k1 {k2}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F.W0 76 /r
</td></tr>
<tr><th>VPCMPEQD k1 {k2}, zmm2, zmm3/m512/m32bcst
</th><td>MVEX.NDS.512.66.0F.W0 76 /r 
</td></tr> 
<tr><th>VPCMPEQD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1F /r 00
</td></tr>
<tr><th>VPCMPEQD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1F /r 00 
</td></tr>
<tr><th>VPCMPEQD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1F /r 00 
</td></tr>
<tr><th>VPCMPEQD k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1F /r 00 
</td></tr>

</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x00</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
<a class="EXT" href="../eatests/t5797.htm">t5797</a>
</dd>
</dl><pre>
IiyVPCMPEQD:: PROC
    MOV EBX,EDX
    MOV AL,0x1F
    MOV CL,0x00
    SHR EBX,16
    CMP BL,krg
    JNE .S:
    IiDispatchCode SHORT= .S:, LONG=IiyVPCMPD.cc:
 .S:IiEncoding CODE=SHORT,DATA=DWORD
    IiAllowModifier CODE
    IiAllowMaskMerging
    IiAllowBroadcasting DWORD
    IiEmitOpcode 0x76
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDisp8MVEX Si32
    IiDispatchFormat xmm.xmm.xmm,xmm.xmm.mem,ymm.ymm.ymm,ymm.ymm.mem, \
          krg.xmm.xmm,krg.xmm.mem,krg.ymm.ymm,krg.ymm.mem,krg.zmm.zmm,krg.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F.WIG
    RET
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F.W0
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F.W0
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.W0, MVEX.NDS.512.66.0F.W0
    RET
 ENDP IiyVPCMPEQD::
</pre>

<dl id="IiyVPCMPLTD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPLTD</a></dt>
<dd>Compare if Less Than Packed signed DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLTD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1F /r 01 
</td></tr>
<tr><th>VPCMPLTD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1F /r 01 
</td></tr>
<tr><th>VPCMPLTD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1F /r 01 
</td></tr>
<tr><th>VPCMPLTD k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1F /r 01 
</td></tr>
<tr><th>VPCMPLTD k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F38.W0 74 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x01</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
<a class="EXT" href="../eatests/t5797.htm">t5797</a>
</dd>
</dl><pre>
IiyVPCMPLTD:: PROC
    MOV AL,0x1F
    MOV CL,0x01
    CMP DH,zmm ; Operand2. 
    JNE IiyVPCMPD.cc: ; Use long version 66.0F3A 1F ib 
    JNSt [EDI+II.MfxExplicit],iiMfxPREFIX_MVEX | iiMfxEH_Mask, IiyVPCMPD.cc: ; Use long version.
    JSt [EDI+II.MfgExplicit],iiMfgCODE_LONG, IiyVPCMPD.cc: ; Use long version.
    IiEncoding CODE=SHORT
    IiAllowModifier CODE
    IiAllowMaskMerging
    IiAllowBroadcasting DWORD
    IiEmitOpcode 0x74
    IiOpEn RVM
    IiModRM /r
    IiDisp8MVEX Si32
    IiDispatchFormat krg.zmm.zmm, krg.zmm.mem
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix MVEX.NDS.512.66.0F38.W0
    RET    
 ENDP IiyVPCMPLTD::
</pre>

<dl id="IiyVPCMPLED">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPLED</a></dt>
<dd>Compare if Less than or Equal Packed signed DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLED k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1F /r 02 
</td></tr>
<tr><th>VPCMPLED k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1F /r 02 
</td></tr>
<tr><th>VPCMPLED k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1F /r 02 
</td></tr>
<tr><th>VPCMPLED k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1F /r 02 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x02</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPLED:: PROC
    MOV AL,0x1F
    MOV CL,0x02
    JMP IiyVPCMPD.cc:
 ENDP IiyVPCMPLED::
</pre>

<dl id="IiyVPCMPFALSED">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPFALSED</a></dt>
<dd>Compare if False Packed signed DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPFALSED k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1F /r 03 
</td></tr>
<tr><th>VPCMPFALSED k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1F /r 03 
</td></tr>
<tr><th>VPCMPFALSED k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1F /r 03 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x03</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPFALSED:: PROC
    MOV AL,0x1F
    MOV CL,0x03
    JMP IiyVPCMPD.cc:
 ENDP IiyVPCMPFALSED::
</pre>

<dl id="IiyVPCMPNEQD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPNEQD</a></dt>
<dd>Compare if Not Equal Packed signed DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNEQD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1F /r 04 
</td></tr>
<tr><th>VPCMPNEQD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1F /r 04 
</td></tr>
<tr><th>VPCMPNEQD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1F /r 04 
</td></tr>
<tr><th>VPCMPNEQD k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1F /r 04 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x04</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNEQD:: PROC
    MOV AL,0x1F
    MOV CL,0x04
    JMP IiyVPCMPD.cc:
 ENDP IiyVPCMPNEQD::
</pre>

<dl id="IiyVPCMPNLTD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPNLTD</a></dt>
<dd>Compare if Not Less Than Packed signed DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLTD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1F /r 05 
</td></tr>
<tr><th>VPCMPNLTD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1F /r 05 
</td></tr>
<tr><th>VPCMPNLTD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1F /r 05 
</td></tr>
<tr><th>VPCMPNLTD k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1F /r 05 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x05</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNLTD:: PROC
    MOV AL,0x1F
    MOV CL,0x05
    JMP IiyVPCMPD.cc:
 ENDP IiyVPCMPNLTD::
</pre>

<dl id="IiyVPCMPNLED">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPNLED</a></dt>
<dd>Compare if Not Less than or Equal Packed signed DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLED k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1F /r 06
</td></tr>
<tr><th>VPCMPNLED k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1F /r 06 
</td></tr>
<tr><th>VPCMPNLED k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1F /r 06 
</td></tr>
<tr><th>VPCMPNLED k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1F /r 06 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x06</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNLED:: PROC
    MOV AL,0x1F
    MOV CL,0x06
    JMP IiyVPCMPD.cc:
 ENDP IiyVPCMPNLED::
</pre>

<dl id="IiyVPCMPTRUED">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPTRUED</a></dt>
<dd>Compare if True Packed signed DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPTRUED k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1F /r 07 
</td></tr>
<tr><th>VPCMPTRUED k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1F /r 07 
</td></tr>
<tr><th>VPCMPTRUED k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1F /r 07 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x07</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPTRUED:: PROC
    MOV AL,0x1F
    MOV CL,0x07
    JMP IiyVPCMPD.cc:
 ENDP IiyVPCMPTRUED::
</pre>

<dl id="IiyVPCMPEQUD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPEQUD</a></dt>
<dd>Compare if Equal Packed Unsigned DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPEQUD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1E /r 00 
</td></tr>
<tr><th>VPCMPEQUD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1E /r 00 
</td></tr>
<tr><th>VPCMPEQUD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1E /r 00 
</td></tr>
<tr><th>VPCMPEQUD k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1E /r 00 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x00</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPEQUD:: PROC
    MOV AL,0x1E
    MOV CL,0x00
    JMP IiyVPCMPD.cc
 ENDP IiyVPCMPEQUD::
</pre>

<dl id="IiyVPCMPLTUD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPLTUD</a></dt>
<dd>Compare if Less Than Packed Unsigned DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLTUD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1E /r 01 
</td></tr>
<tr><th>VPCMPLTUD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1E /r 01 
</td></tr>
<tr><th>VPCMPLTUD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1E /r 01
</td></tr>
<tr><th>VPCMPLTUD k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1E /r 01 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x01</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPLTUD:: PROC
    MOV AL,0x1E
    MOV CL,0x01
    JMP IiyVPCMPD.cc
 ENDP IiyVPCMPLTUD::
</pre>

<dl id="IiyVPCMPLEUD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPLEUD</a></dt>
<dd>Compare if Less than or Equal Packed Unsigned DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLEUD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1E /r 02 
</td></tr>
<tr><th>VPCMPLEUD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1E /r 02 
</td></tr>
<tr><th>VPCMPLEUD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1E /r 02 
</td></tr>
<tr><th>VPCMPLEUD k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1E /r 02 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x02</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPLEUD:: PROC
    MOV AL,0x1E
    MOV CL,0x02
    JMP IiyVPCMPD.cc
 ENDP IiyVPCMPLEUD::
</pre>

<dl id="IiyVPCMPFALSEUD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPFALSEUD</a></dt>
<dd>Compare if False Packed Unsigned DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPFALSEUD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1E /r 03 
</td></tr>
<tr><th>VPCMPFALSEUD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1E /r 03 
</td></tr>
<tr><th>VPCMPFALSEUD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1E /r 03 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x03</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPFALSEUD:: PROC
    MOV AL,0x1E
    MOV CL,0x03
    JMP IiyVPCMPD.cc
 ENDP IiyVPCMPFALSEUD::
</pre>

<dl id="IiyVPCMPNEQUD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPNEQUD</a></dt>
<dd>Compare if Not Equal Packed Unsigned DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNEQUD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1E /r 04 
</td></tr>
<tr><th>VPCMPNEQUD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1E /r 04 
</td></tr>
<tr><th>VPCMPNEQUD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1E /r 04 
</td></tr>
<tr><th>VPCMPNEQUD k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1E /r 04 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x04</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNEQUD:: PROC
    MOV AL,0x1E
    MOV CL,0x04
    JMP IiyVPCMPD.cc
 ENDP IiyVPCMPNEQUD::
</pre>

<dl id="IiyVPCMPNLTUD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPNLTUD</a></dt>
<dd>Compare if Not Less Than Packed Unsigned DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLTUD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1E /r 05 
</td></tr>
<tr><th>VPCMPNLTUD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1E /r 05 
</td></tr>
<tr><th>VPCMPNLTUD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1E /r 05 
</td></tr>
<tr><th>VPCMPNLTUD k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1E /r 05 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x05</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNLTUD:: PROC
    MOV AL,0x1E
    MOV CL,0x05
    JMP IiyVPCMPD.cc
 ENDP IiyVPCMPNLTUD::
</pre>

<dl id="IiyVPCMPNLEUD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPNLEUD</a></dt>
<dd>Compare if Not Less than or Equal Packed Unsigned DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLEUD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1E /r 06 
</td></tr>
<tr><th>VPCMPNLEUD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1E /r 06 
</td></tr>
<tr><th>VPCMPNLEUD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1E /r 06 
</td></tr>
<tr><th>VPCMPNLEUD k1 {k2}, zmm2, zmm3/m512
</th><td>MVEX.NDS.512.66.0F3A.W0 1E /r 06 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x06</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNLEUD:: PROC
    MOV AL,0x1E
    MOV CL,0x06
    JMP IiyVPCMPD.cc
 ENDP IiyVPCMPNLEUD::
</pre>

<dl id="IiyVPCMPTRUEUD">
<dt><a href="#IiyVPCMPD">&uarr; VPCMPTRUEUD</a></dt>
<dd>Compare if True Packed Unsigned DWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPTRUEUD k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W0 1E /r 07 
</td></tr>
<tr><th>VPCMPTRUEUD k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W0 1E /r 07 
</td></tr>
<tr><th>VPCMPTRUEUD k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W0 1E /r 07 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x07</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPTRUEUD:: PROC
    MOV AL,0x1E
    MOV CL,0x07
    JMP IiyVPCMPD.cc
 ENDP IiyVPCMPTRUEUD::
</pre>

<dl id="IiyVPCMPEQQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPEQQ</a></dt>
<dd>Compare if Equal Packed signed QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPEQQ xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.WIG 29 /r 
</td></tr>
<tr><th>VPCMPEQQ ymm1, ymm2, ymm3 /m256
</th><td>VEX.NDS.256.66.0F38.WIG 29 /r 
</td></tr>
<tr><th>VPCMPEQQ k1 {k2}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F38.W1 29 /r 
</td></tr>
<tr><th>VPCMPEQQ k1 {k2}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F38.W1 29 /r 
</td></tr>
<tr><th>VPCMPEQQ k1 {k2}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F38.W1 29 /r 
</td></tr>
<tr><th>VPCMPEQQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1F /r 00 
</td></tr>
<tr><th>VPCMPEQQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1F /r 00 
</td></tr>
<tr><th>VPCMPEQQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1F /r 00 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x00</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
<a class="EXT" href="../eatests/t5797.htm">t5797</a>
</dd>
</dl><pre>
IiyVPCMPEQQ:: PROC
    MOV EBX,EDX
    MOV AL,0x1F
    MOV CL,0x00
    SHR EBX,16
    CMP BL,krg
    JNE .S:
    IiDispatchCode  SHORT=.S:, LONG=IiyVPCMPQ.cc:
 .S:IiEncoding CODE=SHORT,DATA=QWORD
    IiAllowModifier CODE
    IiAllowMaskMerging
    IiAllowBroadcasting QWORD
    IiEmitOpcode 0x29
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDisp8MVEX Si64
    IiDispatchFormat xmm.xmm.xmm,xmm.xmm.mem,ymm.ymm.ymm,ymm.ymm.mem, \
          krg.xmm.xmm,krg.xmm.mem,krg.ymm.ymm,krg.ymm.mem,krg.zmm.zmm,krg.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38.WIG
    RET
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W1
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W1 
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W1
    RET
 ENDP IiyVPCMPEQQ::
</pre>

<dl id="IiyVPCMPLTQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPLTQ</a></dt>
<dd>Compare if Less Than Packed signed QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLTQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1F /r 01 
</td></tr>
<tr><th>VPCMPLTQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1F /r 01 
</td></tr>
<tr><th>VPCMPLTQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1F /r 01 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x01</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPLTQ:: PROC
    MOV AL,0x1F
    MOV CL,0x01
    JMP IiyVPCMPQ.cc:
 ENDP IiyVPCMPLTQ::
</pre>

<dl id="IiyVPCMPLEQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPLEQ</a></dt>
<dd>Compare if Less than or Equal Packed signed QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLEQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1F /r 02 
</td></tr>
<tr><th>VPCMPLEQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1F /r 02 
</td></tr>
<tr><th>VPCMPLEQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1F /r 02 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x02</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPLEQ:: PROC
    MOV AL,0x1F
    MOV CL,0x02
    JMP IiyVPCMPQ.cc:
 ENDP IiyVPCMPLEQ::
</pre>

<dl id="IiyVPCMPFALSEQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPFALSEQ</a></dt>
<dd>Compare if False Packed signed QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPFALSEQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1F /r 03 
</td></tr>
<tr><th>VPCMPFALSEQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1F /r 03 
</td></tr>
<tr><th>VPCMPFALSEQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1F /r 03 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x03</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPFALSEQ:: PROC
    MOV AL,0x1F
    MOV CL,0x03
    JMP IiyVPCMPQ.cc:
 ENDP IiyVPCMPFALSEQ::
</pre>

<dl id="IiyVPCMPNEQQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPNEQQ</a></dt>
<dd>Compare if Not Equal Packed signed QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNEQQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1F /r 04 
</td></tr>
<tr><th>VPCMPNEQQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1F /r 04 
</td></tr>
<tr><th>VPCMPNEQQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1F /r 04 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x04</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNEQQ:: PROC
    MOV AL,0x1F
    MOV CL,0x04
    JMP IiyVPCMPQ.cc:
 ENDP IiyVPCMPNEQQ::
</pre>

<dl id="IiyVPCMPNLTQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPNLTQ</a></dt>
<dd>Compare if Not Less Than Packed signed QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLTQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1F /r 05 
</td></tr>
<tr><th>VPCMPNLTQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1F /r 05 
</td></tr>
<tr><th>VPCMPNLTQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1F /r 05 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x05</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNLTQ:: PROC
    MOV AL,0x1F
    MOV CL,0x05
    JMP IiyVPCMPQ.cc:
 ENDP IiyVPCMPNLTQ::
</pre>

<dl id="IiyVPCMPNLEQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPNLEQ</a></dt>
<dd>Compare if Not Less than or Equal Packed signed QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLEQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1F /r 06 
</td></tr>
<tr><th>VPCMPNLEQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1F /r 06 
</td></tr>
<tr><th>VPCMPNLEQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1F /r 06 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x06</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNLEQ:: PROC
    MOV AL,0x1F
    MOV CL,0x06
    JMP IiyVPCMPQ.cc:
 ENDP IiyVPCMPNLEQ::
</pre>

<dl id="IiyVPCMPTRUEQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPTRUEQ</a></dt>
<dd>Compare if True Packed signed QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPTRUEQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1F /r 07 
</td></tr>
<tr><th>VPCMPTRUEQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1F /r 07 
</td></tr>
<tr><th>VPCMPTRUEQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1F /r 07 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1F /r 0x07</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPTRUEQ:: PROC
    MOV AL,0x1F
    MOV CL,0x07
    JMP IiyVPCMPQ.cc:
 ENDP IiyVPCMPTRUEQ::
</pre>

<dl id="IiyVPCMPEQUQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPEQUQ</a></dt>
<dd>Compare if Equal Packed Unsigned QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPEQUQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1E /r 00
</td></tr>
<tr><th>VPCMPEQUQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1E /r 00 
</td></tr>
<tr><th>VPCMPEQUQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1E /r 00 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x00</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPEQUQ:: PROC
    MOV AL,0x1E
    MOV CL,0x00
    JMP IiyVPCMPQ.cc
 ENDP IiyVPCMPEQUQ::
</pre>

<dl id="IiyVPCMPLTUQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPLTUQ</a></dt>
<dd>Compare if Less Than Packed Unsigned QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLTUQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1E /r 01 
</td></tr>
<tr><th>VPCMPLTUQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1E /r 01 
</td></tr>
<tr><th>VPCMPLTUQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1E /r 01 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x01</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPLTUQ:: PROC
    MOV AL,0x1E
    MOV CL,0x01
    JMP IiyVPCMPQ.cc
 ENDP IiyVPCMPLTUQ::
</pre>

<dl id="IiyVPCMPLEUQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPLEUQ</a></dt>
<dd>Compare if Less than or Equal Packed Unsigned QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPLEUQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1E /r 02 
</td></tr>
<tr><th>VPCMPLEUQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1E /r 02 
</td></tr>
<tr><th>VPCMPLEUQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1E /r 02 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x02</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPLEUQ:: PROC
    MOV AL,0x1E
    MOV CL,0x02
    JMP IiyVPCMPQ.cc
 ENDP IiyVPCMPLEUQ::
</pre>

<dl id="IiyVPCMPFALSEUQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPFALSEUQ</a></dt>
<dd>Compare if False Packed Unsigned QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPFALSEUQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1E /r 03 
</td></tr>
<tr><th>VPCMPFALSEUQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1E /r 03 
</td></tr>
<tr><th>VPCMPFALSEUQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1E /r 03 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x03</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPFALSEUQ:: PROC
    MOV AL,0x1E
    MOV CL,0x03
    JMP IiyVPCMPQ.cc
 ENDP IiyVPCMPFALSEUQ::
</pre>

<dl id="IiyVPCMPNEQUQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPNEQUQ</a></dt>
<dd>Compare if Not Equal Packed Unsigned QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNEQUQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1E /r 04 
</td></tr>
<tr><th>VPCMPNEQUQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1E /r 04 
</td></tr>
<tr><th>VPCMPNEQUQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1E /r 04 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x04</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNEQUQ:: PROC
    MOV AL,0x1E
    MOV CL,0x04
    JMP IiyVPCMPQ.cc
 ENDP IiyVPCMPNEQUQ::
</pre>

<dl id="IiyVPCMPNLTUQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPNLTUQ</a></dt>
<dd>Compare if Not Less Than Packed Unsigned QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLTUQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1E /r 05 
</td></tr>
<tr><th>VPCMPNLTUQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1E /r 05 
</td></tr>
<tr><th>VPCMPNLTUQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1E /r 05 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x05</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNLTUQ:: PROC
    MOV AL,0x1E
    MOV CL,0x05
    JMP IiyVPCMPQ.cc
 ENDP IiyVPCMPNLTUQ::
</pre>

<dl id="IiyVPCMPNLEUQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPNLEUQ</a></dt>
<dd>Compare if Not Less than or Equal Packed Unsigned QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPNLEUQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1E /r 06 
</td></tr>
<tr><th>VPCMPNLEUQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1E /r 06 
</td></tr>
<tr><th>VPCMPNLEUQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1E /r 06 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x06</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPNLEUQ:: PROC
    MOV AL,0x1E
    MOV CL,0x06
    JMP IiyVPCMPQ.cc
 ENDP IiyVPCMPNLEUQ::
</pre>

<dl id="IiyVPCMPTRUEUQ">
<dt><a href="#IiyVPCMPQ">&uarr; VPCMPTRUEUQ</a></dt>
<dd>Compare if True Packed Unsigned QWORD values into mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPTRUEUQ k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F3A.W1 1E /r 07 
</td></tr>
<tr><th>VPCMPTRUEUQ k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F3A.W1 1E /r 07 
</td></tr>
<tr><th>VPCMPTRUEUQ k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F3A.W1 1E /r 07 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>1E /r 0x07</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5796.htm">t5796</a>
</dd>
</dl><pre>
IiyVPCMPTRUEUQ:: PROC
    MOV AL,0x1E
    MOV CL,0x07
    JMP IiyVPCMPQ.cc
 ENDP IiyVPCMPTRUEUQ::
</pre>

<dl id="IiyVPCMPGTB">
<dt><a href="#IiyHandlers">&uarr; VPCMPGTB</a></dt>
<dd>Compare Packed Signed Integers for Greater Than</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPGTB xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 64 /r 
</td></tr>
<tr><th>VPCMPGTB ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 64 /r 
</td></tr>
<tr><th>VPCMPGTB k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG 64 /r 
</td></tr>
<tr><th>VPCMPGTB k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG 64 /r 
</td></tr>
<tr><th>VPCMPGTB k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG 64 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,compar</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qd | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F64 /r | 0x660F64 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5798.htm">t5798</a>
</dd>
</dl><pre>
IiyVPCMPGTB:: PROC
    IiEncoding DATA=BYTE
    IiAllowMaskMerging
    IiEmitOpcode 0x64
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, krg.xmm.xmm, krg.xmm.mem, krg.ymm.ymm, krg.ymm.mem, krg.zmm.zmm, krg.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F.WIG
    RET
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F.WIG
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F.WIG
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.WIG
    RET
  ENDP IiyVPCMPGTB::
</pre>

<dl id="IiyVPCMPGTW">
<dt><a href="#IiyHandlers">&uarr; VPCMPGTW</a></dt>
<dd>Compare Packed Signed Integers for Greater Than</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPGTW xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 65 /r
</td></tr>
<tr><th>VPCMPGTW ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 65 /r 
</td></tr>
<tr><th>VPCMPGTW k1 {k2}, xmm2, xmm3/m128
</th><td>EVEX.NDS.128.66.0F.WIG 65 /r 
</td></tr>
<tr><th>VPCMPGTW k1 {k2}, ymm2, ymm3/m256
</th><td>EVEX.NDS.256.66.0F.WIG 65 /r 
</td></tr>
<tr><th>VPCMPGTW k1 {k2}, zmm2, zmm3/m512
</th><td>EVEX.NDS.512.66.0F.WIG 65 /r 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,compar</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qd | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F65 /r | 0x660F65 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5798.htm">t5798</a>
</dd>
</dl><pre>
IiyVPCMPGTW:: PROC
    IiEncoding DATA=WORD
    IiAllowMaskMerging
    IiEmitOpcode 0x65
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FVM
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, krg.xmm.xmm, krg.xmm.mem, krg.ymm.ymm, krg.ymm.mem, krg.zmm.zmm, krg.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F.WIG
    RET
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F.WIG
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F.WIG
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.WIG
    RET
  ENDP IiyVPCMPGTW::
</pre>

<dl id="IiyVPCMPGTD">
<dt><a href="#IiyHandlers">&uarr; VPCMPGTD</a></dt>
<dd>Compare Packed Signed Integers for Greater Than</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPGTD xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F.WIG 66 /r 
</td></tr>
<tr><th>VPCMPGTD ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F.WIG 66 /r 
</td></tr>
<tr><th>VPCMPGTD k1 {k2}, xmm2, xmm3/m128/m32bcst
</th><td>EVEX.NDS.128.66.0F.W0 66 /r 
</td></tr>
<tr><th>VPCMPGTD k1 {k2}, ymm2, ymm3/m256/m32bcst
</th><td>EVEX.NDS.256.66.0F.W0 66 /r 
</td></tr>
<tr><th>VPCMPGTD k1 {k2}, zmm2, zmm3/m512/m32bcst
</th><td>EVEX.NDS.512.66.0F.W0 66 /r 
</td></tr>
<tr><th>VPCMPGTD k2 {k1}, zmm1, zmm2/m512/m32bcst
</th><td>MVEX.NDS.512.66.0F.W0 66 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>mmx,compar</dd>
<dt>Operands</dt>
<dd><b>Pq</b>,Qd | <b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x0F66 /r | 0x660F66 /r</dd>
<dt>CPU</dt>
<dd>PX+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5798.htm">t5798</a>
</dd>
</dl><pre>
IiyVPCMPGTD:: PROC
    IiAllowMaskMerging
    IiAllowBroadcasting DWORD
    IiEmitOpcode 0x66
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDisp8MVEX Si32
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, krg.xmm.xmm, krg.xmm.mem, krg.ymm.ymm, krg.ymm.mem, krg.zmm.zmm, krg.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F.WIG
    RET
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F.W0
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F.W0
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F.W0, MVEX.NDS.512.66.0F.W0
    RET
  ENDP IiyVPCMPGTD::
</pre>

<dl id="IiyVPCMPGTQ">
<dt><a href="#IiyHandlers">&uarr; VPCMPGTQ</a></dt>
<dd>Compare Packed Qword Data for Greater Than</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCMPGTQ xmm1, xmm2, xmm3/m128
</th><td>VEX.NDS.128.66.0F38.WIG 37 /r 
</td></tr>
<tr><th>VPCMPGTQ ymm1, ymm2, ymm3/m256
</th><td>VEX.NDS.256.66.0F38.WIG 37 /r 
</td></tr>
<tr><th>VPCMPGTQ k1 {k2}, xmm2, xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F38.W1 37 /r 
</td></tr>
<tr><th>VPCMPGTQ k1 {k2}, ymm2, ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F38.W1 37 /r 
</td></tr>
<tr><th>VPCMPGTQ k1 {k2}, zmm2, zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F38.W1 37 /r
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse42,simdint,compar</dd>
<dt>Operands</dt>
<dd><b>Vdq</b>,Wdq</dd>
<dt>Opcode</dt>
<dd>0x660F3837 /r</dd>
<dt>CPU</dt>
<dd>C2++</dd>
<dt>Documented</dt>
<dd>D<a href="http://ref.x86asm.net/geek-abc.html#gen_note_SSE4_amd"><sup>43</sup></a></dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5798.htm">t5798</a>
</dd>
</dl><pre>
IiyVPCMPGTQ:: PROC
    IiAllowMaskMerging 
    IiAllowBroadcasting QWORD
    IiEmitOpcode 0x37
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, krg.xmm.xmm, krg.xmm.mem, krg.ymm.ymm, krg.ymm.mem, krg.zmm.zmm, krg.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix VEX.NDS.128.66.0F38.WIG
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix VEX.NDS.256.66.0F38.WIG
    RET
.krg.xmm.xmm:
.krg.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W1
    RET
.krg.ymm.ymm:
.krg.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W1
    RET
.krg.zmm.zmm:
.krg.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W1
    RET
  ENDP IiyVPCMPGTQ::
</pre>

<dl id="IiyVPMOVM2B">
<dt><a href="#IiyHandlers">&uarr; VPMOVM2B</a></dt>
<dd>Convert a Mask Register to a Vector  Register</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVM2B xmm1, k1  
</th><td>EVEX.128.F3.0F38.W0 28 /r  
</td></tr>
<tr><th>VPMOVM2B ymm1, k1  
</th><td>EVEX.256.F3.0F38.W0 28 /r  
</td></tr>
<tr><th>VPMOVM2B zmm1, k1
</th><td>EVEX.512.F3.0F38.W0 28 /r  
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x28</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5802.htm">t5802</a>
</dd>
</dl><pre>
IiyVPMOVM2B:: PROC
    IiEmitOpcode 0x28
.op:IiOpEn RM
    IiModRM /r
    IiDispatchFormat  xmm.krg, ymm.krg, zmm.krg
.xmm.krg:
    IiEmitPrefix EVEX.128.F3.0F38.W0
    RET
.ymm.krg:
    IiEmitPrefix EVEX.256.F3.0F38.W0
    RET
.zmm.krg:
    IiEmitPrefix EVEX.512.F3.0F38.W0
    RET
  ENDP IiyVPMOVM2B::
</pre>

<dl id="IiyVPMOVM2W">
<dt><a href="#IiyHandlers">&uarr; VPMOVM2W</a></dt>
<dd>Convert a Mask Register to a Vector  Register</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVM2W xmm1, k1  
</th><td>EVEX.128.F3.0F38.W1 28 /r  
</td></tr>
<tr><th>VPMOVM2W ymm1, k1  
</th><td>EVEX.256.F3.0F38.W1 28 /r  
</td></tr>
<tr><th>VPMOVM2W zmm1, k1
</th><td>EVEX.512.F3.0F38.W1 28 /r  
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x28</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5802.htm">t5802</a>
</dd>
</dl><pre>
IiyVPMOVM2W:: PROC
    IiEmitOpcode 0x28
.op:IiOpEn RM
    IiModRM /r
    IiDispatchFormat  xmm.krg, ymm.krg, zmm.krg
.xmm.krg:
    IiEmitPrefix EVEX.128.F3.0F38.W1
    RET
.ymm.krg:
    IiEmitPrefix EVEX.256.F3.0F38.W1
    RET
.zmm.krg:
    IiEmitPrefix EVEX.512.F3.0F38.W1
    RET
  ENDP IiyVPMOVM2W::
</pre>

<dl id="IiyVPMOVM2D">
<dt><a href="#IiyVPMOVM2B">&uarr; VPMOVM2D</a></dt>
<dd>Convert a Mask Register to a Vector  Register</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVM2D xmm1, k1  
</th><td>EVEX.128.F3.0F38.W0 38 /r  
</td></tr>
<tr><th>VPMOVM2D ymm1, k1  
</th><td>EVEX.256.F3.0F38.W0 38 /r  
</td></tr>
<tr><th>VPMOVM2D zmm1, k1
</th><td>EVEX.512.F3.0F38.W0 38 /r  
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x38</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5802.htm">t5802</a>
</dd>
</dl><pre>
IiyVPMOVM2D:: PROC
    IiEmitOpcode 0x38
    JMP IiyVPMOVM2B.op:
  ENDP IiyVPMOVM2D::
</pre>

<dl id="IiyVPMOVM2Q">
<dt><a href="#IiyVPMOVM2W">&uarr; VPMOVM2Q</a></dt>
<dd>Convert a Mask Register to a Vector  Register</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVM2Q xmm1, k1  
</th><td>EVEX.128.F3.0F38.W1 38 /r  
</td></tr>
<tr><th>VPMOVM2Q ymm1, k1  
</th><td>EVEX.256.F3.0F38.W1 38 /r  
</td></tr>
<tr><th>VPMOVM2Q zmm1, k1
</th><td>EVEX.512.F3.0F38.W1 38 /r  
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x38</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5802.htm">t5802</a>
</dd>
</dl><pre>
IiyVPMOVM2Q:: PROC
    IiEmitOpcode 0x38
    JMP IiyVPMOVM2W.op:
  ENDP IiyVPMOVM2Q::
</pre>

<dl id="IiyVPMOVB2M">
<dt><a href="#IiyHandlers">&uarr; VPMOVB2M</a></dt>
<dd>Convert a Vector Register to a Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVB2M k1, xmm1  
</th><td>EVEX.128.F3.0F38.W0 29 /r  
</td></tr>
<tr><th>VPMOVB2M k1, ymm1  
</th><td>EVEX.256.F3.0F38.W0 29 /r  
</td></tr>
<tr><th>VPMOVB2M k1, zmm1
</th><td>EVEX.512.F3.0F38.W0 29 /r  
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x29</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5804.htm">t5804</a>
</dd>
</dl><pre>
IiyVPMOVB2M:: PROC
    IiEmitOpcode 0x29
.op:IiOpEn RM
    IiModRM /r
    IiDispatchFormat  krg.xmm, krg.ymm, krg.zmm
.krg.xmm:
    IiEmitPrefix EVEX.128.F3.0F38.W0
    RET
.krg.ymm:
    IiEmitPrefix EVEX.256.F3.0F38.W0
    RET
.krg.zmm:
    IiEmitPrefix EVEX.512.F3.0F38.W0
    RET
  ENDP IiyVPMOVB2M::
</pre>

<dl id="IiyVPMOVW2M">
<dt><a href="#IiyHandlers">&uarr; VPMOVW2M</a></dt>
<dd>Convert a Vector Register to a Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVW2M k1, xmm1  
</th><td>EVEX.128.F3.0F38.W1 29 /r  
</td></tr>
<tr><th>VPMOVW2M k1, ymm1  
</th><td>EVEX.256.F3.0F38.W1 29 /r  
</td></tr>
<tr><th>VPMOVW2M k1, zmm1
</th><td>EVEX.512.F3.0F38.W1 29 /r  
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x29</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5804.htm">t5804</a>
</dd>
</dl><pre>
IiyVPMOVW2M:: PROC
    IiEmitOpcode 0x29
.op:IiOpEn RM
    IiModRM /r
    IiDispatchFormat  krg.xmm, krg.ymm, krg.zmm
.krg.xmm:
    IiEmitPrefix EVEX.128.F3.0F38.W1
    RET
.krg.ymm:
    IiEmitPrefix EVEX.256.F3.0F38.W1
    RET
.krg.zmm:
    IiEmitPrefix EVEX.512.F3.0F38.W1
    RET
  ENDP IiyVPMOVW2M::
</pre>

<dl id="IiyVPMOVD2M">
<dt><a href="#IiyVPMOVB2M">&uarr; VPMOVD2M</a></dt>
<dd>Convert a Vector Register to a Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVD2M k1, xmm1  
</th><td>EVEX.128.F3.0F38.W0 39 /r 
</td></tr>
<tr><th>VPMOVD2M k1, ymm1  
</th><td>EVEX.256.F3.0F38.W0 39 /r 
</td></tr>
<tr><th>VPMOVD2M k1, zmm1
</th><td>EVEX.512.F3.0F38.W0 39 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x39</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5804.htm">t5804</a>
</dd>
</dl><pre>
IiyVPMOVD2M:: PROC
    IiEmitOpcode 0x39
    JMP IiyVPMOVB2M.op:
  ENDP IiyVPMOVD2M::
</pre>

<dl id="IiyVPMOVQ2M">
<dt><a href="#IiyVPMOVW2M">&uarr; VPMOVQ2M</a></dt>
<dd>Convert a Vector Register to a Mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMOVQ2M k1, xmm1  
</th><td>EVEX.128.F3.0F38.W1 39 /r 
</td></tr>
<tr><th>VPMOVQ2M k1, ymm1  
</th><td>EVEX.256.F3.0F38.W1 39 /r 
</td></tr>
<tr><th>VPMOVQ2M k1, zmm1
</th><td>EVEX.512.F3.0F38.W1 39 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x39</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5804.htm">t5804</a>
</dd>
</dl><pre>
IiyVPMOVQ2M:: PROC
    IiEmitOpcode 0x39
    JMP IiyVPMOVW2M.op:
  ENDP IiyVPMOVQ2M::
</pre>

<dl id="IiyVPBROADCASTMW2D">
<dt><a href="#IiyVPMOVM2B">&uarr; VPBROADCASTMW2D</a></dt>
<dd>Broadcast Mask to Vector Register</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPBROADCASTMW2D xmm1, k1
</th><td>EVEX.128.F3.0F38.W0 3A /r
</td></tr>
<tr><th>VPBROADCASTMW2D ymm1, k1
</th><td>EVEX.256.F3.0F38.W0 3A /r
</td></tr>
<tr><th>VPBROADCASTMW2D zmm1, k1
</th><td>EVEX.512.F3.0F38.W0 3A /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x3A</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5806.htm">t5806</a>
</dd>
</dl><pre>
IiyVPBROADCASTMW2D:: PROC
    IiEmitOpcode 0x3A
    JMP IiyVPMOVM2B.op:
  ENDP IiyVPBROADCASTMW2D::
</pre>

<dl id="IiyVPBROADCASTMB2Q">
<dt><a href="#IiyVPMOVM2W">&uarr; VPBROADCASTMB2Q</a></dt>
<dd>Broadcast Mask to Vector Register</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPBROADCASTMB2Q xmm1, k1
</th><td>EVEX.128.F3.0F38.W1 2A /r
</td></tr>
<tr><th>VPBROADCASTMB2Q ymm1, k1
</th><td>EVEX.256.F3.0F38.W1 2A /r
</td></tr>
<tr><th>VPBROADCASTMB2Q zmm1, k1
</th><td>EVEX.512.F3.0F38.W1 2A /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x2A</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5806.htm">t5806</a>
</dd>
</dl><pre>
IiyVPBROADCASTMB2Q:: PROC
    IiEmitOpcode 0x2A
    JMP IiyVPMOVM2W.op:
  ENDP IiyVPBROADCASTMB2Q::
</pre>

<dl id="IiyVPCONFLICTD">
<dt><a href="#IiyHandlers">&uarr; VPCONFLICTD</a></dt>
<dd>Detect Conflicts Within a Vector of Packed Dword Values into Dense  Memory/ Register</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCONFLICTD xmm1 {k1}{z}, xmm2/m128/m32bcst
</th><td>EVEX.128.66.0F38.W0 C4 /r
</td></tr>
<tr><th>VPCONFLICTD ymm1 {k1}{z}, ymm2/m256/m32bcst
</th><td>EVEX.256.66.0F38.W0 C4 /r
</td></tr>
<tr><th>VPCONFLICTD zmm1 {k1}{z}, zmm2/m512/m32bcst
</th><td>EVEX.512.66.0F38.W0 C4 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xC4</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5806.htm">t5806</a>
</dd>
</dl><pre>
IiyVPCONFLICTD:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiEmitOpcode 0xC4
    IiOpEn RM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm, xmm.mem, ymm.ymm, ymm.mem, zmm.zmm, zmm.mem
.xmm.xmm:
.xmm.mem:
    IiEmitPrefix EVEX.128.66.0F38.W0
    RET
.ymm.ymm:
.ymm.mem:
    IiEmitPrefix EVEX.256.66.0F38.W0
    RET
.zmm.zmm:
.zmm.mem:
    IiEmitPrefix EVEX.512.66.0F38.W0
    RET
  ENDP IiyVPCONFLICTD::
</pre>

<dl id="IiyVPCONFLICTQ">
<dt><a href="#IiyHandlers">&uarr; VPCONFLICTQ</a></dt>
<dd>Detect Conflicts Within a Vector of Packed Qword Values into Dense  Memory/ Register</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPCONFLICTQ xmm1 {k1}{z}, xmm2/m128/m64bcst
</th><td>EVEX.128.66.0F38.W1 C4 /r
</td></tr>
<tr><th>VPCONFLICTQ ymm1 {k1}{z}, ymm2/m256/m64bcst
</th><td>EVEX.256.66.0F38.W1 C4 /r
</td></tr>
<tr><th>VPCONFLICTQ zmm1 {k1}{z}, zmm2/m512/m64bcst
</th><td>EVEX.512.66.0F38.W1 C4 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xC4</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5806.htm">t5806</a>
</dd>
</dl><pre>
IiyVPCONFLICTQ:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiEmitOpcode 0xC4
    IiOpEn RM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm, xmm.mem, ymm.ymm, ymm.mem, zmm.zmm, zmm.mem
.xmm.xmm:
.xmm.mem:
    IiEmitPrefix EVEX.128.66.0F38.W1
    RET
.ymm.ymm:
.ymm.mem:
    IiEmitPrefix EVEX.256.66.0F38.W1
    RET
.zmm.zmm:
.zmm.mem:
    IiEmitPrefix EVEX.512.66.0F38.W1
    RET
  ENDP IiyVPCONFLICTQ::
</pre>

<dl id="IiyVPMULTISHIFTQB">
<dt><a href="#IiyHandlers">&uarr; VPMULTISHIFTQB</a></dt>
<dd>Select Packed Unaligned Bytes from Quadword Sources</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMULTISHIFTQB xmm1 {k1}{z}, xmm2,xmm3/m128/m64bcst
</th><td>EVEX.NDS.128.66.0F38.W1 83 /r
</td></tr>
<tr><th>VPMULTISHIFTQB ymm1 {k1}{z}, ymm2,ymm3/m256/m64bcst
</th><td>EVEX.NDS.256.66.0F38.W1 83 /r
</td></tr>
<tr><th>VPMULTISHIFTQB zmm1 {k1}{z}, zmm2,zmm3/m512/m64bcst
</th><td>EVEX.NDS.512.66.0F38.W1 83 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x83</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5806.htm">t5806</a>
</dd>
</dl><pre>
IiyVPMULTISHIFTQB:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiEmitOpcode 0x83
    IiOpEn RVM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm.xmm, xmm.xmm.mem, ymm.ymm.ymm, ymm.ymm.mem, zmm.zmm.zmm, zmm.zmm.mem
.xmm.xmm.xmm:
.xmm.xmm.mem:
    IiEmitPrefix EVEX.NDS.128.66.0F38.W1
    RET
.ymm.ymm.ymm:
.ymm.ymm.mem:
    IiEmitPrefix EVEX.NDS.256.66.0F38.W1
    RET
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix EVEX.NDS.512.66.0F38.W1
    RET
  ENDP IiyVPMULTISHIFTQB::
</pre>

<dl id="IiyVLOADUNPACKLD">
<dt><a href="#IiyHandlers">&uarr; VLOADUNPACKLD</a></dt>
<dd>Load Unaligned Low And Unpack To Doubleword Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLOADUNPACKLD zmm1 {k1}, Ui32(mt)</th><td>MVEX.512.0F38.W0 D0 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD0</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6100.htm">t6100</a>
</dd>
</dl><pre>
IiyVLOADUNPACKLD:: PROC
    IiEmitOpcode 0xD0
.Di:IiDisp8MVEX Di32
.op:IiAllowMaskMerging
    IiOpEn RM
    IiModRM /r
    IiDispatchFormat  zmm.mem
.zmm.mem:
    IiEmitPrefix MVEX.512.0F38.W0
    RET
  ENDP IiyVLOADUNPACKLD::
</pre>

<dl id="IiyVLOADUNPACKLPS">
<dt><a href="#IiyVLOADUNPACKLD">&uarr; VLOADUNPACKLPS</a></dt>
<dd>Load Unaligned Low And Unpack To Float32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLOADUNPACKLPS zmm1 {k1}, Uf32(mt)</th><td>MVEX.512.0F38.W0 D1 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD1</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6100.htm">t6100</a>
</dd>
</dl><pre>
IiyVLOADUNPACKLPS:: PROC
    IiEmitOpcode 0xD1
    IiDisp8MVEX Df32
    JMP IiyVLOADUNPACKLD.op:
  ENDP IiyVLOADUNPACKLPS::
</pre>

<dl id="IiyVLOADUNPACKHD">
<dt><a href="#IiyVLOADUNPACKLD">&uarr; VLOADUNPACKHD</a></dt>
<dd>Load Unaligned High And Unpack To Doubleword Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLOADUNPACKHD zmm1 {k1}, Ui32(mt)</th><td>MVEX.512.0F38.W0 D4 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD4</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6102.htm">t6102</a>
</dd>
</dl><pre>
IiyVLOADUNPACKHD:: PROC
    IiEmitOpcode 0xD4
    JMP IiyVLOADUNPACKLD.Di:
  ENDP IiyVLOADUNPACKHD::
</pre>

<dl id="IiyVLOADUNPACKHPS">
<dt><a href="#IiyVLOADUNPACKLD">&uarr; VLOADUNPACKHPS</a></dt>
<dd>Load Unaligned High And Unpack To Float32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLOADUNPACKHPS zmm1 {k1}, Uf32(mt)</th><td>MVEX.512.0F38.W0 D5 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD5</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6102.htm">t6102</a>
</dd>
</dl><pre>
IiyVLOADUNPACKHPS:: PROC
    IiEmitOpcode 0xD5
    IiDisp8MVEX Df32
    JMP IiyVLOADUNPACKLD.op:
  ENDP IiyVLOADUNPACKHPS::
</pre>

<dl id="IiyVLOADUNPACKLQ">
<dt><a href="#IiyHandlers">&uarr; VLOADUNPACKLQ</a></dt>
<dd>Load Unaligned Low And Unpack To Int64 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLOADUNPACKLQ zmm1 {k1}, Ui64(mt)</th><td>MVEX.512.0F38.W1 D0 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD0</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6100.htm">t6100</a>
</dd>
</dl><pre>
IiyVLOADUNPACKLQ:: PROC
    IiEmitOpcode 0xD0
.op:IiDisp8MVEX Sn64
    IiAllowMaskMerging
    IiOpEn RM
    IiModRM /r
    IiDispatchFormat  zmm.mem
.zmm.mem:
    IiEmitPrefix MVEX.512.0F38.W1
    RET
  ENDP IiyVLOADUNPACKLQ::
</pre>

<dl id="IiyVLOADUNPACKLPD">
<dt><a href="#IiyVLOADUNPACKLQ">&uarr; VLOADUNPACKLPD</a></dt>
<dd>Load Unaligned Low And Unpack To Float64 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLOADUNPACKLPD zmm1 {k1}, Uf64(mt)</th><td>MVEX.512.0F38.W1 D1 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD1</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6100.htm">t6100</a>
</dd>
</dl><pre>
IiyVLOADUNPACKLPD:: PROC
    IiEmitOpcode 0xD1
    JMP IiyVLOADUNPACKLQ.op:
  ENDP IiyVLOADUNPACKLPD::
</pre>

<dl id="IiyVLOADUNPACKHQ">
<dt><a href="#IiyVLOADUNPACKLQ">&uarr; VLOADUNPACKHQ</a></dt>
<dd>Load Unaligned High And Unpack To Int64 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLOADUNPACKHQ zmm1 {k1}, Ui64(mt)</th><td>MVEX.512.0F38.W1 D4 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD4</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6102.htm">t6102</a>
</dd>
</dl><pre>
IiyVLOADUNPACKHQ:: PROC
    IiEmitOpcode 0xD4
    JMP IiyVLOADUNPACKLQ.op:
  ENDP IiyVLOADUNPACKHQ::
</pre>

<dl id="IiyVLOADUNPACKHPD">
<dt><a href="#IiyVLOADUNPACKLQ">&uarr; VLOADUNPACKHPD</a></dt>
<dd>Load Unaligned High And Unpack To Float64 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLOADUNPACKHPD zmm1 {k1}, Uf64(mt)</th><td>MVEX.512.0F38.W1 D5 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD5</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6102.htm">t6102</a>
</dd>
</dl><pre>
IiyVLOADUNPACKHPD:: PROC
    IiEmitOpcode 0xD5
    JMP IiyVLOADUNPACKLQ.op:
  ENDP IiyVLOADUNPACKHPD::
</pre>

<dl id="IiyVPACKSTORELD">
<dt><a href="#IiyHandlers">&uarr; VPACKSTORELD</a></dt>
<dd>Pack and Store Unaligned Low From Int32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKSTORELD mt {k1}, Di32(zmm1)</th><td>MVEX.512.66.0F38.W0 D0 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD0</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6104.htm">t6104</a>
</dd>
</dl><pre>
IiyVPACKSTORELD:: PROC
    IiEmitOpcode 0xD0
.Di:IiDisp8MVEX Di32    
.op:IiAllowMaskMerging
    IiOpEn MR
    IiModRM /r
    IiDispatchFormat  mem.zmm
.mem.zmm:
    IiEmitPrefix MVEX.512.66.0F38.W0
    RET
  ENDP IiyVPACKSTORELD::
</pre>

<dl id="IiyVPACKSTORELPS">
<dt><a href="#IiyVPACKSTORELD">&uarr; VPACKSTORELPS</a></dt>
<dd>Pack and Store Unaligned Low From Float32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKSTORELPS mt {k1}, Df32(zmm1)</th><td>MVEX.512.66.0F38.W0 D1 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD1</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6104.htm">t6104</a>
</dd>
</dl><pre>
IiyVPACKSTORELPS:: PROC
    IiEmitOpcode 0xD1
    IiDisp8MVEX Df32
    JMP IiyVPACKSTORELD.op:
  ENDP IiyVPACKSTORELPS::
</pre>

<dl id="IiyVPACKSTOREHD">
<dt><a href="#IiyVPACKSTORELD">&uarr; VPACKSTOREHD</a></dt>
<dd>Pack And Store Unaligned High From Int32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKSTOREHD mt {k1}, Di32(zmm1)</th><td>MVEX.512.66.0F38.W0 D4 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD4</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6106.htm">t6106</a>
</dd>
</dl><pre>
IiyVPACKSTOREHD:: PROC
    IiEmitOpcode 0xD4
    JMP IiyVPACKSTORELD.Di:
  ENDP IiyVPACKSTOREHD::
</pre>

<dl id="IiyVPACKSTOREHPS">
<dt><a href="#IiyVPACKSTORELD">&uarr; VPACKSTOREHPS</a></dt>
<dd>Pack And Store Unaligned High From Float32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKSTOREHPS mt {k1}, Df32(zmm1)</th><td>MVEX.512.66.0F38.W0 D5 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD5</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6106.htm">t6106</a>
</dd>
</dl><pre>
IiyVPACKSTOREHPS:: PROC
    IiEmitOpcode 0xD5
    IiDisp8MVEX Df32
    JMP IiyVPACKSTORELD.op:
  ENDP IiyVPACKSTOREHPS::
</pre>

<dl id="IiyVPACKSTORELQ">
<dt><a href="#IiyHandlers">&uarr; VPACKSTORELQ</a></dt>
<dd>Pack and Store Unaligned Low From Int64 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKSTORELQ mt {k1}, Di64(zmm1)</th><td>MVEX.512.66.0F38.W1 D0 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD0</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6104.htm">t6104</a>
</dd>
</dl><pre>
IiyVPACKSTORELQ:: PROC
    IiEmitOpcode 0xD0
.op:IiDisp8MVEX Sn64
    IiAllowMaskMerging
    IiOpEn MR
    IiModRM /r
    IiDispatchFormat  mem.zmm
.mem.zmm:
    IiEmitPrefix MVEX.512.66.0F38.W1
    RET
  ENDP IiyVPACKSTORELQ::
</pre>

<dl id="IiyVPACKSTORELPD">
<dt><a href="#IiyVPACKSTORELQ">&uarr; VPACKSTORELPD</a></dt>
<dd>Pack and Store Unaligned Low From Float64 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKSTORELPD mt {k1}, Df64(zmm1)</th><td>MVEX.512.66.0F38.W1 D1 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD1</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6104.htm">t6104</a>
</dd>
</dl><pre>
IiyVPACKSTORELPD:: PROC
    IiEmitOpcode 0xD1
    JMP IiyVPACKSTORELQ.op:
  ENDP IiyVPACKSTORELPD::
</pre>

<dl id="IiyVPACKSTOREHQ">
<dt><a href="#IiyVPACKSTORELQ">&uarr; VPACKSTOREHQ</a></dt>
<dd>Pack And Store Unaligned High From Int64 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKSTOREHQ mt {k1}, Di64(zmm1)</th><td>MVEX.512.66.0F38.W1 D4 /r
</td></tr>
</table></dd>
<dt>Operands</dt>
<dd>0xD4</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6106.htm">t6106</a>
</dd>
</dl><pre>
IiyVPACKSTOREHQ:: PROC
    IiEmitOpcode 0xD4
    JMP IiyVPACKSTORELQ.op:
  ENDP IiyVPACKSTOREHQ::
</pre>

<dl id="IiyVPACKSTOREHPD">
<dt><a href="#IiyVPACKSTORELQ">&uarr; VPACKSTOREHPD</a></dt>
<dd>Pack And Store Unaligned High From Float64 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPACKSTOREHPD mt {k1}, Df64(zmm1)</th><td>MVEX.512.66.0F38.W1 D5 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xD5</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6106.htm">t6106</a>
</dd>
</dl><pre>
IiyVPACKSTOREHPD:: PROC
    IiEmitOpcode 0xD5
    JMP IiyVPACKSTORELQ.op:
  ENDP IiyVPACKSTOREHPD::
</pre>

<dl id="IiyVCVTFXPNTUDQ2PS">
<dt><a href="#IiyHandlers">&uarr; VCVTFXPNTUDQ2PS</a></dt>
<dd>Convert Fixed Point Uint32 Vector to Float32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VCVTFXPNTUDQ2PS zmm1 {k1}, i32(zmm2/mt), imm8
</th><td>MVEX.512.0F3A.W0 CA /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCA</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6110.htm">t6110</a>
</dd>
</dl><pre>
IiyVCVTFXPNTUDQ2PS:: PROC
    IiEmitOpcode 0xCA
.op:IiAllowModifier MASK,SAE,EH
    IiOpEn RM
    IiModRM /r
    IiDisp8MVEX Si32
    IiEmitImm Operand3, BYTE, Max=127
    IiDispatchFormat  zmm.zmm.imm, zmm.mem.imm
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix MVEX.512.0F3A.W0
    RET
  ENDP IiyVCVTFXPNTUDQ2PS::
</pre>

<dl id="IiyVCVTFXPNTDQ2PS">
<dt><a href="#IiyVCVTFXPNTUDQ2PS">&uarr; VCVTFXPNTDQ2PS</a></dt>
<dd>Convert Fixed Point Int32 Vector to Float32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VCVTFXPNTDQ2PS zmm1 {k1}, S (zmm2/m ), imm8</th><td>MVEX.512.0F3A.W0 CB /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCB</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6110.htm">t6110</a>
</dd>
</dl><pre>
IiyVCVTFXPNTDQ2PS:: PROC
    IiEmitOpcode 0xCB
    JMP IiyVCVTFXPNTUDQ2PS.op:
  ENDP IiyVCVTFXPNTDQ2PS::
</pre>

<dl id="IiyVCVTFXPNTPS2UDQ">
<dt><a href="#IiyHandlers">&uarr; VCVTFXPNTPS2UDQ</a></dt>
<dd>Convert Float32 Vector to Fixed Point Uint32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VCVTFXPNTPS2UDQ zmm1 {k1}, Sf32(zmm2/mt), imm8
</th><td>MVEX.512.66.0F3A.W0 CA /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCA</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6110.htm">t6110</a>
</dd>
</dl><pre>
IiyVCVTFXPNTPS2UDQ:: PROC
    IiEmitOpcode 0xCA
.op:IiAllowModifier MASK,SAE,EH
    IiOpEn RM
    IiModRM /r
    IiDisp8MVEX Us32
    IiEmitImm Operand3, BYTE, Max=127
    IiDispatchFormat  zmm.zmm.imm, zmm.mem.imm
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix MVEX.512.66.0F3A.W0
    RET
  ENDP IiyVCVTFXPNTPS2UDQ::
</pre>

<dl id="IiyVCVTFXPNTPS2DQ">
<dt><a href="#IiyVCVTFXPNTPS2UDQ">&uarr; VCVTFXPNTPS2DQ</a></dt>
<dd>Convert Float32 Vector to Fixed Point Int32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VCVTFXPNTPS2DQ zmm1 {k1}, Sf32(zmm2/mt), imm8</th><td>MVEX.512.66.0F3A.W0 CB /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCB</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6110.htm">t6110</a>
</dd>
</dl><pre>
IiyVCVTFXPNTPS2DQ:: PROC
    IiEmitOpcode 0xCB
    JMP IiyVCVTFXPNTPS2UDQ.op:
  ENDP IiyVCVTFXPNTPS2DQ::
</pre>

<dl id="IiyVCVTFXPNTPD2UDQ">
<dt><a href="#IiyHandlers">&uarr; VCVTFXPNTPD2UDQ</a></dt>
<dd>Convert Float64 Vector to Fixed Point Uint32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VCVTFXPNTPD2UDQ zmm1 {k1}, Sf64(zmm2/mt), imm8
</th><td>MVEX.512.F2.0F3A.W1 CA /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCA</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6110.htm">t6110</a>
</dd>
</dl><pre>
IiyVCVTFXPNTPD2UDQ:: PROC
    IiEmitOpcode 0xCA
.op:IiAllowModifier MASK,SAE,EH
    IiOpEn RM
    IiModRM /r
    IiEmitImm Operand3, BYTE, Max=3
    IiDisp8MVEX Ub64
    IiDispatchFormat  zmm.zmm.imm, zmm.mem.imm
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix MVEX.512.F2.0F3A.W1
    RET
  ENDP IiyVCVTFXPNTPD2UDQ::
</pre>

<dl id="IiyVCVTFXPNTPD2DQ">
<dt><a href="#IiyVCVTFXPNTPD2UDQ">&uarr; VCVTFXPNTPD2DQ</a></dt>
<dd>Convert Float64 Vector to Fixed Point Int32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VCVTFXPNTPD2DQ zmm1 {k1}, Sf64(zmm2/mt), imm8
</th><td>MVEX.512.F2.0F3A.W1 E6 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xE6</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6110.htm">t6110</a>
</dd>
</dl><pre>
IiyVCVTFXPNTPD2DQ:: PROC
    IiEmitOpcode 0xE6
    JMP IiyVCVTFXPNTPD2UDQ.op:
  ENDP IiyVCVTFXPNTPD2DQ::
</pre>

<dl id="IiyVRNDFXPNTPS">
<dt><a href="#IiyHandlers">&uarr; VRNDFXPNTPS</a></dt>
<dd>Round Float32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRNDFXPNTPS zmm1 {k1}, Sf32(zmm2/mt), imm8</th><td>MVEX.512.66.0F3A.W0 52 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x52</dd>
</dl><pre>
IiyVRNDFXPNTPS:: PROC
    IiAllowMaskMerging
    IiEmitOpcode 0x52
    IiOpEn RM
    IiModRM /r
    IiEmitImm Operand3, BYTE
    IiDisp8MVEX Us32
    IiDispatchFormat  zmm.zmm.imm, zmm.mem.imm
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix MVEX.512.66.0F3A.W0
    RET
  ENDP IiyVRNDFXPNTPS::
</pre>

<dl id="IiyVRNDFXPNTPD">
<dt><a href="#IiyHandlers">&uarr; VRNDFXPNTPD</a></dt>
<dd>Round Float64 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRNDFXPNTPD zmm1 {k1}, Sf64(zmm2/mt), imm8
</th><td>MVEX.512.66.0F3A.W1 52 /r ib 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x52</dd>
</dl><pre>
IiyVRNDFXPNTPD:: PROC
    IiAllowMaskMerging
    IiEmitOpcode 0x52
    IiOpEn RM
    IiModRM /r
    IiEmitImm Operand3, BYTE
    IiDisp8MVEX Ub64
    IiDispatchFormat  zmm.zmm.imm, zmm.mem.imm
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix MVEX.512.66.0F3A.W1
    RET
  ENDP IiyVRNDFXPNTPD::
</pre>

<dl id="IiyVPERMF32X4">
<dt><a href="#IiyHandlers">&uarr; VPERMF32X4</a></dt>
<dd>Shuf&#61442;e Vector Dqwords</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPERMF32X4 zmm1 {k1}, zmm2/mt, imm8
</th><td>MVEX.512.66.0F3A.W0 07 /r ib
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x07</dd>
</dl><pre>
IiyVPERMF32X4:: PROC
    IiAllowMaskMerging
    IiEmitOpcode 0x07
    IiOpEn RM
    IiModRM /r
    IiEmitImm Operand3, BYTE
    IiDisp8MVEX Di64
    IiDispatchFormat  zmm.zmm.imm, zmm.mem.imm
.zmm.zmm.imm:
.zmm.mem.imm:
    IiEmitPrefix MVEX.512.66.0F3A.W0
    RET
  ENDP IiyVPERMF32X4::
</pre>

<dl id="IiyVPADCD">
<dt><a href="#IiyHandlers">&uarr; VPADCD</a></dt>
<dd>Add Int32 Vectors with Carry</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPADCD zmm1 {k1}, k2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 5C /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x5C</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6120.htm">t6120</a>
</dd>
</dl><pre>
IiyVPADCD:: PROC
    IiEmitOpcode 0x5C
.op:IiAllowMaskMerging
    IiOpEn RVM
    IiModRM /r
    IiDisp8MVEX Si32
    IiDispatchFormat  zmm.krg.zmm, zmm.krg.mem
.zmm.krg.zmm:
.zmm.krg.mem:
    IiEmitPrefix MVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPADCD::
</pre>

<dl id="IiyVPADDSETCD">
<dt><a href="#IiyVPADCD">&uarr; VPADDSETCD</a></dt>
<dd>Add Int32 Vectors and Set Mask to Carry</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPADDSETCD zmm1 {k1}, k2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 5D /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x5D</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6120.htm">t6120</a>
</dd>
</dl><pre>
IiyVPADDSETCD:: PROC
    IiEmitOpcode 0x5D
    JMP IiyVPADCD.op:
  ENDP IiyVPADDSETCD::
</pre>

<dl id="IiyVPSBBD">
<dt><a href="#IiyVPADCD">&uarr; VPSBBD</a></dt>
<dd>Subtract Int32 Vectors with Borrow</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPSBBD zmm1 {k1}, k2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 5E /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x5E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6120.htm">t6120</a>
</dd>
</dl><pre>
IiyVPSBBD:: PROC
    IiEmitOpcode 0x5E
    JMP IiyVPADCD.op:
  ENDP IiyVPSBBD::
</pre>

<dl id="IiyVPSUBRSETBD">
<dt><a href="#IiyVPADCD">&uarr; VPSUBRSETBD</a></dt>
<dd>Reverse Subtract Int32 Vectors and Set Borrow</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPSUBRSETBD zmm1 {k1}, k2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 6F /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x6F</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6120.htm">t6120</a>
</dd>
</dl><pre>
IiyVPSUBRSETBD:: PROC
    IiEmitOpcode 0x6F
    JMP IiyVPADCD.op:
  ENDP IiyVPSUBRSETBD::
</pre>

<dl id="IiyVPSUBSETBD">
<dt><a href="#IiyVPADCD">&uarr; VPSUBSETBD</a></dt>
<dd>Subtract Int32 Vectors and Set Borrow</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPSUBSETBD zmm1 {k1}, k2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 5F /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x5F</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6120.htm">t6120</a>
</dd>
</dl><pre>
IiyVPSUBSETBD:: PROC
    IiEmitOpcode 0x5F
    JMP IiyVPADCD.op:
  ENDP IiyVPSUBSETBD::
</pre>

<dl id="IiyVPSUBRD">
<dt><a href="#IiyHandlers">&uarr; VPSUBRD</a></dt>
<dd>Reverse Subtract Int32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPSUBRD zmm1 {k1}, zmm2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 6C /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x6C</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6122.htm">t6122</a>
</dd>
</dl><pre>
IiyVPSUBRD:: PROC
    IiEmitOpcode 0x6C
.op:IiAllowMaskMerging
    IiOpEn RVM
    IiModRM /r
    IiDisp8MVEX Si32
    IiDispatchFormat  zmm.zmm.zmm, zmm.zmm.mem
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix MVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPSUBRD::
</pre>

<dl id="IiyVPSBBRD">
<dt><a href="#IiyVPSUBRD">&uarr; VPSBBRD</a></dt>
<dd>Reverse Subtract Int32 Vectors with Borrow</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPSBBRD zmm1 {k1}, k2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 6E /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x6E</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6122.htm">t6122</a>
</dd>
</dl><pre>
IiyVPSBBRD:: PROC
    IiEmitOpcode 0x6E
    JMP IiyVPSUBRD.op:
  ENDP IiyVPSBBRD::
</pre>

<dl id="IiyVPMULHUD">
<dt><a href="#IiyVPSUBRD">&uarr; VPMULHUD</a></dt>
<dd>Multiply Uint32 Vectors And Store High Result</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMULHUD zmm1 {k1}, zmm2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 86 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x86</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6122.htm">t6122</a>
</dd>
</dl><pre>
IiyVPMULHUD:: PROC
    IiEmitOpcode 0x86
    JMP IiyVPSUBRD.op:
  ENDP IiyVPMULHUD::
</pre>

<dl id="IiyVPMULHD">
<dt><a href="#IiyVPSUBRD">&uarr; VPMULHD</a></dt>
<dd>Multiply Int32 Vectors And Store High Result</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMULHD zmm1 {k1}, zmm2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 87 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x87</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6122.htm">t6122</a>
</dd>
</dl><pre>
IiyVPMULHD:: PROC
    IiEmitOpcode 0x87
    JMP IiyVPSUBRD.op:
  ENDP IiyVPMULHD::
</pre>

<dl id="IiyVFIXUPNANPS">
<dt><a href="#IiyVPSUBRD">&uarr; VFIXUPNANPS</a></dt>
<dd>FixUp Special Float32 VectorNumbersWithNaNPassthrough</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VFIXUPNANPS zmm1 {k1}, zmm2, Si32(zmm3/mt)</th><td>MVEX.NDS.512.66.0F38.W0 55 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x55</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6122.htm">t6122</a>
</dd>
</dl><pre>
IiyVFIXUPNANPS:: PROC
    IiAllowSuppressing
    IiEmitOpcode 0x55
    JMP IiyVPSUBRD.op:
  ENDP IiyVFIXUPNANPS::
</pre>

<dl id="IiyVPMADD231D">
<dt><a href="#IiyVPSUBRD">&uarr; VPMADD231D</a></dt>
<dd>Multiply First Source By Second Source and Add To Destination Int32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMADD231D zmm1 {k1}, zmm2, Si32(zmm3/mt)</th><td>MVEX.NDS.512.66.0F38.W0 B5 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xB5</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6122.htm">t6122</a>
</dd>
</dl><pre>
IiyVPMADD231D:: PROC
    IiEmitOpcode 0xB5
    JMP IiyVPSUBRD.op:
  ENDP IiyVPMADD231D::
</pre>

<dl id="IiyVPMADD233D">
<dt><a href="#IiyHandlers">&uarr; VPMADD233D</a></dt>
<dd>Multiply First Source By Specially Swizzled Second Source and Add To Second Source Int32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPMADD233D zmm1 {k1}, zmm2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 B4 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xB4</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6124.htm">t6124</a>
</dd>
</dl><pre>
IiyVPMADD233D:: PROC
    IiAllowMaskMerging
    IiAllowNoSwizzle
    IiDisp8MVEX Sf32
    IiEmitOpcode 0xB4
    IiOpEn RVM
    IiModRM /r
    IiDispatchFormat  zmm.zmm.zmm, zmm.zmm.mem
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix MVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPMADD233D::
</pre>

<dl id="IiyVSCALEPS">
<dt><a href="#IiyHandlers">&uarr; VSCALEPS</a></dt>
<dd>Scale Float32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSCALEPS zmm1 {k1}, zmm2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 84 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x84</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5710.htm">t5710</a>
<a class="EXT" href="../eatests/t6128.htm">t6128</a>
</dd>
</dl><pre>
IiyVSCALEPS:: PROC
    IiEmitOpcode 0x84
    IiDisp8MVEX Si32
.op:IiAllowModifier MASK,EH,SAE
    IiAllowRounding
    IiOpEn RVM
    IiModRM /r
    IiDispatchFormat  zmm.zmm.zmm, zmm.zmm.mem
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix MVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVSCALEPS::
</pre>

<dl id="IiyVADDNPS">
<dt><a href="#IiyVSCALEPS">&uarr; VADDNPS</a></dt>
<dd>Add and Negate Float32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VADDNPS zmm1 {k1}, zmm2, Sf32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 50 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x50</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6128.htm">t6128</a>
</dd>
</dl><pre>
IiyVADDNPS:: PROC
    IiEmitOpcode 0x50
    IiDisp8MVEX Us32
    JMP IiyVSCALEPS.op:
  ENDP IiyVADDNPS::
</pre>

<dl id="IiyVADDNPD">
<dt><a href="#IiyVSCALEPS">&uarr; VADDNPD</a></dt>
<dd>Add and Negate Float64 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VADDNPD zmm1 {k1}, zmm2, Sf64(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W1 50 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x50</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6128.htm">t6128</a>
<a class="EXT" href="../eatests/t6130.htm">t6130</a>
</dd>
</dl><pre>
IiyVADDNPD:: PROC
    IiEmitOpcode 0x50
.op:IiDisp8MVEX Ub64
    IiAllowMaskMerging
    IiAllowSuppressing
    IiAllowRounding
    IiOpEn RVM
    IiModRM /r
    IiDispatchFormat  zmm.zmm.zmm, zmm.zmm.mem
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix MVEX.NDS.512.66.0F38.W1
    RET
  ENDP IiyVADDNPD::
</pre>

<dl id="IiyVSUBRPD">
<dt><a href="#IiyVADDNPD">&uarr; VSUBRPD</a></dt>
<dd>Reverse Subtract Float64 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSUBRPD zmm1 {k1}, zmm2, Sf64(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W1 6D /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x6D</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6130.htm">t6130</a>
</dd>
</dl><pre>
IiyVSUBRPD:: PROC
    IiEmitOpcode 0x6D
    JMP IiyVADDNPD.op:
  ENDP IiyVSUBRPD::
</pre>

<dl id="IiyVPADDSETSD">
<dt><a href="#IiyHandlers">&uarr; VPADDSETSD</a></dt>
<dd>Add Int32 Vectors and Set Mask to Sign</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPADDSETSD zmm1 {k1}, zmm2, Si32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 CD /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCD</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6122.htm">t6122</a>
</dd>
</dl><pre>
IiyVPADDSETSD:: PROC
    IiAllowMaskMerging
    IiEmitOpcode 0xCD
    IiOpEn RVM
    IiModRM /r
    IiDisp8MVEX Si32
    IiDispatchFormat  zmm.zmm.zmm, zmm.zmm.mem
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix MVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVPADDSETSD::
</pre>

<dl id="IiyVGMAXABSPS">
<dt><a href="#IiyHandlers">&uarr; VGMAXABSPS</a></dt>
<dd>Absolute Maximum of Float32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VGMAXABSPS zmm1 {k1}, zmm2, Sf32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 51 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x51</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6126.htm">t6126</a>
</dd>
</dl><pre>
IiyVGMAXABSPS:: PROC
    IiEmitOpcode 0x51
.op:IiAllowMaskMerging
    IiAllowSuppressing
    IiOpEn RVM
    IiModRM /r
    IiDisp8MVEX Us32
    IiDispatchFormat  zmm.zmm.zmm, zmm.zmm.mem
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix MVEX.NDS.512.66.0F38.W0
    RET
  ENDP IiyVGMAXABSPS::
</pre>

<dl id="IiyVGMINPS">
<dt><a href="#IiyVGMAXABSPS">&uarr; VGMINPS</a></dt>
<dd>Minimum of Float32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VGMINPS zmm1 {k1}, zmm2, Sf32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 52 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x52</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6126.htm">t6126</a>
</dd>
</dl><pre>
IiyVGMINPS:: PROC
    IiEmitOpcode 0x52
    JMP IiyVGMAXABSPS.op:
  ENDP IiyVGMINPS::
</pre>

<dl id="IiyVGMAXPS">
<dt><a href="#IiyVGMAXABSPS">&uarr; VGMAXPS</a></dt>
<dd>Maximum of Float32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VGMAXPS zmm1 {k1}, zmm2, Sf32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 53 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x53</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6126.htm">t6126</a>
</dd>
</dl><pre>
IiyVGMAXPS:: PROC
    IiEmitOpcode 0x53
    JMP IiyVGMAXABSPS.op:
  ENDP IiyVGMAXPS::
</pre>

<dl id="IiyVSUBRPS">
<dt><a href="#IiyVSCALEPS">&uarr; VSUBRPS</a></dt>
<dd>Reverse Subtract Float32 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VSUBRPS zmm1 {k1}, zmm2, Sf32(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 6D /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x6D</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6124.htm">t6124</a>
</dd>
</dl><pre>
IiyVSUBRPS:: PROC
    IiEmitOpcode 0x6D
    IiDisp8MVEX Us32
    JMP IiyVSCALEPS.op:
  ENDP IiyVSUBRPS::
</pre>

<dl id="IiyVADDSETSPS">
<dt><a href="#IiyVSCALEPS">&uarr; VADDSETSPS</a></dt>
<dd>Add Float32 Vectors and Set Mask to Sign</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VADDSETSPS zmm1 {k1}, zmm2, S (zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W0 CC /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCC</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6124.htm">t6124</a>
</dd>
</dl><pre>
IiyVADDSETSPS:: PROC
    IiEmitOpcode 0xCC
    IiDisp8MVEX Us32
    JMP IiyVSCALEPS.op:
  ENDP IiyVADDSETSPS::
</pre>

<dl id="IiyVGMINPD">
<dt><a href="#IiyHandlers">&uarr; VGMINPD</a></dt>
<dd>Minimum of Float64 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VGMINPD zmm1 {k1}, zmm2, Sf64(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W1 52 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x52</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6132.htm">t6132</a>
</dd>
</dl><pre>
IiyVGMINPD:: PROC
    IiEmitOpcode 0x52
.op:IiAllowMaskMerging
    IiAllowSuppressing
    IiOpEn RVM
    IiModRM /r
    IiDisp8MVEX Ub64
    IiDispatchFormat  zmm.zmm.zmm, zmm.zmm.mem
.zmm.zmm.zmm:
.zmm.zmm.mem:
    IiEmitPrefix MVEX.NDS.512.66.0F38.W1
    RET
  ENDP IiyVGMINPD::
</pre>

<dl id="IiyVGMAXPD">
<dt><a href="#IiyVGMINPD">&uarr; VGMAXPD</a></dt>
<dd>Maximum of Float64 Vectors</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VGMAXPD zmm1 {k1}, zmm2, Sf64(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W1 53 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x53</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6132.htm">t6132</a>
</dd>
</dl><pre>
IiyVGMAXPD:: PROC
    IiEmitOpcode 0x53
    JMP IiyVGMINPD.op:
  ENDP IiyVGMAXPD::
</pre>

<dl id="IiyVFIXUPNANPD">
<dt><a href="#IiyVGMINPD">&uarr; VFIXUPNANPD</a></dt>
<dd>FixUp Special Float64 Vector Numbers With NaN Passthrough</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VFIXUPNANPD zmm1 {k1}, zmm2, Si64(zmm3/mt)
</th><td>MVEX.NDS.512.66.0F38.W1 55 /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x55</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6132.htm">t6132</a>
</dd>
</dl><pre>
IiyVFIXUPNANPD:: PROC
    IiEmitOpcode 0x55
    JMP IiyVGMINPD.op:
  ENDP IiyVFIXUPNANPD::
</pre>

<dl id="IiyVLOG2PS">
<dt><a href="#IiyHandlers">&uarr; VLOG2PS</a></dt>
<dd>Vector Logarithm Base-2 of Float32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VLOG2PS zmm1 {k1}, zmm2/mt
</th><td>MVEX.512.66.0F38.W0 C9 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xC9</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6134.htm">t6134</a>
</dd>
</dl><pre>
IiyVLOG2PS:: PROC
    IiEmitOpcode 0xC9
.op:IiAllowMaskMerging
    IiAllowSuppressing Swizzle=No
    IiOpEn RM
    IiModRM /r
    IiDisp8MVEX Di64
    IiDispatchFormat  zmm.zmm, zmm.mem
.zmm.zmm:
.zmm.mem:
    IiEmitPrefix MVEX.512.66.0F38.W0
    RET
  ENDP IiyVLOG2PS::
</pre>

<dl id="IiyVEXP223PS">
<dt><a href="#IiyVLOG2PS">&uarr; VEXP223PS</a></dt>
<dd>Base-2 Exponential Calculation of Float32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VEXP223PS zmm1 {k1}, zmm2/mt
</th><td>MVEX.512.66.0F38.W0 C8 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xC8</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6134.htm">t6134</a>
</dd>
</dl><pre>
IiyVEXP223PS:: PROC
    IiEmitOpcode 0xC8
    JMP IiyVLOG2PS.op:
  ENDP IiyVEXP223PS::
</pre>

<dl id="IiyVRCP23PS">
<dt><a href="#IiyVLOG2PS">&uarr; VRCP23PS</a></dt>
<dd>Reciprocal of Float32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRCP23PS zmm1 {k1}, zmm2/mt
</th><td>MVEX.512.66.0F38.W0 CA /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCA</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6134.htm">t6134</a>
</dd>
</dl><pre>
IiyVRCP23PS:: PROC
    IiEmitOpcode 0xCA
    JMP IiyVLOG2PS.op:
  ENDP IiyVRCP23PS::
</pre>

<dl id="IiyVRSQRT23PS">
<dt><a href="#IiyVLOG2PS">&uarr; VRSQRT23PS</a></dt>
<dd>Vector Reciprocal Square Root of Float32 Vector</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VRSQRT23PS zmm1 {k1}, zmm2/mt
</th><td>MVEX.512.66.0F38.W0 CB /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xCB</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6134.htm">t6134</a>
</dd>
</dl><pre>
IiyVRSQRT23PS:: PROC
    IiEmitOpcode 0xCB
    JMP IiyVLOG2PS.op:
  ENDP IiyVRSQRT23PS::
</pre>

<dl id="IiyVPLZCNTD">
<dt><a href="#IiyHandlers">&uarr; VPLZCNTD</a></dt>
<dd>Count the Number of Leading Zero Bits for Packed Dword Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPLZCNTD xmm1 {k1}{z}, xmm2/m128/m32bcst
</th><td>EVEX.128.66.0F38.W0 44 /r
</td></tr>
<tr><th>VPLZCNTD ymm1 {k1}{z}, ymm2/m256/m32bcst
</th><td>EVEX.256.66.0F38.W0 44 /r
</td></tr>
<tr><th>VPLZCNTD zmm1 {k1}{z}, zmm2/m512/m32bcst
</th><td>EVEX.512.66.0F38.W0 44 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x44</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5726.htm">t5726</a>
</dd>
</dl><pre>
IiyVPLZCNTD:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting DWORD
    IiEmitOpcode 0x44
    IiOpEn RM
    IiModRM /r
    IiDisp8EVEX FV32
    IiDispatchFormat  xmm.xmm, xmm.mem, ymm.ymm, ymm.mem, zmm.zmm, zmm.mem
.xmm.xmm:
.xmm.mem:
    IiEmitPrefix EVEX.128.66.0F38.W0
    RET
.ymm.ymm:
.ymm.mem:
    IiEmitPrefix EVEX.256.66.0F38.W0
    RET
.zmm.zmm:
.zmm.mem:
    IiEmitPrefix EVEX.512.66.0F38.W0
    RET
  ENDP IiyVPLZCNTD::
</pre>

<dl id="IiyVPLZCNTQ">
<dt><a href="#IiyHandlers">&uarr; VPLZCNTQ</a></dt>
<dd>Count the Number of Leading Zero Bits for Packed Qword Values</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPLZCNTQ xmm1 {k1}{z}, xmm2/m128/m64bcst
</th><td>EVEX.128.66.0F38.W1 44 /r
</td></tr>
<tr><th>VPLZCNTQ ymm1 {k1}{z}, ymm2/m256/m64bcst
</th><td>EVEX.256.66.0F38.W1 44 /r
</td></tr>
<tr><th>VPLZCNTQ zmm1 {k1}{z}, zmm2/m512/m64bcst
</th><td>EVEX.512.66.0F38.W1 44 /r
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x44</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t5726.htm">t5726</a>
</dd>
</dl><pre>
IiyVPLZCNTQ:: PROC
    IiAllowModifier MASK
    IiAllowBroadcasting QWORD
    IiEmitOpcode 0x44
    IiOpEn RM
    IiModRM /r
    IiDisp8EVEX FV64
    IiDispatchFormat  xmm.xmm, xmm.mem, ymm.ymm, ymm.mem, zmm.zmm, zmm.mem
.xmm.xmm:
.xmm.mem:
    IiEmitPrefix EVEX.128.66.0F38.W1
    RET
.ymm.ymm:
.ymm.mem:
    IiEmitPrefix EVEX.256.66.0F38.W1
    RET
.zmm.zmm:
.zmm.mem:
    IiEmitPrefix EVEX.512.66.0F38.W1
    RET
  ENDP IiyVPLZCNTQ::
</pre>

<dl id="IiyVPREFETCHNTA">
<dt><a href="#IiyHandlers">&uarr; VPREFETCHNTA</a></dt>
<dd>Prefetch memory line using NTA hint</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPREFETCHNTA m8
</th><td>VEX.128.0F 18 /0 
</td></tr>
<tr><th>VPREFETCHNTA m8
</th><td>MVEX.512.0F 18 /0 
</td></tr>
</table></dd>
<dt>Category</dt>
<dd>sse1,fetch</dd>
<dt>Operands</dt>
<dd>Mb</dd>
<dt>Opcode</dt>
<dd>0x0F18 /0</dd>
<dt>CPU</dt>
<dd>P3+</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6242.htm">t6242</a>
</dd>
</dl><pre>
IiyVPREFETCHNTA:: PROC
    MOV EAX,iiPpgModRMd + 0<<28  ; >>
.rm:IiModRM EAX    
    IiRequire AVX512, MVEX
    IiEmitOpcode 0x18
    IiOpEn M
    IiDisp8MVEX Di64
    IiDispatchFormat  mem
.mem:
    IiEmitPrefix VEX.128.0F, MVEX.512.0F
    RET
  ENDP IiyVPREFETCHNTA::
</pre>

<dl id="IiyVPREFETCH0">
<dt><a href="#IiyVPREFETCHNTA">&uarr; VPREFETCH0</a></dt>
<dd>Prefetch memory line using T0 hint</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPREFETCH0 m8 
</th><td>VEX.128.0F 18 /1 
</td></tr>
<tr><th>VPREFETCH0 m8
</th><td>MVEX.512.0F 18 /1 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x18</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6240.htm">t6240</a>
</dd>
</dl><pre>
IiyVPREFETCH0:: PROC
    MOV EAX,iiPpgModRMd + 1<<28   ; >>
    JMP IiyVPREFETCHNTA.rm:
  ENDP IiyVPREFETCH0::
</pre>

<dl id="IiyVPREFETCH1">
<dt><a href="#IiyVPREFETCHNTA">&uarr; VPREFETCH1</a></dt>
<dd>Prefetch memory line using T1 hint</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPREFETCH1 m8
</th><td>VEX.128.0F 18 /2
</td></tr>
<tr><th>VPREFETCH1 m8
</th><td>MVEX.512.0F 18 /2
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x18</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6240.htm">t6240</a>
</dd>
</dl><pre>
IiyVPREFETCH1:: PROC
    MOV EAX,iiPpgModRMd + 2<<28  ; >>
    JMP IiyVPREFETCHNTA.rm:
  ENDP IiyVPREFETCH1::
</pre>

<dl id="IiyVPREFETCH2">
<dt><a href="#IiyVPREFETCHNTA">&uarr; VPREFETCH2</a></dt>
<dd>Prefetch memory line using T2 hint</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPREFETCH2 m8
</th><td>VEX.128.0F 18 /3
</td></tr>
<tr><th>VPREFETCH2 m8
</th><td>MVEX.512.0F 18 /3
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x18</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6240.htm">t6240</a>
</dd>
</dl><pre>
IiyVPREFETCH2:: PROC
    MOV EAX,iiPpgModRMd + 3<<28        ; >>
    JMP IiyVPREFETCHNTA.rm:
  ENDP IiyVPREFETCH2::
</pre>

<dl id="IiyVPREFETCHENTA">
<dt><a href="#IiyVPREFETCHNTA">&uarr; VPREFETCHENTA</a></dt>
<dd>Prefetch memory line using NTA hint, with intent to write</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPREFETCHENTA m8
</th><td>VEX.128.0F 18 /4 
</td></tr>
<tr><th>VPREFETCHENTA m8
</th><td>MVEX.512.0F 18 /4 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x18</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6242.htm">t6242</a>
</dd>
</dl><pre>
IiyVPREFETCHENTA:: PROC
    MOV EAX,iiPpgModRMd + 4<<28
    JMP IiyVPREFETCHNTA.rm:
  ENDP IiyVPREFETCHENTA::
</pre>

<dl id="IiyVPREFETCHE0">
<dt><a href="#IiyVPREFETCHNTA">&uarr; VPREFETCHE0</a></dt>
<dd>Prefetch memory line using T0 hint, with intent to write</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPREFETCHE0 m8 
</th><td>VEX.128.0F 18 /5 
</td></tr>
<tr><th>VPREFETCHE0 m8
</th><td>MVEX.512.0F 18 /5 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x18</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6240.htm">t6240</a>
</dd>
</dl><pre>
IiyVPREFETCHE0:: PROC
    MOV EAX,iiPpgModRMd + 5<<28
    JMP IiyVPREFETCHNTA.rm:
  ENDP IiyVPREFETCHE0::
</pre>

<dl id="IiyVPREFETCHE1">
<dt><a href="#IiyVPREFETCHNTA">&uarr; VPREFETCHE1</a></dt>
<dd>Prefetch memory line using T1 hint, with intent to write</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPREFETCHE1 m8
</th><td>VEX.128.0F 18 /6 
</td></tr>
<tr><th>VPREFETCHE1 m8
</th><td>MVEX.512.0F 18 /6 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x18</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6240.htm">t6240</a>
</dd>
</dl><pre>
IiyVPREFETCHE1:: PROC
    MOV EAX,iiPpgModRMd + 6<<28
    JMP IiyVPREFETCHNTA.rm:
  ENDP IiyVPREFETCHE1::
</pre>

<dl id="IiyVPREFETCHE2">
<dt><a href="#IiyVPREFETCHNTA">&uarr; VPREFETCHE2</a></dt>
<dd>Prefetch memory line using T2 hint, with intent to write</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>VPREFETCHE2 m8 
</th><td>VEX.128.0F 18 /7 
</td></tr>
<tr><th>VPREFETCHE2 m8
</th><td>MVEX.512.0F 18 /7 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0x18</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6240.htm">t6240</a>
</dd>
</dl><pre>
IiyVPREFETCHE2:: PROC
    MOV EAX,iiPpgModRMd + 7<<28
    JMP IiyVPREFETCHNTA.rm:
  ENDP IiyVPREFETCHE2::
</pre>

<dl id="IiyCLEVICT0">
<dt><a href="#IiyHandlers">&uarr; CLEVICT0</a></dt>
<dd>Evict L1 line</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>CLEVICT0 m8 
</th><td>VEX.128.F2.0F AE /7 
</td></tr>
<tr><th>CLEVICT0 m8
</th><td>MVEX.512.F2.0F AE /7 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xAE</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6242.htm">t6242</a>
</dd>
</dl><pre>
IiyCLEVICT0:: PROC
    IiEmitPrefix VEX.128.F2.0F, MVEX.512.F2.0F
.pf:IiOpEn M
    IiModRM /7
    IiEmitOpcode 0xAE
    IiDisp8MVEX Di64
    IiDispatchFormat  mem
.mem:RET
  ENDP IiyCLEVICT0::
</pre>

<dl id="IiyCLEVICT1">
<dt><a href="#IiyCLEVICT0">&uarr; CLEVICT1</a></dt>
<dd>Evict L2 line</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>CLEVICT1 m8 
</th><td>VEX.128.F3.0F AE /7 
</td></tr>
<tr><th>CLEVICT1 m8
</th><td>MVEX.512.F3.0F AE /7 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xAE</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6242.htm">t6242</a>
</dd>
</dl><pre>
IiyCLEVICT1:: PROC
    IiEmitPrefix VEX.128.F3.0F, MVEX.512.F3.0F
    JMP IiyCLEVICT0.pf:
  ENDP IiyCLEVICT1::
</pre>

<dl id="IiyDELAY">
<dt><a href="#IiyHandlers">&uarr; DELAY</a></dt>
<dd>Stall Thread</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>DELAY r32 
</th><td>VEX.128.F3.0F.W0 AE /6 
</td></tr>
<tr><th>DELAY r64</th><td>VEX.128.F3.0F.W1 AE /6 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xAE</dd>
</dl><pre>
IiyDELAY:: PROC
     IiRequire AVX512, MVEX
     IiOpEn M
     IiModRM /6
     IiEmitOpcode 0xAE
     IiDispatchFormat  r32, r64
.r32:IiEmitPrefix VEX.128.F3.0F.W0
     RET
.r64:IiEmitPrefix VEX.128.F3.0F.W1
     RET
  ENDP IiyDELAY::
</pre>

<dl id="IiySPFLT">
<dt><a href="#IiyHandlers">&uarr; SPFLT</a></dt>
<dd>Set performance monitor filtering mask</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>SPFLT r32 
</th><td>VEX.128.F2.0F.W0 AE /6 
</td></tr>
<tr><th>SPFLT r64</th><td>VEX.128.F2.0F.W1 AE /6 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xAE</dd>
</dl><pre>
IiySPFLT:: PROC
     IiRequire AVX512, MVEX
     IiOpEn M
     IiEmitOpcode 0xAE
     IiModRM /6
     IiDispatchFormat  r32, r64
.r32:IiEmitPrefix VEX.128.F2.0F.W0
     RET
.r64:IiEmitPrefix VEX.128.F2.0F.W1
     RET
  ENDP IiySPFLT::
</pre>

<dl id="IiyTZCNTI">
<dt><a href="#IiyHandlers">&uarr; TZCNTI</a></dt>
<dd>Initialized Trailing Zero Count</dd>
<dt>Intel reference</dt>
<dd><table>
<tr><th>TZCNTI r32, r32 
</th><td>VEX.128.F2.0F.W0 BC /r 
</td></tr>
<tr><th>TZCNTI r64, r64
</th><td>VEX.128.F2.0F.W1 BC /r 
</td></tr>
</table></dd>
<dt>Opcode</dt>
<dd>0xBC</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t6246.htm">t6246</a>
</dd>
</dl><pre>
IiyTZCNTI:: PROC
   IiRequire AVX512, MVEX
    IiOpEn RM
    IiEmitOpcode 0xBC
    IiModRM /r
    IiDispatchFormat  r32.r32, r64.r64
.r32.r32:
    IiEmitPrefix VEX.128.F2.0F.W0
    RET
.r64.r64:
    IiEmitPrefix VEX.128.F2.0F.W1
    RET
  ENDP IiyTZCNTI::
</pre>

<!--IiyEpilogue--><pre>
  ENDPROGRAM iiy
</pre><!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
