<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='pfrsrc.htm source file'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>pfrsrc.htm source file</title>
</head>
<body class='EASOURCE' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>pfrsrc.htm
<br/><i>Structures</i>
<br/><a href="#PFRSRC_DATA_ENTRY">PFRSRC_DATA_ENTRY</a>
<br/><a href="#PFRSRC_GRPICONDIR">PFRSRC_GRPICONDIR</a>
<br/><a href="#PFRSRC_GRPICONDIRENTRY">PFRSRC_GRPICONDIRENTRY</a>
<br/><a href="#PFRSRC_ICONDIR">PFRSRC_ICONDIR</a>
<br/><a href="#PFRSRC_ICONDIRENTRY">PFRSRC_ICONDIRENTRY</a>
<br/><a href="#PFRSRC_RES_HEADER">PFRSRC_RES_HEADER</a>
<br/><a href="#PFRSRC_RES_RECORD">PFRSRC_RES_RECORD</a>
<br/><a href="#PFRSRC_RESOURCE_DIRECTORY">PFRSRC_RESOURCE_DIRECTORY</a>
<br/><a href="#PFRSRC_RESOURCE_ENTRY">PFRSRC_RESOURCE_ENTRY</a>
<br/><i>Encodings</i>
<br/><a href="#PfrsrcEncoding">PfrsrcEncoding</a>
<br/><i>Procedures</i>
<br/><a href="#PfrsrcCompile">PfrsrcCompile</a>
<br/><a href="#PfrsrcLoadIconFile">PfrsrcLoadIconFile</a>
<br/><a href="#PfrsrcLoadPgm">PfrsrcLoadPgm</a>
<br/><a href="#PfrsrcStoreRecord">PfrsrcStoreRecord</a>
<br/><a href="#PfrsrcStoreUstring">PfrsrcStoreUstring</a>
</h1>
<p>This source PFRSRC is able to load compiled resource file and convert it
<!---->to a special segment [.rsrc], which will be linked to output executable PE or DLL format.
</p>
<br class="CLEAR"/>
<pre>
       EUROASM NOWARN=2101
pfrsrc PROGRAM FORMAT=COFF,MODEL=FLAT,WIDTH=32
       INCLUDEHEAD1 euroasm.htm, \  Interface (structures, symbols and macros) of other modules used in this source.
                   ea.htm,eaopt.htm,exp.htm,msg.htm,pf.htm,pgm.htm,pgmopt.htm,reloc.htm,sss.htm
</pre><pre>
 pfrsrc HEAD ; Start module interface.
</pre>

<dl id="PFRSRC_RES_HEADER"><dt><a href="#top">&uarr; PFRSRC_RES_HEADER</a></dt>
<dd>Linkable compiled resource file, usually with extension <q>.res</q>, consists of raw resource data chunks, each preceeded by resource header.
<!---->Resource has three main properties encoded as unsigned 16bit integer number: <strong>type, name</strong> and
<strong>language</strong>.
<br/>There are two kinds of resource types: user-defined and standard (defined by Microsoft).
<!---->Name and user-defined type may be alternatively identified by string name rather than by 16bit number.
<br/><dfn>Resource header</dfn> is used by compiled resource file. This structure has in fact variable size, unless actual ResTypeLength=ResNameLength=2.
<br/>When the first WORD in <code>.ResType</code> is 0xFFFF, ResTypeLength is 2 and the second word
<!---->specifies resource type identifier (standard or custom numeric id). Otherwise it is a zero-terminated Unichar string.
<br/>When the first WORD in <code>.ResName</code> is 0xFFFF, ResNameLength is 2 and the second word
<!---->specifies resource name identifier (numeric id). Otherwise it is a zero-terminated Unichar string.
<br/>When the offset following <code>.ResName</code> member is not DWORD aligned, one padding zero-word must be added.
</dd></dl><pre>
ResTypeLength    EQU 2
ResNameLength    EQU 2

PFRSRC_RES_HEADER STRUC
.DataSize        D DWORD ; Size of raw data which immediately follow this header.
.HeaderSize      D DWORD ; Size of this header.
.ResType         D ResTypeLength * UNICHAR
.ResName         D ResNameLength * UNICHAR
.DataVersion     D DWORD ; Version of following raw data, should be 0.
.MemoryFlags     D WORD  ; Resource status, see <a href="#PfrsrcEncoding">PfrsrcEncoding</a>.
.LanguageID      D WORD  ; Language and sublanguage which strings are written in.
.Version         D DWORD ; Version of the resource editor.
.Characteristics D DWORD ; Flags specified by resource editor.
 ENDSTRUC PFRSRC_RES_HEADER ; Size=20h=32 or more when strings are used.
</pre>

<dl id="PFRSRC_RES_RECORD"><dt><a href="#top">&uarr; PFRSRC_RES_RECORD</a></dt>
<dd>This is an internal &euro;ASM structure derived from <a href="#PFRSRC_RES_HEADER">PFRSRC_RES_HEADER
</a> used for construction of resource tree.
<br/>Interpretation of members <code>.Type</code> and <code>.Name</code> depends
<!---->on their most significant bit. Offsets are relative to the start of segment <code>[.rsrc]</code>.
</dd></dl><pre>
PFRSRC_RES_RECORD STRUC
.Type    D D ; MSbit=0: Offset of pascal unicode string identifier of resource type.
             ; MSbit=1: Value of numeric identifier of resource type in the lower word.
.Name    D D ; MSbit=0: Offset of pascal unicode string identifier of resource name.
             ; MSbit=1: Value of numeric identifier of resource name in the lower word.
.Lang    D D ; Value of the language and sublanguage identifier in the lower word.
.Data    D D ; Pointer to <a href="#PFRSRC_RES_HEADER">PFRSRC_RES_HEADER</a> which defines raw resource data following the header.
               ; Following offsets are used for building the tree.
.TypeDir D D ; Offset of <a href="#PFRSRC_RESOURCE_DIRECTORY">PFRSRC_RESOURCE_DIRECTORY</a> which specifies resource type.
.NameDir D D ; Offset of <a href="#PFRSRC_RESOURCE_DIRECTORY">PFRSRC_RESOURCE_DIRECTORY</a> which specifies resource name.
.LangDir D D ; Offset of <a href="#PFRSRC_RESOURCE_DIRECTORY">PFRSRC_RESOURCE_DIRECTORY</a> which specifies resource language.
.DataDir D D ; Offset of <a href="#PFRSRC_DATA_ENTRY">PFRSRC_DATA_ENTRY</a> which specifies resource raw data.
  ENDSTRUC PFRSRC_RES_RECORD ; Size=20h=32.
</pre>

<dl id="PFRSRC_RESOURCE_DIRECTORY"><dt><a href="#top">&uarr; PFRSRC_RESOURCE_DIRECTORY</a></dt>
<dd><dfn>Resource Directory</dfn> is a 16byte structure used in <code>[.rsrc]</code> section in executable file.
<br/>It belongs to the resource tree.</dd></dl><pre>
PFRSRC_RESOURCE_DIRECTORY STRUC
.Characteristics      D D ; Reserved.
.TimeDateStamp        D D ; Time of resource creation. Number of seconds since midnight 1.1.1970
.MajorVersion         D W ; Resource version.
.MinorVersion         D W
.NumberOfNamedEntries D W ; How many  string-identified PFRSRC_RESOURCE_ENTRY objects follow the directory.
.NumberOfIdEntries    D W ; How many numeric-identified PFRSRC_RESOURCE_ENTRY objects follow the directory.
 ENDSTRUC PFRSRC_RESOURCE_DIRECTORY ; Size=10h=16.
</pre>

<dl id="PFRSRC_RESOURCE_ENTRY"><dt><a href="#top">&uarr; PFRSRC_RESOURCE_ENTRY</a></dt>
<dd><dfn>Resource Entry</dfn> is a 8byte structure used in <code>[.rsrc]</code> section in executable file.
<br/>Theese entries belong to the resource tree where they immediately follow
<a href="#PFRSRC_RESOURCE_DIRECTORY">PFRSRC_RESOURCE_DIRECTORY</a>.
<br/>Their most significant bit selects their interpretation.
<br/>Offsets are related to the beginning of <code>[.rsrc]</code> section.
</dd></dl><pre>
PFRSRC_RESOURCE_ENTRY STRUC
.IdOrName  D D ; MSbit=0: Resource numeric identifier in lower word.
               ; MSbit=1: Offset of UNICHAR Pascal-string carrying the typename or resource name.
.DataOrDir D D ; MSbit=0: Offset of PFRSRC_DATA_ENTRY, i.e. the final tree leaf describing the raw data.
               ; MSbit=1: Offset of another PFRSRC_RESOURCE_DIRECTORY (one level lower).
  ENDSTRUC PFRSRC_RESOURCE_ENTRY ; Size=8.
</pre>

<dl id="PFRSRC_DATA_ENTRY"><dt><a href="#top">&uarr; PFRSRC_DATA_ENTRY</a></dt>
<dd><dfn>Data Entry</dfn> describes one unit of raw resource data, e.g. bitmap or menu.
<br/>It belongs to the resource tree.</dd></dl><pre>
PFRSRC_DATA_ENTRY STRUC
.OffsetToData D D ; RVA of the raw data unit.
.Size         D D ; Numer of bytes in the raw data unit.
.CodePage     D D ; Encoding of characters in the raw data unit.
.Reserved     D D ; 0.
  ENDSTRUC PFRSRC_DATA_ENTRY ; Size=10h=16.
</pre>

<dl id="PFRSRC_ICONDIR"><dt><a href="#top">&uarr; PFRSRC_ICONDIR</a></dt>
<dd>MS Windows ICO files begin with this 6bytes icon directory, which is followed by
<code>.idCount</code> <a href="#PFRSRC_ICONDIRENTRY">icon entries</a> and then followed with
<code>.idCount</code> image raw data (bitmaps).</dd>
<dt>See also</dt><dd><a class="EXTW" href="https://en.wikipedia.org/wiki/ICO_%28file_format%29">ICO file format</a> and
<a class="EXTW" href="https://blogs.msdn.microsoft.com/oldnewthing/20101018-00/?p=12513/">The format of icon resources</a></dd>
</dl><pre>
PFRSRC_ICONDIR STRUC
.idReserved D W ; Always 0.
.idType     D W ; 1=icon image (*.ico). 2=cursor image (*.cur).
.idCount    D W ; Number of icon images in this file.
  ENDSTRUC PFRSRC_ICONDIR ; Size=6.
</pre>

<dl id="PFRSRC_ICONDIRENTRY"><dt><a href="#top">&uarr; PFRSRC_ICONDIRENTRY</a></dt>
<dd>Icon entry which describes property of icon image built in *.ico file.
<br/><code>.bColorCount = 1 &lt;&lt; (.wBitCount * .wPlanes)</code>
<br/><code>.bColorCount = 0</code> when <code>(.wBitCount * wPlanes)&gt;= 8</code>.</dd>
<dt>See also</dt><dd><a href="#PFRSRC_ICONDIR">PFRSRC_ICONDIR</a></dd>
</dl><pre>
PFRSRC_ICONDIRENTRY STRUC
.bWidth        D B ; Image width  in pixels. 0 when 256px or more.
.bHeight       D B ; Image height in pixels. 0 when 256px or more.
.bColorCount   D B ; Number of colors in palette, see above.
.bReserved     D B ; 0.
.wPlanes       D W ; Number of color planes (0 or 1).
.wBitCount     D W ; Number of bits per pixel.
.dwBytesInRes  D D ; Size of icon raw data.
.dwImageOffset D D ; File address of raw data from the beginning of the file.
  ENDSTRUC PFRSRC_ICONDIRENTRY ; Size=16=10h.
</pre>

<dl id="PFRSRC_GRPICONDIR"><dt><a href="#top">&uarr; PFRSRC_GRPICONDIR</a></dt>
<dd>Resource raw data of type <code>pfrsrcGROUP_ICON</code> in RES files and PE executables.
<br/>Identical with <a href="#PFRSRC_ICONDIR">PFRSRC_ICONDIR</a>.
<!---->It is followed with .idCount of
<code>.idCount</code> <a href="#PFRSRC_GRPICONDIRENTRY">group-icon direntries</a>. </dd>
<dt>See also</dt><dd>
<a href="#PFRSRC_ICONDIR">PFRSRC_ICONDIR</a>,
<a class="EXTW" href="https://en.wikipedia.org/wiki/ICO_%28file_format%29">ICO file format</a> and
<a class="EXTW" href="https://blogs.msdn.microsoft.com/oldnewthing/20120720-00/?p=7083">The format of icon resources</a></dd>
</dl><pre>
PFRSRC_GRPICONDIR STRUC
.idReserved D W ; Always 0.
.idType     D W ; 1=icon image (*.ico). 2=cursor image (*.cur).
.idCount    D W ; Number of GRPICONDIRENTRY objects in this resource object.
  ENDSTRUC PFRSRC_GRPICONDIR ; Size=6.
</pre>

<dl id="PFRSRC_GRPICONDIRENTRY"><dt><a href="#top">&uarr; PFRSRC_GRPICONDIRENTRY</a></dt>
<dd>Resource raw dataIcon  of type <code>pfrsrcGROUP_ICON</code> in PE executables.
<br/>Similar to <a href="#PFRSRC_ICONDIRENTRY">PFRSRC_ICONDIRENTRY</a> but the last member.</dd>
<dt>See also</dt><dd><a href="#PFRSRC_GRPICONDIR">PFRSRC_GRPICONDIR</a></dd>
</dl><pre>
PFRSRC_GRPICONDIRENTRY STRUC
.bWidth       D B ; Image width  in pixels. 0 when 256px or more.
.bHeight      D B ; Image height in pixels. 0 when 256px or more.
.bColorCount  D B ; Number of colors in palette. 0 when palette is not used.
.bReserved    D B ; 0.
.wPlanes      D W ; Number of color planes (0 or 1).
.wBitCount    D W ; Number of bits per pixel.
.dwBytesInRes D D ; Size of icon raw data.
.nId          D W ; Numeric name identifier of this icon variant.
  ENDSTRUC PFRSRC_GRPICONDIRENTRY ; Size=14=0Eh.
</pre>

<dl id="PfrsrcEncoding"><dt><a href="#top">&uarr; PfrsrcEncoding</a></dt>
<dd>Encoding of memory status used in <a href="#PFRSRC_RES_HEADER">PFRSRC_RES_HEADER</a>
<!---->and standard resource type identifiers.</dd></dl><pre>
; Memory flags:
pfrsrcResMOVABLE     = 0x0010 ; Loader may move the resource in memory.
pfrsrcResPURE        = 0x0020 ; Resource contain DWORD-aligned data, no alignment needed.
pfrsrcResPRELOAD     = 0x0040 ; Resource must be loaded in memory on load time.
pfrsrcResDISCARDABLE = 0x1000 ; Resource may be removed and reloaded on demand.

; Standard resource type numeric identifiers:
pfrsrcCURSOR        =  0x0001
pfrsrcBITMAP        =  0x0002
pfrsrcICON          =  0x0003
pfrsrcMENU          =  0x0004
pfrsrcDIALOG        =  0x0005
pfrsrcSTRING        =  0x0006
pfrsrcFONTDIR       =  0x0007
pfrsrcFONT          =  0x0008
pfrsrcACCELERATOR   =  0x0009
pfrsrcRCDATA        =  0x000A
pfrsrcMESSAGETABLE  =  0x000B
pfrsrcGROUP_CURSOR  =  0x000C
pfrsrcGROUP_ICON    =  0x000E
pfrsrcVERSION       =  0x0010
</pre>
<pre>
 ENDHEAD pfrsrc  ; End of module interface.
</pre>

<dl id="PfrsrcCompile">
<dt><a href="#top">&uarr; PfrsrcCompile</a> OutputStream, Pgm</dt>
<dd><dfn>PfrsrcCompile</dfn> is a dummy procedure because EuroAssembler
<!---->does not compile resource files.
<dt>Input</dt>
<dd><b>OutputStream</b> is pointer to a
<a class="EXT" href="../maclib/memory32.htm#STREAM">STREAM</a> for the output file contents.
<br/><b>Pgm</b> is pointer to <a class="EXT" href="pgm.htm#PGM">PGM</a> representing completely assembled program.</dd>
<dt>Output</dt>
<dd>-</dd>
<dt>Error</dt>
<dd>DB '7827 EuroAssembler does not compile format RSRC, use resource compiler instead.</dd>
<dt>Invoked from</dt>
<dd><a class="EXT" href="pf.htm#PfOutput">PfOutput</a></dd>
</dl><pre>
PfrsrcCompile  Procedure OutputStream, Pgm
   Msg '7827' ; EuroAssembler does not compile to format RSRC, use resource compiler instead.
  EndProcedure PfrsrcCompile
</pre>

<dl id="PfrsrcStoreUstring">
<dt><a href="#top">&uarr; PfrsrcStoreUstring</a> StringPtr, StringEnd, StringNameBuffer</dt>
<dd><dfn>PfrsrcStoreUstring</dfn> will convert input zero-terminated Unichar string
<!---->to Pascal Unichar string and compare it with all strings already stored
<!---->in StringNameBuffer. If it wasn't there, the string will be stored to the buffer.
<!---->In both cases the procedure returns offset of the string relative to the bottom of StringNameBuffer.</dd>
<dt>Input</dt>
<dd><b>StringPtr</b> is pointer to the zero terminated Unichar string.
<dd><b>StringEnd</b> is pointer to the end of memory area where it is allowed to search for terminator 0.
<br/><b>StringNameBuffer</b> is pointer to <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> reserved by caller, where the converted string will be stored, if it wasn't stored before.
<!---->This pointer may be 0 when the resource file is verified only rather than loaded.</dd>
<dt>Output</dt>
<dd><b>CF=0, EAX=</b> offset of the Pascal Unichar string in the buffer.
<br/><b>ESI=</b> pointer behind the input String.</dd>
<dt>Error</dt>
<dd><b>CF=1, EAX=0</b>
<br/><b>ESI=</b>StringEnd when the terminating zero is missing.</dd>
<dt>Invoked by</dt>
<dd><a href="#PfrsrcStoreRecord">PfrsrcStoreRecord</a>
</dd>
</dl><pre>
PfrsrcStoreUstring Procedure StringPtr, StringEnd, StringNameBuffer
    XOR EAX,EAX
    MOV EDI,[%StringPtr]
    MOV ECX,[%StringEnd]
    MOV [%ReturnEAX],EAX
    SUB ECX,EDI
    MOV ESI,EDI
    REPNE SCASW
    MOV [%ReturnESI],EDI
    STC
    JNE .90:                                     ; Return with error if terminator missing.
    SUB EDI,ESI ; Brutto string size.
    SAR EDI,1
    LEA EDX,[EDI-1]                              ; EDX is now netto string length in Unichars.
    CMP EDX,0x0000_FFFE
    CMC
    JC .90:                                      ; Error - string is too long.
    MOV ECX,[%StringNameBuffer]
    TEST ECX
    JZ .90:
    BufferRetrieve ECX                           ; ESI is now pointer to older Pascal Unichar string on buffer. Length=[ESI].
    LEA EBX,[ESI+ECX]                            ; EBX points now to the end of buffer data.
.20:MOV [%ReturnEAX],ESI                         ; Assume that it might be found.
    MOV EDI,[%StringPtr]                         ; EDI is now pointer to the new string. Length=EDX.
    CMP ESI,EBX
    JNB .40:                                     ; If the string EDI,EDX was not found on buffer.
    LODSW                                        ; AX is now the old string length.
    CMP EAX,EDX
    JNE .30:                                     ; Skip to the next string when lengths are different.
    MOV ECX,EDX
    REPE CMPSW
    JNE .30:
    BufferRetrieve [%StringNameBuffer]           ; The same string was found at [%ReturnEAX].
    SUB [%ReturnEAX],ESI                         ; Return buffer offset instead of pointer.
    JMP .90:
.30:MOV ESI,[%ReturnEAX]
    LODSW
    ADD ESI,EAX
    ADD ESI,EAX                                  ; ESI now points to the next string on buffer.
    JMP .20:
.40:MOV EBX,[%StringNameBuffer]
    BufferRetrieve EBX
    MOV [%ReturnEAX],ECX
    BufferStoreWord EBX,EDX
    SAL EDX,1
    BufferStore EBX,EDI,EDX
.90:EndProcedure PfrsrcStoreUstring
</pre>

<dl id="PfrsrcStoreRecord">
<dt><a href="#top">&uarr; PfrsrcStoreRecord</a> ResPtr, ResEnd, MinPtr, MaxEnd, RecBuffer, StrNameBuffer</dt>
<dd><dfn>PfrsrcStoreRecord</dfn> will convert information about one resource item specified by
<a href="#PFRSRC_RES_HEADER">PFRSRC_RES_HEADER</a> to a form of <a href="#PFRSRC_RES_RECORD">PFRSRC_RES_RECORD
</a> and store the record to RecBuffer. String identifiers of resource type and name is
<!---->converted from C-style to Pascal-style and stored to StrNameBuffer only if the same string
<!---->was not already stored.
<br>Empty resource items (PFRSRC_RES_HEADER.DataSize=0) are not stored.
<br>Both buffers may be NULL if this procedure is used only to verify validity of resource file.</dd>
<dt>Input</dt>
<dd><b>ResPtr</b> is pointer to <a href="#PFRSRC_RES_HEADER">PFRSRC_RES_HEADER
</a> header in resource file mapped in memory. When it is not DWORD aligned, the header will be read from the nearest dword.
<br><b>ResEnd</b> is pointer to the end of resource file.
<br><b>MinPtr</b> is minimal value of ResPtr.
<br><b>MaxEnd</b> is maximal value of the end of resource file.
<br><b>RecBuffer</b> is pointer to <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> reserved by caller, where the converted record will be stored. It may be 0 if the file is verified only.
<br><b>StrNameBuffer</b> is pointer to <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER
</a> reserved by caller, where the Pascal Unicode strings will be stored. It may be 0 if the file is verified only.</dd>
<dt>Output</dt>
<dd><b>CF=0, ZF=0, EAX</b>=pointer to the next header. One record <a class="#PFRSRC_RES_RECORD">PFRSRC_RES_RECORD</a> was written to RecBuffer.
<br><b>CF=0, ZF=1, EAX=</b>ResPtr when ResPtr pointed to the end of file. Nothing stored to RecBuffer.</dd>
<dt>Error</dt>
<dd><b>CF=1, EAX=</b>ResPtr if the resource file <q>.res</q> has invalid structure.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pf.htm#PfDetect">PfDetect</a>
<a href="#PfrsrcLoadPgm">PfrsrcLoadPgm</a>
</dd>
<dt>Invokes</dt>
<dd><a href="#PfrsrcStoreUstring">PfrsrcStoreUstring</a>
</dd>
</dl><pre>
PfrsrcStoreRecord Procedure ResPtr, ResEnd, MinPtr, MaxEnd, RecBuffer, StrNameBuffer
ResRecord LocalVar Size=SIZE# PFRSRC_RES_RECORD  ; Room for the record before it is stored to buffer.
    MOV ESI,[%ResPtr]
    CMP ESI,[%MinPtr]
    JC .90:
    MOV EAX,[%MaxEnd]
    CMP EAX,[%ResEnd]
    JC .90:
    LEA EBX,[%ResRecord]
    MOV [%ReturnEAX],ESI                         ; Preinitialize returned EAX for the case of error or end of file.
    CMP ESI,[%ResEnd]
    JE .90:                                      ; If EOF.
    ADD ESI,3
    AND ESI,-4                                   ; DWORD alignment.
    MOV [%ReturnEAX],ESI                         ; Preinitialize returned aligned EAX for the case of error or end of file.
    CMP ESI,[%ResEnd]
    JE .90:                                      ; If EOF.
    LEA EAX,[ESI+SIZE#PFRSRC_RES_HEADER]
    CMP [%ResEnd],EAX
    JC .90:                                      ; When the file is too short.
    ; <b>Record raw data</b>.
    MOV [EBX+PFRSRC_RES_RECORD.Data],ESI
    ; <b>Record type</b>.
    ADD ESI,8
    LODSD
    MOV ECX,EAX
    SHR EAX,16
    BTS EAX,31                                   ; Set MSbit.
    INC CX
    JZ .20:                                      ; Record type started with CX=0xFFFF.
    SUB ESI,4
    Invoke PfrsrcStoreUstring,ESI,[%ResEnd],[%StrNameBuffer]
    JC .90:
.20:MOV [EBX+PFRSRC_RES_RECORD.Type],EAX
    ; <b>Record name</b>.
    LODSD
    MOV ECX,EAX
    SHR EAX,16
    BTS EAX,31                                   ; Set MSbit.
    INC CX
    JZ .40:                                      ; Record name started with CX=0xFFFF.
    SUB ESI,4
    Invoke PfrsrcStoreUstring,ESI,[%ResEnd],[%StrNameBuffer]
    JC .90:
.40:MOV [EBX+PFRSRC_RES_RECORD.Name],EAX
    ADD ESI,3                                    ; ESI may be DWORD misaligned.
    AND ESI,-4
    ADD ESI,6                                    ; Skip .DataVersion and .MemoryFlags.
    ; <b>Record language</b>. MSbit is not set, though it is never identified by a string.
    MOVZXW EAX,[ESI]
    MOV [EBX+PFRSRC_RES_RECORD.Lang],EAX
    ; <b>Tree entries</b>.
    LEA EDI,[EBX+PFRSRC_RES_RECORD.TypeDir]
    XOR EAX,EAX
    STOSD
    STOSD
    STOSD
    STOSD
    MOV ESI,[%ReturnEAX]                         ; Aligned ResPtr.
    MOV ECX,[ESI+PFRSRC_RES_HEADER.DataSize]
    JECXZ .80:                                   ; Skip the whole record if raw data size is empty.
    MOV ECX,[%RecBuffer]
    JECXZ .80:                                   ; Skip if no buffer is provided.
    ; <b>Store the record</b> EBX to buffer ECX.
    BufferStore ECX,EBX,SIZE#PFRSRC_RES_RECORD
.80:; Return <b>pointer to the next header</b> in EAX.
    MOV ECX,[ESI+PFRSRC_RES_HEADER.DataSize]
    ADD ESI,[ESI+PFRSRC_RES_HEADER.HeaderSize]
    ADD ESI,ECX                                  ; End of raw data is pointer to the next header.
    MOV [%ReturnEAX],ESI                         ; It may be unaligned.
.90:EndProcedure PfrsrcStoreRecord
</pre>

<dl id="PfrsrcLoadPgm">
<dt><a href="#top">&uarr; PfrsrcLoadPgm</a> BasePgm, ObjBegin, ObjSize, FileNamePtr</dt>
<dd><dfn>PfrsrcLoadPgm</dfn> converts compiled resources to a format accepted
<!---->by MS Windows in resource section of PE image.
<!---->Segment contents has three divisions:
<ol><li>binary tree which consists of resource directories, resource entries, data entries,</li>
<li>string names, if used instead of numeric identificators,</li>
<li>raw data of all resources.</li>
</ol> Converted data and relocations are stored to .EmitBuffer and .RelocBuffer
<!---->of the new segment <code>[.rsrc]</code>, with <code>PURPOSE=RESOURCE
</code>, which will be appended to other segments of the BasePgm.
<!---->When segment with this name already exists in BasePgm and when its Status is
<code>sssImplicit</code>, its old contents (which was specified by program option ICONFILE=) will be overwritten.
<br/>Pointer to resources will be also stored to
<code><a class="EXT" href="pfpe.htm#PFPE_OPTIONAL_HEADER32">PFPE_OPTIONAL_HEADER32</a>.DataDirectory</code> or
<code><a class="EXT" href="pfpe.htm#PFPE_OPTIONAL_HEADER64">PFPE_OPTIONAL_HEADER64</a>.DataDirectory</code>.
<br/>The input compiled resource file (usualy with extension <q>.res</q>) is assumed to be formally verified by
<a class="EXT" href="pf.htm#PfDetect">PfDetect</a>.</dd>
<dt>Input</dt>
<dd><b>BasePgm</b> is pointer to an existing <a class="EXT" href="pgm.htm#PGM">PGM
</a> which the resources are linked to.
<br/><b>ObjBegin</b> is pointer to the contents of linked file mapped in memory by the caller.
<br/><b>ObjSize</b> is number of bytes in the file.
<br/><b>FileNamePtr</b> is pointer to zero-terminated file name (used in error reports).</dd>
<dt>Output</dt>
<dd>New segment <code>[.rsrc]</code> with <code>PURPOSE=RESOURCE</code> is created and put on <code>%BaseProgram.SssList</code>.</dd>
<dt>Error</dt>
<dd>Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invoked from</dt>
<dd><a class="EXT" href="pf.htm#PfLoad">PfLoad</a></dd>
<dt>Invoked by</dt>
<dd><a href="#PfrsrcLoadIconFile">PfrsrcLoadIconFile</a>
</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferAlign">EaBufferAlign</a>
<a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a href="#PfrsrcStoreRecord">PfrsrcStoreRecord</a>
<a class="EXT" href="sss.htm#SssCreateSe">SssCreateSe</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t9385.htm">t9385</a>
<a class="EXT" href="../eatests/t9436.htm">t9436</a>
<a class="EXT" href="../eatests/t9485.htm">t9485</a>
<a class="EXT" href="../eatests/t9536.htm">t9536</a>
</dd>
</dl><pre>
PfrsrcLoadPgm Procedure BasePgm, ObjBegin, ObjSize, FileNamePtr
ObjEnd        LocalVar ; End of input data in memory.
TypeCnt       LocalVar ; Number of Type entries (tree level 1).
NameCnt       LocalVar ; Number of Name entries (tree level 2).
LangCnt       LocalVar ; Number of Lang entries (tree level 3).
ResRecordBuf  LocalVar ; Pointer to <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> which keeps <a href="#PFRSRC_RES_RECORD">PFRSRC_RES_RECORD</a>.
ResRecord     LocalVar Size=SIZE# PFRSRC_RES_RECORD ; Room for temporary resource record.
TreeBuf       LocalVar ; Pointer to <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> which keeps <a href="#PFRSRC_RESOURCE_DIRECTORY">PFRSRC_RESOURCE_DIRECTORY</a> and <a href="#PFRSRC_RESOURCE_ENTRY">PFRSRC_RESOURCE_ENTRY</a>.
TreeBottom    LocalVar ; Pointer to the start of tree in TreeBuf.
TreePtr       LocalVar ; Pointer to current <a href="#PFRSRC_RESOURCE_DIRECTORY">PFRSRC_RESOURCE_DIRECTORY</a> inside %TreeBuf.
TreeSize      LocalVar ; Size of the binary tree division. Naturally QWORD aligned.
DataEntryBuf  LocalVar ; Pointer to <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> which keeps <a href="#PFRSRC_DATA_ENTRY">PFRSRC_DATA_ENTRY</a>.
DataEntryPtr  LocalVar ; Pointer to the current <a href="#PFRSRC_DATA_ENTRY">PFRSRC_DATA_ENTRY</a> inside %DataEntryBuf.
DataEntrySize LocalVar ; Size of the entire <a href="#PFRSRC_DATA_ENTRY">PFRSRC_DATA_ENTRY</a> division. Naturally QWORD aligned.
StrNameBuf    LocalVar ; Pointer to <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> which keeps Pascal UNICHAR string.
StrNamePtr    LocalVar ; Pointer to the current free Pascal Unichar string inside StrNameBuf.
StrNameSize   LocalVar ; Size of Pascal Unichar strings. Naturally WORD aligned, at the end stuffed to DWORD.
RawDataOffset LocalVar ; Offset of current raw data in output section.
DirLevel2Ptr LocalVar  ; Pointer to first resource directory inside tree which specifies resource name.
DirLevel3Ptr LocalVar  ; Pointer to first resource directory inside tree which specifies resource language.
DirLevel4Ptr LocalVar  ; Pointer to first data entry inside tree which specifies resource data.
    ClearLocalVar
    Invoke EaBufferReserve::,PfrsrcLoadPgm
    MOV [%ResRecordBuf],EAX
    MOV EBX,EAX
    Invoke EaBufferReserve::,PfrsrcLoadPgm
    MOV [%TreeBuf],EAX
    Invoke EaBufferReserve::,PfrsrcLoadPgm
    MOV [%StrNameBuf],EAX
    MOV EDI,EAX
    Invoke EaBufferReserve::,PfrsrcLoadPgm
    MOV [%DataEntryBuf],EAX
    MOV EAX,[%ObjBegin]
    MOV ECX,[%ObjSize]
    LEA EDX,[EAX+ECX]
    MOV [%ObjEnd],EDX
    ; <b>Resource file will be indexed</b> into temporary array of <a href="#PFRSRC_RES_RECORD">PFRSRC_RES_RECORD</a>s and sorted.
.05:MOV ECX,[%ObjSize]
    ADD ECX,[%ObjBegin]
    Invoke PfrsrcStoreRecord,EAX,EDX,[%ObjBegin],ECX,EBX,EDI
    JC .90:
    JNZ .05:                                     ; Store the next resource record.
    BufferRetrieve EBX                           ; ESI,ECX now contains resource headers converted to RecRecords. They will be sorted by type, name, language.
    SAR ECX,5                                    ; SIZE# PFRSRC_RES_RECORD = 2<sup>5</sup>.
    JZ .90:                                      ; If no resource were present in the file.
    ShellSort ESI,ECX,SIZE#PFRSRC_RES_RECORD,.CmpRecords
    Invoke EaBufferAlign::,EDI,4                 ; Strings in StrNameBuf might have been unaligned.
.10:; ESI now points to ECX sorted records PFRSRC_RES_RECORD, one for each resource.
    ; This array will be passed several times to create the tree.
    ; <b>Pass 1: examine size of the three-level binary tree</b>.
    LEA EDI,[%ResRecord]                         ; This room will be used as a memory of previous values.
    CALL .ResetPrev:
.12:PUSH ESI,EDI
     CMPSD                                       ; Has the Type changed?
    POP EDI,ESI
    JE .14:
    INCD [%TypeCnt]
.14:PUSH ESI,EDI
      CMPSD
      JNE .16:
      CMPSD                                     ; Has the Type or Name changed?
.16:POP EDI,ESI
    JE .18:
    INCD [%NameCnt]
.18:INCD [%LangCnt]                             ; LangCnt is identical with total RecRecord count,
                                                ;   even when two resources have the same .Type, .Name, .Lang.
.19:MOVSD
    MOVSD                                       ; Copy the current record ESI to be used as the previous ResRecord.
    SUB EDI,8
    ADD ESI,SIZE#PFRSRC_RES_RECORD - 8
    DEC ECX
    JNZ .12:                                    ; The next sorted record.
    MOV ECX,[%TypeCnt]                          ; Number of PFRSRC_RESOURCE_ENTRY = %TypeCnt + %NameCnt + %LangCnt.
    ADD ECX,[%NameCnt]
    ADD ECX,[%LangCnt]
    SAL ECX,3                                   ; Each entry takes 8 bytes.
    MOV EDX,[%TypeCnt]                          ; Number of PFRSRC_RESOURCE_DIRECTORY = %TypeCnt + %NameCnt +1.
    ADD EDX,[%NameCnt]
    INC EDX
    SAL EDX,4                                   ; Each directory takes 16 bytes.
    ADD ECX,EDX
    MOV EDX,[%LangCnt]                          ; Number of PFRSRC_DATA_ENTRY = %LangCnt.
    SAL EDX,4                                   ; Each data entry takes 16 bytes.
    ADD ECX,EDX
    MOV [%TreeSize],ECX
    BufferNew [%TreeBuf],ECX                    ; Reserve space for the tree.
    MOV [%TreeBottom],EAX
    MOV [%TreePtr],EAX
    MOV EDI,EAX
    SHR ECX,2
    XOR EAX,EAX
    REP STOSD                                   ; Clear the entire binary tree division.
    BufferRetrieve [%StrNameBuf]                ; ECX is now dword aligned total size of string division.
    ADD ECX,[%TreeSize]                         ; Add the size of tree division.
    MOV [%RawDataOffset],ECX

    ; <b>Pass 2: invert MSbit and relocate offsets in StrNameBuf by [%TreeSize]</b>.
    BufferRetrieve [%ResRecordBuf]
    MOV EDI,[%TreeSize]
    MOV EDX,SIZE#PFRSRC_RES_RECORD
    MOV EBX,0x8000_0000                         ; Inverted MSbit.
.21:MOV EAX,[ESI+PFRSRC_RES_RECORD.Type]        ; Loop .21: .. .29: through all records.
    XOR EAX,EBX                                 ; Invert MSbit of .Type.
    TEST EAX                                    ; It's a string if MSbit=1.
    JNS .25:                                    ; No relocation if it is a numeric value.
    ADD EAX,EDI                                 ; Relocate.
.25:MOV [ESI+PFRSRC_RES_RECORD.Type],EAX
    MOV EAX,[ESI+PFRSRC_RES_RECORD.Name]
    XOR EAX,EBX                                 ; Invert MSbit of .Name.
    TEST EAX                                    ; It's a string if MSbit=1.
    JNS .29:                                    ; No relocation if it is a numeric value.
    ADD EAX,EDI                                 ; Relocate.
.29:MOV [ESI+PFRSRC_RES_RECORD.Name],EAX
    ADD ESI,EDX                                 ; MSbit of .Lang is not inverted because language is never identified by string.
    SUB ECX,EDX
    JA .21:
    LEA EDI,[%ResRecord]                        ; EDI points to the record with previous values.

    ; <b>Pass 3: tree level 1 - resource types</b>.
    SUB EBX,EBX ; Tree level 1.
    CALL .ResetPrev:
    BufferRetrieve [%ResRecordBuf]              ; ESI is now one ResRecord from sorted table.
    CALL .NewResDir:                            ; Create level 1 directory EDX for type entries (offset %TreePtr=0).
.31:PUSH ESI,EDI
      CMPSD                                     ; Has the Type changed?
    POP EDI,ESI
    JE .39:                                     ; Skip creating resource entry if type did not change.
    CALL .NewResEntry:                          ; Create resource entry for the type.
.39:MOVSD                                       ; Copy current record .Type to the previous ones.
    SUB EDI,4
    ADD ESI,SIZE#PFRSRC_RES_RECORD - 4
    SUB ECX,SIZE#PFRSRC_RES_RECORD
    JA .31:                                     ; The next record.

    ; <b>Pass 4: tree level 2 - resource name</b>.
    MOV BL,4                                    ; Tree level 2.
    MOV EAX,[%TreePtr]
    MOV [%DirLevel2Ptr],EAX
    CALL .ResetPrev:
    BufferRetrieve [%ResRecordBuf]              ; ESI is now one ResRecord from sorted table.
.41:PUSH ESI,EDI
      CMPSD                                     ; Has the Type changed?
.43:POP EDI,ESI
    JE .45:
    CALL .NewResDir:                            ; Type changed. Create level 2 directory EDX for name entries.
    JMP .47:
.45:PUSH ESI,EDI
      CMPSD
      CMPSD                                     ; Has the Name changed?
    POP EDI,ESI
    JE .49:
.47:CALL .NewResEntry:                          ; Create resource entry for the name.
.49:MOVSD                                       ; Copy current record .Type to the previous ones.
    MOVSD                                       ; Copy current record .Name to the previous ones.
    SUB EDI,8
    ADD ESI,SIZE#PFRSRC_RES_RECORD - 8
    SUB ECX,SIZE#PFRSRC_RES_RECORD
    JA .41:                                     ; The next record.

    ; <b>Pass 5: tree level 3 - resource language</b>.
    MOV BL,8                                    ; Tree level 3.
    MOV EAX,[%TreePtr]
    MOV [%DirLevel3Ptr],EAX
    CALL .ResetPrev:
    BufferRetrieve [%ResRecordBuf]              ; ESI is now one ResRecord from sorted table.
.51:PUSH ESI,EDI
      CMPSD                                     ; Has the Type changed?
      JNE .55:
      CMPSD                                     ; Has the Name changed?
.55:POP EDI,ESI
    JE .59:                                     ; Skip creating resource dir if type and name did not change.
    CALL .NewResDir:                            ; Type or name changed. Create level 3 directory EDX for lang entries.
.59:CALL .NewResEntry:                          ; Create resource entry for the language.
    MOVSD
    MOVSD                                       ; Copy current record values to the previous ones.
    SUB EDI,8
    ADD ESI,SIZE#PFRSRC_RES_RECORD - 8
    SUB ECX,SIZE#PFRSRC_RES_RECORD
    JA .51:                                     ; The next record.

    ; <b>Pass 6: tree level 4 - data entries</b>.
    BufferRetrieve [%ResRecordBuf]              ; ESI is now one ResRecord from the sorted table.
    MOV EDI,[%TreePtr]                          ; EDI is now pointer to PFRSRC_DATA_ENTRY.
    MOV [%DirLevel4Ptr],EDI
    MOV EAX,[%RawDataOffset]                    ; Offset in soon-to-be compiled segment.
.61:Align2Dword EAX                             ; Each record creates one data entry.
    MOV EBX,[ESI+PFRSRC_RES_RECORD.Data]        ; EBX is now pointer to PFRSRC_RES_HEADER.
    MOV EDX,[EBX+PFRSRC_RES_HEADER.DataSize]    ; Raw data netto size, unaligned.
    MOV [EDI+PFRSRC_DATA_ENTRY.OffsetToData],EAX
    MOV [EDI+PFRSRC_DATA_ENTRY.Size],EDX
    ADD EAX,EDX
    MOV [%RawDataOffset],EAX
    MOV EDX,EDI
    SUB EDX,[%TreeBottom]
    MOV [ESI+PFRSRC_RES_RECORD.DataDir],EDX
    ADD EDI,SIZE# PFRSRC_DATA_ENTRY
    ADD ESI,SIZE#PFRSRC_RES_RECORD
    SUB ECX,SIZE#PFRSRC_RES_RECORD
    JA .61:

    ; <b>Walk the tree and resolve links</b>.
    MOV ESI,[%TreeBottom]
.71:CMP ESI,[%DirLevel2Ptr]                      ; ESI now points to resource directory level 1.
    JNB .73:
    MOVZX ECX,[ESI+PFRSRC_RESOURCE_DIRECTORY.NumberOfNamedEntries]
    ADD CX,[ESI+PFRSRC_RESOURCE_DIRECTORY.NumberOfIdEntries]
    ADD ESI,SIZE#PFRSRC_RESOURCE_DIRECTORY
.72:; ESI now points to ECX resource entries.
    MOV EDX,[ESI+PFRSRC_RESOURCE_ENTRY.DataOrDir]; Temporary pointer to resource record.
    MOV EAX,[EDX+PFRSRC_RES_RECORD.NameDir]
    BTS EAX,31                                   ; MSbit=1.
    MOV [ESI+PFRSRC_RESOURCE_ENTRY.DataOrDir],EAX
    ADD ESI,SIZE#PFRSRC_RESOURCE_ENTRY
    LOOP .72:
    JMP .71:
.73:CMP ESI,[%DirLevel3Ptr]                      ; ESI now points to resource directory level 2.
    JNB .76:
    MOVZX ECX,[ESI+PFRSRC_RESOURCE_DIRECTORY.NumberOfNamedEntries]
    ADD CX,[ESI+PFRSRC_RESOURCE_DIRECTORY.NumberOfIdEntries]
    ADD ESI,SIZE#PFRSRC_RESOURCE_DIRECTORY
.75:; ESI now points to ECX resource entries.
    MOV EDX,[ESI+PFRSRC_RESOURCE_ENTRY.DataOrDir]; Temporary pointer to resource record.
    MOV EAX,[EDX+PFRSRC_RES_RECORD.LangDir]
    BTS EAX,31                                   ; MSbit=1.
    MOV [ESI+PFRSRC_RESOURCE_ENTRY.DataOrDir],EAX
    ADD ESI,SIZE#PFRSRC_RESOURCE_ENTRY
    LOOP .75:
    JMP .73:
.76:CMP ESI,[%DirLevel4Ptr]                      ; ESI now points to resource directory level 3.
    JNB .79:
    MOVZX ECX,[ESI+PFRSRC_RESOURCE_DIRECTORY.NumberOfNamedEntries]
    ADD CX,[ESI+PFRSRC_RESOURCE_DIRECTORY.NumberOfIdEntries]
    ADD ESI,SIZE#PFRSRC_RESOURCE_DIRECTORY
.78:; ESI now points to ECX resource entries.
    MOV EDX,[ESI+PFRSRC_RESOURCE_ENTRY.DataOrDir]; Temporary pointer to resource record.
    MOV EAX,[EDX+PFRSRC_RES_RECORD.DataDir]      ; Offset of data entry (leaf), MSbit=0.
    MOV [ESI+PFRSRC_RESOURCE_ENTRY.DataOrDir],EAX
    ADD ESI,SIZE#PFRSRC_RESOURCE_ENTRY
    LOOP .78:
    JMP .76:
.79: ; Tree in [%TreeBuf] and names in [%StrNameBuf] is now completed.
    ; <b>Create a new resource segment</b> in the current program, i.e. BasePgm.
    MOV EBX,[%BasePgm]
    Invoke SssCreateSe::,[EBX+PGM.CurrentStm],0,=B".rsrc",5, \
                         sssSegment+sssPrivate+sssNotBSS+sssWidth32+sssUsed,sssPurposeRESOURCE,16
    JC .90:
    MOV EDX,EAX                                  ; Segment [.rsrc] wih empty .EmitBuffer and .RelocBuffer.
    ; <b>Compile emitted contents of resource segment EDX</b>.
    MOV ECX,[%RawDataOffset]
    MOV [EDX+SSS.TopLow],ECX
    BufferNew [EDX+SSS.EmitBuffer],ECX
    MOV EDI,EAX                                  ; Pointer to .EmitBuffer bottom.
    BufferRetrieve [%TreeBuf]
    REP MOVSB                                    ; Copy the tree division.
    BufferRetrieve [%StrNameBuf]
    REP MOVSB                                    ; Copy the string names division.
    BufferRetrieve [%ResRecordBuf]
    XOR EAX,EAX
.82:PUSH ECX,ESI
      MOV ECX,EDI
      Align2Dword ECX
      SUB ECX,EDI
      JZ .83:
      REP STOSB                                  ; Align raw data to dword.
.83:  MOV ESI,[ESI+PFRSRC_RES_RECORD.Data]       ; Pointer to the resource header.
      MOV ECX,[ESI+PFRSRC_RES_HEADER.DataSize]
      ADD ESI,[ESI+PFRSRC_RES_HEADER.HeaderSize]
      REP MOVSB                                  ; Copy raw data.
.84:POP ESI,ECX
    ADD ESI,SIZE#PFRSRC_RES_RECORD
    SUB ECX,SIZE#PFRSRC_RES_RECORD
    JA .82:
    MOV EBX,EDX ; ^SSS [.rsrc].
    ; <b>Create relocations in resource segment EBX</b>.
    MOV ECX,[%LangCnt]                           ; Number of relocations.
    MOV EAX,SIZE# RELOC
    MUL ECX
    BufferNew [EBX+SSS.RelocBuffer],EAX, Zeroed=Yes
    MOV EDI,EAX                                  ; Pointer to the future RELOC objects.
    MOV ESI,[%DirLevel4Ptr]                      ; ESI is now pointer to ECX data entries.
.86:MOV EAX,ESI                                  ; PFRSRC_DATA_ENTRY.OffsetToData.
    SUB EAX,[%TreeBottom]
    MOV [EDI+RELOC.OrgLow],EAX                   ; Offset of PFRSRC_DATA_ENTRY in level 4.
    MOV [EDI+RELOC.Section],EBX
    MOV EAX,[EBX+SSS.SymPtr]                     ; symSe reprezents the beginning of [.rsrc] section.
    MOV [EDI+RELOC.Symbol],EAX
    SetSt [EDI+RELOC.Status],relocAbsRVA+relocWidth32
    ADD ESI,SIZE#PFRSRC_DATA_ENTRY
    ADD EDI,SIZE#RELOC
    LOOP .86:                                    ; The next RELOC.

.CmpRecords PROC1                                ; <b>Callback subprocedure to compare two records</b> pointed by ESI,EDI dword by dword.
    PUSH ECX
      MOV ECX,SIZE#PFRSRC_RES_RECORD / 4
      MOV EAX,ESI
      MOV EDX,EDI
      REPE CMPSD
      MOV ESI,EAX
      MOV EDI,EDX
      CMC                                        ; Ascending order.
      JNC .C9:
      MOV ECX,SIZE#PFRSRC_RES_RECORD / 4         ; Swap records ESI with EDI, return with CF.
 .C2: MOV EDX,[EDI]
      LODSD
      MOV [ESI-4],EDX
      STOSD
      LOOP .C2:
      STC
.C9:POP ECX
    RET
   ENDP1 .CmpRecords

.ResetPrev:PROC1 ; <b>Subprocedures which create the binary tree</b>.
                 ; Initializes record at [%ResRecord] to never used values -1.
                 ; Input: EDI=[%ResRecord].
                 ; Output: All registers are preserved.
    PUSH EAX,EDI
     XOR EAX,EAX
     NOT EAX
     STOSD       ; PFRSRC_RES_RECORD.Type=-1.
     STOSD       ; PFRSRC_RES_RECORD.Name=-1.
     STOSD       ; PFRSRC_RES_RECORD.Lang=-1.
    POP EDI,EAX
    RET
    ENDP1 .ResetPrev:

.NewResDir:PROC1 ; Creates empty resource directory at [%TreePtr], increments [%TreePtr] by dirsize=16.
                 ; Input: ESI=resouce record, EBX=0,4,8,12 for tree level 1,2,3,4
                 ; Returns EDX=created directory, other registers are preserved.
    PUSH EAX
     MOV EAX,[%BasePgm]
     MOV EDX,[%TreePtr]
     MOV EAX,[Ea.Eaopt.TimeStamp::]
     MOV [EDX+PFRSRC_RESOURCE_DIRECTORY.TimeDateStamp],EAX
     MOV EAX,EDX
     SUB EAX,[%TreeBottom]
     MOV [ESI+PFRSRC_RES_RECORD.TypeDir+EBX],EAX
     ADDD [%TreePtr],SIZE#PFRSRC_RESOURCE_DIRECTORY
    POP EAX
    RET
    ENDP1 .NewResDir:

.NewResEntry:PROC1 ; Creates resource entry at [%TreePtr], increments [%TreePtr] by entrysize=8.
                   ; The entry is counted to .NrOfNamedEntries or .NrOfIdEntries in resource directory EDX.
                   ; Input: ESI=Resource record, EDX=resource directory, EBX=0,4,8,12 for tree level 1,2,3,4.
                   ; Output: All registers are preserved.
     PUSH EAX,EDI
      MOV EDI,[%TreePtr] ; Pointer to PFRSRC_RESOURCE_ENTRY.IdOrName.
      MOV EAX,[ESI+PFRSRC_RES_RECORD.Type+EBX]   ; Value of type, name or language.
      STOSD ; Store PFRSRC_RESOURCE_ENTRY.IdOrName.
      XCHG EAX,ESI
      STOSD                                      ; Store temporary pointer to the current resource record to .DataOrDir.
      XCHG ESI,EAX
      MOV [%TreePtr],EDI                         ; The next vacant resource entry or dir.
      SAR EAX,31                                 ; MSbit selects numeric or string typename.
      AND AL,-2                                  ; EAX=-2 for string type, EAX=0 for numeric type.
      INCW [EDX+PFRSRC_RESOURCE_DIRECTORY.NumberOfIdEntries+EAX] ; Increment one of two counters.
     POP EDI,EAX
     RET
    ENDP1 .NewResEntry:


    JMP .90:
.90:Invoke EaBufferRelease::, [%DataEntryBuf]
    Invoke EaBufferRelease::, [%StrNameBuf]
    Invoke EaBufferRelease::, [%TreeBuf]
    Invoke EaBufferRelease::, [%ResRecordBuf]
    EndProcedure PfrsrcLoadPgm
</pre>

<dl id="PfrsrcLoadIconFile">
<dt><a href="#top">&uarr; PfrsrcLoadIconFile</a> Program</dt>
<dd><dfn>PfrsrcLoadIconFile</dfn> is invoked when a PE or DLL executable program is linked.
<!---->If no segment with <code>PURPOSE=RESOURCE</code> exists in program yet, it will create an implicit segment
<code>[.rsrc]</code> with just one resource: the icon specified by program option
<code>IconFile=</code>.
<br/>If the IconFile= option is empty or if the icon file was not found, no resource segment is created.</dd>
<dt>Input</dt>
<dd><b>Program</b>is pointer to <a class="EXT" href="pgm.htm#PGM">PGM</a> in PE of DLL format.</dd>
<dt>Output</dt>
<dd><b>CF=0</b> when segment <code>[.rsrc]</code> was created succesfully.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Depends on</dt>
<dd><a class="EXT" href="pf.htm#PfQueryChar">PfQueryChar</a></dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferAlign">EaBufferAlign</a>
<a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a class="EXT" href="eaopt.htm#EaoptGetOnePath">EaoptGetOnePath</a>
<a href="#PfrsrcLoadPgm">PfrsrcLoadPgm</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pfpe.htm#PfpeCompile">PfpeCompile</a>
</dd>
</dl><pre>
PfrsrcLoadIconFile Procedure Program
PathNr    LocalVar ; Ordinal number of LINKPATH.
RsrcSss   LocalVar ; Pointer to the section [.rsrc].
IcoPtr    LocalVar ; Pointer to the beginning of icon file mapped in memory.
IcoSize   LocalVar ; Netto size of icon file.
IcoEnd    LocalVar ; Pointer to the end of *.ico file in memory.
ResBuffer LocalVar ; <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> for compiled resource.
IcoImgBuf LocalVar ; <a class="EXT" href="../maclib/memory32.htm#BUFFER">BUFFER</a> with DD Ptr,Size pairs.
IcoImgQW  LocalVar ; Pointer to DD Ptr,Size pairs inside %IcoImgBuf.
NameId    LocalVar ; Numeric name of icon (1,2,3..).
ResHeader LocalVar Size=SIZE#PFRSRC_RES_HEADER ; Working space for resource header.
IcoFile   LocalVar Size=SIZE#FILE ; Linked icon file.
    ClearLocalVar
    MOV EBX,[%Program]
    ; <b>Check already linked segments on sssPurposeRESOURCE</b>.
    ListGetFirst [EBX+PGM.SssList]
    JZ .90:
.10:JSt [EAX+SSS.Purpose],sssPurposeRESOURCE,.90: ; If a resource section already exists, do nothing.
    ListGetNext EAX
    JNZ .10:
    ; <b>Check if icon file is specified</b>.
    MOV EDX,[EBX+PGM.Pgmopt.IconFileSize]
    MOV ESI,[EBX+PGM.Pgmopt.IconFilePtr]
    TEST EDX
    JZ .90:                                      ; When IconFile is empty, no resource section will be linked.
    ; <b>Query if Filemask ESI,EDX was specified with path</b> (it contains slash or colon).
    PfQueryChar '\'
    JE .50:
    PfQueryChar '/'
    JE .50:
    PfQueryChar ':'
    JE .50:
    SUB EAX,EAX                                  ; When there is no path in ICONFILE=, try all pathes from LINKPATH=.
    MOV [%PathNr],EAX
.20:Invoke EaoptGetOnePath::,[Ea.Eaopt.LinkPathPtr::],[Ea.Eaopt.LinkPathSize::],[%PathNr]
    JC .E7752:                                   ; IconFile=!1$ was no found in LinkPath="!2S".
    INCD [%PathNr]                               ; Prepare for the next path. One path is in ESI,ECX.
    MOV EBX,[%Program]
    MOV EDX,[EBX+PGM.Pgmopt.IconFileSize]
    LEA EAX,[EDX+ECX+1]
    CMP EAX,260
    JA .E6953:                                   ; Size of LinkPath "!1_" + size of filename exceeded 256 characters.
    LEA EDI,[%IcoFile+FILE.Name]                 ; Assign path+iconfile name to %IcoFile.
    REP MOVSB
    MOV AX,'\/'
    CMPB [Ea.EuroasmOS::],'W'                    ; Choose slash or backslash.
    JE .30:
    XCHG AL,AH
.30:CMP AL,[EDI-1]
    JE .40:
    CMP AH,[EDI-1]
    JE .40:
    STOSB                                        ; If the path was not terminated with slash or backslash, add it.
.40:MOV ESI,[EBX+PGM.Pgmopt.IconFilePtr]
    MOV ECX,EDX
    REP MOVSB
    SUB EAX,EAX
    STOSB                                        ; Zero terminate the filename.
    LEA EDI,[%IcoFile]                           ; IconFile is now assigned with path and filemask.
    LEA EDX,[EDI+FILE.Name]
    SysOpenFileMap EDI,EDX
    JC .20:                                      ; If not found, try the next IncludePath.
    JMP .60:
.50:LEA EDI,[%IcoFile]
    SysOpenFileMap EDI,ESI,FileNameSize=EDX      ; Path was found in filename ESI.
    JC .E7751:                                   ; IconFile=!1$ was not found.
.60:MOV ESI,[EDI+FILE.BufPtr]
    MOV ECX,[EDI+FILE.BufSize]
    MOV [%IcoPtr],ESI
    CMP ECX,SIZE# PFRSRC_ICONDIR + SIZE# PFRSRC_ICONDIRENTRY
    JNA .E7753:                                  ; Invalid format of IconFile="!1$".
    Invoke EaBufferReserve::,PfrsrcLoadIconFile
    MOV [%IcoImgBuf],EAX
    ; <b>Icon file is now mapped to memory at ESI</b>. Let's create linkable compiled resource "file" in memory.
    ADD ECX,ESI
    MOV [%IcoEnd],ECX
    MOVZXW ECX,[ESI+PFRSRC_ICONDIR.idCount]      ; Number of icon images in the file.
    TEST ECX
    JZ .E7753:                                   ; Invalid format of IconFile="!1$".
    CMP ECX,16
    JA .E7753:                                   ; Invalid format of IconFile="!1$".
    INC ECX,ECX                                  ; That number of RES_HEADER will be in resource "file".
    SAL ECX,5                                    ; Multiply with SIZE# PFRSRC_RES_HEADER.
    ADD ECX,[EDI+FILE.BufSize]                   ; Plus icon file size.
    BufferCreate [EBX+PGM.Pool],Size=ECX         ; Resource "file" will be compiled here.
    MOV [%ResBuffer],EAX
    ; <b>Store initial resource header</b>.
    LEA EDI,[%ResHeader]
    XOR EAX,EAX
    NOT EAX
    MOVD [EDI+PFRSRC_RES_HEADER.HeaderSize],SIZE# PFRSRC_RES_HEADER
    MOV [EDI+PFRSRC_RES_HEADER.ResType],AX       ; Use numeric Id rather than Unicode strings.
    MOV [EDI+PFRSRC_RES_HEADER.ResName],AX
    BufferStore [%ResBuffer],EDI,SIZE# PFRSRC_RES_HEADER
    ; <b>Store resource header for GROUP_ICON</b>.
    MOVZXW ECX,[ESI+PFRSRC_ICONDIR.idCount]      ; Number of icon images in the file.
    MOV EAX,SIZE# PFRSRC_GRPICONDIRENTRY         ; 14.
    MUL ECX
    ADD EAX,SIZE# PFRSRC_GRPICONDIR              ; 6.
    MOV [EDI+PFRSRC_RES_HEADER.DataSize],EAX
    MOVW [EDI+PFRSRC_RES_HEADER.ResType+2],pfrsrcGROUP_ICON ; 0x000E.
    MOVW [EDI+PFRSRC_RES_HEADER.ResName+2],1     ; GROUP_ICON #1.
    MOVW [EDI+PFRSRC_RES_HEADER.MemoryFlags],pfrsrcResMOVABLE+pfrsrcResPURE+pfrsrcResDISCARDABLE
    BufferStore [%ResBuffer],EDI,SIZE# PFRSRC_RES_HEADER
    ; <b>Store resource data for GROUP_ICON</b>. Plain copy ICONDIR to GRPINCONDIR.
    BufferStore [%ResBuffer],ESI,SIZE# PFRSRC_ICONDIR
    ADD ESI,SIZE# PFRSRC_ICONDIR                 ; ESI now points to ICONDIRENTRY.
    ; Store ICONDIRENTRY to GRPICONDIRENTRY with DD .dwImageOffset modified to DW .nId.
    ; Repeat for each image (ECX-times) in the loop .61: .. .69:
.61:CMP ESI,[%IcoEnd]
    JNB .E7753:                                  ; Invalid format of IconFile="!1$".
    PUSH ECX
      BufferNew [%ResBuffer],SIZE# PFRSRC_GRPICONDIRENTRY - 2 ; Omit the last member (.nId).
      MOV EDI,EAX
      MOV EAX,[ESI+PFRSRC_ICONDIRENTRY.dwImageOffset] ; File address.
      ADD EAX,[%IcoPtr]                          ; Convert FA to memory pointer.
      BufferStoreDword [%IcoImgBuf],EAX          ; Temporary save pointer and then size of image.
      MOV EAX,[ESI+PFRSRC_ICONDIRENTRY.dwBytesInRes]
      BufferStoreDword [%IcoImgBuf],EAX          ; Size of image.
      MOV ECX,SIZE# PFRSRC_ICONDIRENTRY - 4      ; Omit the last member (.dwImageOffset).
      REP MOVSB
      MOV EAX,[%NameId]
      INC EAX
      MOV [%NameId],EAX
      BufferStoreWord [%ResBuffer],EAX           ; Store PFRSRC_GRPICONDIRENTRY.nId.
      LODSD                                      ; Skip void PFRSRC_ICONDIRENTRY.dwImageOffset.
.69:POP ECX
    LOOP .61:
    Invoke EaBufferAlign::,[%ResBuffer],4
    ; <b>Store resource header and data for each icon image</b> in the loop .71: .. .79:.
    BufferRetrieve [%IcoImgBuf]
    MOV [%IcoImgQW],ESI                          ; Prepare pointer to DD Ptr,Size pairs with raw image data.
    MOV ESI,[%IcoPtr]                            ; Restore pointer to icon file mapped in memory.
    MOVZXW ECX,[ESI+PFRSRC_ICONDIR.idCount]      ; Number of icon images in the file.
    MOVD [%NameId],0
.71:CMP ESI,[%IcoEnd]
    JNB .E7753:                                  ; Invalid format of IconFile="!1$".
    PUSH ECX
      LEA EDI,[%ResHeader]
      MOVW [EDI+PFRSRC_RES_HEADER.ResType+2],pfrsrcICON ; 3.
      MOV EAX,[%NameId]
      INC EAX
      MOV [%NameId],EAX
      MOV [EDI+PFRSRC_RES_HEADER.ResName+2],AX   ; Numeric icon Id.
      MOV EDX,[%IcoImgQW]
      MOV EAX,[EDX+4]
      MOV [EDI+PFRSRC_RES_HEADER.DataSize],EAX
      BufferStore [%ResBuffer],EDI,SIZE# PFRSRC_RES_HEADER
      MOV ESI,EDX
      LODSD                                      ; Load pointer to the raw data.
      MOV ECX,EAX
      LODSD                                      ; Load size of raw data.
      MOV [%IcoImgQW],ESI                        ; Prepare for the next image.
      BufferStore [%ResBuffer],ECX,EAX           ; Store the raw image data.
      Invoke EaBufferAlign::,[%ResBuffer],4
    POP ECX
    LOOP .71:
    BufferRetrieve [%ResBuffer]                  ; ESI,ECX now contain the contents of resource file.
    ; <b>Convert resource ESI,ECX to binary tree</b> in [.rsrc] section.
    LEA EDX,[%IcoFile]
    Invoke PfrsrcLoadPgm,EBX,ESI,ECX,[EDX+FILE.Name]
    JMP .90:
.E6953:Msg '6953',ESI                            ; Size of LinkPath "!1_" + size of filename exceeded 256 characters.
       JMP .Error:
.E7751:MOV ESI,[EBX+PGM.Pgmopt.IconFilePtr]
       Msg '7751',ESI                            ; IcoFile=!1$ was not found.
       JMP .Error:
.E7752:MOV ESI,[EBX+PGM.Pgmopt.IconFilePtr]
       LEA EAX,[Ea.Eaopt.LinkPathPtr]
       Msg '7752',ESI,EAX                        ; IconFile=!1$ was no found in LinkPath="!2S".
       JMP .Error:
.E7753:MOV ESI,[EBX+PGM.Pgmopt.IconFilePtr]
       Msg '7753',ESI                            ; Invalid format of IconFile="!1$".
.Error:STC
.90:  Invoke EaBufferRelease::,[%IcoImgBuf]
    EndProcedure PfrsrcLoadIconFile
</pre>

<pre>
  ENDPROGRAM pfrsrc
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
