<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='ctx.htm source file'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>ctx.htm source file</title>
</head>
<body class='EASOURCE' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>ctx.htm
<br/><i>Classes</i>
<br/><a href="#CTX">CTX</a>
<br/><a href="#CTX_FOR">CTX_FOR</a>
<br/><a href="#CTX_MAC">CTX_MAC</a>
<br/><i>Encodings</i>
<br/><a href="#CtxEnc">CtxEnc</a>
<br/><i>Procedures</i>
<br/><a href="#Ctx1stRepeat">Ctx1stRepeat</a>
<br/><a href="#CtxCreate">CtxCreate</a>
<br/><a href="#CtxDestroy">CtxDestroy</a>
<br/><a href="#CtxDiscard">CtxDiscard</a>
<br/><a href="#CtxExpansionNrUpdate">CtxExpansionNrUpdate</a>
<br/><a href="#CtxFind">CtxFind</a>
<br/><a href="#CtxForNext">CtxForNext</a>
<br/><a href="#CtxGetEndTypename">CtxGetEndTypename</a>
<br/><a href="#CtxPeek">CtxPeek</a>
<br/><a href="#CtxStatusAll">CtxStatusAll</a>
</h1>
<p>Object <dfn>Ctx</dfn> represents one program <a class="EXT" href="../eadoc/index.htm#ProgStrucVerBlock">block
</a>. Whenever a block statement is executed, one Ctx object is pushed on Src.CtxStack
<!---->and it is popped when the corresponding ENDblock is encounterred.</p>
<p>Proper block nesting must be maintained in noemitting state too.</p>
<br class="CLEAR"/>
<pre>
    EUROASM NOWARN=2101
ctx PROGRAM FORMAT=COFF,MODEL=FLAT,WIDTH=32
   INCLUDEHEAD euroasm.htm, \  Interface (structures, symbols and macros) of other modules used in this source.
               ea.htm,eaopt.htm,exp.htm,member.htm,msg.htm,pass.htm,pgm.htm,pgmopt.htm,stm.htm
</pre><pre>
   ctx HEAD ; Start of module interface. 
</pre>

<dl id="CTX"><dt><a href="#top">&uarr; CTX</a></dt>
<dd>Structure which describes block context. Context objects are kept on <code>Src.CtxStack</code>.</dd></dl><pre>
CTX STRUC
.NamePtr      D D ; Pointer to block identifier delocalized name.
.NameSize     D D ; Size of block identifier.
.ExpansionNr  D D ; Value of dynamic %variable <code>%.</code> which makes unique labels.
.Status       D D ; Context boolean properties, see <a href="#CtxEnc">CtxEnc</a> below.
              ; +10h.
.ObjPtr       D D ; Pointer to the corresponding object, depending on ctxAnyType, see <a href="#CtxEnc">CtxEnc</a> below.
.MacPtr       D D ; Pointer to <a class="EXT" href="mac.htm#MAC">MAC</a> during macro definition.
.PreviousSect D D ; ^SSS with section which was current before entering the block.
.BlockSect    D D ; ^SSS with section of block-begin pseudoinstruction, possibly changed by AUTOSEGMENT=ON.
              ; +20h.
.LinePtr      D D ; Pointer to the 1st physical line of block-begin statement.
.ChunkPtr     D D ; Pointer to <a class="EXT" href="chunk.htm#CHUNK">CHUNK</a> where .LinePtr belongs to.
.LineNext     D D ; Pointer to the end of source line with macroinstruction invocation.
.ChunkNext    D D ; Pointer to <a class="EXT" href="chunk.htm#CHUNK">CHUNK</a> where .LineNext belongs to.
              ; +30h.
.LineEnd      D D ; Pointer behind the 1st physical line of block-begin statement.
.Shift        D D ; Ordinal operands number modifier. Default=0, increased by %SHIFT (%MACRO).
.ValBuffer    D D ; ^BUFFER keeping values of operands in buffers below until the end of block expansion.
.ObjBuffer    D D ; ^BUFFER which contains ^CTX_FOR or ^CTX_MAC object at block expansion.
              ; +40h.
.OrdBuffer    D D ; ^BUFFER of 2*DDs keeping values of ordinal operands at %MACRO/%FOR invocation.
.KeyBuffer    D D ; ^BUFFER of 4*DDs keeping keyword operands at macro invocation.
.FrmBuffer    D D ; ^BUFFER of 4*DD keeping ordinal and keyword formal parameters at %MACRO/%FOR invocation.
                  ; Their names are without <kbd>%</kbd>. In case of ctxFOR this buffer contains just one parameter.
  ENDSTRUC CTX
</pre>

<dl id="CTX_MAC"><dt><a href="#top">&uarr; CTX_MAC</a></dt>
<dd>This structure describes some context properties of %MACRO expansion.
<!---->In the context of expansion of block %MACRO..%ENDMACRO <code>CTX.ObjBuffer</code> contains an object
<!---->of CTX_MAC structure. It is created at invocations of a macro.</dd></dl><pre>
CTX_MAC STRUC
.LabelPtr       D D ; Pointer to the label of macro invocation.
.LabelSize      D D ; Size of the label of macro invocation.
.MacroNamePtr   D D ; Pointer to the name of macro.
.MacroNameSize  D D ; Size of the name of macro.
.ProtoLinePtr   D D ; Pointer to the prototype (%MACRO statement).
.InvokStmStatus D D ; STM.Status of the statement which invoked the macro.
    ENDSTRUC CTX_MAC
</pre>

<dl id="CTX_FOR"><dt><a href="#top">&uarr; CTX_FOR</a></dt>
<dd>This structure describes some context properties of %FOR block expansion.
<!---->In the context of expansion of block %FOR..%ENDFOR <code>CTX.ObjBuffer</code> contains an object
<!---->of CTX_FOR structure.</dd></dl><pre>
CTX_FOR STRUC
.OrdinalNr    D D ; Curent ordinal number of processed %FOR operand.
.NrOfOrdinals D D ; Maximal ordinal number of %FOR operands.
.Step         D Q ; Current STEP value (signed integer). The value is -1 or +1 when flag <code>CTX.Status:ctxStep0</code> is set.
.Value        D Q ; Current formal variable numeric value. Also stored to CTX.FrmBuffer as a string.
.RangeLeft    D Q ; Current operand range value. Ignored when the operand is not a range.
.RangeRight   D Q ; Current operand range value. Ignored when the operand is not a range.
     ENDSTRUC CTX_FOR
</pre>

<dl id="CtxEnc"><dt><a href="#top">&uarr; CtxEnc</a></dt>
<dd>Encoding of context flags used in CTX.Status.</dd></dl><pre>
ctxAnyType      = 0x0000_0FFF ; <b>Block type mask</b>. See also CtxGetEndTypename.CtxEndTypenameTable.
ctxPROGRAM      = 0x0000_0001 ; CTX.ObjPtr=^PGM
ctxPROC         = 0x0000_0002 ; CTX.ObjPtr=^SYM
ctxPROC1        = 0x0000_0004 ; CTX.ObjPtr=^SYM
ctxSTRUC        = 0x0000_0008 ; CTX.ObjPtr=^SSS
ctxMACRO        = 0x0000_0010 ; CTX.ObjPtr=^CTX_MAC
ctxFOR          = 0x0000_0020 ; CTX.ObjPtr=^CTX_FOR
ctxWHILE        = 0x0000_0040 ; CTX.ObjPtr=0
ctxREPEAT       = 0x0000_0080 ; CTX.ObjPtr=0
ctxIF           = 0x0000_0100 ; CTX.ObjPtr=0
;               = 0x0000_0200 ; Unused.
ctxHEAD         = 0x0000_0400 ; CTX.ObjPtr=0
ctxCOMMENT      = 0x0000_0800 ; CTX.ObjPtr=0
                              ; <b>Other context properties</b>.
ctxDefinition   = 0x0000_1000 ; Block is being defined (STRUC, %MACRO).
ctxExpansion    = 0x0000_2000 ; Block is being expanded (STRUC, %MACRO, %FOR, %WHILE, %REPEAT).
ctxPrototype    = 0x0000_4000 ; %MACRO prototype is being prepared.
ctxMacExpList   = 0x0000_8000 ; Macroinstruction entered when LIST=ON,LISTMACRO=ON,
 ; its expansion should be +listed even when the macro is defined in included file and LISTINCLUDE=OFF.
ctxNamespace    = 0x0001_0000 ; This block defines namespace.
ctxExpandable   = 0x0002_0000 ; Block has <kbd>%.</kbd> property (%FOR,%WHILE,%REPEAT,%MACRO).
ctxFormal       = 0x0004_0000 ; Block has formal parameters (%FOR, %MACRO). All buffers reserved.
ctxRepeat       = 0x0008_0000 ; This block is %FOR or %WHILE or %REPEAT (see LISTREPEAT).
ctx1stRepeat    = 0x0010_0000 ; Repeat block is expanded for the 1st time. Display in listing.
ctxNestingOff   = 0x0020_0000 ; This block was specified with key NESTINGCHECK=OFF.
ctxIsRange      = 0x0040_0000 ; Current %FOR operand is numeric range.
ctxStep0        = 0x0080_0000 ; Set if STEP=0 or if STEP= was not explicitly specified. Empiric slope will be used.
ctxExited       = 0x0100_0000 ; %EXITblock encountered, ignore possible nesting errors.
ctxElsed        = 0x0200_0000 ; %ELSE statement was already encountered in this ctxIF.
ctxIfEmit       = 0x0400_0000 ; %IF block enterred in emitting status.
;               = 0x0800_0000 ; Unused.
ctxPgmPassed    = 0x1000_0000 ; PGM has performed at least 1 pass. Used to skip PROGRAM stm in repeated passes.
ctxPgmReturned  = 0x2000_0000 ; ENDPROGRAM just returned to its PROGRAM statement. Reset in PseudoPROGRAM.
ctxMacLabeled   = 0x4000_0000 ; Macro definition has formal label %: declared in one of its statements.
ctxNoEmit       = 0x8000_0000 ; Nonemitting part of block reached, such as false %IF, %COMMENT, EXITed etc.
</pre>
<pre>
  ENDHEAD ctx ; End of module interface.
</pre>

<pre>
[.text]
</pre>

<dl id="CtxPeek">
<dt><a href="#top">&uarr; CtxPeek</a> CtxType, CtxStackPtr</dt>
<dd>CtxPeek will seek Src.CtxStack from below CtxStackPtr to bottom and returns
<!---->the first context matching CtxType (or at least one of the flags if more than 1 specified).
<br/>It does not change the context stack.</dd>
<dt>Input</dt>
<dd><b>CtxType</b> Flag in CTX.Status, e.g. ctxPROC. 
<br/><b>CtxStackPtr</b> is pointer to the context (CTX structure) returned in previous CtxPeek invocation.
<!---->It may be 0, top of context stack is used in this case.</dd>
<dt>Output</dt>
<dd><b>CF=0 EAX=</b> pointer to CTX structure.</dd>
<dt>Error</dt>
<dd><b>CF=1 EAX=0</b> if no such context was found.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="chunk.htm#ChunkSubHead">ChunkSubHead</a>
<a href="#Ctx1stRepeat">Ctx1stRepeat</a>
<a class="EXT" href="iig.htm#IigRET">IigRET</a>
<a class="EXT" href="mac.htm#MacFind">MacFind</a>
<a class="EXT" href="msg.htm#MsgProc">MsgProc</a>
<a class="EXT" href="pgm.htm#PgmCreateProgram">PgmCreateProgram</a>
<a class="EXT" href="pgm.htm#PgmGetCurrent">PgmGetCurrent</a>
<a class="EXT" href="pgmopt.htm#PgmoptSetDefaults">PgmoptSetDefaults</a>
<a class="EXT" href="pseudo.htm#PseudoENDPROGRAM">PseudoENDPROGRAM</a>
<a class="EXT" href="pseudo.htm#PseudopcDROPMACRO">PseudopcDROPMACRO</a>
<a class="EXT" href="pseudo.htm#PseudopcMACRO">PseudopcMACRO</a>
<a class="EXT" href="pseudo.htm#PseudopcSHIFT">PseudopcSHIFT</a>
<a class="EXT" href="src.htm#SrcAssemble">SrcAssemble</a>
<a class="EXT" href="stm.htm#StmListing">StmListing</a>
<a class="EXT" href="stm.htm#StmParse">StmParse</a>
<a class="EXT" href="sym.htm#SymDelocalName">SymDelocalName</a>
<a class="EXT" href="var.htm#VarCheckFormal">VarCheckFormal</a>
<a class="EXT" href="var.htm#VarExpand">VarExpand</a>
</dd>
</dl><pre>
CtxPeek Procedure CtxType, CtxStackPtr
      SUB EAX,EAX
      MOV [%ReturnEAX],EAX
      MOV EBX,[Src.CtxStack::]
      MOV EAX,[%CtxStackPtr]
      CMP EBX,1
      MOV EDX,[%CtxType]
      JC .99:
      TEST EAX
      JNZ .30:
      StackPeekLast EBX
.10:  JC .99:
      TEST [EAX+CTX.Status],EDX
      JNZ .80:
.30:  StackPeekPrev EBX,EAX
      JMP .10:
.80:  MOV [%ReturnEAX],EAX
.99: EndProcedure CtxPeek
</pre>

<dl id="CtxGetEndTypename">
<dt><a href="#top">&uarr; CtxGetEndTypename</a> CtxType</dt>
<dd><dfn>CtxGetEndTypename</dfn> returns uppercase mnemonic of ENDblock specified with CtxType flag,
<!---->such as "ENDPROC", "ENDSTRUC", "%ENDIF", "%ENDFOR" etc.
<br>It returns EXITblock mnemonic if CtxType.ctxExited is set.</dd>
<dt>Input</dt>
<dd><b>CtxType</b> Ctx.Status with flag identifying the context type.</dd>
<dt>Output</dt>
<dd><b>EAX=</b> pointer to DQ with name and size of ENDblock name.
<!---->It points to a QWORD with pointer in low DD and size in high DD.</dd>
<dt>Error</dt>
<dd><b>EAX=</b> pointer to DQ 0,0 (empty name) when CtxType didn't specify a valid block.</dd>
<dt>Example</dt><dd class="PRE">CtxGetEndTypename ctxMACRO ; Returns string "%ENDMACRO".
<!----></dd>
<dt>Invoked by</dt>
<dd><a href="#CtxDiscard">CtxDiscard</a>
<a class="EXT" href="src.htm#SrcAssemble">SrcAssemble</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t1210.htm">t1210</a>
</dd>
</dl><pre>
CtxGetEndTypename Procedure CtxType
     MOV EBX,[%CtxType]
     MOV ESI,.CtxEndTypenameTable:
     JNSt EBX,ctxExited,.10:
     MOV ESI,.CtxExitTypenameTable:
 .10:MOV EAX, .Dummy
     AND EBX,ctxAnyType
     BSF EDX,EBX                                 ; EDX=0 (ctxPROGRAM), 1(ctxPROC), 2(ctxPROC1)..11(ctxCOMMENT)
     JZ .80:
     CMP EDX,SIZE#.CtxEndTypenameTable /4
     JNB .80:
     MOV EAX,[ESI+4*EDX]
.80: MOV [%ReturnEAX],EAX
     ; JMPS .90:
[.data]
     ALIGN 4
.Dummy DD 0,0
.CtxEndTypenameTable DD \ ; The order must match <a href="#CTX">CTX</a>.Status:ctxAnyType.
     Dict_PseudoENDPROGRAM::,Dict_PseudoENDPROC::,    Dict_PseudoENDPROC1::,\
     Dict_PseudoENDSTRUC::,  Dict_PseudopcENDMACRO::, Dict_PseudopcENDFOR::,\
     Dict_PseudopcENDWHILE::,Dict_PseudopcENDREPEAT::,Dict_PseudopcENDIF::, \
     .Dummy,                 Dict_PseudoENDHEAD::,   Dict_PseudopcENDCOMMENT::
.CtxExitTypenameTable DD \ ; The order must match CTX.Status:ctxAnyType.
     Dict_PseudoENDPROGRAM::,Dict_PseudoENDPROC::,    Dict_PseudoENDPROC1::,\
     Dict_PseudoENDSTRUC::,  Dict_PseudopcEXITMACRO::,Dict_PseudopcEXITFOR::,\
     Dict_PseudopcEXITWHILE::,Dict_PseudopcEXITREPEAT::,Dict_PseudopcELSE::, \
     .Dummy,                 Dict_PseudoENDHEAD::,   Dict_PseudopcENDCOMMENT::
     DS 0*CTX_MAC
[.text]
.90:EndProcedure CtxGetEndTypename
</pre>

<dl id="CtxCreate">
<dt><a href="#top">&uarr; CtxCreate</a> CtxPtr, CtxStatus, StmPtr</dt>
<dd>CtxCreate initializes context structure in block pseudoinstruction executing.
<!---->It does not push the context on stack.
<br/>Emitting and structure status is inherited from current status, other context flags should be provided via CtxStatus parameter.
<br/>If CtxStatus:ctxExpandable&amp;ctxExpansion is set, CtxCreate will increment and assign ExpansionNr
<!---->and report E7140 when it exceeds MAXEXPANSIONS=.
<br/>If CtxStatus:ctxFormal is set, CtxCreate will reserve all buffers necessarry for
<!---->evaluation of formal %variables during block expansion.</dd>
<dt>Input</dt>
<dd><b>CtxPtr</b> Allocated fresh context object with undefined contents.
<br/><b>CtxStatus</b> Flags to set in CTX.Status.
<br/><b>StmPtr</b> Parsed block-begin statement.</dd>
<dt>Output</dt>
<dd>.Name, .Status, .LinePtr, .ExpansionNr
<!----> members of structure <a href="#CTX">CTX</a> are initialized, other members zeroed.</dd>
<dt>Error</dt>
<dd>Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>See also</dt>
<dd>&nbsp;</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a class="EXT" href="sym.htm#SymDelocalName">SymDelocalName</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="mac.htm#MacExpand">MacExpand</a>
<a class="EXT" href="pseudo.htm#PseudoData">PseudoData</a>
<a class="EXT" href="pseudo.htm#PseudoPROC">PseudoPROC</a>
<a class="EXT" href="pseudo.htm#PseudoPROC1">PseudoPROC1</a>
<a class="EXT" href="pseudo.htm#PseudoPROGRAM">PseudoPROGRAM</a>
<a class="EXT" href="pseudo.htm#PseudoSTRUC">PseudoSTRUC</a>
<a class="EXT" href="pseudo.htm#PseudopcCOMMENT">PseudopcCOMMENT</a>
<a class="EXT" href="pseudo.htm#PseudopcFOR">PseudopcFOR</a>
<a class="EXT" href="pseudo.htm#PseudopcIF">PseudopcIF</a>
<a class="EXT" href="pseudo.htm#PseudopcMACRO">PseudopcMACRO</a>
<a class="EXT" href="pseudo.htm#PseudopcREPEAT">PseudopcREPEAT</a>
<a class="EXT" href="pseudo.htm#PseudopcWHILE">PseudopcWHILE</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t1210.htm">t1210</a>
</dd>
</dl><pre>
CtxCreate Procedure CtxPtr, CtxStatus, StmPtr
      MOV EDI,[%CtxPtr]
      MOV EBX,[%StmPtr]
      Clear EDI,Size=SIZE#CTX
      Invoke EaBufferReserve::,CtxCreate 
      MOV [EDI+CTX.ValBuffer],EAX                ; ValBuffer is always reserved, regardless of ctxExpandable.
      MOV EDX,[%CtxStatus]
     ; <b>Set context name</b>.
      MOV ECX,[EBX+STM.LabelSize]
      MOV ESI,[EBX+STM.LabelPtr]
      JNSt EDX,ctxMACRO,.20:
      JNSt EDX,ctxExpansion,.20:
      MOV ECX,[EBX+STM.OperationSize]            ; Macro invocation has context name in Stm.Operation instead of Stm.Label.
      MOV ESI,[EBX+STM.OperationPtr]
      JMP .30:
.20:  JNSt EDX,ctxREPEAT, .30:
      ; <b>%REPEAT statement is an exception</b>: it has block name in its 1st ordinal instead of label field.
      BufferRetrieve [EBX+STM.OrdBuffer]
      JECXZ .50:
      MOV ECX,[ESI+4]
      MOV ESI,[ESI+0]
      StripColons ESI,ECX
.30:  TEST ECX
      JNZ .40:
      JSt EDX,ctxIF|ctxRepeat|ctxCOMMENT|ctxHEAD, .50: ; Those blocks may have no name.
.40:  Invoke SymDelocalName::,ESI,ECX,[EDI+CTX.ValBuffer],memberDelocal
      BufferRetrieve [EDI+CTX.ValBuffer]
      MOV [EDI+CTX.NamePtr],ESI                  ; Persistent delocalized block name.
      MOV [EDI+CTX.NameSize],ECX
.50:  MOV EAX,[EBX+STM.LinePtr]
      MOV ECX,[EBX+STM.LineEnd]
      MOV ESI,[EBX+STM.ChunkPtr]
      MOV EBX,[EBX+STM.Section]
      MOV [EDI+CTX.LinePtr],EAX
      MOV [EDI+CTX.LineEnd],ECX
      MOV [EDI+CTX.ChunkPtr],ESI
      MOV [EDI+CTX.PreviousSect],EBX
      MOV [EDI+CTX.BlockSect],EBX
.60:  JNSt EDX,ctxFormal,.80:
      Invoke EaBufferReserve::,CtxCreate
      MOV [EDI+CTX.ObjBuffer],EAX
      Invoke EaBufferReserve::,CtxCreate
      MOV [EDI+CTX.OrdBuffer],EAX
      Invoke EaBufferReserve::,CtxCreate
      MOV [EDI+CTX.KeyBuffer],EAX
      Invoke EaBufferReserve::,CtxCreate
      MOV [EDI+CTX.FrmBuffer],EAX
.80:  MOV [EDI+CTX.Status],EDX      
.90: EndProcedure CtxCreate
</pre>

<dl id="CtxDestroy">
<dt><a href="#top">&uarr; CtxDestroy</a> CtxPtr</dt>
<dd>CtxDestroy will release context buffers reserved in CtxCreate.</dd>
<dt>Input</dt>
<dd><b>CtxPtr</b> Pointer to <a href="#CTX">CTX</a> object.</dd>
<dt>Output</dt>
<dd>Buffers released.</dd>
<dt>Error</dt>
<dd>not detected.</dd>
<dt>See also</dt>
<dd><a href="#CtxCreate">CtxCreate</a></dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
</dd>
<dt>Invoked by</dt>
<dd><a href="#CtxDiscard">CtxDiscard</a>
</dd>
</dl><pre>
CtxDestroy Procedure CtxPtr
      MOV EBX,[%CtxPtr]
      Invoke EaBufferRelease::,[EBX+CTX.ObjBuffer]
      Invoke EaBufferRelease::,[EBX+CTX.OrdBuffer]
      Invoke EaBufferRelease::,[EBX+CTX.KeyBuffer]
      Invoke EaBufferRelease::,[EBX+CTX.FrmBuffer]
      Invoke EaBufferRelease::,[EBX+CTX.ValBuffer]
     EndProcedure CtxDestroy
</pre>

<dl id="CtxForNext">
<dt><a href="#top">&uarr; CtxForNext</a> CtxPtr</dt>
<dd>CtxForNext assigns the first or the next value of formal variable.
<!----></dd>
<dt>Input</dt>
<dd><b>CtxPtr</b> is prepared %FOR context.
<br/>Ctx.ObjBuffer contains <a href="#CTX_FOR">CTX_FOR</a> object, also pointed to with Ctx.ObjPtr.
<br/>Ctx.OrdBuffer contains pairs of DD which are persistent copies of %FOR Stm.OrdBuffer,
<!---->i.e. %FOR ordinal operands at block entry.
<br/>Ctx.FrmBuffer contains 4*DD specifying formal name and its previous value. The value will be updated here.</dd>
<dt>Output</dt>
<dd><b>CF=</b>0 Formal variable in Ctx.FrmBuffer is assigned with the next value.
<code>CTX_FOR.OrdinalNr</code> and <code>CTX_FOR.Value</code> will be updated, too.
<br/><b>CF=</b>1 at the end of expansion (all ordinals exhausted).</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Errors are reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>See also</dt>
<dd>&nbsp;</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="exp.htm#ExpEvalNum">ExpEvalNum</a>
<a class="EXT" href="exp.htm#ExpParseRange">ExpParseRange</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pseudo.htm#PseudopcFOR">PseudopcFOR</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t2641.htm">t2641</a>
</dd>
</dl><pre>
CtxForNext Procedure CtxPtr
RangeRightPtr  LocalVar
RangeRightSize LocalVar
CtxForNumber   LocalVar Size=20                  ; Room for the expanded number.
     MOV EBX,[%CtxPtr]
     MOV EDI,[EBX+CTX.ObjPtr]                    ; ^CTX_FOR
     JSt [EBX+CTX.Status],ctxIsRange,.60:
 .20:MOV EDX,[EDI+CTX_FOR.OrdinalNr]             ; Get the next ordinal.
     INC EDX
     CMP [EDI+CTX_FOR.NrOfOrdinals],EDX
     JC .99: ; No more ordinals.
     MOV [EDI+CTX_FOR.OrdinalNr],EDX
     BufferRetrieve [EBX+CTX.OrdBuffer]
     LEA ESI,[ESI+8*EDX-8]                       ; ESI now points to pair OrdValuePtr,OrdValueSize.
     MOV ECX,[ESI+4]
     MOV ESI,[ESI]
     LEA EDX,[ESI+ECX]
     Invoke ExpParseRange::,ESI,EDX
     JNC .30:                                    ; If the ordinal is numeric range.
     RstSt [EBX+CTX.Status],ctxIsRange
     MOV EDI,ESI
     MOV EDX,ECX
     BufferRetrieve [EBX+CTX.FrmBuffer]
     MOV [ESI+8],EDI                             ; Copy nonrange operand to formal variable value.
     MOV [ESI+12],EDX
     JMP .90:
 .30:SetSt [EBX+CTX.Status],ctxIsRange           ; %FOR loop has just enterred the next numeric range operand.
    ; ESI..EDX is <b>range source notation</b>, EAX points behind the range operator.
     SUB EDX,EAX 
     MOV [%RangeRightPtr],EAX                    ; Save it for later evaluation.
     MOV [%RangeRightSize],EDX
     LEA ECX,[EAX-2]
     SUB ECX,ESI
     Invoke ExpEvalNum::,ESI,ECX                 ; RangeLeft evaluation.
     JC .20:                                     ; If syntax error, report Msg and go to the next operand.
     MOV [EDI+CTX_FOR.RangeLeft+0],EAX
     MOV [EDI+CTX_FOR.RangeLeft+4],EDX
     Invoke ExpEvalNum::,[%RangeRightPtr],[%RangeRightSize]
     JC .20:                                     ; If syntax error, report Msg and go to the next operand.
     MOV [EDI+CTX_FOR.RangeRight+0],EAX
     MOV [EDI+CTX_FOR.RangeRight+4],EDX
     JNSt [EBX+CTX.Status],ctxStep0,.40:
    ; If <b>STEP=0</b>, it will be actually +1 or -1.
     SUB ECX,ECX 
     SUB EAX,[EDI+CTX_FOR.RangeLeft+0]
     SBB EDX,[EDI+CTX_FOR.RangeLeft+4]
     JS .35:                                     ; If range slope negative.
     MOV [EDI+CTX_FOR.Step+4],ECX 
     INC ECX
     MOV [EDI+CTX_FOR.Step+0],ECX                ; Step:= +1.
     JMPS .40:
 .35:DEC ECX                                     ; Negative range slope.
     MOV [EDI+CTX_FOR.Step+0],ECX
     MOV [EDI+CTX_FOR.Step+4],ECX                ; Step:= -1.
 .40:JSt [EBX+CTX.Status],ctxStep0,.50:
     ; If nonzero range <b>slope differs</b> from the step sign, this operand will be skipped.
     MOV EAX,[EDI+CTX_FOR.RangeRight+0]
     MOV EDX,[EDI+CTX_FOR.RangeRight+4]
     SUB EAX,[EDI+CTX_FOR.RangeLeft+0]
     SBB EDX,[EDI+CTX_FOR.RangeLeft+4]
     JS .45:                                     ; If the range slope is negative.
     JNZ .43:                                    ; If the range slope is positive.
     TEST EAX
     JZ .50:                                     ; If the range slope is zero, e.g.  "1..1"
 .43:; Range <b>slope is positive</b>.
     TESTB [EDI+CTX_FOR.Step+7],0x80
     JNZ .20:                                    ; Ignore this range when the step is negative.
     JMPS .50:
 .45:TESTB [EDI+CTX_FOR.Step+7],0x80
     JZ .20:                                     ; If range slope is negative and step is positive, skip the operand.
 .50:MOV EAX,[EDI+CTX_FOR.RangeLeft+0]           ; Start with the left range value.
     MOV EDX,[EDI+CTX_FOR.RangeLeft+4]
     MOV [EDI+CTX_FOR.Value+0],EAX
     MOV [EDI+CTX_FOR.Value+4],EDX
     JMP .80:
 .60: ; %FOR processing is <b>inside a numeric range</b>.
     MOV EAX,[EDI+CTX_FOR.Value+0]
     MOV EDX,[EDI+CTX_FOR.Value+4]
     ADD EAX,[EDI+CTX_FOR.Step+0]
     ADC EDX,[EDI+CTX_FOR.Step+4]
     MOV [EDI+CTX_FOR.Value+0],EAX
     MOV [EDI+CTX_FOR.Value+4],EDX
     TESTB [EDI+CTX_FOR.Step+7],0x80
     JNZ .70:
     CMP EDX,[EDI+CTX_FOR.RangeRight+4]           ; Step is positive. EDX:EAX is the incremented formal value.
     JL .80: 
     JG .20:                                      ; Out of range, continue with the next operand.
     CMP EAX,[EDI+CTX_FOR.RangeRight+0]
     JBE .80:
     JMP .20:                                     ; Out of range, continue with the next operand.
 .70:CMP EDX,[EDI+CTX_FOR.RangeRight+4]           ; Step is negative. EDX:EAX is the decremented formal value.
     JG .80:
     JL .20:                                      ; Out of range, continue with the next operand.
     CMP EAX,[EDI+CTX_FOR.RangeRight+0]
     JB .20:                                      ; Out of range, continue with the next operand.
 .80: ; <b>Convert CTX_FOR.Value to decadic</b> into CTX.KeyBuffer and update CTX.FrmBuffer.
     BufferClear [EBX+CTX.KeyBuffer]
     LEA ECX,[%CtxForNumber]
     MOV EAX,[EDI+CTX_FOR.Value+0]
     MOV EDX,[EDI+CTX_FOR.Value+4]
     StoQD ECX,Size=20,Signed=yes
     SUB EDI,ECX                                  ; Context.KeyBuffer will be misused to persistently keep the formal value.
     BufferStore [EBX+CTX.KeyBuffer],ECX,EDI
     BufferRetrieve [EBX+CTX.KeyBuffer]
     MOV EAX,ESI
     BufferRetrieve [EBX+CTX.FrmBuffer]
     MOV [ESI+8],EAX                              ; Pointer within KeyBuffer.
     MOV [ESI+12],EDI                             ; Number of digits in decadic value.
 .90:CLC
.99:EndProcedure CtxForNext
</pre>

<dl id="CtxExpansionNrUpdate">
<dt><a href="#top">&uarr; CtxExpansionNrUpdate</a> CtxPtr, StmPtr</dt>
<dd>CtxExpansionNrUpdate will load and increment Pass.ExpansionNr and copy it to Ctx.ExpansionNr.
<!---->It will also report E7140 when ExpansionNr is greater than allowed MAXEXPANSIONS number,
<!---->which may happen by programmer's mistake in endless loop.</dd>
<dt>Input</dt>
<dd><b>CtxPtr</b> Current expandable context.
<br/><b>StmPtr</b> Current parsed statement.</dd>
<dt>Output</dt>
<dd><b>CF=0</b> ExpansionNr incremented in pass and context.</dd>
<dt>Error</dt>
<dd><b>CF=1</b> MAXEXPANSIONS reached. ExpansionNr incremented, 
<!---->error E7140 reported by <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pseudo.htm#PseudopcFOR">PseudopcFOR</a>
<a class="EXT" href="pseudo.htm#PseudopcMACRO">PseudopcMACRO</a>
<a class="EXT" href="pseudo.htm#PseudopcREPEAT">PseudopcREPEAT</a>
<a class="EXT" href="pseudo.htm#PseudopcWHILE">PseudopcWHILE</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t7362.htm">t7362</a>
</dd>
</dl><pre>
CtxExpansionNrUpdate Procedure CtxPtr, StmPtr
      MOV EBX,[%StmPtr]
      MOV EDI,[%CtxPtr]
      MOV ESI,[EBX+STM.Program]
      TEST ESI
      JZ .90:
      MOV ECX,[ESI+PGM.PassPtr]
      JECXZ .90:
      MOV EAX,[ECX+PASS.ExpansionNr]
      INC EAX
      MOV [ECX+PASS.ExpansionNr],EAX
      MOV [EDI+CTX.ExpansionNr],EAX
      LEA ESI,[ESI+PGM.Pgmopt]
      DEC EAX
      MOV ECX,[ESI+PGMOPT.MaxExpansions]
      CMP EAX,ECX
      CMC
      Msg cc=E,'7140',ECX                        ; Number of expansions exceeded MAXEXPANSIONS=!1D.
 .90:EndProcedure CtxExpansionNrUpdate
</pre>

<dl id="Ctx1stRepeat">
<dt><a href="#top">&uarr; Ctx1stRepeat</a></dt>
<dd>Ctx1stRepeat inspect all contexts of ctxRepeat type, and returns 
<!----><code>ctx1stRepeat</code> if all those underlying contexts
<!---->have ctx1stRepeat set. Otherwise it returns <code>0</code>.</dd>
<dt>Input</dt>
<dd><b>-</b></dd>
<dt>Output</dt>
<dd><b>EAX=</b>0 or ctx1stRepeat.</dd>
<dt>Error</dt>
<dd><b>-</b> not expected.</dd>
<dt>Invokes</dt>
<dd><a href="#CtxPeek">CtxPeek</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pseudo.htm#PseudopcFOR">PseudopcFOR</a>
<a class="EXT" href="pseudo.htm#PseudopcREPEAT">PseudopcREPEAT</a>
<a class="EXT" href="pseudo.htm#PseudopcWHILE">PseudopcWHILE</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t2751.htm">t2751</a>
</dd>
</dl><pre>
Ctx1stRepeat Procedure
     SUB EAX,EAX
     MOV EDX,ctx1stRepeat
 .10:Invoke CtxPeek,ctxRepeat,EAX
     JC .90:
     JSt [EAX+CTX.Status],ctx1stRepeat,.10:
     XOR EDX,EDX
 .90:MOV [%ReturnEAX],EDX
     EndProcedure Ctx1stRepeat
</pre>

<dl id="CtxStatusAll">
<dt><a href="#top">&uarr; CtxStatusAll</a></dt>
<dd>CtxStatusAll returns statuses from all contexts on stack, logically ORed.</dd>
<dt>Input</dt>
<dd><b>-</b></dd>
<dt>Output</dt>
<dd><b>EAX</b>=Logical OR from all Ctx.statuses on CtxStack.</dd>
<dt>Error</dt>
<dd><b>-</b></dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="stm.htm#StmParse">StmParse</a>
<a class="EXT" href="var.htm#VarExpand">VarExpand</a>
</dd>
</dl><pre>
CtxStatusAll Procedure
     MOV EBX,[Src.CtxStack::]
     XOR ECX,ECX
     StackPeekLast EBX
     JC .90:
     OR ECX,[EAX+CTX.Status]
 .20:StackPeekPrev EBX,EAX
     JC .90:
     OR ECX,[EAX+CTX.Status]
     JMP .20:     
 .90:MOV [%ReturnEAX],ECX
    EndProcedure CtxStatusAll
</pre>

<dl id="CtxFind">
<dt><a href="#top">&uarr; CtxFind</a> CtxType, StmPtr</dt>
<dd><dfn>CtxFind</dfn> searches context stack for the given CtxType with matching block identifier.
<!---->The block identifier in statement is delocalized first, however, if given CtxType has
<!---->ctxNamespace property, this context is not used for delocalization.
<br/>If no matching blockId found, it returns the first context with matching CtxType.
<br/>CtxFind does not change the context stack and does not report errors.
<!---->It is invoked from ENDblock and EXITblock handlers.</dd>
<dt>Input</dt>
<dd><b>CtxType</b> One of <a href="#CtxEnc">Ctx.Status</a>:ctxAnyType flag.
<br/><b>StmPtr</b> Pointer to a parsed <a class="EXT" href="stm.htm#STM">STM
</a> currently processed (ENDblock or  EXITblock). It may be 0, no block matching is performed in this case, returned ZF=0.</dd>
<dt>Output</dt>
<dd><b>CF=0 EAX=</b> pointer to <a href="#CTX">CTX</a> of requested type on the context stack.
<br/><b>ZF=1</b> if block identifiers match.
<br/><b>ZF=0</b> if CtxType found but block identifiers do not match.</dd>
<dt>Error</dt>
<dd><b>CF=1 EAX=0</b> if no context of CtxType was on the stack.</dd>
<dt>Example</dt><dd class="PRE"> Invoke CtxEnd, ctxFOR, EBX
<!---->  JC UnexpectedENDblock
<!---->  JZ UnmatchedENDblock</dd>
<dt>See also</dt>
<dd><a href="#CtxDiscard">CtxDiscard</a>.</dd>
<dt>Invokes</dt>
<dd><a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
<a class="EXT" href="sym.htm#SymDelocalName">SymDelocalName</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="chunk.htm#ChunkInclude">ChunkInclude</a>
<a class="EXT" href="pseudo.htm#PseudoENDPROC">PseudoENDPROC</a>
<a class="EXT" href="pseudo.htm#PseudoENDPROC1">PseudoENDPROC1</a>
<a class="EXT" href="pseudo.htm#PseudoENDPROGRAM">PseudoENDPROGRAM</a>
<a class="EXT" href="pseudo.htm#PseudoENDSTRUC">PseudoENDSTRUC</a>
<a class="EXT" href="pseudo.htm#PseudoPROGRAM">PseudoPROGRAM</a>
<a class="EXT" href="pseudo.htm#PseudopcELSE">PseudopcELSE</a>
<a class="EXT" href="pseudo.htm#PseudopcENDCOMMENT">PseudopcENDCOMMENT</a>
<a class="EXT" href="pseudo.htm#PseudopcENDFOR">PseudopcENDFOR</a>
<a class="EXT" href="pseudo.htm#PseudopcENDIF">PseudopcENDIF</a>
<a class="EXT" href="pseudo.htm#PseudopcENDMACRO">PseudopcENDMACRO</a>
<a class="EXT" href="pseudo.htm#PseudopcENDREPEAT">PseudopcENDREPEAT</a>
<a class="EXT" href="pseudo.htm#PseudopcENDWHILE">PseudopcENDWHILE</a>
<a class="EXT" href="pseudo.htm#PseudopcEXITFOR">PseudopcEXITFOR</a>
<a class="EXT" href="pseudo.htm#PseudopcEXITMACRO">PseudopcEXITMACRO</a>
<a class="EXT" href="pseudo.htm#PseudopcEXITREPEAT">PseudopcEXITREPEAT</a>
<a class="EXT" href="pseudo.htm#PseudopcEXITWHILE">PseudopcEXITWHILE</a>
<a class="EXT" href="stm.htm#StmParseSET">StmParseSET</a>
</dd>
</dl><pre>
CtxFind Procedure CtxType, StmPtr
     MOVD [%ReturnEAX],0
     MOV EDX,[%CtxType]
     MOV EBX,[%StmPtr]
     StackPeekLast [Src.CtxStack::]
     JMPS .20:
 .10:StackPeekPrev [Src.CtxStack::],EDI
 .20:MOV CL,-1                                  ; Signalize that no matching blockId was found.
     JC .70:                                    ; If the context stack is empty.
     MOV EDI,EAX
     JNSt [EDI+CTX.Status],EDX,.10:
     CMPD [%ReturnEAX],0
     JNZ .30:
     MOV [%ReturnEAX],EDI                        ; Prepare to return the first context found for the case of not-matching blockId.
 .30:TEST EBX                                    ; EDI is context of desired type. If StmPtr provided, check blockId.
     JZ .80:                                     ; If blockId match cannot be tested, the 1st context will be used.
     MOV ESI,[EBX+STM.LabelPtr] 
     MOV ECX,[EBX+STM.LabelSize]
     CMPD [EBX+STM.OperationData],PseudopcENDREPEAT::, IMM=DWORD
     JE .40:
     CMPD [EBX+STM.OperationData],PseudopcUNTIL::, IMM=DWORD
     JE .40:
     BufferRetrieve [EBX+STM.OrdBuffer]          ; Other than %ENDREPEAT have blockId in 1st ordinal.
     TEST ECX
     JZ .80:                                     ; Empty ENDblockId is always matching.
     MOV ECX,[ESI+4]
     MOV ESI,[ESI+0]
     StripColons ESI,ECX                         ; Get rid of trailing colon(s), if any.
 .40:TEST ECX                                    ; ESI,ECX is now the ENDblock identifier.
     JZ .80:                                     ; Empty ENDblockId is always matching.
     Invoke EaBufferReserve::,CtxFind
     Invoke SymDelocalName::,ESI,ECX,EAX,memberDelocalParent ; In case that block name has local scope.
     BufferRetrieve EAX
     Invoke EaBufferRelease::,EAX
 .50:Compare [EDI+CTX.NamePtr],[EDI+CTX.NameSize],ESI,ECX
     MOV CL,0                                    ; Mark matching blockId found.
     JE .80:                                     ; If blockId match, done. ZF=1.
     JMP .10:                                    ; Otherwise try to find a better context.
 .70:; Stack peeked but <b>no matching blockId found</b>.
     MOV EDI,[%ReturnEAX] 
 .80:MOV [%ReturnEAX],EDI                        ; EDI=0 if no CtxType found. CL=0 if blockId match.
     TEST EDI
     STC
     JZ .90:                                     ; Return CF=ZF=1 if no such context is on stack.
     TEST CL                                     ; Return CF=0, ZF=1 if blockId match, otherwise CF=ZF=0.
 .90:EndProcedure CtxFind
</pre>

<dl id="CtxDiscard">
<dt><a href="#top">&uarr; CtxDiscard</a> CtxPtr, StmPtr</dt>
<dd>CtxDiscard will pop the context pointed to with CtxPtr (and all above, if any)
<!---->and, if not <code>Stm.CtxStatusAll:ctxExited</code>, report E7110 or E7120 on each block mismatch detected.</dd>
<dt>Input</dt>
<dd><b>CtxPtr</b> is pointer to <a href="#CTX">CTX</a> to be discarded (popped and destroyed).
<!---->It must point to an existing context on stack.
<br/><b>StmPtr</b> is pointer to ENDblock parsed statement <a class="EXT" href="stm.htm#STM">STM</a>.</dd>
<dt>Output</dt>
<dd>Specified context is removed from stack, block ends.</dd>
<dt>Error</dt>
<dd><b>CF=</b>1 Error E7110 is reported with macro <a class="EXT" href="msg.htm#Msg">Msg</a>.</dd>
<dt>See also</dt>
<dd><a href="#CtxFind">CtxFind</a>.</dd>
<dt>Invokes</dt>
<dd><a href="#CtxDestroy">CtxDestroy</a>
<a href="#CtxGetEndTypename">CtxGetEndTypename</a>
<a class="EXT" href="ea.htm#EaBufferRelease">EaBufferRelease</a>
<a class="EXT" href="ea.htm#EaBufferReserve">EaBufferReserve</a>
</dd>
<dt>Invoked by</dt>
<dd><a class="EXT" href="pseudo.htm#PseudoENDPROC">PseudoENDPROC</a>
<a class="EXT" href="pseudo.htm#PseudoENDPROC1">PseudoENDPROC1</a>
<a class="EXT" href="pseudo.htm#PseudoENDPROGRAM">PseudoENDPROGRAM</a>
<a class="EXT" href="pseudo.htm#PseudoENDSTRUC">PseudoENDSTRUC</a>
<a class="EXT" href="pseudo.htm#PseudopcENDCOMMENT">PseudopcENDCOMMENT</a>
<a class="EXT" href="pseudo.htm#PseudopcENDFOR">PseudopcENDFOR</a>
<a class="EXT" href="pseudo.htm#PseudopcENDIF">PseudopcENDIF</a>
<a class="EXT" href="pseudo.htm#PseudopcENDMACRO">PseudopcENDMACRO</a>
<a class="EXT" href="pseudo.htm#PseudopcENDREPEAT">PseudopcENDREPEAT</a>
<a class="EXT" href="pseudo.htm#PseudopcENDWHILE">PseudopcENDWHILE</a>
</dd>
<dt>Tested by</dt>
<dd><a class="EXT" href="../eatests/t1210.htm">t1210</a>
</dd>
</dl><pre>
CtxDiscard Procedure CtxPtr, StmPtr
CtxDbuffer LocalVar                              ; Temporary buffer for contextes with NESTINGCHECK=OFF.
     Invoke EaBufferReserve::,CtxDiscard
     MOV [%CtxDbuffer],EAX
     MOV ESI,[%CtxPtr]
     MOV EBX,[%StmPtr]
     TEST ESI
     JZ .80:
     MOV EDX,[ESI+CTX.Status]
     AND EDX,ctxAnyType
 .10:StackPop [Src.CtxStack::]
     JC .60:
     MOV EDI,EAX
     CMP EDI,[%CtxPtr]
     JE .50:                                     ; If this is the context to discard.
     JSt [EBX+STM.CtxStatusAll],ctxExited,.50:   ; On EXITblock do not report mismatch.
     JNSt [EBX+STM.CtxStatusAll],ctxNestingOff,.20:
     ; If any context on stack has <b>ctxNestingOff</b>, do not report mismatch and
     ;   do not remove contexts above the one which is being discarded. Store them to CtxDbuffer instead.
     BufferStore [%CtxDbuffer],EDI,SIZE#CTX      ; Silently save it to be pushed back later in .70:.
     JMP .10: 
 .20:JNSt [EBX+STM.CtxStatusAll],ctxRepeat,.30:
     JNSt [EBX+STM.CtxStatusAll],ctx1stRepeat,.50:
 .30:Invoke CtxGetEndTypename,[EDI+CTX.Status]
     JNSt [EDI+CTX.Status],ctxREPEAT,.40:
     XCHG EAX,EDI
 .40:Msg '7110',EAX,EDI                          ; Wrong nesting, expected "!1S !2S".',0
 .50:Invoke CtxDestroy,EDI
     CMP EDI,[%CtxPtr]
     JNE .10:
 .60:BufferRetrieve [%CtxDbuffer]                ; Zero or more undestroyed CTX objects.
 .70:LEA EDI,[ESI+ECX-SIZE#CTX]                  ; The last one.
     CMP EDI,ESI
     JB .80:                                     ; If no more saved contexts.
     StackPush [Src.CtxStack::],EDI              ; Return contexts back to stack in original order.
     SUB ECX,SIZE#CTX
     JMP .70:
 .80:Invoke EaBufferRelease::,[%CtxDbuffer]     
 .90:EndProcedure CtxDiscard
</pre>
<pre>
   ENDPROGRAM ctx
</pre><!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
