<!doctype html><html lang='en'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='&euro;ASM file tsrup.htm'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>tsrup.htm</title>
</head>
<body class='OBJLIB' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>tsrup.htm
<br/><a href="#AllocUMB">AllocUMB</a>
<br/><a href="#Header">Header</a>
<br/><a href="#InstallationCheck">InstallationCheck</a>
<br/><a href="#InstallConventional">InstallConventional</a>
<br/><a href="#InstallUpper">InstallUpper</a>
<br/><a href="#Interrupt_routine">Interrupt_routine</a>
<br/><a href="#Main">Main</a>
<br/><a href="#Uninstall">Uninstall</a>
</h1>
<p><dfn>Terminate and Stay Resident</dfn> (TSR) are 16bit programs which provide services
<!---->for  other  DOS  programs.  This  is  similar  to  device drivers which are
<!---->installed to memory  during DOS boot. Unlike devices,  properly written TSR
<!---->programs can be  installed ad hoc and easily removed  from memory when they are no longer needed.</p>
<p>To understand how TSRs are installed  into memory, we must be familiar with
<!---->the concept  of <strong>memory allocation</strong>  in DOS.  MS-DOS  quantitizes memory into
<!---->16 bytes long chunks  called <dfn>paragraphs</dfn>. Each block of memory is prefixed
<!---->with  one additional  paragraph, <a class="EXT" href="../maclib/doss.htm#MCB">Memory  Control Block
</a>  (MCB), which  holds information  about its block and links to the next, immediately following MCB. When a process
<!---->requests a memory block allocation, DOS  must rearrange the chain of memory
<!---->blocks, reserve continuous block of requested  size and mark it as occupied
<!---->by the process  in question. When user launches  a COM program from command
<!---->line, the command interpreter  (typically COMMAND.COM) allocates two memory blocks:
<ol><li>one small for the copy of master environment strings, and</li>
<li>the second block for the Program Segment Prefix (PSP) and adjacent program body.</li></ol>
<p>All available conventional memory is given to the executed program.</p>
<p>DOS will  deallocate (=mark as  free) both memory  blocks when the  program terminates normally.
<!---->If TSR program  wants DOS to not deallocate all its
<!---->memory  upon termination,  it has  to exit with call to special DosAPI
<!---->function AH=31h and  tell DOS  how many  paragraphs of terminating program's
<!---->memory  should be left allocated. Such resident block decreases the
<!---->amount of memory available for launching other programs.</p>
<blockquote>The largest possible executable program size can be inspected with the DOS utility
<code>MEM.EXE</code>.</blockquote>
<p>Conventional memory is a critical resource in DOS. All devices and TSR
<!---->programs  should be optimised  to minimise the occupied amount of resident memory.</p>
<p>This example TSR shifts the resident code at installation and
<!---->overwrites FCB and DTA portion of <a class="EXT" href="../maclib/doss.htm#PSP">PSP
</a> which would otherwise remain unused. With this technique it occupies only 128 bytes.</p>
<dl><dd class="PRE">
<!----> <abbr>        Before installation           After InstallConventional</abbr>
<!---->
<!---->               &#x2502;           &#x2502;             &#x2502;           &#x2502;
<!---->               &#x2502;  free,    &#x2502;             &#x2502;           &#x2502;
<!---->               &#x2502; allocated &#x2502;             &#x2502;           &#x2502;
<!---->               &#x2502;  to COM   &#x2502;             &#x2502;           &#x2502;
<!---->               &#x2502;  program  &#x2502;             &#x2502;           &#x2502;
<!---->               &#x2502;           &#x2502;             &#x2502;           &#x2502;
<!---->       &#x250C;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;             &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;             &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;             &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;             &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;             &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;install&#x2591;&#x2591;&#x2502;             &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;code&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;             &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;             &#x2502;           &#x2502;
<!---->       &#x2502;   Main&#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;             &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;             &#x2502;           &#x2502;
<!---->       &#x2502; TsrTop&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2510;           &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2502; &#x2502;           &#x2502;           &#x2502;
<!---->  COM &#x2500;&#x2524;       &#x2502;&#x2593;&#x2593;resident&#x2593;&#x2502; &#x2502;           &#x2502;           &#x2502;
<!----> file  &#x2502;       &#x2502;&#x2593;&#x2593;&#x2593;code&#x2593;&#x2593;&#x2593;&#x2593;&#x2502; &#x251C;&#x2500;&#x2510;         &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2502; &#x2502; &#x2502;         &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2502; &#x2502; &#x2502;         &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2502; &#x2502; &#x2502;         &#x2502;           &#x2502;
<!---->       &#x2502; NewInt&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2518; &#x2502;         &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;JMP Main&#x2591;&#x2591;&#x2502;   &#x2502;         &#x2502;           &#x2502;
<!---->       &#x2514;  100h &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;   &#x2502;         &#x2502;           &#x2502;
<!---->       &#x250C;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;   &#x2502;         &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;   &#x2502;Shift    &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;   &#x2502;         &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;   &#x2502;         &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;   &#x2502;         &#x2502;  free     &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;   &#x2502;         &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;   &#x2502;         &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;   &#x2502;         &#x2502;           &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;   &#x2502; &#x250C;       &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2510;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;   &#x2502; &#x2502;       &#x2502;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2502; &#x2502;
<!---->  PSP &#x2500;&#x2524;       &#x2502;&#x2591;.DTA&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;   &#x2502; &#x2502;       &#x2502;&#x2593;&#x2593;resident&#x2593;&#x2502; &#x2502;
<!---->       &#x2502;   80h &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;   &#x2514;&gt;&#x2524;       &#x2502;&#x2593;&#x2593;&#x2593;code&#x2593;&#x2593;&#x2593;&#x2593;&#x2502; &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;.FCB&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;     &#x2502;       &#x2502;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2502; &#x2502;
<!---->       &#x2502;       &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;     &#x2502;       &#x2502;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2502; &#x2502;
<!---->       &#x2502;       &#x2502;.Reserved53&#x2502;     &#x2502;       &#x2502;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2593;&#x2502; &#x2502;
<!---->       &#x2502;   53h &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;     &#x2514;   53h &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;occupied
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;             &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502; by TSR
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502;             &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;
<!---->       &#x2502;       &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;             &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;.EnvSeg&#x2591;&#x2591;&#x2591;&#x2502;&#x2500;&#x2510;           &#x2502;&#x2591;.EnvSeg&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;
<!---->       &#x2502;   2Ch &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;       2Ch &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;           &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;
<!---->       &#x2502;       &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;           &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;
<!---->       &#x2514;   00h &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;       00h &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2518;
<!---->               &#x2502;  MCB      &#x2502; &#x2502;           &#x2502;  MCB      &#x2502;
<!---->               &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;           &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
<!---->                             &#x2502;
<!---->                             &#x2502;
<!---->                             &#x2502;
<!---->               &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510; &#x2502;           &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
<!---->               &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;           &#x2502;           &#x2502;
<!---->               &#x2502;&#x2591;env. vars&#x2591;&#x2502; &#x2502;           &#x2502; free      &#x2502;
<!---->               &#x2502;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2591;&#x2502; &#x2502;           &#x2502;           &#x2502;
<!---->               &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&lt;&#x2518;           &#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
<!---->               &#x2502;  MCB      &#x2502;             &#x2502;  MCB      &#x2502;
<!---->               &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;             &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</dd></dl>
<dl><dd>
<p><strong>TSRUP</strong> is a skeleton of simple <em>Terminate and Stay Resident</em> (TSR) program
<!---->for DOS which keeps the NumLock indicator ON all the time while it is installed.
<!---->Of course, this is not much useful function, but its functionality is easy to extend.</p>
<p>This sample also demonstrates some techniques how to keep the size of memory permanently occupied by
<!---->the TSR as low as possible:<ul>
<li>it deallocates the block of memory with copy of environment variables assigned to the program,</li>
<li>it utilizes the useless tail of PSP, which starts at
<a class="EXT" href="../maclib/doss.htm#PSP">PSP.Reserved53</a>,</li>
<li>it installs itself to the memory above videoram (HIMEM),
<!---->so the installed TSR doesn't decrease the memory available to other programs at all,</li>
<li>it is able to uninstall itself from memory completely, without reboot.</li></ul></dd></dl>
<dl>
<dt>Format</dt><dd>COM TSR</dd>
<dt>Platform</dt><dd>DOS. NumLock is kept on in Windows 95|98 too, but not in Windows NT and higher versions.</dd>
<dt>See also</dt><dd><a class="EXT" href="tsrclock.htm">tsrclock</a> for a more primitive TSR program..</dd>
<dt>Build</dt><dd><code> euroasm tsrup.htm</code></dd>
<dt>Run</dt><dd><code>tsrup.com /I</code></dd>
</dl>
<dl id="Header"><dt><a href="#top">Header</a></dt><dd><p>All program with Format=COM must start at CS:256,
<!---->so we must put a JMP instruction in the beginning to skip the resident code.</p>
</dd></dl><pre>
          EUROASM
%Active   %SETC '$'            ; Markers used to modify the first byte of TsrIdentifier.
%Passive  %SETC '-'
tsrup  PROGRAM Format=COM,Width=16
          INCLUDE "doss.htm"   ; Uses the structure <a class="EXT" href="../maclib/doss.htm#PSP">PSP</a>.
          INCLUDE "dosapi.htm" ; Uses macros <a class="EXT" href="../maclib/dosapi.htm#DosAPI">DosAPI</a> and <a class="EXT" href="../maclib/dosapi.htm#StdOutput">StdOutput</a>.
[COM]     SEGMENT Purpose=CODE+DATA+RODATA
          JMP Main:                      ; Fixed entry point of COM programs requires to skip the resident division.
</pre>

<dl id="Interrupt_routine"><dt><a href="#top">Interrupt routine</a></dt><dd>
<p>New handler for interrupt(s) does the actual TSR's job.
<!---->The far jump at its end chains this handler to previously installed handlers (if any)
<!---->and, finally, to the  original BIOS handler which sends acknowledgement
<!---->to the interrupt controller 8259 and provides the final IRET from the interruption.</p>
<p>This program hooks interrupt 8 which is invoked by hardware timer every 55 ms.
<!---->As we don't need to update NumLock status
<!---->that often, the update code will be executed only once per 16 interruptions.</p>
<p>The actual function of this TSR, keeping NumLock ON permanently, is achieved by
<!---->periodical setting NumLock flag in ROM-BIOS area.
<!---->The NumLock LED indicator will keep pace with this bit (at least in DOS and Windows9x).
</p>
<h6>Interrupt handlers should perform very fast, without waiting for user interaction
<!---->or huge data manipulation. </h6>
<p>When routine NewInt08 is called by hardware-invoked interruption signal, CS:IP points to NewInt08,
<!---->other registers are undefined and must be preserved.
<br/>Instruction <code>JMP 0:0</code> near its end (immediate segment:offset in the JMP instruction body)
<!---->will be referred as OldInt08 and replaced with current INT 08 vector taken from the interrupt table
<!---->at installation-time. </p>
<p>Actual resident code is claimed between labels TsrBottom and TsrTop.</p>
</dd></dl><pre>
TsrBottom:                              ; Here starts the resident code.
NewInt08 PROC DIST=FAR                  ; New handler for interrupt which does the actual TSR's job.
         PUSHF                          ; All registers and flags must be preserved.
         PUSH AX
          MOV AL,[CS:IntCounter]
          INC AL
          CMP AL,16
          JB .Skip:                     ; Execute only once per 16 interruptions.
          PUSH DS
           SUB AX,AX
           MOV DS,AX                    ; Keyboard status in ROM-BIOS will be referenced at segment 0.
           OR [0x0417],0x20,DATA=BYTE   ; Set NumLock status bit in ROM-BIOS area at 0:0417h.
          POP  DS
  .Skip:  MOV [CS:IntCounter],AL
         POP AX
         POPF
         JMP 0:0                        ; Continue with older INT 08 handlers.
OldInt08 EQU $-4                        ; Previous vector value is kept in the body of JMPF instruction.
         ENDP NewInt08
IntCounter    DB 0                      ; Incremented on every INT 08 invocation, zeroed when it reaches 16.
TsrIdentifier DB '%Passive','%^PROGRAM' ; Unique identifier of this program in memory, actually <kbd>-tsrup</kbd>.
TsrTop:                                 ; Here the resident code ends.
</pre>

<dl id="Main"><dt><a href="#top">Main</a></dt><dd>The main program body reads the switch of requested action
<!---->(installation or uninstallation) from the command-line, performs the action
<!---->and writes informative or help message to the Standard Output.</dd>
</dl><pre>
MsgHelp DB "Installed resident program '%^PROGRAM' keeps the NumLock permanently ON.",13,10
        DB "Options:  /C alias Conventional memory installation",13,10,
        DB "          /I alias Install to upper memory (HIMEM)",13,10
        DB "          /U alias Uninstall from memory.",13,10,0
Main PROC
     ; <b>Simplified parsing</b> will get the requested action (DL='I','C','U')
     ;        from the first letter found on the command line.
     MOV SI,PSP.CmdArgSize
     CLD
     SUB AX,AX
     LODSB
     MOV CX,AX                       ; Number of characters in the command line.
     JECXZ Help:                     ; If program launched without arguments.
.10: LODSB                           ; Get the next character.
     OR AL,'X'^'x'                   ; Convert the letter to a lower case.
     Dispatch AL,'c','i','u'         ; Acceptable first letters of supported actions.
     LOOP .10:                       ; Otherwise try the next character.
Help:StdOutput MsgHelp               ; If no valid action was specified.
     TerminateProgram Errorlevel=8
.c:
.i:
.u:  AND AL,~'X'^'x'                 ; Convert the letter to upper case.
     MOV DL,AL                       ; Requested action ('C','I' or 'U') is now in the register DL.
     ; Program doesn't use <b>environment variables</b>, they can be freed now.
     MOV ES,[PSP.EnvSeg]             ; Paragraph address of environment is at DS:0x002C.
     DosAPI AH=0x49                  ; Release the block of memory at segment ES.
     ; Prepare to <b>hook interrupt handlers</b>.
     DosAPI AX=0x3508                ; Get current INT 08 vector to ES:BX.
     MOV [OldInt08+0],BX             ; Let the new handler continue with the old vector ES:BX.
     MOV [OldInt08+2],ES
     ; PSP is no longer needed, it may be overwritten from <code>PSP.Reserved53</code> upwards.
     ; The resident code <code>TsrBottom .. TsrTop</code> will be shifted backward to spare the occupied memory.
Shift EQU TsrBottom - PSP.Reserved53 ; The amount is known at assembly-time (0xB0 bytes).
      PUSH DS
      POP ES                         ; Restore ES back to the common PSP segment.
      MOV SI,TsrBottom               ; Start of resident code.
      MOV DI,PSP.Reserved53          ; New offset of resident code.
      MOV CX,TsrTop - TsrBottom      ; Size of the shifted resident in bytes.
      REP MOVSB                      ; Perform the shift.
      Dispatch DL,'I','U'            ; Perform the requested action stored in DL.
      ; Action 'C': <b>Conventional TSR installation</b> to lower memory.
      CALL InstallationCheck
      JZ .40:
.30:  StdOutput =B"'%^PROGRAM' is already installed, use '%^PROGRAM Uninstall' first.",Eol=Yes
      TerminateProgram Errorlevel=4
.40:  StdOutput =B"'%^PROGRAM' was installed to conventional memory.",Eol=Yes
      JMP InstallConventional
.I:   ; Action 'I': <b>Install TSR to upper memory</b>.
      CALL InstallationCheck
      JNZ .30:
      MOV CX,TsrTop-Shift+15
      SHR CX,4
      CALL AllocUMB                  ; Allocate CX paragraphs of the upper memory.
      JNC .50:
      StdOutput =B"'%^PROGRAM' could not be installed to upper memory. Use '%^PROGRAM Conv' instead.",Eol=Yes
      TerminateProgram Errorlevel=4
.50:  StdOutput =B"'%^PROGRAM' was installed to upper memory.",Eol=Yes
      JMP InstallUpper
.U:   ; Action 'U': <b>Uninstall from memory</b>.
      CALL InstallationCheck
      JNZ .60:
      StdOutput =B"'%^PROGRAM' was not installed yet.",Eol=Yes
      TerminateProgram Errorlevel=4
.60:  CALL Uninstall
      JNC .70:
      StdOutput =B"'%^PROGRAM' could not be uninstalled, some other TSR program was installed after it.",Eol=Yes
      TerminateProgram Errorlevel=4
.70:  StdOutput =B"'%^PROGRAM' was uninstalled from memory.",Eol=Yes
      TerminateProgram Errorlevel=0
 ENDP Main
</pre>

<dl id="InstallationCheck"><dt><a href="#top">InstallationCheck</a></dt><dd><p>Good TSR program will not allow installation
<!---->if it already was installed. This requires some kind of installation check.
<!---->This procedure provides detection by searching for a string TsrIdentifier
<!---->at its shifted offset, which appears in installed resident in %Active state
<!---->(the TsrIdentifier is by default in %Passive state).</p>
<p>During the InstallationCheck will be the status temporarily switched to %Active
<!---->and the active TsrIdentifier is searched for at all possible segments (0xFFFF0..0x00000).</p>
<p>TSR identifier should be unique among other TSR programs which use
<!---->the same identification method to find out if they are installed in memory.
<!---->It is predecessed with %Active or %Passive character (<kbd>$</kbd> or
<kbd>-</kbd>) which distinguishes between the active TSR resident block and its other copies.</p>
<blockquote>Without the active/passive status prefix the installation check would be fooled
<!---->by old invalid copies of TsrIdentifier which might accidentally occur
<!---->in deallocated  memory or in cache buffers.</blockquote></dd>
<dt>Input</dt><dd>-</dd>
<dt>Output</dt><dd><b>ZF=</b>1 if not installed yet,
<br/><b>ES=</b>0.</dd>
<dt>Error</dt><dd><b>ZF=</b>0 if the TSR was already installed in memory.
<br/><b>ES=</b> paragraph address of the installed resident (either in upper or in conventional memory).</dd>
</dl><pre>
InstallationCheck PROC Dist=Near
    PUSHAW
     MOV BX,TsrIdentifier-Shift ; Offset in the installed instance.
     MOVB [BX],'%Active'        ; Temporarily switch ShiftedTsrIdentifier to active state.
     CLD
     SUB AX,AX                  ; This register will hold inspected segment address.
.40: DEC AX                     ; Check all segments from 0xFFFF downto 0x0000.
     MOV ES,AX                  ; Returned segment candidate.
     JZ .90                     ; Jump with ZF=1 if bottom reached and still not found.
     MOV DI,BX                  ; Offset in the searched segment.
     MOV SI,BX                  ; Offset in the current segment.
     MOV CX,SIZE# TsrIdentifier ; Including the status-byte prefix.
     REPE CMPSB
     JNE .40                    ; If not found, repeat with the next lower paragraph address.
     MOV CX,DS                  ; Match was found but
     CMP CX,AX                  ;  if it was at the current segment DS,
     JE .40                     ;  ignore this and continue searching bellow the current instance.
.90: MOVB [BX],'%Passive'       ; Restore the passive status back.
    POPAW
    RET                         ; ZF=1 if not installed yet else ZF=0 and ES=segment found.
  ENDP InstallationCheck
</pre>

<dl id="AllocUMB"><dt><a href="#top">AllocUMB</a></dt><dd><p>This procedure tries to allocate block
<!---->of upper memory and returns its segment in ES.</p>
<p>Upper memory (above linear address 0x0A0000) is not available in  MS-DOS without
<!---->two memory devices which must be loaded in CONFIG.SYS:</p></dd>
<dd class="PRE">   DEVICE=HIMEM.SYS
<!---->   DEVICE=EMM386.EXE RAM <abbr>and/or NOEMS</abbr></dd>
<dd><p>Even with those devices the upper memory is not automatically allocated by DOS function 0x48.
<!---->DOS must be explicitly told to add upper memory to the chain of free memory blocks
<!---->and we also need to temporary change its default allocation strategy,
<!---->which by default prefers conventional memory.</p></dd>
<dt>Input</dt><dd><b>CX=</b> is the amount of requested memory in paragraphs (OWORDs).</dd>
<dt>Output</dt><dd><b>CF=</b>0 if the allocation of HIMEM was successful.
<br/><b>ES=</b>paragraph address of allocated memory.</dd>
<dt>Error</dt><dd><b>CF=</b>1 if upper memory could not be allocated.</dd></dl><pre>
AllocUMB PROC Dist=Near
    PUSHAW
     DosAPI AX=0x5800         ; Get alloc strategy (0=first fit, 1=best fit, 2=last fit).
     JC .90                   ; Fails on DOS version older than 3.
     MOV SI,AX                ; Save the current strategy to SI to be restored later.
     DosAPI AX=0x5802         ; Get UMB Link Status (0=convent.only  1=including upper).
     JC .90                   ; Fails on DOS version older than 5.
     MOV DX,AX                ; UMB Link Status will be saved to DL.
     DosAPI AX=0x5803,BX=1    ; Set UMB Link Status to 1=include upper memory.
     DosAPI AX=0x5801,BL=0x41 ; Set Allocation Strategy to 0x41=upper best fit.
     DosAPI AH=48h,BX=CX      ; Try to allocate upper memory block, paragraph size is in CX.
     PUSHF                    ; Save the result of allocation (CF=error).
      MOV ES,AX               ; Segment address of UMB if allocation succeeded.
      SUB BX,BX               ; In any case previous state should be restored.
      DosAPI AX=0x5803,BL=DL  ; Restore UMB Link Status from DL.
      DosAPI AX=0x5801,BX=SI  ; Restore Allocation Strategy from SI.
     POPF                     ; Return with ES=allocated segment (valid only if CF=0).
.90:POPAW
    RET
ENDP AllocUMB
</pre>

<dl id="InstallConventional"><dt><a href="#top">InstallConventional</a></dt><dd>This procedure installs the resident
<!---->in a standard way, leaving the shifted resident part in memory.</dd></dl><pre>
InstallConventional PROC
     MOVB [TsrIdentifier-Shift],'%Active'
     DosAPI AX=0x2508,DX=NewInt08-Shift ; Set Interrupt Vector 08 to the new handler at DS:DX.
     MOV DX,TsrTop-Shift+15
     SHR DX,4
     TerminateStayResident DX, Errorlevel=0
    ENDP InstallConventional
</pre>

<dl id="InstallUpper"><dt><a href="#top">InstallUpper</a></dt>
<dd><p>With  version 5, MS-DOS brought out the concept
<!---->of using memory above the conventional limit 0x9000:0xFFFF, also called
<dfn>UPPER memory</dfn>. In Microsoft DOS it is achieved with two device drivers:
<!---->HIMEM and  EMM386. Resident programs can be loaded to the upper memory
<!---->using internal command LOADHIGH but there's a rub.
<!---->Upper memory is often fragmented and LOADHIGH  must find continuous
<!---->block of upper memory large enough for the whole program, not only for the
<!---->portion which remains resident.
<br/>This example uses better solution: the program is launched in conventional
<!---->memory, it allocates only a little slot in upper memory and moves
<!---->the resident part there by itself. Thanks to this technique it can benefit
<!---->from upper memory in cases where LOADHIGH or MEMORYMAKER don't work.</p>
<p>TSRup installed to upper memory occupies mere 128 bytes of resident memory, see <code>MEM /U</code>.</p>
</dd>
<dt>Input</dt><dd><b>ES=</b> is preallocated segment of the upper memory (as returned by
<a href="#AllocUMB">AllocUMB</a>. Its size must be at least <code>TsrTop - Shift</code> bytes.</dd>
<dt>Output</dt><dd>is not applicable.</dd></dl><pre>
InstallUpper PROC Dist=Near
     SUB SI,SI
     SUB DI,DI
     CLD
     MOV CX,TsrTop-Shift  ; Head of PSP and adjacent resident size.
     REP MOVSB            ; Copy the block with shifted resident to the upper memory.
     MOVB [ES:TsrIdentifier-Shift],'%Active'
     PUSH DS
      PUSH ES
      POP DS              ; DS is temporarily set to upper memory segment ES.
      DosAPI AX=0x2508,DX=NewInt08-Shift ; Set interrupt vector 08 to the upper memory at DS:DX.
     POP DS
     MOV AX,ES
     MOV BX,AX            ; Save the upper memory segment to BX.
     DEC AX               ; Its Memory Control Block is 1 paragraph below. Let's update the name of its owner.
     MOV ES,AX            ; ES:0 is now <a class="EXT" href="../maclib/doss.htm#MCB">MCB</a> of our upper memory block.
     MOV DI,MCB.Name      ; At this offset in MCB should be the name of the block owner.
     MOV SI,TsrIdentifier+1-Shift ; The name displayed with <code>MEM /C</code>, actually <kbd>tsrup</kbd>.
     %IF SIZE# TsrIdentifier > 1+8
       MOV CL,8           ; Maximum possible size of block owner name.
     %ELSE
       MOV CL,SIZE# TsrIdentifier - 1
     %ENDIF
     REP MOVSB            ; Name of the resident (without status prefix) is now set in its MCB.
     DosAPI AH=0x50       ; Set the current PSP to BX=segment of upper memory.
     PUSH DS
     POP ES               ; ES now points to the running PSP in conventional memory.
     DosAPI AH=0x49       ; Now deallocate the whole program whose PSP is pointed by ES.
     ; The following instructions actually run in deallocated memory but they are not overwritten yet by DOS.
     MOV DX,TsrTop-Shift+15
     SHR DX,4
     TerminateStayResident DX,Errorlevel=0 ; Terminate PSP in upper memory.
ENDP InstallUpper
</pre>

<dl id="Uninstall"><dt><a href="#top">Uninstall</a></dt>
<dd><p>Uninstallation of previously installed TSR program
<!---->is possible only if the current vector INT 08 points to the instance of our resident program.
<!---->Otherwise it means that some other TSR program has been installed after this TSRup
<!---->and hooked the same INT 08 routine.</dd>
<dt>Input</dt><dd><b>ES=</b> segment of TSR which is being uninstalled (conventional or upper memory).
<dt>Output</dt><dd><b>CF=</b>0,  TSR memory is freed, TsrIdentifier status is marked Passive.</dd>
<dt>Error</dt><dd><b>CF=</b>1 if TSR cannot be uninstalled.</dd></dl><pre>
Uninstall PROC
    PUSHAW
     PUSH DS
       SUB AX,AX
       MOV DS,AX        ; Interrupt table is at segment 0.
       MOV AX,ES        ; Segment of previously installed instance.
       CMP AX,[4*08h+2] ; Uninstalled TSR should be pointed to by the interrupt table.
     POP DS
     STC                ; Return with carry flag if the interrupt vector
     JNE .90            ;   does not point to the segment of deallocated resident.
     PUSH DS            ; Otherwise unhook the interrupt.
       LDS DX,[ES:OldInt08-Shift]
       DosAPI AX=0x2508 ; Restore Interrupt Vector 08 from DS:DX.
     POP DS
     MOVB [ES:TsrIdentifier-Shift],'%Passive' ; Prevent InstallationCheck to find this uninstalled instance.
     DosAPI AH=0x49     ; Deallocate TSR memory at segment ES.
.90:POPAW
    RET
   ENDP Uninstall
</pre>

<pre>
      ENDPROGRAM tsrup
</pre>
<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Back to the top&#x25B2;</a>
</body></html>
