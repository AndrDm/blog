<!doctype html><html lang='cs'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='&euro;ASM file man_cze.htm'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>man_cze.htm manual</title>
</head>
<body class='EADOC' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->

<h1>EuroAssembler dokumentace</h1><br class="CLEAR"/>
<h2><a class="EXT" href="man_eng.htm">English version of this manual</a></h2>
<h2><a class="EXT" href="tut_cze.htm">Tutorial - jak programovat v asembleru</a></h2>
<h2><a href="#About">O aplikaci &euro;ASM &darr;</a></h2>
<h2><a href="#IO">Vstup/výstup &darr;</a></h2>
<h2><a href="#ProgStruc">Struktura &euro;ASM programu &darr;</a></h2>
<h2><a href="#Elements">Prvky zdrojového kódu &darr;</a></h2>
<h2><a href="#Instructions">Instrukce &darr;</a></h2>
<h2><a href="#PgmFormats">Programové formáty &darr;</a></h2>
<h2><a href="#EaFn">Funkce EuroAssembleru &darr;</a></h2>
<hr/>

<h2 id="About"><a href="#top">&uarr; O aplikaci EuroAssembler</a></h2>
 <h3><a href="#ProductIdentification">Identifikace &darr;</a></h3>
 <h3><a href="#ShortCharacteristic">Stručná charakteristika &darr;</a></h3>
 <h3><a href="#Conventions">Typografické konvence &darr;</a></h3>
 <h3><a href="#Why">Proč asembler &darr;</a></h3>
 <h3><a href="#WhyYAA">K čemu další asembler &darr;</a></h3>
 <h3><a href="#WhyEuro">Proč EuroAssembler &darr;</a></h3>
 <h3><a href="#Licence">Licence &darr;</a></h3>
 <h3><a class="EXT" href="https://euroassembler.eu/download/#History">Historie</a></h3>
 <h3><a class="EXT" href="https://euroassembler.eu/download/#Download">Stažení</a></h3>
 <h3><a href="#Installation">Instalace &darr;</a></h3>
<hr/>

<h3 id="ProductIdentification"><a href="#About">&uarr; Identifikace </a></h3>
<P>Jméno tohoto softwaru je <dfn>EuroAssembler</dfn>.
Všimněte si chybějící mezery mezi <em>Euro</em> a <em>Assembler</em>.
<br/>Název se často zkracuje jako <strong>&euro;ASM</strong>.
<br/>V 7-bitovém (ASCII) prostředí bývá rovněž uváděn jako <strong>EUROASM</strong>
a v některých interních identifikátorech je to pouze <strong>ea</strong>.
<blockquote>Znak Euro <kbd>&euro;</kbd> je na klávesnici v MS-Windows
dostupný jako <kbd>Alt~0128</kbd> nebo jako HTML entita <kbd>&amp;euro;</kbd>.
</blockquote>

<h3 id="ShortCharacteristic"><a href="#About">&uarr; Stručná charakteristika</a></h3>

<ul>
<li>&euro;ASM je makroasembler s Intelovskou syntaxí pro architekturu IA-32 a x64 dle AMD&amp;Intel<sup>&trade;</sup>.
<br/>Rovněž <a href="#EaFn">funguje</a> jako linker, knihovník, objektový konvertor, make-manažer.</li>
<li>EUROASM je 32-bitová konzolová aplikace pro MS-Windows a pro Linux, která načítá zdrojový text
napsaný v jazyce asembler a převádí jej na kompilovaný objektový formát nebo na spustitelný program, a vytváří rovněž listingový soubor.</li>
<li>Programy napsané v &euro;ASM mohou běžet na 16, 32 nebo 64 bitovém operačním systému.</li>
<li>&euro;ASM je distribuován spolu se svým komentovaným <a class="EXT" href="../easource/">zdrojovým tvarem</a>,
<a class="EXT" href="../maclib/">knihovnami maker</a> a
<a class="EXT" href="../objlib/">vzorovými programy</a>.</li>
<li>&euro;ASM je k dispozici zdarma.</li>
</ul>
<p>Některé další vlastnosti se u jiných asemblerů vidí pouze zřídka:</p>
<ul>
<li>Jedno vyvolání EuroAssembleru může překládat více než jeden zdrojový program.
Každý zdrojový soubor vytváří vlastní listing a cílový program.
<blockquote><code>euroasm.exe source1.asm, source2.asm, more*.asm</code>
</blockquote></li>
<li>Listingový soubor úspěšně vygenerovaný předchozím spuštěním &euro;ASM může být znovu využit jako zdrojový soubor.
Formát listingu je kompatibilní se zdrojovým textem, neboť hexadecimální kód listingu je při čtení ignorován.</li>
<li>&euro;ASM is je iterativní mnohoprůchodový makroasembler s plnou podporou dopředných referencí a částečnou podporou datových typů.
<blockquote>Návěští, symboly definované pomocí EQU, struktury, to vše může být odkazováno dříve, než bylo definováno (i když to nelze doporučit).
<samp>|0000:                 |   ; Odkaz na strukturovanou proměnnou Today, která bude definována později.
|0000:C706[1000]E007   |   MOV [Today.Year],2016 ; Vlož číslo do proměnné typu WORD.
|0006:C606[1200]0C     |   MOV [Today.Month],12  ; Vlož číslo do proměnné typu BYTE.
|000B:C606[1300]1F     |   MOV [Today.Day],31    ; Vlož číslo do proměnné typu BYTE.
|0010:                 |
|0010:00000000         |Today  DS Datum ; Definice strukturovaného symbolu, jehož struktura bude deklarována později.
|0014:                 |
|[Datum]               |Datum STRUC     ; Deklarace struktury Datum.
|0000:....             |.Year   DW WORD
|0002:..               |.Month  DB BYTE
|0003:..               |.Day    DB BYTE
|0004:                 |      ENDSTRUC Datum
</samp></blockquote></li>

<li>Instrukce asembleru mohou být kombinovány s HTML.
Řádky zdrojového kódu začínající <code>&lt;HTML tagem&gt;</code> se považují za komentáře.
To umožňuje dokumentovat zdrojový kód pomocí značkovacího jazyka.</li>
<li>Povely INCLUDE mohou importovat jiný zdrojový soubor buď jako celek, nebo pouze jeho oddíl,
který může být specifikován jako rozsah řádků, nebo jako blok definovaný direktivami
<code>HEAD</code> a <code>ENDHEAD</code>. Vložitelný oddíl programového modulu <code>HEAD..ENDHEAD</code>
nemusí být udržován v samostatných hlavičkových souborech (jako např. <q>*.h</q> soubory v jazyku C).</li>
<li>Chyby a varování se zobrazují na standardním výstupu &euro;ASM a jsou rovněž vkládány do listingu, hned pod chybný příkaz.</li>
<li>&euro;ASM se zotavuje z chyb ve zdrojovém textu. Překlad se nezastavuje na každé zjištěné chybě
(ledaže by se jednalo o chybu
<a href="#MsgSeverity">fatální</a>).</li>
<li>&euro;ASM vždy generuje ten nejkratší strojový kód, avšak programátor může zvolit delší variantu pomocí
<a href="#InstructionModifiers">instrukčních modifikátorů</a>:
<samp>|00000000:41           | INC ECX
|00000001:41           | INC ECX,CODE=SHORT
|00000002:FFC1         | INC ECX,CODE=LONG
|00000004:             |
|00000004:83D801       | SBB EAX,1
|00000007:83D801       | SBB EAX,1,IMM=BYTE
|0000000A:81D801000000 | SBB EAX,1,IMM=DWORD
|00000010:             |
|00000010:E97D000000   | JMP $+0x82, DIST=SHORT
|## W2401 Modifier "DIST=SHORT" could not be obeyed in this instruction.
|00000015:             |
</samp></li>
<li>Data mohou být definována buď explicitně, pomocí pseudoinstrukcí D, DB, DW atd.,
anebo implicitně jako literál.
<samp>|[DATA]        |[DATA]   ; Přepnout do datové sekce.
|0000:4578706C~|Explicit DB  "Explicit text definition.$",0
|[CODE]        |[CODE]   ; Přepnout do kódové sekce.
|0020:BA[0000] |         MOV DX,Explicit
|0023:B409     |         MOV AH,9 ; Zapsat řetězec DS:DX na standardní výstup.
|0025:CD21     |         INT 21h  ; Vyvolat funkci DOSu.
|0027:BA[6400] |         MOV DX,=B"Implicit text definition (literal).$"
|002A:B409     |         MOV AH,9 ; Zapsat řetězec DS:DX na standardní výstup.
|002C:CD21     |         INT 21h  ; Vyvolat funkci DOSu.
|002E:         |</samp></li>
<li>EuroAssembler podporuje instrukce <em>Advanced vector extension</em>
včetně AVX-512 instrukcí zakódovaných pomocí prefixů MVEX a EVEX.</li>
<li>Vedle obvyklých podprogramových bloků <code>PROC..ENDPROC</code> &euro;ASM zavádí
<a href="#EaFnRfSemiinlineMacro">semiinline procedury</a> <code>PROC1..ENDPROC1</code>,
které se expandují z makra pouze jednou, během jeho první expanze.</li>
<li>&euro;ASM může linkovat objektové moduly (OMF, ELF, COFF) na spustitelné formáty (COM, EXE, DLL, ELFX)
jakož i na jiné objektové moduly a knihovny.
Viz seznam přípustných <a class="EXT" href="../eatests/#LinkerCombinations">kombinací</a>.</li>
<li>Při používání dynamicky linkovaných funkcí můžeme specifikovat jejich knihovnu DLL už během deklarace importu,
např. <code>IMPORT RegCloseKey, LIB="user32.dll"</code>.
Importní knihovny nejsou linkerem &euro;ASM vyžadovány, i když je podporuje.</li>
<li>Každý zdrojový soubor může obsahovat více než jeden modul (program),
každý takový blok <code>PROGRAM..ENDPROGRAM</code> generuje svůj vlastní objektový nebo spustitelný soubor.
Pokud autor chce, může udržovat celý mnohamodulový projekt v jediném velkém souboru.</li>
<li>Parametry příkazového řádku, nezbytné při spouštění většiny jiných asemblerů a linkerů,
nejsou nutné. Při distribuci vašeho zdrojového kódu nemusíte specifikovat, jak ho přeložit.
Spustitelný program se vygeneruje povelem <code>euroasm source.asm</code>.</li>
<li>EuroAssembler je napsán v EuroAssembleru, jeho zdrojový tvar může být zkontrolován <a class="EXT" href="../easource/">online</a>.</li>
<li id="HelloWorld">Následující příklad vytváří dvě varianty klasického programu <em>Hello,&nbsp;world!</em>,
<q>HelloL32.x</q> and <q>HelloL64.x</q>.
Oba spustitelné soubory budou vytvořeny z následujícího zdrojového souboru <q>hello.asm</q> jediným povelem <code>euroasm&nbsp;hello.asm</code>.
Můžeme je pak spustit v Linuxu nebo v jeho Windows emulátoru WSL:</li>
<pre>
        EUROASM CPU=x64

HelloL32 PROGRAM Format=ELFX, Entry=Main:, Width=32 ; HelloL32.x funguje v 32bitovém Linuxu.
 Main:    MOV EAX,4             ; Volání jádra sys_write=4.
          MOV EBX,1             ; Souborový deskriptor standardního výstupu (konzoly).
          MOV ECX,Message       ; Adresa zprávy.
          MOV EDX,SIZE# Message ; Velikost zprávy.
          INT 0x80              ; Zavolej jádro.
          MOV EAX,1             ; Operace sys_exit=1.
          XOR EBX,EBX           ; Vrať errorlevel=0.
          INT 0x80              ; Zavolej jádro.
 Message: DB "Hello, world of %^Width bits in Linux!",10
         ENDPROGRAM HelloL32

HelloL64 PROGRAM Format=ELFX, Entry=Main:, Width=64 ; HelloL64.x funguje v 64bitovém Linuxu.
 Main:    MOV RAX,1             ; Volání jádra sys_write=1.
          MOV RDI,1             ; Souborový deskriptor standardního výstupu (konzoly).
          LEA RSI,[Message]     ; Adresa zprávy.
          MOV RDX,SIZE# Message ; Velikost zprávy.
          SYSCALL               ; Zavolej jádro.
          MOV RAX,60            ; Operace sys_exit=60.
          XOR EDI,EDI           ; Vrať errorlevel=0.
          SYSCALL               ; Zavolej jádro.
 Message: DB "Hello, world of %^Width bits in Linux!",10
         ENDPROGRAM HelloL64
</pre>
<p>Také bychom mohl skrýt většinu strojových instrukcí předchozích programů pomocí makroinstrukcí z knihoven
<q>linapi.htm</q> (32 bit) a <q>linabi.htm</q> (64 bit),
a použitím literálů (=B &quot;Hello...&quot;) k definici zobrazovaných řetězců:
</p>
<pre>
         EUROASM CPU=x64

HelloL32 PROGRAM Format=ELFX, Entry=Main:, Width=32 ; HelloL32.x funguje v 32bitovém Linuxu.
          INCLUDE linapi.htm ; Definuj 32bitová makra <a class="EXT" href="../maclib/linapi.htm#StdOutput">StdOutput</a> a <a class="EXT" href="../maclib/linapi.htm#TerminateProgram">TerminateProgram</a>.
 Main:    StdOutput =B "Hello, world of %^Width bits in Linux!", Eol=Yes
          TerminateProgram Errorlevel=0
         ENDPROGRAM HelloL32

         %DROPMACRO *        ; Zapomeň makra definovaná v "linapi.htm".

HelloL64 PROGRAM Format=ELFX, Entry=Main:, Width=64 ; HelloL64.x funguje v 64bitovém Linuxu.
          INCLUDE linabi.htm ; Definuj 64bitová makra <a class="EXT" href="../maclib/linabi.htm#StdOutput">StdOutput</a> a <a class="EXT" href="../maclib/linabi.htm#TerminateProgram">TerminateProgram</a>.
 Main:    StdOutput =B "Hello, world of %^Width bits in Linux!", Eol=Yes
          TerminateProgram Errorlevel=0
         ENDPROGRAM HelloL64
</pre>
<p>A ještě příklad programů určených pro MS-Windows:</p>
<pre>
        EUROASM CPU=x64, SIMD=Yes

HelloW32 PROGRAM Format=PE, Entry=Main:, Width=32 ; HelloW32.exe funguje v 32bitových a 64bitových Windows.
         INCLUDE winapi.htm ; Definuj 32bitová makra <a class="EXT" href="../maclib/winapi.htm#WinAPI">WinAPI</a> a <a class="EXT" href="../maclib/winapi.htm#TerminateProgram">TerminateProgram</a>.
   Main: WinAPI MessageBox,0,="Hello, world of %^Width bits in Windows!",="Title",0, Lib=user32.dll
         TerminateProgram Errorlevel=0
        ENDPROGRAM HelloW32

        %DROPMACRO *        ; Zapomeň makra definovaná v "winapi.htm".

HelloW64 PROGRAM Format=PE, Entry=Main:, Width=64 ; HelloW64.exe funguje v 64bitových Windows.
         INCLUDE winabi.htm ; Definuj 64bitová makra <a class="EXT" href="../maclib/winabi.htm#WinABI">WinABI</a> a <a class="EXT" href="../maclib/winabi.htm#TerminateProgram">TerminateProgram</a>.
   Main: WinABI MessageBox,0,="Hello, world of %^Width bits in Windows!",="Title",0, Lib=user32.dll
         TerminateProgram Errorlevel=0
        ENDPROGRAM HelloW64
</pre>
</ul>

<h3 id="Conventions" title="Typographic conventions"><a href="#About">&uarr; Typografické konvence </a></h3>
<p>Tento manuál reprezentuje dokumentaci, referenční příručku, příklady a implementační poznámky.
K jejich rozlišení slouží rozličné styly.</p>
<p>Podkladová barva stránky rozlišuje</p>
<div style="background-color:white;padding:3px;">
 &nbsp; <span class="EADOC" title="class=&quot;EADOC&quot;">&nbsp;tento manuál a seznam odkazů</span>,&nbsp;
<span class="MACLIB" title="class=&quot;MACLIB&quot;">&nbsp;knihovny makroinstrukcí</span>,&nbsp;
<span class="EASOURCE" title="class=&quot;EASOURCE&quot;">&nbsp;zdrojové kódy &euro;ASM</span>,&nbsp;
<span class="EATESTS" title="class=&quot;EATESTS&quot;">&nbsp;testovací soubory</span>,&nbsp;
<span class="OBJLIB" title="class=&quot;OBJLIB&quot;">&nbsp;objekty a vzorové programy</span>.</div>

<p id="Navigation" title="Navigation conventions">
<p><a href="#Navigation" title="&lt;a&gt;">
Přerušované podtržení </a> odkazuje na odstavec v rámci téže webové strany.</p>
<p><a class="EXT" href="#Navigation" title="&lt;a class=&quot;EXT&quot;&gt;">
Podtržení</a> naviguje na jinou HTML stránku v rámci tohoto webu.</p>
<p>Podtržení s <a class="EXTL" href="#Navigation" title="&lt;a class=&quot;EXTL&quot;&gt;">
ikonou Link</a> odkazuje na stránku <code>Links</code> soustřeďující externí odkazy.</p>
<p>Podtržení s <a class="EXTW" href="https://www.google.com" title="&lt;a class=&quot;EXTW&quot;&gt;">
ikonou Exit</a> naviguje mimo web EuroAssembleru, možná je budete chtít otevřít v novém okně nebo tabu.</p>

<p>Obsah tohoto návodu je organizován do kapitol se <strong>stromovou strukturou</strong>.</p>
<h2><a href="#top">&uarr; Title</a></h2> Šipka nahoru u názvu kapitoly naviguje o <b>jednu úroveň výše.</b>.
<br class='CLEAR'/>
<h2><a href="#top">Title &darr;</a></h2> Šipka dolů za názvem kapitoly naviguje na
<b>konkrétní text</b>.<br class='CLEAR'/>

<h6 title="&lt;h6&gt;">Pravidla stojící za zapamatování jsou označena ikonou žárovky.</h6>
<p><dfn title="&lt;dfn&gt;">Definice</dfn> nových pojmů jsou psány tučnou modrou <i>kurzívou</i>.</p>
<blockquote title="&lt;blockquote&gt;">
Implementační detaily, diskuse a osobní poznámky se zobrazují menším fontem.</blockquote>

<p><q title="&lt;q&gt;">Názvy souborů</q> jsou zvýrazněny uvozovkami.</p>
<p>Znaky použité v <kbd title="&lt;kbd&gt;">textu</kbd> mají bílé pozadí.</p>
<p>Krátké úseky <code title="&lt;code&gt;">zdrojového kódu</code> se zobrazují neproporciálním fontem černě na žluté v toku textu.</p>
<pre title="&lt;pre&gt;">; Delší ukázky zdrojového kódu se zobrazují v rámečku.
; Mohou mít více řádků.
; <del title="&lt;del&gt;">Negativní příklady</del> jsou přeškrtnuty.
</pre>
<div class="MACLIB"><dl class="PRE" title="&lt;dl class=&quot;PRE&quot;&gt;"><dt>&nbsp;</dt>
<dd class="PRE"> Ukázky kódu v makroknihovnách a zdrojových souborech jsou ignorovýny EuroAssemblerem,
 neboť jejich fyzické řádky začínají HTML tagem <kbd>&lt;</kbd>.</dd></dl>
</div>
<samp title="&lt;samp&gt;">               <abbr title="&lt;abbr&gt;">vysvětlující metaindormace &#x2510;</abbr>
|0000:0000| ; Tištěný výstup EuroAssembleru (listing) se zobrazuje černě na bílém papíru.
|0000:0000| ; Obsahuje sestavený strojový kód, kopie zdrojových instrukcí
|0000:0000| ; a chybová hlášení.
</samp>

<h3 id="Why"><a href="#About">&uarr; Proč asembler</a></h3>
<p><dfn>Asembler</dfn> (ASM) je jediný programovací jazyk, který nám dává plnou kontrolu nad strojovým kódem.
Muset ručně zapisovat každou instrukci pro <dfn>Central Processing Unit</dfn> (CPU)
je ovšem značně namáhavé, proto byly vynalezeny znovupoužitelné podprogramy:
<strong>procedury, funkce, makroinstrukce</strong>.
<br/>Podprogram je něco jako černá skříňka s dokumentovaným účelem, vstupem a výstupem.
Hlavní rozdíl mezi naším vlastním podprogramem a funkcí vyššího jazyka (HLL)
je v tom, že pokud nepracuje dle očekávání, můžeme snadno vystopovat chybu
krokováním programu v debugeru, a je to pouze <b>naše</b> vlastní chyba.</p>
<p>Podprogram v asembleru může vykonávat stejnou funkci jako povely vyššího programovacího jazyka (HLL)
nebo volání operačního systému (OS).
Makrojazyk EuroAssembleru dovoluje připravit pokročilá makra šitá na míru řešenému problému
a vyvíjet pak programy v ASM téměř stejně rychle jako HLL.</p>
<p>Výhoda znalosti asembleru se projeví, když nějaký špatně napsaný cizí program
způsobí výjimku a skončí. Dr.Watson, disasembler, debuger ukazuje pouze kód ve strojových instrukcích,
který bez znalosti asembleru budeme jen stěží umět interpretovat, zatímco zkušený ASM programátor
se bude cítit jako ryba ve vodě.</p>
<blockquote>Hlavní nevýhodou asemblerů jsou chybějící standardní knihovny,
které sjednocují programování v HLL jako C nebo Java.
Mnoho ASM programátorů buduje své vlastní knihovny, což vyžaduje poskytovat jejich kód současně s programem.
Ovšem tvorba vlastní knihovny je zároveň nejlepší metoda, jak si zapamatovat názvy a parametry v ní obsažených funkcí.
<br/>Distribuce EuroAssembleru obsahuje několik <a class="EXT" href="../maclib/">makroknihoven</a>
pro začátek a pro inspiraci.</blockquote>
<h6>Asembler je univerzální stavebnice. Můžete si naprogramovat téměř cokoli,
ale nejprve je třeba připravit nástroje.</h6>

<table id="Phases" title="Assembly-time"><caption>Postup tvorby programu</caption>
<tr><th>Fáze</th><th>Použitý nástroj</th></tr>
<tr><td>design-time</td><td>představivost</td></tr>
<tr><td>write-time</td><td>textový editor</td></tr>
<tr><td>assembly-time</td><td>asembler</td></tr>
<tr><td>combine-time</td><td>linker</td></tr>
<tr><td>link-time</td><td>linker</td></tr>
<tr><td>load-time</td><td>loader operačního systému</td></tr>
<tr><td>bind-time</td><td>loader operačního systému</td></tr>
<tr><td>run-time</td><td>procesor</td></tr>
</table>

<h3 id="WhyYAA"><a href="#About">&uarr; K čemu další asembler</a></h3>
<p>Nespokojenost s existujícími nástroji je hlavní důvod, proč někteří programátoři vyvíjejí vlastní programovací jazyk.
<blockquote><p>
Nezanedbatelná je skutečnost, že vytvoření asembleru je velmi zajímavá činnost.
Nekompletní seznam nástrojů, se kterými jsem měl potěšení se setkat, je uveden na odkazu
<a class="EXTL" href="../eadoc/links.htm#Assemblers">[Assemblers]</a>
a <a class="EXTL" href="../eadoc/links.htm#UsefulTools">[UsefulTools]</a>.</p>
<p>První nástroj, se kterým jsem se setkal když jsem začal v raných osmdesátých letech flirtovat s asemblerem,
byl FDOS od IBM pro mainframy S360 <a class="EXTL" href="../eadoc/links.htm#HLASM">[HLASM]</a>.
Což byl na svou dobu velmi sofistikovaný produkt s pokročilými funkcemi, jako
sekce, klíčové operandy (keywords), s literály, s makrojazykem, jenž dovolovat manipulovat nejen se strojovými instrukcemi,
ale i s vlastními makroproměnnými a jejich názvy.</p>
<p>V asemblerech pro architekturu Intel jsem pak postrádal mnohé z těchto funkcí.
<a class="EXTL" href="../eadoc/links.htm#NASM">[NASM]</a> ver.0.99 byl poměrně dobrý,
první bootstrapová verze &euro;ASM byla napsána právě v něm, ale byl jsem rozčarován
jeho neschopností automaticky vybírat SHORT nebo NEAR formu instrukce JMP
a dalšími návrhovými vadami, jako třeba neexpandovat %proměnné v řetězcích.</p>
<p>Nechápal jsem, proč konstantní symboly definované pomocí EQU musely být deklarovány
před prvním užitím. Proč nemohu deklarovat makro v makru.
Jak řešit situace, kdy soubor A inkluduje soubory B a C,
a soubor C rovněž inkluduje soubor B a duplikuje tak jeho definice.</p>
<p>Nemám rád jazyky zamořené mezerami.
V jazyce <a class="EXTL" href="links.htm#HLASM">HLASM</a> mezera za seznamem operandů znamenala
začátek komentáře, který končil až s koncem děrného štítku.
&euro;ASM není tak přísný v tomto <em>horror vacui</em>, ve skutečnosti mezery
mohou být vloženy mezi jazykové elementy kvůli zlepšení čitelnosti.
Nicméně netisknutelné mezery nejsou téměř nikdy <em>vyžadovány</em> syntaxí.</p>
<p>&euro;ASM nepoužívá anglické slovní modifikátory, jako
<code>SHORT, NEAR, DWORD PTR, NOSPLIT</code> identifikované pouze jejich hodnotou.
Místo toho preferuje paradigma <dfn>Name=Value</dfn> spolu s klíčovými <em>modifikátory instrukcí</em>,
jako <code>DATA=QWORD,IMM=BYTE,MASK=K5,ZEROING=ON</code>, jež odstraňují nejednoznačnosti
a nahrazují nehezké dekorátory navrhované v dokumentaci od Intelu.</p>
</blockquote>

<h3 id="WhyEuro"><a href="#About">&uarr; Proč <dfn>Euro</dfn>Assembler</a></h3>
<ol>
<li><dfn>Euro</dfn> neboť přichází z Česka ležícího v srdci Evropy (
<a class="EXTW" href="https://autorskesperky.com/blog/post/cesko.html">Czechia, the heart of Europe</a>).</li>
<li>Jak Evropa, tak i &euro;ASM jsou mnohojazyčné tím, jak podporují národní znaky v identifikátorech a řetězcích.</li>
<li><kbd>&euro;</kbd> je jeden z posledních neobsazených znaků mezi ostatními *ASM
<a class="EXTL" href="../eadoc/links.htm#Assemblers">asemblery</a> :-) </li>
</ol>

<h3 id="Licence" title="Licence"><a href="#About">&uarr; Licence</a></h3>
<p>Právo užívat EuroAssembler je poskytnuto každému, kdo se řídí touto licencí.
<br/>Nejsou <strong>žádná omezení</strong> ohledně účelu aplikací vyrobených tímto nástrojem.
Mohou být svobodně používány v soukromém, výukovém i komerčním prostředí.</p>
<p>EuroAssembler je poskytnut <strong>bezplatně</strong> <em>tak, jak je</em>, bez jakékoli záruky od jeho autora.</p>
<p>Tento software <strong>smí být redistribuován</strong> v nezměněné zipované podobě, tak jak byl stažen z
<a class="EXT" href="https://euroassembler.eu/download/">EuroAssembler.eu</a>.
Za právo používat tento software nesmí být vyžadován žádný poplatek.</p>
<blockquote>Můžete rozšiřovat <q>euroasm.zip</q> na jiné weby, repozitáře, archivy FTP, kompaktní disky a obdobná média.
Snažte se prosím vždy šířit nejnovější verzi EuroAssembleru.</blockquote>
<p><a class="EXT" href="/easource/">Zdrojový kód</a> EuroAssembleru napsal
<em>Pavel Šrubař</em>, AKA <a class="EXTW" href="https://vitsoft.info/about.me/"><em>vitsoft</em></a>, a jako takový je chráněn autorským zákonem.</p>
<p><a class="EXT" href="/maclib/">Makroknihovny</a> a <a class="EXT" href="/objlib/">vzorové projekty</a>
jsou uvolněny jako <b>public domain</b> a mohou být libovolně upravovány.</p>
<blockquote>Modifikaci dodaných knihoven nicméně nemohu doporučit, protože vaše vylepšení by mohly být přepsány
po vydání novější verze &euro;ASM. Vytvořte raději soubory s vlastními názvy.</blockquote>
<p><strong>Smíte modifikovat </strong> zdrojový kód &euro;ASM za výhradním účelem opravy chyb nebo
obohacením o nové funkce, avšak <strong>nesmíte distribuovat</strong> takto upravený software.
Smí být používán pouze na tomtéž počítači, kde byl upraven, sestaven a znovu slinkován.</p>
<blockquote>EuroAssembler není open source. Nechci větvit vývoj EuroAssembleru do navzájem nekompatibilních verzí,
kde každá větev poskytuje odlišné vylepšení. Raději prosím zašlete své modifikace autorovi
nebo je napište do <a class="EXT" href="https://euroassembler.eu/forum/">
diskusního fóra</a>, aby mohly být zařazeny do dalších vydání EuroAssembleru.</blockquote>

<h3 id="Installation" title="Installation of &euro;ASM"><a href="#About">&uarr; Instalace</a></h3>
<p>Distribuovaný soubor <q>euroasm.zip</q> obsahuje adresáře a soubory jak jsou vyjmenovány na stránce
<a class="EXT" href="../sitemap.htm">Sitemap</a>
Čas poslední modifikace všech souborů je nastaven na nominální hodnotu vydání.
Názvy souborů jsou malými písmeny (Linuxová konvence) a ve 8.3 formátu (DOSová konvence),
takže je rozbalí jakákoli starší DOSová utilita.
<br/>K instalaci na novější verzi MS-Windows budete muset spustit <strong>konzolu jako administrátor</strong>.</p>
<p>Zvolte a vytvořte <dfn>domovský adresář</dfn>,
například <q>C:\euroasm</q> ve Windows nebo <q>~/euroasm</q> v Linuxu, přejděte do něj a rozzipujte
stažený soubor <q>euroasm.zip</q>.</p>
<p>V <strong>Linuxu</strong> přesuňte nebo zkopírujte spustitelný soubor <q>euroasm.x</q> do některého adresáře
uvedeného v proměnné environmentu <code>$PATH</code>, například příkazem
<code class="MSG">sudo mv euroasm.x /usr/local/bin/euroasm</code>. Při prvním spuštění
pomocí <code class="MSG">sudo euroasm</code> se pokusí vytvořit globální konfigurační soubor
<q>/etc/eurotool/euroasm.ini</q>.</p>

<p>Ve <strong>Windows</strong> přesuňte nebo zkopírujte s právy administrátora spustitelný soubor
<q>euroasm.exe</q> do některého adresáře uvedeného v proměnné environmentu <code>%PATH%</code>,
například příkazem <code class="MSG">copy euroasm.exe %windir%</code>. Při prvním spuštění
pomocí <code class="MSG">euroasm.exe</code> se pokusí vytvořit globální konfigurační soubor
<q>%AppData%\eurotool\euroasm.ini</q>.</p>
<p>EuroAssembler by nyní měl jít spustit odkudkoli zadáním příkazu <code>euroasm</code>.
Nyní byste měli upravit plain-text editorem globální konfigurační soubor.</p>
<blockquote>Možná  budete chtít upravit relativní hodnoty IncludePath= and LinkPath=
v sekci <code>[EUROASM]</code> absolutní cestou specifikující domácí adresář EuroAssembleru.
<br/>V sekci <code>[PROGRAM]</code> možná budete chtít upravit preferovaný formát generovaných souborů,
např. <code>Format=PE, Subsystem=CON</code> a <code>Width=32</code>.
Také můžete nahradit <code>IconFile=&quot;euroasm.ico&quot;</code>
za nic anebo za svou preferovanou ikonu a nahrát ji do složky <q>objlib</q>.</blockquote>
<p>Pro (nedoporučenou) holou <strong>minimální instalaci</strong> můžete vymazat celý domácí adresář.
Ano, soubor <q>euroasm.exe</q> nebo <q>euroasm.x</q> nepotřebuje žádné další podpůrné soubory,
úpravy environmentu nebo registrů MS-Windows.</p>
<p>Pokud byste chtěli číst tuto dokumentaci v jiném jazyce,
přejmenujte defaultní anglickou verzi tohoto manuálu <q>eadoc\index.htm</q> na <q>eadoc\man_eng.htm</q>
a pak přejmenujte dostupný překlad, např. <q>eadoc\man_cze.htm</q> na <q>eadoc\index.htm</q>.</p>

<p>Pro <strong>vývojářskou instalaci</strong> rozbalte v domovském adresáři vývojářské skripty
z podarchivu <q>generate.zip</q>.
Budete muset mít na svém počítači instalován webserver a PHP (verze 5.3 nebo novější).</p>
<p>Většina souborů EuroAssembleru je v HTML formátu, takže asi budete chtít
začlenit &euro;ASM do vašeho <strong>lokálního webserveru</strong>.</p>
<blockquote><p>V mé instalaci Apache jsem do jeho konfiguračního souboru
<q>httpd.conf</q> nebo <q>apache2.conf</q> přidal</p>
<pre>&lt;VirtualHost *:80&gt;
    DocumentRoot C:/euroasm/
    ServerName euroasm.localhost
&lt;/VirtualHost&gt;</pre>
<p>Dále jsem přidal řádek <code>127.0.0.1 euroasm.localhost</code>
do souboru <q>%SystemRoot%\SYSTEM32\drivers\etc\hosts</q>.
Nyní mohu napsat <code>euroasm.localhost</code> do adresního řádku internetového prohlížeče
a číst soubory EuroAssembleru lokálně.</p>
</blockquote>

<hr/>
<h2 id="IO"><a href="#top">&uarr; Vstup/Výstup </a></h2>
<h3><a href="#StandardIO">Standardní kanály &darr;</a></h3>
<h3><a href="#OtherIO">Další kanály &darr;</a></h3>
<h3><a href="#Messages">Oznámení &darr;</a></h3>
<h3><a href="#FilesIO">Vstupní a výstupní soubory &darr;</a></h3>
<hr/>
<p>Počítače komunikují s uživateli rozličnými kanály:
standardní vstup a výstup, parametry příkazové řádky, proměnné environmentu,
hodnota errorlevel, diskové soubory, hardwarová zařízení.</p>
<h3 id="StandardIO"><a href="#IO">&uarr; Standardní kanály</a></h3>
<p>Základní forma komunikace mezi programem a lidským uživatelem má podobu proudu znaků,
defaultně směrovaného na konzolu terminálu, kde byl program spuštěn.
Může být přesměrován do souboru nebo do ovladače zařízení pomocí operátorů
příkazové řádky <kbd>&gt;</kbd>, <kbd>&gt;&gt;</kbd>,
<kbd>&lt;</kbd>, <kbd>|</kbd>.</p>
<p><strong>Standardní vstup</strong> není v &euro;ASM používán.</p>
<p><strong>Standardní výstup</strong> zobrazuje chyby, varování a informativní <a href="#Messages">zprávy</a> generované EuroAssemblerem.
</p>
<p><strong>Standardní chybový výstup</strong> není v &euro;ASM používán.</p>
<h3 id="OtherIO"><a href="#IO">&uarr; Další kanály</a></h3>
<p><strong>Parametry příkazové řádky</strong> nejsou používány.
&euro;ASM předpokládá, že vše na příkazové řádce jsou názvy souborů, které má přeložit.
Veškeré parametry řídící asembler a linker jsou definovány
v <dfn>konfiguračních souborech <q>euroasm.ini</q></dfn> nebo přímo ve zdrojovém kódu.</p>
<blockquote>Ve skutečnosti sice je několik parametrů EUROASM rozeznáváno na příkazovém řádku,
avšak jejich preferované umístění je konfigurační soubor anebo zdrojový kód.
Parametry z příkazového řádku jsou využity pouze v <a class="EXT" href="../eatests/#Launch">testech</a>,
kde potlačují některé informaticní zprávy.</blockquote>
<p><strong>Proměnné environmentu </strong> nejsou v &euro;ASM používány.
Mohou však být začleněny do zdrojového textu v asm-time pomocí pseudoinstrukce
<a href="#pcSETE">%SETE</a>. A je samozřejmě také možné číst tyto proměnné v run-time
pomocí příslušného systémového volání, jako <code>GetEnvironmentVariable()</code>.</p>
<p>&euro;ASM nepoužívá žádná <strong>další zařízení</strong> (I/O porty, tiskárny,zvukové a grafické adaptéry apod.)
během asm-time.</p>

<h3 id="Messages" title="Messages"><a href="#IO">&uarr; Oznámení</a></h3>
<p>Informace detekované EuroAssemblerem během jeho činnosti
jsou publikovány ve formě krátkých textových oznámení
směrovaných na standardní výstup a do listingového souboru.</p>

<h4><a href="#MsgSeverity">Závažnost oznámení &darr;</a></h4>
<h4><a href="#MsgInOutput">Oznámení na standardním výstupu &darr;</a></h4>
<h4><a href="#MsgInListing">Oznámení v listingu &darr;</a></h4>
<p>Oznámení je identifikováno kombinací písmene následovaného čtyřmi dekadickými číslicemi.
Jejich kompletní text je definován ve zdrojovém souboru &euro;ASM <a class="EXT"
href="../easource/msg.htm#MsgTexts">msg.htm</a>.</p>
<p>Písmenový prefix a první číslice (0..9) určují závažnost tohoto oznámení.
Nejvyšší závažnost zjištěná během činnosti &euro;ASM určuje hodnotu
<dfn id="Errorlevel" title="Errorlevel">errorlevel</dfn>, se kterou <q>euroasm.exe</q> končí.</p>

<table id="MsgSeverity" title="Message severity"><caption>Závažnost oznámení</caption>
<tr><th>Druh zprávy</th><th>Prefix</th><th>Rozsah <br>identifikátorů</th><th>Závažnost</th><th>Vyhledávací<br/>značka</th></tr>
<tr><td>Informativní</td><td>I</td><td>I0000..I0999</td><td>0</td><td><kbd>|#</kbd></td></tr>
<tr><td>Ladicí</td><td>D</td><td>D1000..D1999</td><td>1</td><td><kbd>|#</kbd></td></tr>
<tr><td>Varování</td><td>W</td><td>W2000..W3999</td><td>2..3</td><td><kbd>|##</kbd></td></tr>
<tr><td>Nepotlačitelná varování</td><td>W</td><td>W4000..W4999</td><td>4</td><td><kbd>|##</kbd></td></tr>
<tr><td>Uživatelem definovaná chyba</td><td>U</td><td>U5000..U5999</td><td>5</td><td><kbd>|###</kbd></td></tr>
<tr><td>Chyba</td><td>E</td><td>E6000..E8999</td><td>6..8</td><td><kbd>|###</kbd></td></tr>
<tr><td>Fatální chyba</td><td>F</td><td>F9000..F9999</td><td>9</td><td><kbd>|###</kbd></td></tr>
</table>

<p>EuroAssembler je upovídaný, avšak může být zcela umlčen při spuštění s parametrem
<code>NOWARN=0000..0999</code>, a pokud nezjistí žádnou chybu.</p>
<p>Varování zpravidla nebrání zkompilovanému programu ve spuštění,
jsou to spíše upozornění, že programátor něco opomenul nebo učinil překlep.</p>
<p>Oznámení se závažností 5..8 indikují, že některé řádky nebyly přeloženy kvůli chybě.
Cílový soubor může být formálně v pořádku, ale pravděpodobně nebude fungovat, jak by měl.</p>
<p>Fatální chyby upozorňují na chybu interakce s operačním systémem,
vyčerpání zdrojů, chybu v práci se soubory nebo interní chybu EuroAssembleru.
Cílový soubor při fatální chybě nejspíš nebyl vůbec vytvořen.</p>
<blockquote>Oznámení a varování v rozsahu I0000..W3999 mohou být potlačena
parametrem EUROASM <a href="#WARNeq">NOWARN=</a>,
ovšem tato pštrosí politika není dobrý nápad, vždy je lepší odstranit příčinu varování.
<br/>Hodláte-li publikovat svůj kód, měl by jít zkompilovat s hodnotou errorlevel&nbsp;0.</blockquote>

<h4 id="MsgInOutput" title="Output messages"><a href="#Messages">&uarr; Oznámení na standardním výstupu</a></h4>
<p>Typické oznámení sestává z identifikátoru, za kterým následuje upravený text zprávy.
Při jeho zobrazení na standardním výstupu je doprovázen <dfn>pozičním indikátorem</dfn>
ve formě názvu zdrojového souboru následovaného číslem fyzického řádku ve složených závorkách,
například
<pre>E6601 Symbol "UnknownSym" mentioned at "t1646.htm"{71} was not found. "t1646.htm"{71}
<abbr>&#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;                                                                 &#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;&#x25B2;
Identifikátor                                                        poziční indikátor</abbr></pre>
<p>Obvykle vidíme pouze jeden poziční indikátor, pouze v případě zjištění chyby ve fázi expanze makra
je přidán další indikátor určující číslo řádku v makroknihovně.
V případě expanze makra uvnitř jiného makra budou poziční indikátory dále zřetězeny.</p>

<h4 id="MsgInListing" title="Listing messages"><a href="#Messages">&uarr; Oznámení v listingu</a></h4>
<p>Oznámení zapisovaná do listingového souboru mají lehce odlišný formát.
Poziční indikátor je vynechán, neboť chybové zprávy jsou vkládány hned pod zdrojový řádek způsobující chybu.:</p>
<samp>|002B:         | MOV SI,UnknownSym: ; E6601 expected.
|### E6601 Symbol "UnknownSym" mentioned at "t1646.htm"{71} was not found.
<abbr>&#x25B2;&#x25B2;&#x25B2;&#x25B2;
marker</abbr></samp>
<p>Textu oznámení předchází <dfn id="MsgSearchMarker" title="Message search marker">
vyhledávací značka</dfn>, která pomáhá nalézt chybu v listingu.</p>
<blockquote><p>Pomocí vyhledávací funkce <em>Find/FindNext</em> <code>(Ctrl-F)</code>
editoru nebo prohlížeče použitého ke čtení listingového souboru můžeme přeskakovat od jedné chyby ke druhé.
<br/>K prohlížení listingu můžete rovněž využít specializovaný <a class="EXT" href="../prowin32/lstview.htm">&euro;ASM listing viewer</a>
distribuovaný jako vzorový projekt.</blockquote>
<p>Ladicí oznámení <code>D1???</code> generovaná pseudoinstrukcí
<a href="#pcDISPLAY">%DISPLAY</a> se vypisují i v případech jejího umístění do <em>false</em> větve příkazu
<a href="#pcIF">%IF</a> nebo do bloku vyřazeného z kompilace pomocí
<a href="#pcCOMMENT">%COMMENT..%ENDCOMMENT</a>.</p>
<p>Listing se generuje pouze v posledním průchodu (<em>final pass</em>).
Informativní oznámení se do listingu vůbec nezapisují, s výjimkou zpráv <code>I056?</code>.</p>

<hr/>
<h3 id="FilesIO"><a href="#IO">&uarr; Vstupní a výstupní soubory</a></h3>
<h4><a href="#IniFile">Konfigurační soubor &darr;</a></h4>
<h4><a href="#SourceFile">Zdrojový kód &darr;</a></h4>
<h4><a href="#ObjectFile">Cílový soubor &darr;</a></h4>
<h4><a href="#ListingFile">Listingový soubor &darr;</a></h4>
<h4><a href="#FilePath">Cesty k souborům &darr;</a></h4>
<p>EuroAssembler čte dva druhy vstupních souborů: <dfn>konfigurační</dfn> a <dfn>zdrojový</dfn>.</p>
<p>EuroAssembler zapisuje dva druhy výstupních souborů: <dfn>cílový</dfn> a <dfn>listing</dfn>.</p>
<h6>Pokud výstupní soubor existoval, &euro;ASM ho bez varování přepíše</h6>
<h4 id="IniFile"><a href="#FilesIO">Konfigurační soubor</a></h4>

<p>Konfigurační soubor s pevným názvem <q>euroasm.ini</q> specifikuje
výchozí volby pro assembler. &euro;ASM je načítá ze dvou souborů s identickým názvem a strukturou:
globální a lokální.</p>
<p><strong>Globální konfigurační soubor ve Windows</strong> verzi má název
<q>%AppData%\eurotool\euroasm.ini</q> a zpracovává se jednou, když byl &euro;ASM spuštěn.
Pokud předtím neexistoval, &euro;ASM se jej pokusí vytvořit s výchozími hodnotami parametrů (factory-default).</p>

<p><strong>Globální konfigurační soubor v Linux</strong> verzi má název
<q>/etc/eurotool/euroasm.ini</q> a zpracovává se jednou, když byl &euro;ASM spuštěn.
Pokud předtím neexistoval, &euro;ASM se jej pokusí vytvořit s výchozími hodnotami parametrů (factory-default).</p>

<p><strong>Lokální konfigurační soubor</strong> se hledá ve stejném adresáři jako zdrojový text.
Pokud byl na příkazovém řádku definován více než jeden zdrojový soubor,
lokální konfigurační soubor se načítá znovu vždy při zahájení zpracování zdrojového souboru.
<br/>Lokální <q>euroasm.ini</q> není EuroAssemblerem vytvářen, musíte zkopírovat globální soubor
a případně vymazat opakující se volby kvůli lepší výkonnosti.</p>
<blockquote>Příklad povelu, který kompiluje dva zdroje:
<br/><code>C:\PgmFiles\euroasm.exe Source1.asm D:\Temp\Source2.asm</code>
<br/>EuroAssembler se pokusí načíst počáteční konfiguraci ze tří souborů:
<code>C:\Users\<i>login</i>\AppData\Roaming\eurotool\euroasm.ini</code>,
<code>.\euroasm.ini</code>,
<code>D:\Temp\euroasm.ini</code>.
</blockquote>
<p>Počáteční obsah konfigurace zabudovaný do <q>euroasm.exe</q>
jako factory-defaults je definován v <a class="EXT" href="../objlib/euroasm.ini">objlib/euroasm.ini</a>.
Soubor obsahuje dvě sekce: <code>[EUROASM]</code> a <code>[PROGRAM]</code>.</p>
<p>Ta první určuje parametry pro samotný &euro;ASM, jako např.
volbu CPU, druh informací zapisovaných do listingu, která varování se mají potlačit atd.
Parametry ze sekce [EUROASM] mohou být redefinovány později ve zdrojovém textu
pseudoinstrukcí <a href="#EUROASM">EUROASM</a>, kde také naleznete podrobnější popis parametrů.</p>
<p>Sekce [PROGRAM] určuje defaultní parametry vytvářeného programu,
například paměťový model, formát, název výstupního souboru apod.
Tyto parametry mohou být změněny později ve zdrojovém kódu pseudoinstrukcí
<a href="#PROGRAM">PROGRAM</a>.</p>
<p>Pořadí parametrů v konfiguračním souboru není důležité.
Na velikosti písmen v názvech parametrů nezáleží.
Parametry s logickými hodnotami (boolean) akceptují následující možnosti:
<code>ON, YES, TRUE, ENABLE, ENABLED</code> jako <em>zapnout</em>
a <code>OFF, NO, FALSE, DISABLE, DISABLED</code> jako <em>vypnout</em>.
Akceptují se rovněž numerické hodnoty, které budou převedeny na logické.</p>

<blockquote>Rozhodnete-li se zveřejnit svůj program v EuroAssembleru,
nemusíte specifikovat parametry příkazového řádku nutného ke kompilaci a linkování,
neboť tyto mohou být definovány v samotném zdrojovém kódu.
Typický program v &euro;ASM začíná konfigurační pseudoinstrukcí, jako např.
<code> EUROASM AUTOALIGN=YES,CPU=PENTIUM</code>,
takže pak není obtížné uhodnout, ve kterém asembleru byl napsán.
<br/>Jako vývojář programů v EuroAssembleru byste neměli spoléhat,
že uživatelé budou mít stejný obsah <q>euroasn.ini</q> jako vy.
Specifikujte všechna důležitá nastavení na začátku publikovaného zdrojového kódu.
Lokální konfigurační soubor se hodí během vývoje, kdy zdroje ve stejném adresáři
nemusejí explicitně specifikovat všechny parametry EUROASM a PROGRAM.
</blockquote>
<p>Povely ke konfiguraci EuroAssembleru jsou definovány v konfiguračních souborech
a ve zdrojových souborech pseudoinstrukcí <a href="#EUROASM">EUROASM</a>).
Jejich pořadí zpracování je následující:</p>

<ol><li>Když se <q>euroasm.exe</q> spustí, výchozí volby jsou již definovány pomocí <strong>factory defaults</strong>.</li>
<li>&euro;ASM se nyní podívá na <strong>příkazový řádek</strong>, kterým byl spuštěn.
Pokud zde byly definovány některé EUROASM volby, nahradí ty aktuálně platné.</li>
<li>&euro;ASM nyní načte <strong>globální konfigurační soubor</strong> a reaplikuje jeho volby.</li>
<li>Volby z <strong>příkazového řádku</strong> (pokud existují) jsou reaplikovány (krok 2 se opakuje).</li>
<li>Pak se &euro;ASM podívá na název zdrojového souboru na příkazové řádce,
a pokud <strong>lokální konfigurační soubor</strong> existuje ve stejném adresáři, je načten a aplikován
na současně platné hodnoty.</li>
<li>Zdrojový soubor je kompilován. Každá <strong>pseudoinstrukce EUROASM</strong>
nalezená v kódu přepisuje současně platnou verzi</li>
<li>Pokud je na příkazovém řádku nalezen další zdrojový soubor,
&euro;ASM obnoví konfiguraci uloženou na konci kroku&nbsp;4 a pak pokračuje od kroku&nbsp;5.</li>
</ol>

<h4 id="SourceFile"><a href="#FilesIO">&uarr; Zdrojový kód</a></h4>
<p>Soubor se zdrojovým kódem obsahuje instrukce k překladu, obvykle se jedná o soubor s prostým textem
nebo HTML text uzpůsobený pro &euro;ASM. Název souboru bude uveden na příkazovém řádku spouštějícím
<code>euroasm</code>. Může být doplněn absolutní cestou k souboru, například
<code>euroasm /user/home/euroasm/MyProject/MySource.asm</code>,
nebo relativní či vynechanou cestou.</p>
<p>Struktura a obsah zdrojového kódu, který je &euro;ASM schopen asemblovat a linkovat,
je popsán <a href="#ProgStruc">níže</a> v tomto dokumentu.</p>

<h4 id="ObjectFile"><a href="#FilesIO">&uarr; Cílový soubor</a></h4>
<p>Hlavním účelem programování je získat ze zdrojového soubor cílový soubor.
Může jím být <dfn>objektový soubor (modul)</dfn>
nebo <dfn>knihovna</dfn> linkovatelná k jiným souborům,
nebo to může být <dfn>binární soubor</dfn> ke speciálním účelům, anebo <dfn>spustitelný soubor</dfn>.</p>
<p>Formát cílového souboru je určen parametrem FORMAT= pseudoinstrukce PROGRAM.
Pro podrobnější informace o výstupních formátech viz kapitolu
<a href="#PgmFormats">Programové formáty</a>.</p>
<p>Název výstupního souboru je určen návěštím pseudoinstrukce PROGRAM,
k němuž je připojena přípona závislá na zvoleném formátu.
Název cílového souboru není nezbytně odvozen od názvu zdrojového souboru, jako u mnoha jiných asemblerů.
Pokud je například ve zdrojovém souboru povel <code>Hello PROGRAM FORMAT=COM</code>,
jeho výstupní soubor bude vytvořen v aktuálním adresáři a dostane název <q>Hello.com</q>
bez ohledu na název zdrojového souboru.
Defaultní jméno může být změněno parametrem <a href="#OUTFILEeq">OUTFILE=</a> pseudoinstrukce PROGRAM.
Pokud je OUTFILE= uvedeno s relativní (nebo s žádnou) cestou, použije se aktuální adresář.</p>

<h4 id="ListingFile"><a href="#FilesIO">&uarr; Listingový soubor</a></h4>
<h5><a href="#DumpParameters">Parametry dumpu &darr;</a></h5>
<h5><a href="#DumpSeparators">Oddělovače sloupců &darr;</a></h5>
<h5><a href="#DumpDecoration">Dekorátory dumpu &darr;</a></h5>
<h5><a href="#ListParameters">Parametry výpisu &darr;</a></h5>
<p><dfn>Listingový soubor</dfn> je prostý text, kam &euro;ASM zapisuje svou činnost:</p>
<ol><li>výsledek sestavení každého povelu asembleru (strojové instrukce) je zobrazen ve sloupci <dfn>dump</dfn> (generovaný hexadecimální kód)</li>
<li>zpracované povely jsou kopírovány do <dfn>zdrojového sloupce</dfn>.</li></ol>
<p>Název listingového souboru vychází z názvu a cesty zdrojového souboru, k němuž je připojena přípona <b>.lst</b>.
<br/>Tuto výchozí cestu a název listingu lze změnit parametrem <a href="#LISTFILEeq">LISTFILE=</a>
pseudoinstrukce EUROASM.</p>

<h5 id="DumpParameters" title="Dump parameters"><a href="#ListingFile">&uarr; Parametry dumpu</a></h5>
<p>Vytvořme zdrojový soubor <q>Hello.asm</q> s následujícím obsahem:</p><pre>
      EUROASM DUMP=ON,DUMPWIDTH=18,DUMPALL=YES
Hello PROGRAM FORMAT=COM,LISTLITERALS=ON, \
              LISTMAP=OFF,LISTGLOBALS=OFF
       MOV DX,=B"Hello, world!$"
       MOV AH,9
       INT 21h
       RET
      ENDPROGRAM Hello
</pre>
<p>Předložíme-li tento soubor EuroAssembleru příkazem
<code>euroasm Hello.asm</code>, vygeneruje se mimo jiné listing <q>Hello.asm.lst</q>.</p>
<p>Šířka hexadecimálního výstupu (levý sloupec listingu) je určena volbou
EUROASM <a href="#DUMPeq">DUMPWIDTH=</a>.
Další volby EUROASM, které ovlivňují levý sloupec, jsou <a href="#DUMPeq">DUMPALL=</a>
a <a href="#DUMPeq">DUMP=OFF</a>, která umí kompletně potlačit levý sloupec.</p>
<samp><abbr>|&lt;-Sloupec dump-&gt;|&lt;--Zdrojový sloupec-----
&lt;--DumpWidth=18--&gt;</abbr>
|                |      EUROASM DUMP=ON,DUMPWIDTH=18,DUMPALL=YES
|                |Hello PROGRAM FORMAT=COM,LISTLITERALS=ON, \
|                |              LISTMAP=OFF,LISTGLOBALS=OFF
|[COM]           ::::Section changed.
|0100:BA[0801]   |       MOV DX,=B"Hello, world!$"
|0103:B409       |       MOV AH,9
|0105:CD21       |       INT 21h
|0107:C3         |       RET
|[@LT1]          ====ListLiterals in section [@LT1].
|0108:48656C6C6F =B"Hello, world!$"
|010D:2C20776F72 ----Dumping all. <abbr>(kvůli DUMPALL=YES)</abbr>
|0112:6C64212400 ----Dumping all.
|                |      ENDPROGRAM Hello
<abbr>                 &#x25B2;
                oddělovač sloupců</abbr></samp>

<h5 id="DumpSeparators" title="Dump separators"><a href="#ListingFile">&uarr; Oddělovače sloupců</a></h5>
<p>Levý sloupec listingu vždy začíná indikátorem <em>strojové poznámky</em>
(znakem roura <kbd>|</kbd>) a je ukončen <em id="ListingColumns" title="Listing columns">
oddělovačem sloupců</em>, který určuje původ řádku.</p>
<table><caption>Oddělovač sloupců</caption>
<tr><th>Znak</th><th>Funkce</th></tr>
<tr><td><kbd>|</kbd> (roura)</td><td>Konec strojové poznámky. Používá se u běžných instrukcí, které mohou být znovu užity jako &euro;ASM zdroj.</td></tr>
<tr><td><kbd>!</kbd> (vykřičník)</td><td>Kopie zdrojového řádku s expandovanými %proměnnými (pokud <code>LISTVAR=ENABLED</code>).</td></tr>
<tr><td><kbd>+</kbd> (plus)</td><td>Zdrojové řádky generované při expanzi z %FOR,%WHILE,%REPEAT (pokud <code>LISTREPEAT=ENABLED</code>).</td></tr>
<tr><td><kbd>+</kbd> (plus)</td><td>Zdrojové řádky generované při expanzi z %MACRO (pokud <code>LISTMACRO=ENABLED</code>).</td></tr>
<tr><td><kbd>:</kbd> (dvojtečka)</td><td>Řádka přidaná do listingu k zobrazení změněné [sekce].</td></tr>
<tr><td><kbd>.</kbd> (tečka)</td><td>Řádka přidaná do listingu k zobrazení autoalignmentu (pokud <code>AUTOALIGN=ENABLED</code>).</td></tr>
<tr><td><kbd>-</kbd> (minus)</td><td>Řádka přidaná do listingu k zobrazení celého dumpu (pokud <code>DUMPALL=ENABLED</code>).</td></tr>
<tr><td><kbd>=</kbd> (rovnítko)</td><td>Řádka přidaná do listingu k zobrazení literálů (pokud <code>LISTLITERALS=ENABLED</code>).</td></tr>
<tr><td><kbd>&nbsp;</kbd> (mezera)</td><td>Řádka přidaná do listingu k zobrazení obálkových řádků PROGRAM..ENDPROGRAM.</td></tr>
<tr><td><kbd>*</kbd> (hvězdička)</td><td>Řádka přidaná do listingu k zobrazení povelu INCLUDE* s vyřešením zástupných znaků <kbd>*?</kbd></td></tr>
</table>
<p>S výjimkou oddělovače <em>roura</em> <kbd>|</kbd> mají řádky listingu formu
<a href="#MachineRemarks">strojové poznámky</a> a jsou tudíž ignorovány, pokud bude listing znovu předložen EuroAssembleru jako zdrojový soubor.</p>

<h5 id="DumpDecoration" title="Dump decoration"><a href="#ListingFile">&uarr; Dekorátory dumpu</a></h5>
<p>Hexadecimální výpis strojového kódu (dump) u emitujících povelů začíná hexadecimální adresou (ofsetem v aktuální sekci),
která je ukončena dvojtečkou <kbd>:</kbd>.
V 16bitové sekci je tato adresa široká 16 bitů (čtyři hexadecimální cifry), v 32bitové a 64bitové sekci je to 32 bitů.
Pak následují emitované (generované) bajty. Čísla v levém sloupci jsou vždy v hexadecimálním tvaru,
bez uvádění explicitního <a href="#NumberModifiers">číselného modifikátoru</a>.</p>
<p>Pokud je zvolený parametr DUMPWIDTH= příliš nízký k zobrazení všech dat,
jsou buď vpravo oříznuty a nahrazeny tildou <kbd>~</kbd> (pokud&nbsp;<code>DUMPALL=OFF</code>),
anebo jsou do listingu přidány další řádky s oddělovačem <kbd>-</kbd> (pokud <code>DUMPALL=ON</code>).</p>
<p id="Disp8N" title="Disp8*N">V hexadecimálním výpisu mohou být použity ještě další dekorátory:</p>
<table><caption>Dekorátory dumpu</caption>
<tr><th>Dekorátor</th><th>Popis</th></tr>
<tr><td><kbd>~</kbd></td><td>indikace zkrácení výpisu, používaná pokud <code>DUMPALL=OFF</code></td></tr>
<tr><td><kbd>..</kbd></td><td>bajt rezervovaných dat (namísto hexadecimální hodnoty jsou-li data inicializována)</td></tr>
<tr><td><kbd>[]</kbd></td><td>indikátor absolutní relokace</td></tr>
<tr><td><kbd>()</kbd></td><td>indikátor relativní relokace</td></tr>
<tr><td><kbd>{}</kbd></td><td>indikátor paragrafové relokace</td></tr>
<tr><td><kbd>&lt;N</kbd></td><td>použita komprese disp8*N</td></tr>
</table>
<p>Závorky <kbd>[]</kbd>, <kbd>()</kbd> a <kbd>{}</kbd> obklopující hexadecimálně vypsané slovo nebo dvojslovo
indikují, že adresa vyžaduje relokaci v link-time.
Hodnota zobrazená v listingu se bude lišit od ofsetu zobrazovaného ve slinkovaném kódu
nebo v debugeru při běhu programu.</p>
<p>Znak <kbd>&lt;</kbd> následovaný dekadickou číslicí (<kbd>N</kbd>) signalizuje, že
předchozí 8bitový displacement má být posunout vlevo o N bitů k získání efektivní hodnoty.
 (takzvaná komprese <b>disp8*N</b>).
Číslice 1..6 specifikující kompresní faktor <kbd>N</kbd> není do sestaveného kódu emitována.</p>
<samp> <abbr>Závorky  [ ] a { } indikují relokabilní hodnoty.</abbr>
|                            |         EUROASM DUMPWIDTH=30,CPU=X64,SIMD=AVX512,EVEX=ENABLED
|[CODE] <abbr>&#x25BC;    &#x25BC;&#x25BC;    &#x25BC;</abbr>         |[CODE]   SEGMENT WIDTH=16
|0000:EA[0500]{0000}         |         JMPF Label ; Absolute far jump encodes immediate seg:offset.
|0005:CB                     |Label:   RETF
|[CODE64]                    |[CODE64] SEGMENT WIDTH=64
|00000000:62F36D28234D02&lt;504 |         VSHUFF32X4 YMM1,YMM2,[RBP+40h],4
|00000008:C3            <abbr>&#x25B2;&#x25B2;</abbr>   |         RET
                        <abbr>&lt;5 je neemitovaný dekorátor disp8*N.
                      &#x25B2;&#x25B2;Displacement +02h bude posunut vlevo 5krát,
                        takže efektivní displacement je ve skutečnosti +40h.</abbr>
</samp>
<p>U <strong>neemitujících instrukcí</strong> je sloupec dumpu buď prázdný, nebo obsahuje přídavné informace:</p>
<samp>|[DATA]        |[DATA] ; <abbr>Přepnutí segment|section opakuje název ve sloupci dumpu.</abbr>
|0000:         |; <abbr>Prázdný nebo komentářový řádek zobrazuje ve sloupci dumpu pouze adresu v současné sekci.</abbr>
|0000:         |Label: ; <abbr>Ditto.</abbr>
|              |;; <abbr>Řádkový komentář začínající dvojitým středníkem potlačí výpis adresy ve sloupci dumpu.</abbr>
|[DATA]:0000   |Target EQU Label: ; <abbr>Adresní symbol je zobrazen jako <code>[segment]:offset</code>.</abbr>
|4358          |%Counter %SET CX ; <abbr>Nastavení %variable vypisuje její obsah hexadecimálně.</abbr>
|TRUE          | %IF "%Counter" == "CX" ; <abbr>Předasemblerovský konstrukt zobrazuje vyhodnocenou logickou podmínku.</abbr>
|[]:0010       |  Bits EQU 16 ; <abbr>Skalár (numerický symbol) je zobrazen s prázdným segmentem.</abbr>
|FALSE         | %ELSE ; <abbr>Logické podmínky se týkají pseudoinstrukcí %IF, %ELSE, %WHILE, %UNTIL.</abbr>
|              |  Bits EQU 32 ; <abbr>Dump je prázdný v neemitovaných větvích %IF.</abbr>
|              | %ENDIF
</samp>

<h5 id="ListParameters" title="List parameters"><a href="#ListingFile">&uarr; Parametry výpisu</a></h5>
<p>Listingový soubor ve své defaultní konfiguraci je víceméně přesnou kopií zdrojového souboru,
až na přidaný sloupec dumpu.
V některých případech může být potřeba zkontrolovat, zda určité konstrukty fungují podle očekávání.
To se řídí následujícími parametry pseudoinstrukce EUROASM:
<br/><a href="#LISTeq">LISTINCLUDE=ON</a> zobrazuje obsah vloženého souboru, který by byl jinak skryt.
<br/><a href="#LISTeq">LISTVAR=ON</a> vytváří kopii každého povelu, ve které nahradí preprocesorovou %proměnnou její expandovanou hodnotou.
<br/><a href="#LISTeq">LISTMACRO=ON</a> vkládá do listingu povely expandované v makroinstrukci.
<br/><a href="#LISTeq">LISTREPEAT=ON</a> vkládá všechny iterace opakujících se konstruktů
<code>%FOR..%ENDFOR, %WHILE..%ENDWHILE, %REPEAT..%ENDREPEAT</code>.
Opakující se expanze jsou v listingu zobrazeny jako vykomentované pomocí <a href="#DumpSeparators">separátoru</a> <kbd>+</kbd>.
Ve výchozím stavu, kdy je <code>LISTREPEAT=DISABLED</code>, je zobrazována pouze první expanze.</p>
<blockquote><p>Užitečnou vlastností listingu v &euro;ASM je snaha udržovat jej znovupoužitelný jako zdrojový kód.</p>
<p>Chtěl jsem udržet tuto funkčnost bez ohledu na stav parametrů LIST*.
Ve výchozím stavu, kdy je <code>LISTINCLUDE=OFF</code>, je povel INCLUDE normálně zobrazen a obsah vloženého souboru je skryt.
Povelem <code>EUROASM LISTINCLUDE=ON</code> se to obrací: originální pseudoinstrukce INCLUDE
je odkomentována <a href="#DumpSeparators">separátorem dumpu</a> <kbd>*</kbd>, avšak řádky vložené tímto souborem
jsou vloženy do listingu a stávají se tak platnými zdrojovými příkazy.
Viz test <a class="EXT" href="../eatests/t2220.htm">t2220</a>.</p>
<p>Jsou li volby <code>LISTVAR, LISTMACRO, LISTREPEAT</code> zapnuty (enabled), originální řádek s parametrem
<code>EUROASM LISTVAR=ENABLED</code> je zachován a expandované řádky budou vloženy pod něj a odkomentovány
<a href="#DumpSeparators">separátorem</a> <kbd>!</kbd> nebo <kbd>+</kbd>.
Viz test <a class="EXT" href="../eatests/t2230.htm">t2230</a>.</p></blockquote>
<p>Volba <a href="#LISTeq">EUROASM LIST=DISABLE</a> zcela vypne generování listingu až do opětovného povolení,
případně do konce souboru. Takový listing samozřejmě nebude znovupoužitelný jako zdrojový soubor.</p>


<h4 id="FilePath"><a href="#FilesIO">&uarr; Cesty k souborům</a></h4>
<p>Diskové soubory mohou být specifikovány včetně <strong>absolutní cesty</strong>,
tj. cesty jež začíná v kořenu souborového systému, např.
<code>C:\ProgFiles\euroasm.exe D:\Project\source.asm</code>.</p>
<p>Soubory mohou být rovněž určeny <strong>relativní cestou</strong>,
např. <code>euroasm ..\prowin32\skeleton.asm</code>.
Relativní cesta se vždy vztahuje k současnému pracovnímu adresáři.</p>
<p>Soubory mohou být specifikovány <strong>bez cesty</strong>,
tj, pokud jejich název neobsahuje dvojtečku ani lomítko <kbd>:</kbd>, <kbd>\</kbd>, <kbd>/</kbd>.
Umístění takových souborů je pak rekapitulováno níže uvedenou tabulkou:</p>

<table><caption>Adresář použitý při specifikaci souboru bez cesty</caption>
<tr><th>Soubor</th><th>Význam</th><th>Umístění</th><th>Viz také</th></tr>
<tr><td>Executable</td><td><q>euroasm.exe</q></td><td>Adresář s <q>euroasm.exe</q></td><td>OS PATH</td></tr>
<tr><td>Input</td><td>Globalní <q>euroasm.ini</q></td><td>Viz instalační instrukce</td><td></td></tr>
<tr><td>Output</td><td>Globalní <q>euroasm.ini</q></td><td>Viz instalační instrukce</q></td><td></td></tr>
<tr><td>Input</td><td>Lokální <q>euroasm.ini</q></td><td>Adresář se zdrojem</td><td></td></tr>
<tr><td>Input</td><td>Zdrojový soubor</td><td>Aktuální adresář</td><td></td></tr>
<tr><td>Input</td><td>Vložený zdrojový soubor</td><td>Adresář vkládaných souborů</td><td><code>EUROASM INCLUDEPATH=</code></td></tr>
<tr><td>Output</td><td>Cílový soubor </td><td>Aktuální adresář</td><td><code>PROGRAM OUTFILE=</code></td></tr>
<tr><td>Output</td><td>Listingový soubor</td><td>Adresář se zdrojem</td><td><code>EUROASM LISTFILE=</code></td></tr>
<tr><td>Input</td><td>Linkovaný modul</td><td>Adresář linkovaných modulů</td><td><code>EUROASM LINKPATH=</code></td></tr>
<tr><td>Input</td><td>Linkovaný stub</td><td>Adresář linkovaných modulů</td><td><code>PROGRAM STUBFILE=</code></td></tr>
<tr><td>Input</td><td>Linkovaný soubor ikony</td><td>Adresář linkovaných modulů</td><td><code>PROGRAM ICONFILE=</code></td></tr>
<tr><td>Import</td><td>Dynamicky importovaná funkce</td><td>Závisí na OS</td><td><code>IMPORT LIB=</code></td></tr>
</table>

<p><dfn>Aktuálním adresářem</dfn> se rozumí složka přiřazená shellu v okamžiku, kdy byl <q>euroasm.exe</q> spuštěn.
&euro;ASM ho nikdy nemění.</p>
<p><dfn>Adresář s <q>euroasm.exe</q></dfn> je složka, v níž se nachází <q>euroasm.exe</q>,
obvykle jeden z adresářů uvedených v proměnné environmentu PATH.</p>
<p><dfn>Adresář se zdrojem</dfn> je složka, v níž je umístěn soubor s překládaným zdrojovým kódem.</p>
<p><dfn>Adresář vkládaných souborů</dfn> je jeden z adresářů uvedených v parametru
<code>EUROASM INCLUDEPATH=</code>.</p>
<p><dfn>Adresář linkovaných modulů</dfn> je jeden z adresářů uvedených v parametru
<code>EUROASM LINKPATH=</code>.</p>

<hr/>
<h2 id="ProgStruc" title="Structure of program"><a href="#top">&uarr; Struktura &euro;ASM programu</a></h2>

<h3><a href="#ProgStrucChar">Znaková struktura &darr;</a></h3>
<h3><a href="#ProgStrucHor">Horizontální struktura &darr;</a></h3>
<h3><a href="#ProgStrucVer">Vertikální struktura &darr;</a></h3>

<p>Tato kapitola popisuje formát zdrojového souboru, kterému  &euro;ASM rozumí a je schopen jej překládat.</p>
<hr/>
<h3 id="ProgStrucChar"><a href="#ProgStruc">&uarr; Znaková sktruktura</a></h3>
<h4><a href="#ProgStrucCharWidth">Šířka znaků &darr;</a></h4>
<h4><a href="#ProgStrucCharCode">Kódování znaků &darr;</a></h4>
<h4><a href="#ProgStrucCharCase">Velikost písmen &darr;</a></h4>
<h4><a href="#ProgStrucCharClass">Klasifikace znaků &darr;</a></h4>

<hr/>
<h4 id="ProgStrucCharWidth"><a href="#ProgStrucChar">&uarr; Šířka znaků</a></h4>
<h6>Zdrojový soubor obsahuje sled znaků s šířkou 8 bitů nebo s proměnnou šířkou
8..32 bitů (v kódu UTF-8).</h6>
<p>Pokud byl zdrojový text napsán editorem používajícím WIDE (16bitové) kódování znaků (UTF-16),
musí být nejprve uložen jako prostý text v UTF-8 nebo v 8bitovém kódování ANSI nebo OEM,
než bude předložen EuroAssembleru.</p>

<h4 id="ProgStrucCharCode"><a href="#ProgStrucChar">&uarr; Kódování znaků</a></h4>
<p>Program napsaný v &euro;ASM může chtít zobrazovat texty v jiných jazycích než v angličtině.
Takový text obsahuje znaky s hodnotou <dfn id="Codepoint" title="Codepoint">codepointu</dfn> nad 127
(codepoint je pořadové číslo znaku v tabulce <a class="EXTL" href="../eadoc/links.htm#Unicode">[Unicode]</a>).
<br/>Mnoho evropských jazyků se spokojí s omezenou sadou 256 znaků.
Relace mezi jejich kódy a odpovídajícím fontem se nazývá  <dfn>kódová stránka</dfn> (Codepage).</p>
<p>MS-Windows používá různé kódové strany v konzolových aplikacích (OEM)
a v grafických aplikacích (ANSI) a občas mezi nimi provádí automatické konverze.
Avšak &euro;ASM kódovou stranu zdrojového textu nikdy nemění.</p>
<p>Programátor používající v aplikaci několik lidských jazyků by měl v MS-Windows používat 16bitové znaky WIDE
namísto 8bitových ANSI znaků v textových řetězcích. Jako demo-ukázku viz <a class="EXT" href="../prowin32/cpmix32.htm">cpmix32</a>.</p>
<p>Široké kódování (UTF-16) je definováno pseudoinstrukcí <code>DU</code> (Define data in Unichars)
namísto <code>DB</code> (Define data in Bytes).
Příslušné volání WinAPI musí být ve variantě WIDE pro správnou vizuální reprezentaci za běhu,
např. <code>TextOutW()</code> namísto ANSI varianty <code>TextOutA()</code>.
I tak ale kódování znaků v definici <code>DU</code> je stále 8bitové.
Měli byste sdělit EuroAssembleru, která kódová strana byla použita při psaní 8bitového zdrojového textu.
Tuto informaci poskytuje parametr <code>EUROASM CODEPAGE=</code>.
Kódová strana se může v rámci zdrojového textu dynamicky měnit a dovoluje tak střídat
více jazyků v rámci téhož programu.</p>
<p>Texty mířící na konzolu
(používající ANSI verzi WinAPI funkcí, jako např. <code>WriteConsoleA()</code> nebo makroinstrukci <a class="EXT" href="../maclib/winapi.htm#StdOutput">
StdOutput</a>) by měly být psány v kódové stránce OEM.
Asi budete používat dosový editor plain-textu, jako např. <q>EDIT.COM</q>
ke psaní konzolových programů. Tyto editory používají konzolové fonty v OEM kódových stránkách,
takže texty jsou zobrazeny korektně jak v editoru během psaní programu, tak i za jeho běhu.</p>
<p>Texty s volbou PROGRAM SUBSYSTEM=GUI zamýšlené pro grafický mód (používající WinAPI funkce jako <code>TextOutA()</code>)
by měly být psány v kódové straně ANSI, např. pomocí <q>Notepad.exe</q>.</p>

<p>Výchozí volbou je <code>EUROASM CODEPAGE=UTF-8</code>, kdy znaky mají proměnnou šířku od jednoho do čtyř bajtů.
Díky inteligentnímu kódování <a class="EXTL" href="links.htm#UTF8">[UTF8]</a> jsou všechny non-ASCII UTF-8 znaky
kódovány jako bajty s hodnotou 128..255, což &euro;ASM považuje za <a href="#ProgStrucCharClass">písmena</a>,
takže mohou být beze změny použity v indentifikátorech.</p>
<h6>Doporučené kódování zdrojových textů EuroAssembleru je UTF-8.</h6>

<p>Na rozdíl od 8bitových kódování ANSI nebo OEM, které omezují repertoár na 256 znaků,
CODEPAGE=UTF-8 dovoluje mísení libovolných znaků definovaných v tabulce
 <a class="EXTL" href="../eadoc/links.htm#Unicode">
[Unicode]</a> včetně neevropských abeced.
MS-Windows API nepodporuje přímo řetězce v UTF-8, tyto vyžadují překódování za běhu
na UTF-16, které jsou používány variantou WIDE u WinAPI funkcí jako TextOutW().
Toto překódování zajistí WinAPI MultiByteToWideChar() anebo makro
<a class="EXT" href="../maclib/string32.htm#DecodeUTF8">DecodeUTF8</a>.
Samozřejmě ke korektnímu zobrazování exotických znaků (asijské abecedy, emoji ap.)
je potřeba mít instalovány patřičné fonty.</p>
<blockquote>Příklad freeware textového editoru podporujícího kódování UTF-8
je <a class="EXTL" href="../eadoc/links.htm#PSPad">[PSPad]</a>.
<br/>Některé editory vkládají na začátek souboru sekvenci <dfn id="BOM" title="BOM byte order mark">
Byte Order Mark</dfn>, tj. <code>0xEF, 0xBB, 0xBF</code>.
EuroAssembler tyto tři bajty ignoruje.</blockquote>

 <h4 id="ProgStrucCharCase"><a href="#ProgStrucChar">&uarr; Velikost písmen</a></h4>
<h6>&euro;ASM je částečně nezávislý na velikosti písmen.</h6>
<p>U všech identifikátorů vytvořených vámi (programátorem)
na velikosti písmen <strong>záleží</strong>: návěští, konstanty,
uživatelské %proměnné, struktury, sekce, názvy maker.
Naopak u vestavěných názvů na velikosti písmen
<strong>nezáleží</strong>.
Necitlivost k velikosti se týká všech výčtových hodnot:
názvů registrů, strojových instrukcí a prefixů, vestavěných datových typů,
číselných modifikátorů, jmen a parametrů pseudoinstrukcí, souborových atributů,
systémových %^proměnných.</p>
<p>Názvy nezávislé na velikosti znaků jsou v tomto manuálu uváděny VELKÝMI PÍSMENY,
ale mohly být zrovna tak psány malými nebo smíšenými znaky.</p>

<h4 id="ProgStrucCharClass"><a href="#ProgStrucChar">&uarr; Klasifikace znaků</a></h4>
<p>Každý bajt (8 bitů) ve zdrojovém textu &euro;ASM je považován za <dfn>znak</dfn>. Mnoho znaků
má v syntaxi asembleru speciální funkci, až na případy, kdy jsou umístěny uvnitř dvojitých nebo jednoduchých uvozovek.
Znak je považován za neuvozený (<dfn id="Unquoted" title="Unquoted">unquoted</dfn>) pokud se mezi ním a mezi počátkem řádku
vyskytlo nula nebo sudý počet uvozovek.</p>
<dl><dt>Konec řádku</dt><dd>Znak určující konec řádku je <dfn>Line Feed</dfn> alias <dfn>EOL</dfn> (ASCII 10).</dd>
<dt>Netisknutelné znaky</dt><dd>Ostatní řídicí znaky, delete a mezera se považují za netisknutelné znaky (<dfn>white spaces</dfn>).
Mohou být použity jako oddělovače zlepšující čitelnost, avšak jen zřídka mají nějaký syntaktický význam.
Neuvozené vícenásobné netisknutelné znaky jsou zpracovány stejně jako znak jediný.</dd>
<dt>Číslice</dt><dd>Číslice <kbd>0..9</kbd> tvoří čísla a identifikátory. Hexadecimální čísla
mohou navíc obsahovat hexadecimální číslice <kbd>A..F, a..f</kbd>.</dd>
<dt>Písmena</dt><dd>Za písmena se v &euro;ASM považují znaky <kbd>a..z, A..Z</kbd>, podtržení <kbd>_</kbd>,
komerční at <kbd>@</kbd>, dolar <kbd>$</kbd>, přízvuk grave <kbd>`</kbd>, otazník <kbd>?</kbd>
a všechny znaky z horní poloviny ASCII tabulky (128..255).
<br/>Několik písmen je v &euro;ASM využito ke speciálním účelům:
<br/>Podtržítko <kbd>_</kbd> je používáno v identifikátorech a číslech jako oddělovač namísto mezery.
<br/>Komerční at na začátku názvu indikuje název sekce s literály.
<br/>Samotné znaménko dolaru <kbd>$</kbd> představuje symbol reprezentující současný ofset v rámci sekce.
<br/>Znak grave <kbd>`</kbd> se používá jako prefix v případech, kdy název souboru nezačínající písmenem
má představovat platný identifikátor.</dd>
<dt>Ostatní</dt><dd>Všechny ostatní znaky mají v &euro;ASM speciální význam
&ndash; operátory, oddělovače, modifikátory apod.&ndash; ledaže by byly umístěny uvnitř dvojice jednoduchých
<kbd>'</kbd> nebo dvojitých <kbd>&quot;</kbd> uvozovek. S výjimkou
procenta <kbd>%</kbd> a konce řádku EOL jsou tyto znaky považovány za běžná písmena, pokud jsou
umístěny uvnitř řetězce v uvozovkách.</dd>
</dl>

<table id="CharacterTable" title="Character table">
<caption id="ASCIItable" title="ASCII characters">Tabulka klasifikace znaků</caption>
<tr class="row1"><th>ASCII</th><th>znak</th> <th>jméno  </th><th>funkce v &euro;ASM</th></tr>
<tr><td>0..9</td><td> </td>      <td>řídicí             </td><td>netisknutelný znak neboli bílá mezera</td></tr>
<tr><td>10</td><td> </td>        <td>konec řádku        </td><td>konec řádku</td></tr>
<tr><td>11..31</td><td> </td>    <td>řídicí             </td><td>netisknutelný znak neboli bílá mezera</td></tr>
<tr><td>32</td><td> </td>        <td>mezera             </td><td>netisknutelný znak neboli bílá mezera</td></tr>
<tr><td>33</td><td>!</td>        <td>vykřičník          </td><td>logický operátor</td></tr>
<tr><td>34</td><td>"</td>        <td>dvojitá uvozovka   </td><td>ohraničení řetězce</td></tr>
<tr><td>35</td><td>#</td>        <td>modifikátor        </td><td>modifikátor</td></tr>
<tr><td>36</td><td>$</td>        <td>dolar              </td><td>písmeno</td></tr>
<tr><td>37</td><td>%</td>        <td>procento           </td><td>prefix preprocesingu</td></tr>
<tr><td>38</td><td>&amp;</td>    <td>ampersand          </td><td>logický operátor</td></tr>
<tr><td>39</td><td>'</td>        <td>apostrof           </td><td>ohraničení řetězce</td></tr>
<tr><td>40</td><td>(</td>        <td>levá závorka       </td><td>prioritní závorka</td></tr>
<tr><td>41</td><td>)</td>        <td>pravá závorka      </td><td>prioritní závorka</td></tr>
<tr><td>42</td><td>*</td>        <td>hvězdička          </td><td>aritmetický a speciální operátor</td></tr>
<tr><td>43</td><td>+</td>        <td>plus               </td><td>aritmetický operátor</td></tr>
<tr><td>44</td><td>,</td>        <td>čárka              </td><td>oddělovač operandů</td></tr>
<tr><td>45</td><td>-</td>        <td>minus              </td><td>aritmetický operátor</td></tr>
<tr><td>46</td><td>.</td>        <td>tečka              </td><td>oddělovač členů</td></tr>
<tr><td>47</td><td>/</td>        <td>lomítko            </td><td>aritmetický operátor</td></tr>
<tr><td>48..57</td><td>0..9</td> <td>číslice            </td><td>číslice</td></tr>
<tr><td>58</td><td>:</td>        <td>dvojtečka          </td><td>oddělovač</td></tr>
<tr><td>59</td><td>;</td>        <td>středník           </td><td>indikátor komentáře</td></tr>
<tr><td>60</td><td>&lt;</td>     <td>méně než           </td><td>logický operátor, oddělovač komentáře</td></tr>
<tr><td>61</td><td>=</td>        <td>rovnítko           </td><td>logický operátor, klíčový oddělovač, indikátor literálu</td></tr>
<tr><td>62</td><td>&gt;</td>     <td>více než           </td><td>logický operátor</td></tr>
<tr><td>63</td><td>?</td>        <td>otazník            </td><td>písmeno</td></tr>
<tr><td>64</td><td>@</td>        <td>komerční at        </td><td>písmeno</td></tr>
<tr><td>65..90</td><td>A..Z</td> <td>velká písmena      </td><td>písmeno</td></tr>
<tr><td>91</td><td>[</td>        <td>levá hranatá závorka</td><td>závorka paměťového obsahu, operátor substringu</td></tr>
<tr><td>92</td><td>\</td>        <td>zpětné lomítko     </td><td>aritmetický operátor, pokračování řádku</td></tr>
<tr><td>93</td><td>]</td>        <td>pravá hranatá závorka</td><td>závorka paměťového obsahu, operátor substringu</td></tr>
<tr><td>94</td><td>^</td>        <td>caret              </td><td>logický operátor</td></tr>
<tr><td>95</td><td>_</td>        <td>podtržítko         </td><td>písmeno, oddělovač číslic</td></tr>
<tr><td>96</td><td>`</td>        <td>grave              </td>  <td>písmeno</td></tr>
<tr><td>97..122</td><td>a..z</td><td>malá písmena       </td><td>písmeno</td></tr>
<tr><td>123</td><td>{</td>       <td>levá složená závorka</td><td>operátor sublistu</td></tr>
<tr><td>124</td><td>|</td>       <td>roura              </td><td>logický operátor, oddělovač strojové poznámky</td></tr>
<tr><td>125</td><td>}</td>       <td>pravá složená závorka</td><td>operátor sublistu</td></tr>
<tr><td>126</td><td>~</td>       <td>tilda              </td><td>logický operátor, indikace zkratky</td></tr>
<tr><td>127</td><td> </td>       <td>delete             </td><td>netisknutelný znak neboli bílá mezera</td></tr>
<tr><td>128..255</td><td> </td>  <td>non ASCII znaky     </td><td>písmeno</td></tr>
<tr class="row1"><th>ASCII</th><th>znak</th> <th>jméno </th><th>funkce v &euro;ASM</th></tr>
</table>

<hr/>

<h3 id="ProgStrucHor"><a href="#ProgStruc">&uarr; Horizontální struktura</a></h3>
<h4><a href="#PhysicalLine">Fyzický řádek &darr;</a></h4>
<h4><a href="#Statement">Instrukce &darr;</a></h4>
<h4><a href="#StmentMachineRem">Strojová poznámka &darr;</a></h4>
<h4><a href="#StmentLabel">Návěstí &darr;</a></h4>
<h4><a href="#StmentPrefix">Prefix &darr;</a></h4>
<h4><a href="#StmentOperation">Operace &darr;</a></h4>
<h4><a href="#StmentOperand">Operand(y) &darr;</a></h4>
<h4><a href="#StmentLineRem">Řádková poznámka &darr;</a></h4>
<h4><a href="#StmentLineCont">Pokračování řádku &darr;</a></h4>
<p>Zdrojový soubor považujeme za text sestávající z řádků zpracovávaných zleva doprava, shora dolů.</p>
<hr/>
<h4 id="PhysicalLine" title="Physical line"><a href="#ProgStrucHor">&uarr; Fyzický řádek</a></h4>
<p>Zdrojový soubor sestává z <dfn>fyzických řádků</dfn>.
Fyzický řádek je řada znaků zakončená EOL (ASCII 10). Znak EOL je rovněž součástí fyzického řádku.
Může být vynechán pouze pokud se jedná o poslední fyzický řádek souboru.</p>

<h4 id="Statement"><a href="#ProgStrucHor">&uarr; Instrukce </a></h4>
<p><dfn>Instrukce</dfn> (statement) je příkaz pro &euro;ASM provést určitou akci,
obvykle emitovat nějaký kód do cílového souboru nebo změnit svůj vnitřní stav.
Typická instrukce zabírá právě jeden fyzický řádek, avšak delší instrukce
mohou přesahovat do dalších řádků, pokud je použito
<a href="#StmentLineCont">pokračování řádku</a>.</p>
<p>Instrukce sestává z několika polí, ty jsou rozlišovány podle
pozice v řádku, podle separátoru nebo podle jejich obsahu.
Všechna pole instrukce jsou nepovinná, kterékoli může být vynecháno,
jen pole operandů nelze použít, bylo-li vynecháno pole operace.</p>
<table id="StmentFiedlsTable">
<caption>Pole v rámci instrukce</caption>
<tr><th>Pořadí</th><th>Název pole</th><th>Ukončení</th></tr>
<tr><td>1.</td><td>Strojová poznámka</td><td><kbd>|</kbd> nebo <kbd>EOL</kbd></td></tr>
<tr><td>2.</td><td>Návěstí        </td><td><kbd>:</kbd> nebo <kbd>bílá mezera</kbd></td></tr>
<tr><td>3.</td><td>Prefix         </td><td><kbd>:</kbd> nebo <kbd>bílá mezera</kbd></td></tr>
<tr><td>4.</td><td>Operace        </td><td><kbd>bílá mezera</kbd></td></tr>
<tr><td>5.</td><td>Operand        </td><td><kbd>,</kbd></td></tr>
<tr><td>6.</td><td>Řádkový komentář</td><td><kbd>EOL</kbd></td></tr>
</table>
<p>Příklad instrukce:</p>
<samp><abbr>|    strojová poznámka     |Návěstí|Prefix|Operace |  Operand      | Řádkový komentář</abbr>
|00001234:F08705[78560000]  |Mutex: LOCK:  XCHG      EAX,[TheLock] ; Guard the thread.
</samp>

<h4 id="StmentMachineRem"><a href="#ProgStrucHor">&uarr; Strojová poznámka</a></h4>
<p>Strojová poznámka začíná znakem vertikální čára (roura) <code>|</code>, pokud je to první
nebílý znak na řádku. Poznámka je ukončena druhým výskytem téhož znaku anebo koncem fyzického řádku.</p>
<blockquote>Obsahem strojové poznámky je obvykle hexadeciální adresa následovaná
strojovým kódem generovaným dotyčnou instrukcí. Jak její název napovídá,
strojovou poznámku generuje počítač do listingového souboru; programátor ji nikdy nepotřebuje generovat ručně
<br/>Strojové poznámky jsou ve zdrojovém kódu ignorovány, takže platný listing může být beze změny znovupoužit
jako zdrojový soubor.</blockquote>

<h4 id="StmentLabel" title="Label"><a href="#ProgStrucHor">&uarr; Návěstí</a></h4>
<p>Pole pro návěstí může hostit kterýkoli z těchto prvků:</p>
<ol><li>Jméno struktury nebo symbolu nebo identifikátor bloku, např.
<code>My1stStructure</code>, <code>My1stLabel:</code>, <code>Outer</code></li>
<li>Jméno sekce, segmentu nebo grupy v hranatých závorkách. např. <code>[.data]</code></li>
<li>Jméno předprocesorové %proměnné nastavované pomocí %SET*, např. <code>%Count</code></li>
<li>Samotná dvojtečka <kbd>:</kbd> výslovně říká EuroAssembleru, že je použito prázdné návěstí,
takže následující pole musí být prefix nebo operace.</li>
</ol>
<P>V prvním případě může jméno symbolu nebo struktury začínat tečkou <code>.</code>,
což je činí <dfn>lokálním</dfn>. Symbol v poli návěstí může být zakončen jednou nebo více dvojtečkami
<code>:</code> bezprostředně za identifikátorem.
Mezera mezi návěstím a následným polem může být v tom případě vynechána.

<h4 id="StmentPrefix"><a href="#ProgStrucHor">&uarr; Prefix</a></h4>
<p>Strojový <dfn>prefix</dfn> je povel pro CPU změnit svůj vnitřní stav za běhu programu (v run-time).
Podobá se strojové instrukci a ovlivňuje následující instrukci za běhu.
Každý prefix se překládá na jednobytový operační kód.</p>

<table id="Prefixes" title="Prefixes">
<caption>Tabulka prefixů</caption>
<tr class="row1"><th>Jméno</th><th>Skupina</th><th>Operační kód</th></tr>
<tr><td>LOCK</td><td>1</td><td>0xF0</td></tr>
<tr><td>REP</td><td>1</td><td>0xF3</td></tr>
<tr><td>REPE</td><td>1</td><td>0xF3</td></tr>
<tr><td>REPZ</td><td>1</td><td>0xF3</td></tr>
<tr><td>REPNE</td><td>1</td><td>0xF2</td></tr>
<tr><td>REPNZ</td><td>1</td><td>0xF2</td></tr>
<tr><td>XACQUIRE</td><td>1</td><td>0xF2</td></tr>
<tr><td>XRELEASE</td><td>1</td><td>0xF3</td></tr>
<tr><td>SEGCS</td><td>2</td><td>0x2E</td></tr>
<tr><td>SEGSS</td><td>2</td><td>0x36</td></tr>
<tr><td>SEGDS</td><td>2</td><td>0x3E</td></tr>
<tr><td>SEGES</td><td>2</td><td>0x26</td></tr>
<tr><td>SEGFS</td><td>2</td><td>0x64</td></tr>
<tr><td>SEGGS</td><td>2</td><td>0x65</td></tr>
<tr><td>SELDOM</td><td>2</td><td>0x2E</td></tr>
<tr><td>OFTEN</td><td>2</td><td>0x3E</td></tr>
<tr><td>OTOGGLE</td><td>3</td><td>0x66</td></tr>
<tr><td>ATOGGLE</td><td>4</td><td>0x67</td></tr>
</table>
<p>Poslední čtyři názvy jsou implementovány pouze v EuroAssembleru.
<br/><code>SELDOM</code> a <code>OFTEN</code> lze použít před podmíněnými skoky jako nápovědu pro novější CPU, jak předvídat výsledek.
<br/><code>OTOGGLE</code> a <code>ATOGGLE</code> přepínají mezi 16bitovou a 32bitovou šířkou operandů a adresní částí strojového kódu.
Tyto prefixy jsou normálně generovány asemblerem interně, bez explicitní žádosti.</p>
<p>V jedné instrukci mohou být definovány až čtyři prefixy, avšak z každé skupiny pouze jeden.</p>
<h6>Jméno prefixu nelze použít jako návěstí, bez ohledu na velikost písmen.</h6>
<p>Názvy prefixů jsou rezervovány, nelze je použít jako návěstí.
Název může být zakončen dvojtečkou <kbd>:</kbd>, podobně jako symbol.</p>

<p>64bitová architektura AMD a Intel zavedla speciální prefixy <code>REX</code>,
<code>XOP</code>, <code>VEX</code>, <code>MVEX</code>, <code>EVEX</code>.
&euro;ASM považuje tyto prefixy za součást zakódování operace a neposkytuje proto mnemoniku pro jejich přímou deklaraci.</p>
<blockquote><a class="EXTL" href="links.htm#AMDSSE5">[AMDSSE5]</a> zavedl ještě jeden prefix
<code>DREX</code>, avšak jelikož se instrukce s tímto prefixem nedostaly do výroby, &euro;ASM je nepodporuje.</blockquote>
<p>Prefixy pro změnu segmentu SEG*S mohou být alternativně předpisovány jako komponenty
paměťových proměnných v rámci <a href="#RegisterExpressions">registrového výrazu</a>.
V tom případě je prefix emitován pouze pokud není redundantní (pokud specifikuje nedefaultní segment).
Explicitně specifikované prefixy jsou emitovány vždy, v pořadí, v jakém se objevily v instrukci.</p>
<p>EuroAssembler vydává varování, pokud byl prefix použit v rozporu s doporučením pro CPU.
Lze to přepsat uvedením prefixu na samostatném řádku.</p>
<samp>|0000:F091     |LOCK:    XCHG AX,CX   ; Prefix Lock by neměl být použit s registrovými operandy.
|## W2356 Prefix LOCK: is not expected in this instruction.
|0002:F0       |LOCK:                 ; Varování W2356 lze zamezit uvedením prefixu na samostatném řádku,
|0003:91       |         XCHG AX,CX   ;    např. kvůli zjišťování chování procesoru v takové situaci.
|0004:         |
|0004:6691     |         XCHG EAX,ECX ; Prefix 0x66 je emitován interně (v 16bitovém segmentu).
|0006:6691     |OTOGGLE: XCHG EAX,ECX ; Jeho explicitní specifikace se nijak neprojeví,
|0008:6691     |OTOGGLE: XCHG AX,CX   ;    avšak zde mění šířku registrů z 16 na 32 bitů.</samp>

<h4 id="StmentOperation" title="Operation"><a href="#ProgStrucHor">&uarr; Operace</a></h4>
<p>Pole operace je nejdůležitější část instrukce, předepisuje EuroAssembleru, co má dělat:
něco deklarovat, změnit svůj vnitřní stav, emitovat něco do cílového souboru.
Často udává jméno celé instrukci: mluvíme např. o <em>operaci EXTERN</em> namísto o
<em>instrukci s pseudoinstrukcí EXTERN v poli operace</em>.</p>
<p>&euro;ASM rozlišuje tři rody operací:</p>
<ul>
<li><a href="#MachineInstructions">strojové instrukce</a>, jejichž mnemonické názvy jsou definovány
<a class="EXTL" href="../eadoc/links.htm#InstructionsFromVendors">výrobcem CPU</a>, jsou nezávislé na velikosti písmen,</li>
<li><a href="#PseudoInstructions">pseudoinstrukce</a> jsou definovány syntaxí asembleru a jsou rovněž nezávislé na velikosti písmen,</li>
<li><a href="#MacroInstructions">makroinstrukce</a> jsou napsány uživatelem &euro;ASM a jsou citlivé na velikost písmen.</li></ul>

<p>Instrukce mohou mít pole operace prázdné:</p>
<pre>[CODE]   ; Přesměruj další emitování do sekce [CODE].
         ; Prázdnou instrukci lze použít pro optické oddělení nebo pro poznámku.
Label:   ; Definice návěstí, které však neemituje žádný kód ani data.
LOCK:    ; Definice strojového prefixu pro následnou instrukci.</pre>

<p id="Emit">Většina instrukcí žádá &euro;ASM o generování strojového kódu nebo dat do cílového souboru,
říká se jim <dfn id="EmittingInstructions" title="Emitting instructions">emitující</dfn> instrukce:</p><ul>
<li><a href="#Prefixes">prefixy</a>,</li>
<li><a href="#MachineInstructions">strojové instrukce</a>,</li>
<li><a href="#D">pseudoinstrukce D</a> a její klony (DB, DW, DD atd),</li>
<li><a href="#ALIGN">pseudoinstrukce ALIGN</a>.</li>
</ul>

<h4 id="StmentOperand" title="Operand"><a href="#ProgStrucHor">&uarr; Operand(y)</a></h4>
<h5><a href="#OrdinalOperand">Pořadové operandy &darr;</a></h5>
<h5><a href="#KeywordOperand">Klíčové operandy &darr;</a></h5>
<h5><a href="#MixingOperands">Mísení operandů &darr;</a></h5>
<p>Operandy specifikují data, s nimiž instrukce pracuje.
Počet operandů v instrukci není omezen a závisí na poli operace.
Operandem může být jméno registru, číslo, matematický výraz, identifikátor, řetězec nebo jejich kombinace.</p>
<p>Pole operace je odděleno od prvního operandu nejméně jednou bílou mezerou.
Operandy jsou navzájem odděleny čárkou <kbd>,</kbd>, která není v uvozovkách.
&euro;ASM rozlišuje dva druhy operandů: pořadové a klíčové.</p>
<hr/>
<h5 id="OrdinalOperand"><a href="#StmentOperand">&uarr; Pořadové operandy</a></h5>
<p><dfn>Pořadové operandy</dfn> (neboli stručně <em>ordinály</em>) jsou definovány jejich pořadím v instrukci.
První operand má pořadové číslo jedna; v makrech je identifikován jako <code>%1</code>.
Například v instrukci <code>MOV AL,BL</code> má registr AL pořadové číslo 1 a BL číslo 2.
Strojová instrukce MOV kopíruje obsah druhého operandu do prvního.
Čárka mezi operandy zvyšuje pořadové číslo následujícího operandu i v případě, že je prázdný
(obsahuje nanejvýš netisknutelné znaky).</p>
<p>Operand strojové instrukce může představovat registr, bezprostřední číselnou hodnotu,
adresu nebo paměťovou proměnnou v hranatých závorkách, např. <code>MOV AL,[ES:SI+16]</code>.</p>
<blockquote>Jiné asemblery akceptují odlišnou syntaxi v <a href="#RegisterExpressions">paměťové proměnné</a>,
která však není podporována v &euro;ASM, např. <code>MOV AL,<del>ES:[SI+16]</del></code> nebo
<code>MOV AL,<del>[ES:16]+SI</del></code>.
<br/>&euro;ASM vyžaduje, aby byl celý paměťový operand umístěn do hranatých závorek <kbd>[]</kbd>.</blockquote>

<h5 id="KeywordOperand"><a href="#StmentOperand">&uarr; Klíčové operandy</a></h5>
<p>Vedle pořadových operandů zavádí &euro;ASM ještě jeden typ parametrů:
<dfn>klíčové operandy</dfn> (neboli stručně <em>klíče</em>).
Na klíče odkazujeme jménem (klíčovým slovem) namísto jejich pořadí v seznamu operandů.
Klíčový operand má formát <em>jméno=hodnota</em>, kde <em>jméno</em> je identifikátor
bezprostředně následovaný rovnítkem.</p>
<blockquote><p>Klíčové operandy mají řadu výhod: jsou samopopisné (při rozumně zvoleném klíčovém slovu),
nezáleží na jejich pořadí v seznamu operandů (žádné počítání čárek),
mohou mít přiřazenu výchozí hodnotu a mohou být zcela vynechány, pokud mají výchozí hodnotu.</p>
<p>Klíčové operandy se nejčastěji pouívají u makroinstrukcí, avšak
&euro;ASM je umí využít u některých pseudoinstrukcí a dokonce i u strojových instrukcí.
Například v instrukci <code>INC [EDI],DATA=DWORD</code>
klíčový operand <code>DATA=</code> informuje, kterou formu z možných strojových instrukcí INC
chceme použít (inkrementovat BYTE, WORD nebo DWORD).</p> </blockquote>

<p>Pozor na vložení mezery mezi klíč a rovnítko:</p>
<samp>|0000:       |<abbr>; Definujme dvě paměťové proměnné (s nedoporučenými názvy).</abbr>
|0000:3412   |DATA: DW 1234h
|0002:7856   |WORD: DW 5678h
|0004:       |
|0004:50     |  PUSH AX, DATA=WORD
|0005:       |<abbr>; Přeloženo jako <code>PUSH AX</code>.</abbr>
|0005:       |<abbr>; Operand <code>DATA=WORD</code> je rozpoznán jako redundantní avšak platný modifikátor.</abbr>
|0005:       |
|0005:506A00 |  PUSH AX, DATA = WORD
|0008:       |<abbr>; Operand <code>DATA = WORD</code> není rozpoznán jako klíčový</abbr>
|0008:       |<abbr>;   kvůli mezeře následující klíč DATA.</abbr>
|0008:       |<abbr>; &euro;ASM vidí druhý operand jako numerické srovnání symbolů DATA a WORD,</abbr>
|0008:       |<abbr>;   které náhodou v program existují (jinak by se vydalo hlášení E6601).</abbr>
|0008:       |<abbr>; Jejich ofsety (0000h a 0002h) se liší, výsledkem je logické FALSE</abbr>
|0008:       |<abbr>;   reprezentované hodnotou 0. Instrukce je vyhodnocena jako <code>PUSH AX, 0</code></abbr>
|0008:       |<abbr>;   což je legální, neboť &euro;ASM akceptuje sjednocování vícenásobných operandů</abbr>
|0008:       |<abbr>;   do jedné instrukce v případě PUSH, POP, INC, DEC.</abbr>
|0008:       |<abbr>; Řádek je přeložen do dvou strojových instrukcí: <code>PUSH AX</code> a <code>PUSH 0</code>.</abbr>
</samp>

<h5 id="MixingOperands"><a href="#StmentOperand">&uarr; Mísení operandů</a></h5>
<p>Na pořadí klíčových operandů nezáleží.
Je dobrým zvykem nejprve uvádět pořadové operandy a teprve pak všechny klíčové,
avšak klíče mohou být rovněž rozptýleny mezi ordinály.</p>
<h6>Klíčový operand nezvyšuje pořadové číslo.</h6>
<pre>Label1: Operation1 Ordinal1,Ordinal2,,Ordinal4,,
Label2: Operation2 Ordinal1,Keyword1=Value1,Ordinal2,,Ordinal4</pre>
<p>Operation1 v předchozím příkladu má tři operandy s pořadovými čísly 1,2 a 4.
Třetí oprand je prázdný a poslední dvě čárky na konci se ignorují, jelikož nenásleduje žádný neprázdný operand.</p>
<p>U Operation2 jsou použity smísené operandy. Všimněte si, že Ordinal2 má pořadové číslo 2,
přestože je to třetí operand na seznamu. Klíčové operandy se nepočítají do pořadových čísel ordinálů, avšak prázdné operandy ano.</p>

<h4 id="StmentLineRem"><a href="#ProgStrucHor">&uarr; Řádková poznámka</a></h4>
<p>Řádková poznámka začíná neuvozeným středníkem <kbd>;</kbd> a končí až s koncem fyzického řádku.
Řádkové poznámky asembler ignoruje, jsou určeny pro lidského čtenáře strojového kódu.</p>

<h4 id="StmentLineCont"><a href="#ProgStrucHor">&uarr; Pokračování řádku</a></h4>
<p>Instrukce pokračuje na dalším fyzickém řádku, pokud se na pozici začátku některého pole vyskytne
<dfn>pokračovací znak</dfn>, kterým je neuvozené zpětné lomítko <kbd>\</kbd>.</p>
<pre>
 aLabel:       \ ; Tento středník je redundantní
     MOV EAX,  \ První operand instrukce MOV je <em>cíl</em>
         EBX   ; a druhý operand je <em>zdroj</em>.
</pre>
<blockquote>
<p>Vše za pokračovacím znakem se považuje za komentář a nepřekládá, takže středník pak může být vynechán.
V mnohořádkových instrukcích můžeme komentovat kterýkoli fyzický řádek.</p>
</blockquote>

<h6>Pokračovací znak se může vyskytnou na začátku kteréhokoli pole, avšak ne uvnitř pole.</h6>
<p>Celé pole se musí vejít na jeden fyzický řádek.</p>
<p>Zpětné lomítko <kbd>\</kbd> je v &euro;ASM rovněž použito jako binární operátor <a href="#NumericArithmetic">
modulo</a>, avšak binární operátor se nemůže vyskytnout na začátku operace a být tudíž zaměněn za pokračovací znak.</p>
<pre><abbr>;                   modulo  modulo pokračovací znak
;                      |      |    |  </abbr>
|0000:01000200 |  DW 5 \ 4, 6 \ 4, \
|0004:03000000 |     7 \ 4, 8 \ 4
</pre>

<h3 id="ProgStrucVer"><a href="#ProgStruc">&uarr; Vertikállní struktura</a></h3>
<h4><a href="#ProgStrucVerBlock">Blokové instrukce &darr;</a></h4>
<h4><a href="#ProgStrucVerSwitch">Přepínací instrukce &darr;</a></h4>
<h4><a href="#ProgStrucVerSolo">Samostatné instrukce &darr;</a></h4>
<p>Instrukce jsou zpracovávány jedna po druhé shora dolů; některé mohou ovlivňovat své následníky,
nicméně většina z nich jsou samostatné. Z toho pohledu jsou tři druhy instrukcí</p>
<hr/>

<h4 id="ProgStrucVerBlock"><a href="#ProgStrucVer">&uarr; Blokové instrukce</a></h4>
<p>Bloková instrukce se musí vyskytovat v páru se svou zakončující instrukcí.
Interní stav &euro;ASM se změnil pouze mezi blokovou a zakončující instrukcí.
Tomuto rozsahu se říká <dfn>block</dfn>.
<h6>Blok je souvislý zdrojový kód mezi instrukcemi <em>začátek-bloku</em> a <em>konec-bloku</em>.</h6>
<p>Blok začíná na poli <em>operace</em> instrukce <em>začátku-bloku</em> a končí na poli <em>operace</em> instrukce <em>konce-bloku</em>.</p>
<p>Některé blokové operace mohou být předčasně zrušeny operací <em>přerušení-bloku</em> (EXIT), například po zjištění chyby
během expanze makra.</p>
<table>
<caption>Blokové instrukce</caption>
<tr><th colspan="3">Návěstí</th><th colspan="3">Operace</th></tr>
<tr><th>Závaznost</th><th>Co představuje</th><th>Co deklaruje</th> <th>Počátek-bloku</th><th>Přerušení-bloku</th>   <th>Konec-bloku</th></tr>
<tr><td>povinné</td><td>název programu</td><td>program</td>  <td>PROGRAM</td><td>nepoužívá se    </td><td>ENDPROGRAM </td></tr>
<tr><td>povinné</td><td>název procedury</td><td>symbol</td>   <td>PROC    </td><td>nepoužívá se   </td><td>ENDPROC    </td></tr>
<tr><td>povinné</td><td>název procedury</td><td>symbol</td>   <td>PROC1   </td><td>nepoužívá se   </td><td>ENDPROC1   </td></tr>
<tr><td>povinné</td><td>název struktury</td><td>strukturu</td><td>STRUC   </td><td>nepoužívá se   </td><td>ENDSTRUC   </td></tr>
<tr><td>volitelné</td><td>identifikátor bloku</td><td>nic</td>  <td>HEAD   </td><td>nepoužívá se    </td><td>ENDHEAD    </td></tr>
<tr><td>volitelné</td><td>identifikátor bloku</td><td>nic</td>  <td>%COMMENT</td><td>nepoužívá se   </td><td>%ENDCOMMENT</td></tr>
<tr><td>volitelné</td><td>identifikátor bloku</td><td>nic</td>  <td>%IF     </td><td>%ELSE      </td><td>%ENDIF     </td></tr>
<tr><td>volitelné</td><td>identifikátor bloku</td><td>nic</td>  <td>%WHILE  </td><td>%EXITWHILE </td><td>%ENDWHILE  </td></tr>
<tr><td>volitelné</td><td>přehozené identifikátory</td><td>nic</td>  <td>%REPEAT </td><td>%EXITREPEAT</td><td>%ENDREPEAT </td></tr>
<tr><td>povinné</td><td>formální %proměnná</td><td>%variable</td><td>%FOR    </td><td>%EXITFOR   </td><td>%ENDFOR    </td></tr>
<tr><td>povinné</td><td>název makra</td><td>makro</td>    <td>%MACRO  </td><td>%EXITMACRO </td><td>%ENDMACRO  </td></tr>
</table>
<p>Některé blokové instrukce mají více jmen (aliasů):
<br>místo <code>ENDPROC</code> lze použít <code>ENDP</code>,
<br>místo <code>ENDPROC1</code> lze použít <code>ENDP1</code>,
<br>místo <code>%ENDREPEAT</code> lze použít <code>%UNTIL</code>.</p>
<p>Pole návěstí blokové instrukce definuje název programu, procedury, struktury nebo makra.
<br/>V případě bloku %FOR..%ENDFOR návěstí deklaruje formální %proměnnou, která mění svou hodnotu v každém cyklu.
<br/>V ostatních preprocesorových smyčkách (%REPEAT, %WHILE) je pole návěstí nepovinné. Může obsahovat identifikátor,
který opticky spojuje počáteční a koncovou blokovou instrukci (kvůli kontrole na vnořování),
avšak jinak nemá žádný význam - nedeklaruje symbol.</p>
<p>Identifikátor bloku může být použit jako první (a jediný) operand odpovídající instrukce pro přerušení-bloku a konce-bloku.</p>

<blockquote>
<p>Asemblery nejsou jednotné v syntaxi bloků.
MASM používá tentýž blokový identifikátor v poli návěstí u obou instrukcí <em>počátek-procedury</em> i <em>konec-procedury</em>:</p>
<pre>
MyProcedure PROC    ; MASM syntaxe
     ; kód procedury
MyProcedure ENDP
</pre>
<p>To je vhodné pro rychlé vyhledání procedury, kdy nás její název uhodí do oka při projíždění levého sloupce.
Na druhé straně se ale totéž návěstí objevuje dvakrát, což je v rozporu s nutností unikátnosti názvů symbolů.</p>
<p>Možná to byl důvod, proč Borland ve svém TASM IDEAL módu zvolil odlišnou syntaxi:</p>
<pre>
 PROC MyProcedure   ; TASM syntaxe
        ; kód procedury
 ENDP MyProcedure
</pre>
<p>Toto řeší problém dvojího výskytu téhož návěstí, avšak název MyProcedure
se nikdy neobjevuje v poli návěstí, třebaže se jedná o řádný symbol.</p>
<p>&euro;ASM přináší kompromisní řešení: jméno bloku je definováno
v poli návěstí instrukce <em>začátku-bloku</em> a zároveň se může objevit
v poli operandů instrukce <em>konec-bloku</em>.</p>
<pre>
MyProcedure PROC  ; &euro;ASM syntaxe
                  ; kód procedury
            ENDP MyProcedure
</pre>
<p>Operand instrukce <em>konec-bloku</em> může být vynechán, avšak pokud je použit,
musí být identický s návěstím instrukce <em>začátek-bloku</em>.
To umožňuje kontrolu vnoření, neboť &euro;ASM ohlásí chybu,
pokud identifikátory nesouhlasí.</p>
</blockquote>
<p>Bloky se mohou vnořovat, avšak pouze korektně.</p>
<h6>Dva bloky jsou korektně vnořeny, pokud jeden blok obsahuje celičký druhý blok.</h6>
<p>Blok %MACRO..%ENDMACRO v následujícím příkladu obsahuje korektně vnořený block %IF..%ENDIF:</p>
<pre>
WriteCMOS %MACRO Address,Value
           %IF %1 &lt;= 30h
             %ERROR "Checksum protected area!"
             %EXITMACRO WriteCMOS
           %ENDIF
           MOV AL,%1
           OUT 70h,AL
           MOV AL,%2
           OUT 71h,AL
          %ENDMACRO WriteCMOS
</pre>
<blockquote>Chybné vnoření bloků bude tolerováno pouze v procedurách deklarovaných s parametrem
 <a href="#ProcNESTINGCHECKeq">NESTINGCHECK=OFF</a>.
</blockquote>

<p>Identifikátor v poli operandů instrukcí <em>konec-bloku</em> a <em>přerušení-bloku</em> slouží obvykle
pouze ke kontrole správného vnoření. Jsou-li však dva bloky téhož typu vnořeny do sebe,
identifikátor <em>přerušení-bloku</em> může být použit k definování, který blok se má přerušit.
Jako příklad viz test <a class="EXT" href="../eatests/t2642.htm">t2642</a>,
kde jeden <code>Inner %FOR</code> blok je vnořen do vnějšího <code>Outer %FOR</code> bloku,
a operand instrukce %EXITFOR určuje, který blok se má přerušit (vnější či vnitřní).</p>

<h4 id="ProgStrucVerSwitch"><a href="#ProgStrucVer">&uarr; Přepínací instrukce</a></h4>
<p><dfn>Přepínací instrukce</dfn> mění interní stav &euro;ASM
pro všechny následné instrukce až do jeho změny následující přepínací instrukcí,
anebo až do konce zdrojového kodu.</p>
<p>V &euro;ASM jsou pouze dvě přepínací instrukce: <a href="#EUROASM">EUROASM</a>,
a <a href="#SEGMENT">SEGMENT</a>.
Ten druhý má dvě podoby:
<br/><code>[jméno] SEGMENT</code>
&ndash; definice nového segmentu), a
<br/><code>[jméno]</code> &ndash; definice nové sekce v aktuálním segmentu (pokud dosud nebyla definována)
a přepnutí výstupu do této sekce.
<br/>Příklady přepínacích instrukcí:</p>
<pre> EUROASM  AUTOSEGMENT=OFF, CPU=486 ; Změň stav &euro;ASM pro všechny následující instrukce.
[Subprocedures] SEGMENT PURPOSE=CODE, ALIGN=BYTE  ; Deklaruj nový segment.
[.data]                  ; Přesměruj výstup následujících instrukcí do dříve definovaného segmentu [.data].
[StringData]             ; Definuj novou sekci současného segmentu (v segmentu [.data]).
</pre>

<h4 id="ProgStrucVerSolo"><a href="#ProgStrucVer">&uarr; Samostatné instrukce</a></h4>
<p>Všechny ostatní instrukce nejsou logicky vázány s ostatními ve svislé struktuře programu,
a jsou tedy <dfn>samostatné</dfn>.</p>
<hr/>
<h2 id="Elements"><a href="#top">&uarr; Elementy programu v &euro;ASM</a></h2>
<p>Velikost EuroAssemblerových elementů není v principu omezena.
To se týká délky řetězců, fyzických řádků, identifikátorů, zápisu čísel,
matematických výrazů, hloubky vnoření, počtu operandů apod.
Interně jsou jejich velikosti udržovány jako 32bitové číslo, takže teoretický limit je
<code>2 GB = 2_147_483_647 bajtů (znaků)</code>.
<blockquote>V praxi jsme ovšem omezeni množstvím dostupné paměti a rozměry zásobníku,
takže &euro;ASM může zhavarovat s fatální chybou
<kbd>F9110 Cannot allocate virtual memory.</kbd> nebo
<kbd>F9210 Memory reserved for machine stack is too small for this source file.</kbd></blockquote>

<h3><a href="#Addresses">Adresa &darr;</a></h3>
<h3><a href="#AddressingSpace">Adresní prostor &darr;</a></h3>
<h3><a href="#Alignment">Alignment &darr;</a></h3>
<h3><a href="#Booleans">Booleovské hodnoty &darr;</a></h3>
<h3><a href="#BooleansExt">Booleovská rozšíření &darr;</a></h3>
<h3><a href="#Numbers">Čísla &darr;</a></h3>
<h3><a href="#DataTypes">Datové typy &darr;</a></h3>
<h3><a href="#Length">Délka &darr;</a></h3>
<h3><a href="#Distance">Distance &darr;</a></h3>
<h3><a href="#Groups">Grupy &darr;</a></h3>
<h3><a href="#Identifiers">Identifikátory &darr;</a></h3>
<h3><a href="#Namespace">Jmenný prostor &darr;</a></h3>
<h3><a href="#Comments">Komentáře &darr;</a></h3>
<h3><a href="#Literals">Literály &darr;</a></h3>
<h3><a href="#Expressions">Matematické výrazy &darr;</a></h3>
<h3><a href="#Operators">Operátory &darr;</a></h3>
<h3><a href="#MemVariables">Paměťové proměnné &darr;</a></h3>
<h3><a href="#ConditionCodes">Podmínkové kódy &darr;</a></h3>
<h3><a href="#pcVariables">%Proměnné &darr;</a></h3>
<h3><a href="#Registers">Registry &darr;</a></h3>
<h3><a href="#Strings">Řetězce &darr;</a></h3>
<h3><a href="#Scope">Scope &darr;</a></h3>
<h3><a href="#Sections">Sekce &darr;</a></h3>
<h3><a href="#Segments">Segmenty &darr;</a></h3>
<h3><a href="#Segmentation">Segmentace &darr;</a></h3>
<h3><a href="#Structures">Struktury &darr;</a></h3>
<h3><a href="#Symbols">Symboly &darr;</a></h3>
<h3><a href="#Width">Šířka &darr;</a></h3>
<h3><a href="#Size">Velikost &darr;</a></h3>
<h3><a href="#Enumerates">Výčtové hodnoty &darr;</a></h3>

<hr/>
<h3 id="Comments"><a href="#Elements">&uarr; Komentáře</a></h3>
<h4><a href="#BlockComments">Blokové komentáře &darr;</a></h4>
<h4><a href="#LineComments">Řádkové poznámky &darr;</a></h4>
<h4><a href="#MachineRemarks">Strojové poznámky &darr;</a></h4>
<h4><a href="#MarkupComments">Značkovací komentáře &darr;</a></h4>
<p>Komentáře neboli poznámky jsou části zdrojového kódu, které nejsou zpracovávány asemblerem;
jejich účelem je vysvětlování kódu pro lidského čtenáře.
V &euro;ASM rozlišujeme čtyři typy komentářů:</p>
<hr/>
<h4 id="LineComments"><a href="#Comments">&uarr; Řádkové poznámky</a></h4>
<p>Řádková poznámka začíná neuvozeným středníkem <kbd>;</kbd>; vše následující
až do konce řádku asembler ignoruje.
Řádkové poznámky jsou doslovně kopírovány do listingového souboru.</p>
<pre> Label: CALL SomeProc <span class="inner">; Toto je řádková poznámka.</span></pre>
<h4 id="MachineRemarks"><a href="#Comments">&uarr; Strojové poznámky</a></h4>
<p>Strojové poznámky jsou zapisovány EuroAssemblerem do listingového souboru a obsahují
generovaný strojový kód v hexadecimální notaci.</p>
<p>Strojová poznámka začíná vertikální čarou <kbd>|</kbd>, která je prvním tisknutelným znakem na řádku
a končí jeho druhým výskytem na tomtéř řádku, anebo koncem fyzického řádku (podle toho, co přijde dříve).
Je-li ukončovací znak <kbd>|</kbd> vynechán, celý řádek je považován za komentář.
To je využito ke vkládání chybových oznámení do listingu, hned pod chybnou instrukci.</p>
<pre>
<span class="inner">|0030:E81234   |</span>Label1: CALL SomeProc  ; Toto je řádková poznámka.
<span class="inner">|0033:         |</span>Label2: COLL OtherProc ; Zde došlo k překlepu.
<span class="inner">|### E6860 Unrecognized operation "COLL", ignored.</span>
</pre>
<p>Strojové poznámky jsou EuroAssemblerem ignorovány a nekopírují se do listingu.
Namísto toho se generují znova, když byl listing předložen &euro;ASM k nové kompilaci jako zdrojový kód.</p>
<p>U strojových poznámek se nepředpokládá, že by byly programátorem vkládány do programu.</p>
<h4 id="MarkupComments"><a href="#Comments">&uarr; Značkovací komentáře</a></h4>
<p>Začíná-li fyzický řádek znakem <em>méně než</em> <kbd>&lt;</kbd>,
je celý považován za značkovací komentář a ignorován.
To umožňuje směšovat zdrojový kód s tagy <em>hypertextového značkovacího jazyka</em>.
Značkovací komentáře se nekopírují do listingového souboru.</p>
<p>Díky implementaci značkovacích komentářů může být zdrojový kód v &euro;ASM ukládán
nejen jako prostý text, ale též ve formě HTML nebo XML hypertextu.</p>
<pre><span class="inner">&lt;h2&gt;Popis MéProcedury&lt;/h2&gt;</span>
<span class="inner">&lt;img src=&quot;JejiVyobrazeni.png&quot;/&gt;</span>
MéProcedury  PROC  ; Viz obrázek nahoře pro její popis.</pre>
<blockquote><p>Všechny zdrojové kódy dodávané s &euro;ASM jsou kompletně uloženy ve formátu HTML,
což umožnilo dokumentovat kód hypertextovými odkazy, tabulkami, obrázky a lepší vizuální reprezentací,
než by poskytly prosté řádkové komentáře.</p>
<p>Chcete-li udržovat své kódy v HTML, ubezpečte se, že běžné povely pro assembler
nezačínají znakem <kbd>&lt;</kbd> a přeskupte zdrojový text tak, aby každý značkovací komentář
začínal některým tagem HTML.
Taky lze začínat komentářové řádky prázdným HTML tagem <kbd>&lt;span/&gt;</kbd> nebo <kbd>&lt;!----&gt;</kbd>.</p>
</blockquote>

<h4 id="BlockComments"><a href="#Comments">&uarr; Blokové komentáře</a></h4>
<p>Blokový komentář lze využít k dočasnému zneplatnění větší části zdrojového kódu
nebo k začlenění dokumentace.</p>
<p>Blokový komentář začíná pseudoinstrukcí <a href="#pcCOMMENT">%COMMENT</a>
a končí odpovídající pseudoinstrukcí <a href="#pcCOMMENT">%ENDCOMMENT</a>.
Může zahrnovat mnoho programových řádků, které pak nemusejí začínat středníkem.
<br/>Blokové komentáře jsou kopírovány do listingového souboru.</p>
<p>&euro;ASM sice nepřekládá text uvnitř takto vykomentovaného bloku,
avšak musí jej i tak číst, aby našel odpovídající instrukci %ENDCOMMENT,
takže odkomentovaný text musí být platný zdrojový kód.</p>
<h6>Blokové komentáře se mohou vnořovat.</h6>
<p>Text v bloku %COMMENT..%ENDCOMMENT musí být řádně vnořený, i když se ignoruje.</p>
<blockquote>Pseudoinstrukci <code>%COMMENT</code> bychom mohli nahradit pomocí
<code>%IF 0</code>, avšak je intuitivnější.</blockquote>
<pre>
 CALL SomeProc  ; Toto je řádková poznámka.
<span class="inner"> %COMMENT       ; Toto je blokový komentář.
 COLL OtherProc ; Tady došlo k překlepu.
    %COMMENT    ; Toto je vložený blokový komentář.
    %ENDCOMMENT ; Konec vloženého komentáře.
    ; Tato instrukce je rovněž ignorována.
 %ENDCOMMENT</span>
    ; Emitování pokračuje zde.</pre>

<h3 id="Identifiers" title="Identifier"><a href="#Elements">&uarr; Identifikátor</a></h3>
<p><dfn>Identifikátor</dfn> je text, který dává jméno prvkům programu:
symbolu, registru, instrukci, struktuře apod.</p>
<h6>Identifikátor je kombinace <a href="#ProgStrucCharClass">písmen</a> a
<a href="#ProgStrucCharClass">číslic</a>, která začíná písmenem.</h6>
<p>Délka identifikátoru není omezena a všechny jeho znaky jsou platné.</p>
<hr/>
<h3 id="Numbers"><a href="#Elements">&uarr; Čísla</a></h3>
<h4><a href="#DecNumbers">Dekadická čísla &darr;</a></h4>
<h4><a href="#BinNumbers">Binární čísla &darr;</a></h4>
<h4><a href="#OctNumbers">Oktalová čísla &darr;</a></h4>
<h4><a href="#HexNumbers">Hexadecimální čísla &darr;</a></h4>
<h4><a href="#IntNumbers">Přehled celých čísel &darr;</a></h4>
<h4><a href="#FpNumbers">Čísla s plovoucí tečkou &darr;</a></h4>
<h4><a href="#FpSpecValues">Speciální hodnoty FP čísel &darr;</a></h4>
<h4><a href="#CharNumbers">Znakové konstanty &darr;</a></h4>
<p>Číselná notace je způsob, kterým zapisujeme numerické hodnoty.
Interně jsou celočíselné hodnoty uchovávány v &euro;ASM jako 64bitová čísla se znaménkem.</p>
<h6>Číslo je ve zdrojovém textu EuroAssembleru zapisováno jako kombinace číslic a číselných modifikátorů,
které začíná dekadickou číslicí 0..9.</h6>
<p><dfn id="NumberModifiers" title="Number modifiers">Číselný modifikátor</dfn> je jeden ze znaků <kbd>B D E G H K M P Q T</kbd>
přpojených za sekvenci číslic, nebo <kbd>0N 0O 0X 0Y</kbd> (nula následovaná písmenem) na začátku číselného zápisu.
Všechny modifikátory jsou nezávislé na velikosti písmen.
Modifikátor musí být použit u všech notací s výjimkou dekadického formátu, který je výchozí.</p>
<p>Čísla s pohyblivou desetinnou tečkou (FP) mohou používat tečku <kbd>.</kbd> k oddělení celočíselné a desetinné části.</p>
<p>Dalším číselným modifikátorem je podtržítko <kbd>_</kbd>, které je asemblerem ignorováno a slouží jen jako oddělovač číslic
pro lepší čitelnost delších čísel. V žádném zápisu čísel nejsou povoleny mezery.</p>

<h4 id="DecNumbers"><a href="#Numbers">&uarr; Dekadická čísla</a></h4>
<p>Dekadické číslo je kombinací dekadických číslic <kbd>0..9</kbd> s volitelně připojovaným
<dfn>dekadickým modifikátorem</dfn> <kbd>D</kbd>. Ještě existuje pět dalších dekadických přípon:
<br/><kbd>K</kbd> (Kilo), říká EuroAssembleru, že má číslo vynásobit 2<sup>10</sup>=1024,
<br/><kbd>M</kbd> (Mega), říká EuroAssembleru, že má číslo vynásobit 2<sup>20</sup>=1_048_576,
<br/><kbd>G</kbd> (Giga), říká EuroAssembleru, že má číslo vynásobit 2<sup>30</sup>=1_073_741_824,
<br/><kbd>T</kbd> (Tera), říká EuroAssembleru, že má číslo vynásobit 2<sup>40</sup>=1_099_511_627_776,
<br/><kbd>P</kbd> (Peta), říká EuroAssembleru, že má číslo vynásobit 2<sup>50</sup>=1_125_899_906_842_624.</p>
<p>Dekadické číslo může být také prefixováno modifikátorem <kbd>0N</kbd>.
<p>Všech šest čísel v následujícím příkladu má tutéž hodnotu:
<code>1048576, 1048576d, 0n1048576, 1_048_576, 1024K, 1M</code>.</p>
<p>Největší číslo, které se vejde do 32 bitů je
0xFFFF_FFFF=4_294_967_295.</p>
<p>Největší číslo, které se vejde do 63 bitů je
0x7FFF_FFFF_FFFF_FFFF=9_223_372_036_854_775_807.</p>

<h4 id="BinNumbers"><a href="#Numbers">&uarr; Binární čísla</a></h4>
<p>Binární číslo je zapsáno jako sled číslic <kbd>0</kbd> a <kbd>1</kbd> s připojeným
binárním modifikátorem <kbd>B</kbd> anebo s prefixem <kbd>0Y</kbd>. Příklady:
<code>0y101, 101b, 00110010b, 1_1111_0100B</code> odpovídají dekadickým číslům
<code>5, 5, 50, 500</code>.</p>
<p>Největší 32bitové  binární číslo je 1111_1111__1111_1111__1111_1111__1111_1111b.</p>

<h4 id="OctNumbers"><a href="#Numbers">&uarr; Oktalová čísla</a></h4>
<p>Každá oktalová číslice <kbd>0..7</kbd> reprezentuje tři bity z odpovídající binární notace.
Číslo je zakončeno oktalovou příponou <kbd>Q</kbd> anebo mu předchází předpona
<kbd>0O</kbd> nebo <kbd>0o</kbd> (číslice nula následovaná velkým či malým písmenem <kbd>O</kbd>).</p>
<p>Příklad: <code>177_377q = 0o177_377 = 0xFEFF</code></p>
<p>Největší 32bitové oktalové číslo je 37_777_777_777q.</p>
<p>Největší 64bitové oktalové číslo je 1_777_777_777_777_777_777_777q.</p>

<h4 id="HexNumbers"><a href="#Numbers">&uarr; Hexadecimální čísla</a></h4>
<p>Každá hexadecimální číslice kóduje čtyři bity do jednoho znaku. což vyžaduje 2<sup>4</sup>=16
možných hodnot. Proto je deset dekadických čísli rozšířeno písmeny <kbd>A, B, C, D, E, F</kbd>
s hodnotami 10, 11, 12, 13, 14, 15. U hexadecimálních cifer A..F nezáleží na velikosti písmen.
Pokud by měla být první číslice hexadecimálního čísla reprezentována písmenem A..F,
je třeba před číslo přidat nevýznamnou vedoucí nulu.
Hexadecimální číslo je zakončeno příponou <kbd>H</kbd>,
anebo začíná předponou <kbd>0X</kbd>.</p>
<p>Příklad: <code>5h, 0x32, 1F4H, 0x1388, 0C350H</code> reprezentuje postupně čísla
<code>5, 50, 500, 5000, 50000</code>.</p>
<blockquote>Všechna čísla jsou v &euro;ASM interně uchovávána jako 64bitové integery se znaménkem.
Přestože instrukce <code>MOV EAX,0xFFFF_FFFF</code> a <code>MOV EAX,-1</code>
se překládají na identické kódy, interně jsou jejich operandy uchovávány jako
<code>0x0000_0000_FFFF_FFFF</code> a <code>0xFFFF_FFFF_FFFF_FFFF</code>.
Logický výraz <code>0xFFFF_FFFF = -1</code> je <em>nepravda</em>.
<samp>|00000000:B8FFFFFFFF | MOV EAX, 0xFFFF_FFFF
|00000005:B8FFFFFFFF | MOV EAX, -1
|FALSE               | %IF 0xFFFF_FFFF = -1</samp>
</blockquote>

<h4 id="IntNumbers"><a href="#Numbers">&uarr; Přehled celých čísel</a></h4>
<p>Celá čísla mohou být zapsána jako binární, oktalová, dekadická nebo hexadecimání.
Některé číselné modifikátory se překrývají s hexadecimálními číslicemi <kbd>B, D, E</kbd>.
&euro;ASM se snaží rozebírat co nejdelší zápis, aby předešel nejednoznačnostem:
<br/><code>1BH</code> je pochopeno jako hexadecimální číslo 0x1B=27 a nikoliv jako <del>binární číslo 1 následovaná písmenem <kbd>H</kbd></del>.
<br/><code>2DH</code> je pochopeno jako hexadecimální číslo 0x2D=45 a nikoliv jako <del>dekadické číslo 2 následované písmenem <kbd>H</kbd></del>.
<br/><code>3E2H</code> je pochopeno jako hexadecimální číslo 0x3E2=994 a nikoliv jako <del>3 * 10<sup>2</sup> následované písmenem <kbd>H</kbd></del>.
</p>
<table id="IntegerNotation" title="Integer Nr notation"><caption>Zápis celých čísel</caption>
<tr><th>Notace</th><th>Předpona</th><th>Báze</th><th>Přípona</th><th>Násobitel</th></tr>
<tr><td>Binární</td><td>0Y</td><td>2</td><td>B</td><td>1</td></tr>
<tr><td>Oktalová</td><td>0O</td><td>8</td><td>Q</td><td>1</td></tr>
<tr><td rowspan="6">Dekadická</td><td rowspan="6">0N</td><td rowspan="6">10</td><td>D</td><td>1</td></tr>
<tr><td>K</td><td>2<sup>10</sup></td></tr>
<tr><td>M</td><td>2<sup>20</sup></td></tr>
<tr><td>G</td><td>2<sup>30</sup></td></tr>
<tr><td>T</td><td>2<sup>40</sup></td></tr>
<tr><td>P</td><td>2<sup>50</sup></td></tr>
<tr><td>Hexadecimální</td><td>0X</td><td>16</td><td>H</td><td>1</td></tr>
</table>
<p>Binární, oktalová a hexadecimální čísla musejí být vždy uváděna s předponou nebo s příponou
(nebo s oběma, i když to není obvyklé). V EuroAssembleru není direktiva <dfn id="RADIX" title="RADIX">RADIX</dfn>.</p>
<p>Pro více příkladů syntaxe čísel viz testy <a class="EXT" href="../eatests/#Numbers">&euro;ASM numbers tests</a>.</p>

<h4 id="FpNumbers" title="Real Nr notation"><a href="#Numbers">&uarr; Čísla s pohyblivou tečkou</a></h4>
<p id="FloatNumbers" title="Floating point Nr">Čísla s pohyblivou desetinnou tečkou, neboli <em>reálná</em> čísla
se načítají ze zápisu s desetinnou tečkou a exponentu deseti v následující syntaxi:</p>
<table><caption>Anatomie čísel s plovoucí tečkou</caption>
<tr><th>Pořadí</th><th>Název pole</th><th>Obsah</th></tr>
<tr><td>1</td><td>znaménko čísla</td><td><kbd>+</kbd>, <kbd>-</kbd> nebo žádné</td></tr>
<tr><td>2</td><td>celočíselná část</td><td>číslice <kbd>0..9</kbd>, separátor <kbd>_</kbd></td></tr>
<tr><td>3</td><td>desetinná tečka</td><td><kbd>.</kbd></td></tr>
<tr><td>4</td><td>neceločíselná část</td><td>číslice <kbd>0..9</kbd>, separátor <kbd>_</kbd></td></tr>
<tr><td>5</td><td>číselný modifikátor</td><td><kbd>E</kbd> nebo <kbd>e</kbd></td></tr>
<tr><td>6</td><td>znaménko exponentu</td><td><kbd>+</kbd>, <kbd>-</kbd> nebo žádné</td></tr>
<tr><td>7</td><td>exponentová část</td><td>číslice<kbd>0..9</kbd>, separátor<kbd>_</kbd></td></tr>
</table>

<p>Kupříkladu reálné číslo <code>1234.56E3</code> má hodnotu 1234.56 * 10<sup>3</sup>=1234560.</p>
<p>Chybějící znaménko se považuje za <kbd>+</kbd>.</p>
<p>Neceločíselnou část lze vynechat, pokud je nula: <code>123.00E2 = 123.E2</code></p>
<p>Desetinnou tečku lze vynechat, pokud je neceločíselná část vynechána (je nulová).
Modifikátor <kbd>E</kbd> stále určuje, že se jedná o formát plovoucí tečky. <code>123.00E2 = 123.E2 = 123E2 = 12300.</code></p>
<p>Exponentovou část lze vynechat, pokud je nulová. Modifikátor <kbd>E</kbd> se v tom případě může také vynechat.
Bez modifikátoru je to existence desetinné tečky, která určuje, zda je číslo zapsáno
jako celočíselné (integer) nebo s plovoucí tečkou (real).
Příklad: <code>12345.67E0 = 12345.67E = 12345.67</code></p>
<p>V zápisu čísla s plovoucí tečkou nejsou dovoleny žádné mezery.</p>
<p>Číslo se považuje za plovoucí pokud jeho zápis obsahuje buď desetinnou tečku <kbd>.</kbd>,
nebo modifikátor <kbd>E</kbd> (velké nebo malé písmeno) anebo obojí.</p>
<h6>&euro;ASM nepočítá s čísly ve formátu plovoucí tečky v asm-time.</h6>
<p>Všechny interní kalkulace jsou v &euro;ASM prováděny pouze s 64bitovými celými čísly.
Pokud by bylo číslo s plovoucí tečkou (FP) použito v matematickém výrazu, bude nejprve převedeno na celočíselnou hodnotu.
Pokud by se číslo nevešlo do 64 bitů, ohlásí se chyba <a class="EXT" href="../easource/msg.htm#MsgE">E6130</a> (number overflow).
Pokud došlo ke ztrátě přesnosti zanedbáním neceločíselné části čísla, ohlásí se varování
<a class="EXT" href="../easource/msg.htm#MsgW">W2210</a> (precision lost).</p>
<p>Formát FP čísla dle <a class="EXTL" href="../eadoc/links.htm#IEEE754">[IEEE754]</a> se zachovává pouze pokud
je vědecká notace použita ke statické deklaraci čísel v pseudoinstrukcích <a href="#D">DD, DQ, DT</a>.</p>
<p>FP čísla s poloviční přesností (float16) nejsou podporována EuroAssemblerem ani procesory,
s výjimkou dvou SIMD instrukcí <a class="EXT" href="../easource/iiz.htm#IizVCVTPS2PH">VCVTPS2PH</a> a
<a class="EXT" href="../easource/iiz.htm#IizVCVTPH2PS">VCVTPH2PS</a>, a s výjimkou několika
<a href="#OPEReq">konverzních operací</a> kódovaných s prefixem MVEX.</p>
<blockquote>Na rozdíl od celých čísel, znaménko v FP notaci je neoddělitelné
od následnujícíh číslic. Pokud omylem vložíte mezeru mezi znaménko a číslo s plovoucí tečkou,
namísto definice FP čísla to bude &euro;ASM považovat za operaci (unární minus aplikované na číslo)
a tudíž nejprve převede FP číslo na integer, než je vyhodnotí.
<samp>|00000000:001DF1C7             | DD  -123.45E3 ; Single-precision FP number -123.45*10<sup>3</sup>.
|00000004:C61DFEFF             | DD - 123.45E3 ; Dword signed integer number -123450.
|00000008:00000000A023FEC0     | DQ  -123.45E3 ; Double-precision FP number -123.45*10<sup>3</sup>.
|00000010:C61DFEFFFFFFFFFF     | DQ - 123.45E3 ; Qword signed integer number -123450.
|00000018:0000000000001DF10FC0 | DT  -123.45E3 ; Extended-precision FP number -123.45*10<sup>3</sup>.
|00000022:                     | DT - 123.45E3 ; Tbyte integer number není podporováno.
|### E6725 Datatype TBYTE expects plain floating-point number.</samp>
</blockquote>

<h4 id="FpSpecValues" title="Floating point specials"><a href="#Numbers">&uarr; Speciální hodnoty FP čísel</a></h4>
<p>Vedle standardních hodnot mohou čísla s plovoucí tečkou nabývat <dfn>speciální FP konstanty</dfn>:</p>
<table><caption>Speciální FP konstanty (v hexadecimálním formátu)</caption>
<tr><th>Konstanta</th><th>Interpretace</th><th>single precision (DD)</th><th>double precision (DQ)</th><th>extended precision (DT)</th></tr>
<tr><th>#ZERO</th><td>zero</td><td><code>00000000</code></td><td><code>00000000_00000000</code></td>
<td><code>0000_00000000_00000000</code></td></tr>
<tr><th>+#ZERO</th><td>positive zero</td><td><code>00000000</code></td><td><code>00000000_00000000</code></td>
<td><code>0000_00000000_00000000</code></td></tr>
<tr><th>-#ZERO</th><td>negative zero</td><td><code>80000000</code></td><td><code>80000000_00000000</code></td>
<td><code>8000_00000000_00000000</code></td></tr>
<tr><th>#INF</th><td>infinity</td><td><code>7F800000</code></td><td><code>7FF00000_00000000</code></td>
<td><code>7FFF_80000000_00000000</code></td></tr>
<tr><th>+#INF</th><td>positive infinity</td><td><code>7F800000</code></td><td><code>7FF00000_00000000</code></td>
<td><code>7FFF_80000000_00000000</code></td></tr>
<tr><th>-#INF</th><td>negative infinity</td><td><code>FF800000</code></td><td><code>FFF00000_00000000</code></td>
<td><code>FFFF_80000000_00000000</code></td></tr>
<tr><th>#PINF</th><td>pseudo infinity</td><td><code>7F800000</code></td><td><code>7FF00000_00000000</code></td>
<td><code>7FFF_00000000_00000000</code></td></tr>
<tr><th>+#PINF</th><td>positive pseudo infinity</td><td><code>7F800000</code></td><td><code>7FF00000_00000000</code></td>
<td><code>7FFF_00000000_00000000</code></td></tr>
<tr><th>-#PINF</th><td>negative pseudo infinity</td><td><code>FF800000</code></td><td><code>FFF00000_00000000</code></td>
<td><code>FFFF_00000000_00000000</code></td></tr>
<tr><th>#NAN</th><td>not a number</td><td><code>7FC00000</code></td><td><code>7FF80000_00000000</code></td>
<td><code>7FFF_C0000000_00000000</code></td></tr>
<tr><th>+#NAN</th><td>positive not a number</td><td><code>7FC00000</code></td><td><code>7FF80000_00000000</code></td>
<td><code>7FFF_C0000000_00000000</code></td></tr>
<tr><th>-#NAN</th><td>negative not a number</td><td><code>FFC00000</code></td><td><code>FFF80000_00000000</code></td>
<td><code>FFFF_C0000000_00000000</code></td></tr>
<tr><th>#PNAN</th><td>pseudo not a number</td><td><code>7F800001</code></td><td><code>7FF00000_00000001</code></td>
<td><code>7FFF_00000000_00000001</code></td></tr>
<tr><th>+#PNAN</th><td>positive pseudo not a number</td><td><code>7F800001</code></td><td><code>7FF00000_00000001</code></td>
<td><code>7FFF_00000000_00000001</code></td></tr>
<tr><th>-#PNAN</th><td>negative pseudo not a number</td><td><code>FF800001</code></td><td><code>FFF00000_00000001</code></td>
<td><code>FFFF_00000000_00000001</code></td></tr>
<tr><th>#QNAN</th><td>quiet not a number</td><td><code>7FC00000</code></td><td><code>7FF80000_00000000</code></td>
<td><code>7FFF_C0000000_00000000</code></td></tr>
<tr><th>+#QNAN</th><td>positive quiet not a number</td><td><code>7FC00000</code></td><td><code>7FF80000_00000000</code></td>
<td><code>7FFF_C0000000_00000000</code></td></tr>
<tr><th>-#QNAN</th><td>negative quiet not a number</td><td><code>FFC00000</code></td><td><code>FFF80000_00000000</code></td>
<td><code>FFFF_C0000000_00000000</code></td></tr>
<tr><th>#SNAN</th><td>signaling not a number</td><td><code>7F800001</code></td><td><code>7FF00000_00000001</code></td>
<td><code>7FFF_80000000_00000001</code></td></tr>
<tr><th>+#SNAN</th><td>positive signaling not a number</td><td><code>7F800001</code></td><td><code>7FF00000_00000001</code></td>
<td><code>7FFF_80000000_00000001</code></td></tr>
<tr><th>-#SNAN</th><td>negative signaling not a number</td><td><code>FF800001</code></td><td><code>FFF00000_00000001</code></td>
<td><code>FFFF_80000000_00000001</code></td></tr>
</table>
<p>U jmen speciálních FP konstant nezáleží na velikosti písmen.
Pokud je užito znaménko <kbd>+</kbd> nebo <kbd>-</kbd>, je neoddělitelné. Příklady:
<br/><code>FourNans DY 4 * QWORD #NaN ; Definuj vektor čtyř hodnot not-a-number s dvojitou přesností.</code>
<br/><code> MOV ESI,=8*Q#ZERO ; Definuj 8*8 nulových bajtů v literální sekci a nechej na ně ukazovat ESI</code></p>

<h4 id="CharNumbers"><a href="#Numbers">&uarr; Znakové konstanty</a></h4>
<p>Číslo může být zapsáno také jako <dfn>znaková konstanta</dfn>,
což je řetězec nanejvýš osmi znaků.
Jeho číselná hodnota se bere z pořadového čísla znaků v tabulce ASCII.
Příklad znakových konstant a jejich hodnot:</p>
<pre>
'0'   =     30h =      48
'abc' = 636261h = 6513249
"4%%" =   2534h =    9524
</pre>
<h6 id="CharacterConstans" title="Character constants">Znaky s nejméně významnou hodnotou jsou v řetězci vlevo.</h6>
<blockquote><p>Asemblery nejsou jednotné v interpretaci znakových konstant.
MASM a TASM používají <em>zápisovou konvenci</em>,
kdy pořadí znaků ve zdrojovém kódu odpovídá tomu, jak píšeme dekadická čísla: nejméně významná číslice je zcela vpravo.</p>
<p>&euro;ASM a s ním i většina novějších asemblerů používají
<em>paměťovou konvenci</em>, kde pořadí znaků odpovídá uložení znaků v oprační paměti paměti procesorů s architekturou
<em>little endian</em>:</p>
<samp>|                    | ; MASM and TASM:
|00000000:616263     | DB 'abc'      ; Řetězec.
|00000003:63626100   | DD 'abc'      ; Znaková konstanta
|00000007:B863626100 | MOV EAX,'abc' ; AL='c'.

|                    | ; &euro;ASM, FASM, GoASM, NASM, SpASM:
|00000000:616263     | DB 'abc'      ; Řetězec.
|00000003:61626300   | DD 'abc'      ; Znaková konstanta.
|00000007:B861626300 | MOV EAX,'abc' ; AL='a'.
</samp>
</blockquote>

<hr/>
<h3 id="Enumerates" title="Enumerations"><a href="#Elements">&uarr; Výčtové hodnoty</a></h3>
<p>Některé parametry mohou nabývat pouze předdefinované hodnoty,
například volba <a href="#EUROASM">EUROASM</a> <a href="#CPUeq">CPU=</a>
může být <code>086, 186, 286, 386, 486, 586, 686, PENTIUM, P6, X64</code>.</p>
<p>Třebaže některé výčtové hodnoty mohou vypadat jako čísla, nejsou počitatelné.</p>

<h3 id="Booleans" title="Boolean values"><a href="#Elements">&uarr; Booleovské hodnoty</a></h3>
<p>Kterékoli číslo může být interpretováno jako booleovská (logická) hodnota.
Booleovská hodnota může mít jeden ze dvou stavů: <em>pravda</em> nebo <em>nepravda</em>.
Číslo 0 je považováno za booleovskou hodnotu <em>nepravda</em>, zatímco jakékoli nenulové číslo
je vyhodnoceno jako <em>pravda</em>.</p>

<h3 id="BooleansExt" title="Boolean extensions"><a href="#Elements">&uarr; Booleovská rozšíření</a></h3>
<p>Všechny vestavěné booleovské volby v &euro;ASM mají rozšířený repertoár možných hodnot.
Tyto volby akceptují</p>
<ul><li>číselnou hodnotu 0 jako logickou hodnotu <em>nepravda</em> a nenulovou hodnotu
jako <em>pravda</em>,</li>
<li>řetězec je vyhodnocen jako <em>nepravda</em> pokud je prázdný,
jinak jako <em>pravda</em> (řetězec netisknutelných znaků není prázdný),</li>
<li>předvolené konstanty <dfn>TRUE, YES, ON, ENABLE, ENABLED</dfn>
jako <em>pravda</em>, a
<dfn>FALSE, NO, OFF, DISABLE, DISABLED</dfn> jako <em>nepravda</em>
(bez ohledu na velikost písmen).</li>
</ul>
<p>To se týká</p><ul>
<li><a href="#pcIF">podmínek v pseudoinstrukcích</a> %IF, %WHILE, %UNTIL,</li>
<li>pseudoinstrukce <a href="#pcSETB">%SETB</a>,</li>
<li><a href="#InstructionModifiers">logických modifikátorů strojových instrukcí</a> BCST=, EH=, SAE=, ZEROING=, </li>
<li>booleovských operandů <a href="#EUROASM">pseudoinstrukce EUROASM</a> AUTOALIGN=, AUTOSEGMENT=,
DEBUG=, DISPLAYENC=, DISPLAYSTM=, DUMP=, DUMPALL=, LIST=, LISTINCLUDE=,
LISTMACRO=, LISTREPEAT=, LISTVAR=, PROFILE=, UNICODE=, a všech extenzí CPU,</li>
<li>booleovských operandů <a href="#PROGRAM">pseudoinstrukce PROGRAM</a> LISTGLOBALS=, LISTLITERALS=,
LISTMAP=,
<li>booleovského operandu NESTINCHECK= <a href="#PROC">pseudoinstrukcí PROC a PROC1</a>.</li></ul>
<p>Tento rozšířený repertoár platí pouze pro operandy vestavěné do &euro;ASM.
Nejedná se o kdekoli použitelné <a href="#Symbols">symboly</a>,
jako <code><del>MOV EAX,TRUE</del></code>.
K získání podobné funkčnosti v makrech by programátor nejprve musel takové symboly nadefinovat, např.</p><pre>
FALSE   EQU 0
false   EQU 0
TRUE    EQU -1
true    EQU !false
MOV EAX,TRUE
</pre>
<p>Je-li booleovské rozšíření použito jako klíčový operand makra,
může být rovněž testován v těle makra pomocí
<code>%IF, %WHILE, %UNTIL</code>, například</p><pre>
MacroWithBool  %MACRO Bool=On
  %IF %Bool
    ; Instrukce pokud Bool je <em>pravda</em>.
  %ELSE
    ; Instrukce pokud Bool je <em>nepravda</em>.
  %ENDIF
 %ENDMACRO MacroWithBool</pre>
<p>Nyní můžeme makro vyvolat pomocí <code> MacroWithBool Bool=Enable</code>, <code> MacroWithBool Bool=No</code> apod.</p>
<h6>Booleovská rozšíření nejsou povoleny v <a href="#BooleanAlgebra">logických výrazech</a></h6><pre>
MacroWithBool  %MACRO Bool=0
  %IF ! %Bool  ; Toto je logický výraz.
    ; Instrukce pokud Bool je <em>nepravda</em>.
  %ENDIF
  %ENDMACRO MacroWithBool</pre>
<p>Předchozí příklad nebude fungovat s booleovským rozšířením, např. <code>MacroWithBool Bool=False</code>
si bude stěžovat, že <kbd>E6601 Symbol "False" was not found.</kbd>. Avšak po převrácení logiky by měl fungovat dobře:<pre>
MacroWithBool  %MACRO Bool=0
  %IF  %Bool
  %ELSE
    ; Instrukce pokud Bool je <em>nepravda</em>.
  %ENDIF
  %ENDMACRO MacroWithBool</pre>

<h3 id="Strings" title="String"><a href="#Elements">&uarr; Řetězce</a></h3>
<p>Řetězec je sled libovolných znaků obklopený uvozovkami.
Lze používat jak uvozovky dvojité <kbd title="ASCII=34">&quot;</kbd>, tak i jednoduché
<kbd title="ASCII=39">'</kbd> (rovněž nazývané <em>apostrofy</em>).
Obklopující uvozovky se nezapočítávají do obsahu řetězce.
Všechny znaky uvnitř řetězce ztrácejí svůj sémantický význam, jsou jen tři výjimky:</p>
<ol><li><kbd title="ASCII=10">EOL</kbd> nelze použít v řetězci.
Jinými slovy každá část řetězce se musí vejít na fyzický řádek.
Definici delších řetězců ovšem můžeme rozdělit, například
<samp>|0000:5468697320697320 |MultilineString: DB "This is the first line",13,10, \
|0008:7468652066697273~|                    "and this is the second one.",13,10,0
|0036:                 |</samp></li>
<li>Znak použitý k ohraničení řetězce nelze použít uvnitř něho, ledaž by byl zdvojen, např.
<samp>|0000:4F27427269656E00 |Surname: DB 'O''Brien',0
|0008:                 |</samp></li>
<li>Znak procenta <kbd title="ASCII=37">%</kbd> si zachovává svou funkci
předpony preprocesorové %proměnné.
Použijte dvě sousedící procenta tam, kde je v řetězci požadováno jednoduché <kbd>%</kbd>, např.
<samp>|0000:313030252073617665642E00 |Status: DB "100%% saved.",0
|000C:                         |</samp></li></ol>
<h6>Preprocesingové %proměnné jsou expandovány i v řetězcích.</h6>

<p id='EscapeChar'>&euro;ASM nepoužívá únikový znak (escape),  procento a uvozovky escapují samy sebe.
Chcete-li takový znak použít v řetězci, musí být zdvojen.
Tato duplikace se týká pouze zápisu řetězce ve zdrojovém textu a neprodlužuje obsah řetězce v paměti počítače.</p>
<p id='FilenameStrings'>Řetězce uzavřené v 'apostrofech' a ve &quot;dvojitých uvozovkách&quot; jsou ekvivalentní
s jedinou výjimkou: má-li být obsahem řetězce název souboru,lze použít pouze dvojité uvozovky.
neboť apostrof je platným znakem použitelným v názvech souborů na většině souborových systémů.
<br/>Další příklady řetězců:</p>
<samp>|0000:3830202520           |DB "80 %% "
|0005:766F74656420224E6F22 |DB "voted ""No"""
|000F:                     |DB ''        ; Prázdný řetězec.
|000F:27                   |DB "'"       ; Jednoduchý apostrof.
|0010:27                   |DB ''''      ; Jednoduchý apostrof.
|0011:                     |; Příklady neplatné syntaxe (lichý počet uvozovek):
|0011:                     |DB """
|### E6721 Invalid data expression """"".
|0011:                     |DB "It ain't necessarilly so'
|### E6721 Invalid data expression ""It ain't necessarilly so'".
|0011:                     |</samp>

<h3 id="AddressingSpace"><a href="#Elements">&uarr; Adresní prostor</a></h3>
<p>Processor, neboli <dfn>Central Processing Unit</dfn> (CPU),
operuje s daty a komunikuje s okolím (registry, paměť, zařízení).
Typická operace načte informaci z registru, paměti nebo portu (I/O zařízení),
učiní s ní nějakou transformaci a zapíše ji zpět do okolí.
Nejmenší adresovatelnou jednotkou paměti je jeden <strong>bajt</strong> (1 B) a jejich počet je omezen
<dfn>adresním prostorem</dfn>.</p>
<p>Registr je identifikován svým názvem, zařízení je identifikováno číslem portu,
bajt paměti je identifikován jeho adresou.</p>

<table><caption>Adresní prostor</caption>
<tr><th>CPU mód</th><th>GPR </th><th>I/O port </th><th>Adresní prostor</th></tr>
<tr><th>16bit</th><td> 8* 2 B</td><td>64 KB (2<sup>16</sup>)</td><td>1 MB (2<sup>16+4</sup>)</td></tr>
<tr><th>32bit</th><td> 8* 4 B</td><td>64 KB (2<sup>16</sup>)</td><td>4 GB (2<sup>32</sup>)</td></tr>
<tr><th>64bit</th><td>16* 8 B</td><td>64 KB (2<sup>16</sup>)</td><td>16384 PB (2<sup>64</sup>)</td></tr>
</table>

<h3 id="Addresses"><a href="#Elements">&uarr; Adresy</a></h3>
<p>Adresní prostor je limitován architekturou a počtem vodičů mezi procesorem a paměťovými čipy.
Kombinace logických jedniček a nul, která by se dala naměřit na těchto drátech, se nazývá
<dfn id="PhysicalAddress" title="PhA - physical address">fyzická adresa </dfn> (PhA).</p>
<p>Z pohledu aplikačního programátora procesor zapisuje a čte
z <dfn id="VirtualAddress" title="VA - virtual address">virtuální adresy</dfn> (VA).
Neuvažujeme-li segmentaci paměti, můžeme virtuální adrese říkat
<dfn id="LinearAddress" title="LA - linear address">lineární adresa</dfn> (LA).
Virtuální a fyzická adresa byly totožné pouze u první generaci procesorů bez vyrovnávací paměti a stránkování.</p>
<p>Objekty sestaveného obrazu programů v chráněném módu jsou adresovány
pomocí ofsetu od začátku obrazu v paměti (od ImageBase).
Tento ofset se nazývá <dfn id="RelativeVirtualAddress"
title="RVA - relative virtual address">relativní virtuální adresa</dfn> (RVA).</p>
<p>Pozice objektů v souboru bývá identifikována pomocí
<dfn id="FA" title="FA - File Address">adresy v souboru</dfn> (FA), definované
vzdáleností objektu od začátku souboru.</p>
<h6>Adresa je symbolická repreentace určité pozice v paměti.</h6>
<p>PhA, VA, LA, RVA, FA jsou celočíselná nezáporná <strong>prostá čísla</strong>,
avšak adresování v asm-time je komplikovanější.
Z historických důvodů je adresní prostor rozdělen na segmenty paměti
a každý segment je identifikován obsahem <em>segmentového registru</em>.
<dfn id="Address" title="Address">Adresa</dfn> v době kompilace je vyjádřena jako počet bajtů
(<strong>ofset</strong>) mezi pozicí a počátkem segmentu, a samotnou identifikací <strong>segmentu</strong>.
Viz také kapitoly <a href="#AddressSymbols">Adresní symboly</a>
a <a href="#AddressExpressions">Adresní výrazy</a>.</p>

<h3 id="Alignment"><a href="#Elements">&uarr; Alignment</a></h3>
<p>Procesor přistupuje k datům v paměti rychleji, pokud je jejich adresa zarovnána (<em>aligned</em>),
tedy zaokrouhlena na násobek mocniny dvou.
Většina strojových instrukcí IA-32 si sice poradí s nezarovnanými daty, avšak
trvá to déle, pokud data nejsou ve stejné stránce vyrovnávací paměti.</p>
<p>Paměťové proměnné by měly být zarovnány na jejich <em>přirozený alignment</em>
odpovídající jejich velikosti, viz sloupec <em>Autoalign</em> v tabulce
<a href="#DataTypes">datatypů</a>.
Dvojslova DWORD mají hodnotu autoalignmentu rovnou 4, což znamená, že poslední dva bity
by při správném zarovnání měly být nulové. QWORD jsou zarovnány k 8, takže nulové jsou
poslední tři bity (8=2<sup>3</sup>).</p>
<p>Zarovnání lze dosáhnout buď explicitně pomocí pseudoinstrukce <a href="#ALIGN">ALIGN</a>,
anebo klíčem <a href="#ALIGNeq">ALIGN=</a> ve strojové instrukci nebo v definici procedury
<a href="#PROC">PROC</a> nebo <a href="#PROC1">PROC1</a>.</p>
<p>Paměťové proměnné budou automaticky zarovnány, pokud volba <a href="#EUROASM">EUROASM</a>
<a href="#AUTOALIGNeq">AUTOALIGN=ON</a>. Například instrukce
<code>Dvojslovo: DD 1234</code> bude automaticky zarovnána na 4
(ofset Dvojslovo bude dělitelný čtyřmi beze zbytku).
Výplňový znak, vkládaný podle potřeby před zarovnávanou proměnnou,
je nula <kbd>0x00</kbd> v datovém segmentu nebo NOP <kbd>0x90</kbd>, případně <a href="#InsEnhNOP">vícebajtový NOP</a>
v kódovém segmentu.</p>
<p>Hodnota parametru ALIGN= může být numerický výraze vyhodnocený na 1, 2, 4, 8 nebo vyšší mocniny dvou.
&euro;ASM rovněž akceptuje nulu nebo prázdnou hodnotu, což pak je identické s ALIGN=1 (bez efektu).
Vedle těchto číselných hodnot ALIGN= rovněž akceptuje výčtové hodnoty
<dfn>BYTE, WORD, DWORD, QWORD, OWORD, YWORD, ZWORD</dfn> nebo jejich krátké varianty
<dfn>B, W, D, Q, O, Y, Z</dfn>.</p>
<p>Zarovnání je omezeno alignmentem segmentu, v němž příkaz leží.
Pokud je altuální segment zarovnán na DWORD, nelze žádat o zarovnání na QWORD nebo OWORD.
Výchozí zarovnání segmentů je OWORD (10h) a zvyšuje se na <a href="#SECTIONALIGNeq">SectionAlign</a> (obvykle na 1000h),
pokud je program ve formátu ELFX nebo PE/DLL.</p>
<p>Kromě instrukčního modifikátoru <code>ALIGN=</code> může být zarovnání vyžádáno také
samostatnou pseudoinstrukcí <a href="#ALIGN">ALIGN</a>, která dovoluje i záměrné zrušení zarovnání.</p>

<h3 id="Registers" title="Register"><a href="#Elements">&uarr; Registry</a></h3>
<h6>Registr je malá rychlá proměnná s pevnou velikostí umístěná přímo na čipu CPU.</h6>
<p>Třebaže si registr pamatuje zapsanou informaci, není součástí adresovatelné paměti.
Registr může být osloven pouze svým jménem, nemá adresu.</p>
<table>
<caption>Přehled registrů</caption>
<tr><th>Rodina</th><th><small>REGTYPE#</small></th><th>Členové</th><th>Velikost</th></tr>
<tr><td>GPR 8bit</td><td>'B'</td><td>AL, AH, BL, BH, CL, CH, DL, DH,
<br/>DIB, SIB, BPB, SPB, R8B, R9B, R10B, R11B, R12B, R13B, R14B, R15B
<br/>DIL, SIL, BPL, SPL, R8L, R9L, R10L, R11L, R12L, R13L, R14L, R15L</td><td>1</td></tr>
<tr><td>GPR 16bit</td><td>'W'</td><td>AX, BX, CX, DX, BP, SP, SI, DI, R8W, R9W, R10W, R11W, R12W, R13W, R14W, R15W</td><td>2</td></tr>
<tr><td>GPR 32bit</td><td>'D'</td><td>EAX, EBX, ECX, EDX, EBP, ESP, ESI, EDI, R8D, R9D, R10D, R11D, R12D, R13D, R14D, R15D</td><td>4</td></tr>
<tr><td>GPR 64bit</td><td>'Q'</td><td>RAX, RBX, RCX, RDX, RBP, RSP, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, R15</td><td>8</td></tr>
<tr><td>Segment</td><td>'S'</td><td>CS, SS, DS, ES, FS, GS</td><td>2</td></tr>
<tr><td>FPU</td><td>'F'</td><td>ST0, ST1, ST2, ST3, ST4, ST5, ST6, ST7</td><td>10</td></tr>
<tr><td>MMX</td><td>'M'</td><td>MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7</td><td>8</td></tr>
<tr><td>XMM</td><td>'X'</td><td>XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7, XMM8, XMM9, XMM10, XMM11, XMM12, XMM13, XMM14, XMM15,
XMM16, XMM17, XMM18, XMM19, XMM20, XMM21, XMM22, XMM23, XMM24, XMM25, XMM26, XMM27, XMM28, XMM29, XMM30, XMM31</td><td>16</td></tr>
<tr><td>AVX</td><td>'Y'</td><td>YMM0, YMM1, YMM2, YMM3, YMM4, YMM5, YMM6, YMM7, YMM8, YMM9, YMM10, YMM11, YMM12, YMM13, YMM14, YMM15,
YMM16, YMM17, YMM18, YMM19, YMM20, YMM21, YMM22, YMM23, YMM24, YMM25, YMM26, YMM27, YMM28, YMM29, YMM30, YMM31</td><td>32</td></tr>
<tr><td>AVX-512</td><td>'Z'</td><td>ZMM0, ZMM1, ZMM2, ZMM3, ZMM4, ZMM5, ZMM6, ZMM7, ZMM8, ZMM9, ZMM10, ZMM11, ZMM12, ZMM13, ZMM14, ZMM15,
ZMM16, ZMM17, ZMM18, ZMM19, ZMM20, ZMM21, ZMM22, ZMM23, ZMM24, ZMM25, ZMM26, ZMM27, ZMM28, ZMM29, ZMM30, ZMM31</td><td>64</td></tr>
<tr><td>Mask</td><td>'K'</td><td>K0. K1, K2. K3, K4, K5, K6, K7</td><td>8</td></tr>
<tr><td>Bound</td><td>'N'</td><td>BND0, BND1, BND2, BND3</td><td>16</td></tr>
<tr><td>Control</td><td>'C'</td><td>CR0, CR2, CR3, CR4, CR8</td><td>4</td></tr>
<tr><td>Debug</td><td>'E'</td><td>DR0, DR1, DR2, DR3, DR6, DR7</td><td>4</td></tr>
<tr><td>Test</td><td>'T'</td><td>TR3, TR4, TR5</td><td>4</td></tr>
</table>

<p>U jmen registrů nezáleží na velikosti písmen.
Některé <dfn id="GPR" title="GPR">General Purpose Registers</dfn> (GPR) mají aliasy, například
AL je jiný název pro nižší polovinu AX, což je jiný název pro nižší polovinu EAX,
což je jiný název pro nižší polovinu RAX.</p>
<p>Podobné aliasy mají SIMD (AVX) registry: XMM0 je jiný název pro nižší polovinu YMM0,
což je jiný název pro nižší polovinu ZMM0.</p>
<p>Názvy 8bitových registrů DIB, SIB, BPB, SPB, R8B..R15B jsou aliasy pro nejméně významný bajt
registrů RDI, RSI, RBP, RSP, R8..R15. Mohou být nazývány také
jako DIL, SIL, BPL, SPL, R8L..R15L v souladu s dokumentací v manuálech Intelu.
&euro;ASM podporuje obě přípoy ~L i ~B.
Tyto registry jsou dostupné pouze v 64bitovém módu.</p>
<p>Některé asemblery a manuály používají zápis ST(0), ST(1)..ST(7) pro registry jednotky pohyblivé desetinné tečky,
tato syntaxe však není EuroAssemblerem akceptována. Podobně nefunguje ani záměna registru ST0
za ST (vrchol stacku FPU).</p>
<p>Procesor x86 obsahuje ještě některé další registry, které obsahují flagy, tabulky deskriptorů, řídicí a stavové registry FPU,
avšak ty zde nejsou uvedeny, neboť nejsou přímo dostupné pomocí svého názvu.</p>

<h3 id="ConditionCodes"><a href="#Elements">&uarr; Podmínkové kódy</a></h3>
<h4><a href="#ConditionCodesGeneral">Všeobecné podmínkové kódy &darr;</a></h4>
<h4><a href="#ConditionCodesSSE">Podmínkové kódy instrukcí SSE &darr;</a></h4>
<p>Výsledek některých operací procesoru lze považovat za predikát, kterému lze přidělit mnemotechnické jméno
a použít jako součást názvu strojových instrukcí.</p>

<h4 id="ConditionCodesGeneral"><a href="#ConditionCodes">&uarr; Všeobecné podmínkové kody</a></h4>
<p>Některým kombinacím aritmetických  flagů CPU ZF, CF, OF, SF, PF lze přiřadit speciální jména,
tzv. <dfn>podmínkové kódy</dfn>. Jsou použity v mnemonice podmíněného větvení J<em>cc</em>
nebo v instrukcích podmíněných přesunů CMOV<em>cc</em>.</p>
<p>Invertovaný kód může být použit v makroinstrukcích k přeskočení kódu, pokud podmínka není splněna.
Viz sloupec <a href="#InvertedCondition">invertovaná mnemonika</a>.</p>
<table>
<caption>Tabulka všeobecných podmínkových kódů</caption>
<tr><th>Num.<br/>hodnota</th><th>Mnemonika</th><th>Alias</th><th>Popis</th><th>Podmínka</th><th>Invertovaná<br/>mnemonika</th></tr>
<tr><td>0x4</td><td>E   </td><td>Z  </td><td>Equal                </td><td>ZF=1          </td><td>NE  </td></tr>
<tr><td>0x5</td><td>NE  </td><td>NZ </td><td>Not Equal            </td><td>ZF=0          </td><td>E   </td></tr>
<tr><td>0x4</td><td>Z   </td><td>E  </td><td>Zero                 </td><td>ZF=1          </td><td>NZ  </td></tr>
<tr><td>0x5</td><td>NZ  </td><td>NE </td><td>Not Zero             </td><td>ZF=0          </td><td>Z   </td></tr>
<tr><td>0x2</td><td>C   </td><td>B  </td><td>Carry                </td><td>CF=1          </td><td>NC  </td></tr>
<tr><td>0x3</td><td>NC  </td><td>NB </td><td>Not Carry            </td><td>CF=0          </td><td>C   </td></tr>
<tr><td>0x2</td><td>B   </td><td>C  </td><td>Borrow               </td><td>CF=1          </td><td>NB  </td></tr>
<tr><td>0x3</td><td>NB  </td><td>NC </td><td>Not Borrow           </td><td>CF=0          </td><td>B   </td></tr>
<tr><td>0x0</td><td>O   </td><td>   </td><td>Overflow             </td><td>OF=1          </td><td>NO  </td></tr>
<tr><td>0x1</td><td>NO  </td><td>   </td><td>Not Overflow         </td><td>OF=0          </td><td>O   </td></tr>
<tr><td>0x8</td><td>S   </td><td>   </td><td>Sign                 </td><td>SF=1          </td><td>NS  </td></tr>
<tr><td>0x9</td><td>NS  </td><td>   </td><td>Not Sign             </td><td>SF=0          </td><td>S   </td></tr>
<tr><td>0xA</td><td>P   </td><td>PE </td><td>Parity               </td><td>PF=1          </td><td>NP  </td></tr>
<tr><td>0xB</td><td>NP  </td><td>PO </td><td>Not Parity           </td><td>PF=0          </td><td>P   </td></tr>
<tr><td>0xA</td><td>PE  </td><td>P  </td><td>Parity Even          </td><td>PF=1          </td><td>PO  </td></tr>
<tr><td>0xB</td><td>PO  </td><td>NP </td><td>Parity Odd           </td><td>PF=0          </td><td>PE  </td></tr>
<tr><td>0x7</td><td>A   </td><td>NBE</td><td>Above                </td><td>CF=0 &amp;&amp; ZF=0  </td><td>NA  </td></tr>
<tr><td>0x6</td><td>NA  </td><td>BE </td><td>Not Above            </td><td>CF=1 || ZF=1  </td><td>A   </td></tr>
<tr><td>0x3</td><td>AE  </td><td>NB </td><td>Above or Equal       </td><td>CF=0          </td><td>NAE </td></tr>
<tr><td>0x2</td><td>NAE </td><td>B  </td><td>Not Above nor Equal  </td><td>CF=1          </td><td>AE  </td></tr>
<tr><td>0x2</td><td>B   </td><td>NAE</td><td>Below                </td><td>CF=1          </td><td>NB  </td></tr>
<tr><td>0x3</td><td>NB  </td><td>AE </td><td>Not Below            </td><td>CF=0          </td><td>B   </td></tr>
<tr><td>0x6</td><td>BE  </td><td>NA </td><td>Below or Equal       </td><td>CF=1 || ZF=1  </td><td>NBE </td></tr>
<tr><td>0x7</td><td>NBE </td><td>A  </td><td>Not Below nor Equal  </td><td>CF=0 &amp;&amp; ZF=0  </td><td>BE </td></tr>
<tr><td>0xF</td><td>G   </td><td>NLE</td><td>Greater              </td><td>SF=OF &amp;&amp; ZF=0 </td><td>NG  </td></tr>
<tr><td>0xE</td><td>NG  </td><td>LE </td><td>Not Greater          </td><td>SF&lt;&gt;OF || ZF=1</td><td>G   </td></tr>
<tr><td>0xD</td><td>GE  </td><td>NL </td><td>Greater or Equal     </td><td>SF=OF         </td><td>NGE </td></tr>
<tr><td>0xC</td><td>NGE </td><td>L  </td><td>Not Greater nor Equal</td><td>SF&lt;&gt;OF        </td><td>GE  </td></tr>
<tr><td>0xC</td><td>L   </td><td>NGE</td><td>Less                 </td><td>SF&lt;&gt;OF        </td><td>NL  </td></tr>
<tr><td>0xD</td><td>NL  </td><td>GE </td><td>Not Less             </td><td>SF=OF         </td><td>L   </td></tr>
<tr><td>0xE</td><td>LE  </td><td>NG </td><td>Less or Equal        </td><td>SF&lt;&gt;OF || ZF=1</td><td>NLE </td></tr>
<tr><td>0xF</td><td>NLE </td><td>G  </td><td>Not Less nor Equal   </td><td>SF=OF &amp;&amp; ZF=0 </td><td>LE  </td></tr>
<tr><td></td><td>CXZ </td><td>   </td><td>CX register je Zero  </td><td>CX=0          </td><td>    </td></tr>
<tr><td></td><td>ECXZ</td><td>   </td><td>ECX register je Zero </td><td>ECX=0         </td><td>    </td></tr>
<tr><td></td><td>RCXZ</td><td>   </td><td>RCX register je Zero </td><td>RCX=0         </td><td>    </td></tr>
</table>

<h4 id="ConditionCodesSSE"><a href="#ConditionCodes">&uarr; Podmínkové kódy SSE</a></h4>
<p>Instrukce rozšíření <em>Single Instruction Multiple Data</em>
(V)CMP<em>cc</em>SS,(V)CMP<em>cc</em>SD,(V)CMP<em>cc</em>PS,(V)CMP<em>cc</em>PD
používají jiné než všeobecné podmínkové kódy <em>cc</em>.
<blockquote>Pro původní instrukce CMP<em>cc</em>SS,CMP<em>cc</em>SD,CMP<em>cc</em>PS,CMP<em>cc</em>PD
jsou dokumentovány pouze ty uvedené ve sloupci Alias.</blockquote>
<table>
<caption>Podmínkové kódy SSE</caption>
<tr><th>Num.<br/>hodnota</th><th>Mnemonika</th><th>Alias</th><th>Popis</th></tr>
<tr><td>0x00</td><td>EQ_OQ</td><td>EQ</td><td>Equal, Ordered, Quiet</td></tr>
<tr><td>0x01</td><td>LT_OS</td><td>LT</td><td>Less Than, Ordered, Signaling</td></tr>
<tr><td>0x02</td><td>LE_OS</td><td>LE</td><td>Less than or Equal, Ordered, Signaling</td></tr>
<tr><td>0x03</td><td>UNORD_Q</td><td>UNORD</td><td>Unordered, Quiet</td></tr>
<tr><td>0x04</td><td>NEQ_UQ</td><td>NEQ</td><td>Not Equal, Unordered, Quiet</td></tr>
<tr><td>0x05</td><td>NLT_US</td><td>NLT</td><td>Not Less Than, Unordered, Signaling</td></tr>
<tr><td>0x06</td><td>NLE_US</td><td>NLE</td><td>Not Less than or Equal,Unordered, Signaling</td></tr>
<tr><td>0x07</td><td>ORD_Q</td><td>ORD</td><td>Ordered, Quiet</td></tr>
<tr><td>0x08</td><td>EQ_UQ</td><td>  </td><td>Equal, Unordered, Quiet</td></tr>
<tr><td>0x09</td><td>NGE_US</td><td>NGE</td><td>Not Greater than or Equal, Unordered, Signaling</td></tr>
<tr><td>0x0A</td><td>NGT_US</td><td>NGT</td><td>Not Greater Than, Unordered, Signaling</td></tr>
<tr><td>0x0B</td><td>FALSE_OQ</td><td>FALSE</td><td>False, Ordered, Quiet</td></tr>
<tr><td>0x0C</td><td>NEQ_OQ</td><td>   </td><td>Not Equal, Ordered, Quiet</td></tr>
<tr><td>0x0D</td><td>GE_OS</td><td>GE</td><td>Greater than or Equal, Ordered, Signaling</td></tr>
<tr><td>0x0E</td><td>GT_OS</td><td>GT</td><td>Greater Than, Ordered, Signaling</td></tr>
<tr><td>0x0F</td><td>TRUE_UQ</td><td>TRUE</td><td>True, Unordered, Quiet</td></tr>
<tr><td>0x10</td><td>EQ_OS</td><td></td><td>Equal, Ordered, Signaling</td></tr>
<tr><td>0x11</td><td>LT_OQ</td><td></td><td>Less Than, Ordered, Quiet</td></tr>
<tr><td>0x12</td><td>LE_OQ</td><td></td><td>Less than or Equal, Ordered, Quiet</td></tr>
<tr><td>0x13</td><td>UNORD_S</td><td></td><td>Unordered, Signaling</td></tr>
<tr><td>0x14</td><td>NEQ_US</td><td></td><td>Not Equal, Unordered, Signaling</td></tr>
<tr><td>0x15</td><td>NLT_UQ</td><td></td><td>Not Less Than, Unordered, Quiet</td></tr>
<tr><td>0x16</td><td>NLE_UQ</td><td></td><td>Not Less than or Equal, Unordered, Quiet</td></tr>
<tr><td>0x17</td><td>ORD_S</td><td></td><td>Ordered, Signaling</td></tr>
<tr><td>0x18</td><td>EQ_US</td><td></td><td>Equal, Unordered, Signaling</td></tr>
<tr><td>0x19</td><td>NGE_UQ</td><td></td><td>Not Greater than or Equal, Unordered, Quiet</td></tr>
<tr><td>0x1A</td><td>NGT_UQ</td><td></td><td>Not Greater Than, Unordered, Quiet</td></tr>
<tr><td>0x1B</td><td>FALSE_OS</td><td></td><td>False, Ordered, Signaling</td></tr>
<tr><td>0x1C</td><td>NEQ_OS</td><td></td><td>Not Equal, Ordered, Signaling</td></tr>
<tr><td>0x1D</td><td>GE_OQ</td><td></td><td>Greater than or Equal, Ordered, Quiet</td></tr>
<tr><td>0x1E</td><td>GT_OQ</td><td></td><td>Greater Than, Ordered, Quiet</td></tr>
<tr><td>0x1F</td><td>TRUE_US</td><td></td><td>True, Unordered, Signaling</td></tr>
</table>

<h3 id="Operators"><a href="#Elements">&uarr; Operátory</a></h3>
<h6>Operátor je příkaz k počítání v době překladu (asm-time).</h6>
<p>K předepsání matematických operací jsou v &euro;ASM použity kombinace speciálních znaků.
Umístění <dfn>binárního operátoru</dfn> mezi dvě čísla instruuje &euro;ASMm aby nahradil
tyto tři prvky výsledkem operace.
Některé operátory jsou <dfn>unární</dfn>, modifikují hodnotu operandu, před kterým stojí.</p>
<p>Matematické operqace implementované v &euro;ASM jsou uvedeny v následující tabulce.</p>
<table id="OpPriority" title="Operators priority">
<caption id="Priority" title="Priority of operations">Tabulka operací</caption>
<tr><th>Operation       </th><th>Priorita</th><th>Vlastnosti                   </th><th>Levý<br/>operand</th><th>Operátor</th>                 <th>Pravý<br/>operand</th><th>Výsledek</th><th>II <sup>(6)</sup></th></tr>
<tr><td>Membership            </td><td>16</td><td>binární nekomut. <sup>(1)</sup></td><td>identifier</td><td><kbd>.</kbd>                       </td><td>identifier</td><td>identifikátor     </td><td>    </td></tr>
<tr><td>Attribute             </td><td>15</td><td>unární noncomm.  <sup>(3)</sup></td><td>         </td><td><kbd><em>attr</em>#</kbd>          </td><td>element    </td><td>číslo nebo adresa </td><td>    </td></tr>
<tr><td>Case-insens. Equal    </td><td>14</td><td>binární komutativní <sup>(2)</sup></td><td>string</td><td><kbd>==</kbd>                       </td><td>string    </td><td>logický           </td><td>CMPS</td></tr>
<tr><td>Case-sens. Equal      </td><td>14</td><td>binární komutativní           </td><td>string    </td><td><kbd>===</kbd>                      </td><td>string    </td><td>logický           </td><td>CMPS</td></tr>
<tr><td>Case-insens. Nonequal </td><td>14</td><td>binární komutativní <sup>(2)</sup></td><td>string</td><td><kbd>!==</kbd>                      </td><td>string    </td><td>logický           </td><td>CMPS</td></tr>
<tr><td>Case-sens. Nonequal   </td><td>14</td><td>binární komutativní           </td><td>string    </td><td><kbd>!===</kbd>                     </td><td>string    </td><td>logický           </td><td>CMPS</td></tr>
<tr><td>Plus                  </td><td>13</td><td>unární <sup>(3)</sup>         </td><td>          </td><td><kbd>+</kbd>                        </td><td>number    </td><td>číselný           </td><td>NOP </td></tr>
<tr><td>Minus                 </td><td>13</td><td>unární <sup>(3)</sup>         </td><td>          </td><td><kbd>-</kbd>                        </td><td>number    </td><td>číselný           </td><td>NEG </td></tr>
<tr><td>Shift Logical Left    </td><td>12</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>&lt;&lt;</kbd>                 </td><td>number    </td><td>číselný           </td><td>SHL </td></tr>
<tr><td>Shift Arithmetic Left </td><td>12</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>#&lt;&lt;</kbd>                </td><td>number    </td><td>číselný           </td><td>SAL </td></tr>
<tr><td>Shift Logical Right   </td><td>12</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>&gt;&gt;</kbd>                 </td><td>number    </td><td>číselný           </td><td>SHR </td></tr>
<tr><td>Shift Arithmetic Right</td><td>12</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>#&gt;&gt;</kbd>                </td><td>number    </td><td>číselný           </td><td>SAR </td></tr>
<tr><td>Signed Division       </td><td>11</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>#/</kbd>                       </td><td>number    </td><td>číselný           </td><td>IDIV</td></tr>
<tr><td>Division              </td><td>11</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>/</kbd>                        </td><td>number    </td><td>číselný           </td><td>DIV </td></tr>
<tr><td>Signed Modulo         </td><td>11</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>#\</kbd>                       </td><td>number    </td><td>číselný           </td><td>IDIV</td></tr>
<tr><td>Modulo                </td><td>11</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>\</kbd>                        </td><td>number    </td><td>číselný           </td><td>DIV </td></tr>
<tr><td>Signed Multiplication </td><td>11</td><td>binární komutativní           </td><td>number    </td><td><kbd>#*</kbd>                       </td><td>number    </td><td>číselný           </td><td>IMUL</td></tr>
<tr><td>Multiplication        </td><td>11</td><td>binární komutativní           </td><td>number    </td><td><kbd>*</kbd>                        </td><td>number    </td><td>číselný           </td><td>MUL </td></tr>
<tr><td>Scaling               </td><td>10</td><td>binární komutativní <sup>(5)</sup></td><td>number</td><td><kbd>*</kbd>                        </td><td>register  </td><td>adresní výraz    </td><td>    </td></tr>
<tr><td>Addition              </td><td> 9</td><td>binární komutativní           </td><td>number    </td><td><kbd>+</kbd>                        </td><td>number    </td><td>číselný           </td><td>ADD </td></tr>
<tr><td>Subtraction           </td><td> 9</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>-</kbd>                        </td><td>number    </td><td>číselný           </td><td>SUB </td></tr>
<tr><td>Indexing              </td><td> 9</td><td>binární komutativní <sup>(5)</sup></td><td>number</td><td><kbd>+</kbd>                        </td><td>register  </td><td>adresní výraz    </td><td>    </td></tr>
<tr><td>Bitwise NOT           </td><td> 8</td><td>unární <sup>(3)</sup>         </td><td>          </td><td><kbd>~</kbd>                        </td><td>number    </td><td>číselný           </td><td>NOT </td></tr>
<tr><td>Bitwise AND           </td><td> 7</td><td>binární komutativní           </td><td>number    </td><td><kbd>&amp;</kbd>                    </td><td>number    </td><td>číselný           </td><td>AND </td></tr>
<tr><td>Bitwise OR            </td><td> 6</td><td>binární komutativní           </td><td>number    </td><td><kbd>|</kbd>                        </td><td>number    </td><td>číselný           </td><td>OR  </td></tr>
<tr><td>Bitwise XOR           </td><td> 6</td><td>binární komutativní           </td><td>number    </td><td><kbd>^</kbd>                        </td><td>number    </td><td>číselný           </td><td>XOR </td></tr>
<tr><td>Above                 </td><td> 5</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>&gt;</kbd>                     </td><td>number    </td><td>logický           </td><td>JA  </td></tr>
<tr><td>Greater               </td><td> 5</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>#&gt;</kbd>                    </td><td>number    </td><td>logický           </td><td>JG  </td></tr>
<tr><td>Below                 </td><td> 5</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>&lt;</kbd>                     </td><td>number    </td><td>logický           </td><td>JB  </td></tr>
<tr><td>Lower                 </td><td> 5</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>#&lt;</kbd>                    </td><td>number    </td><td>logický           </td><td>JL  </td></tr>
<tr><td>Above or Equal        </td><td> 5</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>&gt;=</kbd>                    </td><td>number    </td><td>logický           </td><td>JAE </td></tr>
<tr><td>Greater or Equal      </td><td> 5</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>#&gt;=</kbd>                   </td><td>number    </td><td>logický           </td><td>JGE </td></tr>
<tr><td>Below or Equal        </td><td> 5</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>&lt;=</kbd>                    </td><td>number    </td><td>logický           </td><td>JBE </td></tr>
<tr><td>Lower or Equal        </td><td> 5</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>#&lt;=</kbd>                   </td><td>number    </td><td>logický           </td><td>JLE </td></tr>
<tr><td>číselný Equal         </td><td> 5</td><td>binární komutativní           </td><td>number    </td><td><kbd>=</kbd>                        </td><td>number    </td><td>logický           </td><td>JE  </td></tr>
<tr><td>číselný Nonequal      </td><td> 5</td><td>binární komutativní <sup>(4)</sup></td><td>number</td><td><kbd>!=</kbd> or <kbd>&lt;&gt;</kbd></td><td>number    </td><td>logický           </td><td>JNE </td></tr>
<tr><td>Logical NOT           </td><td> 4</td><td>unární <sup>(3)</sup>         </td><td>          </td><td><kbd>!</kbd>                        </td><td>number    </td><td>logický           </td><td>NOT </td></tr>
<tr><td>Logical AND           </td><td> 3</td><td>binární komutativní           </td><td>number    </td><td><kbd>&amp;&amp;</kbd>               </td><td>number    </td><td>logický           </td><td>AND </td></tr>
<tr><td>Logical OR            </td><td> 2</td><td>binární komutativní           </td><td>number    </td><td><kbd>||</kbd>                       </td><td>number    </td><td>logický           </td><td>OR  </td></tr>
<tr><td>Logical XOR           </td><td> 2</td><td>binární komutativní           </td><td>number    </td><td><kbd>^^</kbd>                       </td><td>number    </td><td>logický           </td><td>XOR </td></tr>
<tr><td>Segment separation    </td><td> 1</td><td>binární nekomutativní        </td><td>number    </td><td><kbd>:</kbd>                        </td><td>number    </td><td>adresní výraz      </td><td>    </td></tr>
<tr><td>Data duplication      </td><td> 0</td><td>binární nekomut. <sup>(1) (5)</sup></td><td>number</td><td><kbd>*</kbd>                       </td><td>datatype  </td><td>datový výraz      </td><td>    </td></tr>
<tr><td>Range                 </td><td> 0</td><td>binární nekomut. <sup>(1)</sup></td><td>number    </td><td><kbd>..</kbd>                      </td><td>number    </td><td>range             </td><td>    </td></tr>
<tr><td>Substring             </td><td> 0</td><td>binární nekomut. <sup>(1)</sup></td><td>text      </td><td><kbd>[ ]</kbd>                     </td><td>range     </td><td>text              </td><td>    </td></tr>
<tr><td>Sublist               </td><td> 0</td><td>binární nekomut. <sup>(1)</sup></td><td>text      </td><td><kbd>{ }</kbd>                     </td><td>range     </td><td>text              </td><td>    </td></tr>
</table>
<p><sup>(1)</sup> Speciální operace <b>Membership, Duplication, Range, Substring, Sublist</b>
se řeší už na úrovni rozkladu textu místo výpočtu pomocí evaluátoru výrazů, jsou zde uvedeny pouze kvůli kompletnosti.</p>
<p><sup>(2)</sup> Porovnávání řetězcu <b>nezávislé na velikosti</b> ignoruje velikost písmen <kbd>A..Z</kbd> avšak nikoli velikost
písmen s diakritikou větších než ASCII 127.</p>
<p><sup>(3)</sup>  <b>Unární</b> operátor je aplikován na následující operand. <b>Binární</b> operátor pracuje se dvěma operandy.
Operátor <b>atributu</b> je aplikován na následující element nebo výraz v závorkách.</p>
<p><sup>(4)</sup> Numerická operace <b>Nonequal</b> má dva shodné operátory <kbd>!=</kbd> a <kbd>&lt;&gt;</kbd>.
Můžete si vybrat.</p>
<p><sup>(5)</sup> Operace <b>Multiplication</b>, <b>Scaling</b> a <b>Duplication</b> sdílejí tentýž operátor <kbd>*</kbd>.
Podobně <b>Addition</b> a <b>Indexing</b> sdílejí operátor <kbd>+</kbd>. Druh operace je určen typy operandů.</p>
<p><sup>(6)</sup> Sloupec <b>II</b> ilustruje, která strojová instrukce je interně použita k vyhodnocení během překladu.</p>
<p><b>Komutativnost</b> určuje, zda oba operátory binární operace mohou být zaměněny bez vlivu na výsledek.</p>
<p>Slouoec <b>Priorita</b> určuje pořadí zpracování operátorů.
Výrazy s operátory s vyšší prioritou se zpracovávají dříve, avšak lze to změnit použitím prioritních závorek <kbd>( )</kbd>.
Operace se shodnou prioritou se zpracovávají v pořadí zápisu (zleva doprava).</p>
<p>Operace kalkulující s čísly <b>se znaménky</b> mají operátor prefixován znakem <kbd>#</kbd>.
Operace <b>Addition</b> a <b>Subtraction</b> nepotřebují speciální znaménkovou verzi,
neboť počítají se <em>signed</em> i <em>unsigned</em> čísly stejně.</p>
<p>Číselné i logické operace vracejí 64bitové číslo.
V případě <b>booleovských operací</b> má výsledek jednu ze dvou možných hodnot:
<code>0</code> (nepravda) nebo <code>-1 = 0xFFFF_FFFF_FFFF_FFFF</code> (pravda).
Kupříkladu výraz
<br/><code>  '+' &amp; %1 #&gt;= 0   |  '-' &amp;  %1 #&lt; 0  </code>
je vyhodnocen jako
<br/><code>('+' &amp; (%1 #&gt;= 0)) | ('-' &amp; (%1 #&lt; 0))</code>
a výsledkem je znaménko mínus (45) pokud je <code>%1</code> negativní,
nebo znaménko plus (43) v ostatních případech.</p>

<blockquote><p>Mezery oddělující operandy a operátory slouží jen pro lepší čitelnost a nejsou vyžadovány syntaktickými pravidly.
</p>
<p>Skupina operátorů Shift dostala vyšší prioritu než v jiných jazycích,
neboť považuji posuvy za speciální druh násobení a dělení.<br />
Výraz <code>4+3&lt;&lt;2</code> vyhodnocuje NASM jako
<code>(4+3)&lt;&lt;2 = 28</code>, zatímco v &euro;ASM je vyhodnocen jako
<code>4+(3&lt;&lt;2) = 16)</code>.
</blockquote>
<hr/>
<h3 id="Expressions"><a href="#Elements">&uarr; Výrazy</a></h3>
<h4><a href="#NumericExpressions">Číselné a logické výrazy &darr;</a></h4>
<h4><a href="#AddressExpressions">Adresové výrazy &darr;</a></h4>
<h4><a href="#RegisterExpressions">Registrové výrazy &darr;</a></h4>
<h4><a href="#DataExpressions">Datové výrazy &darr;</a></h4>
<h4><a href="#SpecialExpressions">Speciální výrazy &darr;</a></h4>
<p><dfn>Výraz</dfn> (expression) je kombinace operandů, operátorů a prioritních závorek <kbd>()</kbd>
zachovávající pravidla z níže uvedené tabulky.</p>
<table>
<caption>Syntaxe výrazu</caption>
<tr><td>Co může následovat</td><th>levá závorka</th><th>unární operátor</th>
<th>operand</th><th>binární operátor</th><th>pravá závorka</th><th>konec výrazu</th></tr>
<tr><th>začátek výrazu</th><td>ano</td><td>ano</td><td>ano</td><td>ne</td><td>ne</td><td>ano <sup>(2)</sup></td></tr>
<tr><th>levou závorku</th><td>ano</td><td>ano</td><td>ano</td><td>ne</td><td>ano <sup>(2)</sup></td><td>ne</td></tr>
<tr><th>unární operátor</th><td>ano</td><td>ne</td><td>ano</td><td>ne</td><td>ne</td><td>ne</td></tr>
<tr><th>operand</th><td>ne</td><td>ne</td><td>ne</td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><th>binární operátor</th><td>ano</td><td>ano <sup>(1)</sup></td><td>ano</td><td>ne</td><td>ne</td><td>ne</td></tr>
<tr><th>pravou závorku</th><td>ne</td><td>ne</td><td>ne</td><td>ano</td><td>ano</td><td>ano</td></tr>
</table>
<p><sup>(1)</sup> Unární operátor za binárním je povolen, např.
<code>5*-3</code> se vyhodnotí jako <code>5*(-3)</code>.</p>
<p><sup>(2)</sup> Prázdné výrazy, prázdný obsah závorek a nadbytečné závorky se tolerují.</p>

<p>Tabulka vypisuje, které kombinace jsou přípustné.
Měla by se číst po řádkách, např. první řádek sděluje, že výraz může začínat levou závorkou, unárním operátorem
nebo operandem.</p>
<p>Výraz je rozdělen na elementární unární a binární operace, které jsou vyhodnocovány podle priority.
Operace se shodnou prioritou jsou počítány zleva doprava.
Prioritu lze zvětšit pomocí závorek <kbd>( )</kbd>.
</p>

<h4 id="NumericExpressions"><a href="#Expressions">&uarr; Číselné a logické výrazy</a></h4>
<h5><a href="#StringCompare">Porovnání řetězců &darr;</a></h5>
<h5><a href="#NumericCompare">Číselné porovnání &darr;</a></h5>
<h5><a href="#NumericArithmetic">Číselná aritmetika &darr;</a></h5>
<h5><a href="#Shift">Posuvy &darr;</a></h5>
<h5><a href="#BitwiseArithmetic">Bitová aritmetika &darr;</a></h5>
<h5><a href="#BooleanAlgebra">Booleovská algebra &darr;</a></h5>

<h6>Číselné operace interně kalkulují s 64bitovými integery,
bez ohledu zda má cílový program běžet ve 64bitovém módu nebo ne.</h6>

<p>Výsledek číselného nebo logického výrazu je 64bitová numerická hodnota (signed integer).
Lze ji považovat za číslo nebo za logickou hodnotu. Nulový výsledek se považuje
za logickou hodnotu <dfn>nepravda</dfn> a nenulový výsledek za hodnotu <dfn>pravda</dfn>.
Čistě logické výrazy, jako logické NOT, AND, OR, XOR a všechny porovnávací operace
vracejí 0 anebo 0xFFFF_FFFF_FFFF_FFFF = -1. To umožňuje použít výsledek
logických operací s následnými bitovými operacemi se všemi bity.</p>

<h5 id="StringCompare" title="Compare strings"><a href="#NumericExpressions">&uarr; Porovnání řetězců</a></h5>
<p>Porovnávací operace vracejí logickou hodnotu.
Operace necitlivé na velikost písmen nejprve převádějí oba řetězce na stejnou velikost písmen
před samotným srovnáním, to se ale týká pouze ASCII písmen <kbd>A..Z</kbd>, nikoli národních znaků s diakritikou.</p>
<p>Řetězcová porovnávání mají tu nejvyšší prioritu, neboť v asm-time nelze provádět žádnou jinou operaci kromě testu na rovnost.
&euro;ASM nemůže říci, který řetězec je &quot;větší&quot;.
<samp>|00000000:FFFFFFFFFFFFFFFF | DQ "EAX" ==  "eax"          ; Pravda, řetězce jsou si rovny (až na velikost písmen).
|00000008:0000000000000000 | DQ "EAX" === "eax"          ; Nepravda, řetězce se liší velikostí písmen.
|00000010:FFFFFFFFFFFFFFFF | DQ "I'm OK." === 'I''m OK.' ; Pravda, jejich netto hodnoty se shodují.
|00000018:0000000000000000 | DQ "Müller" == "MÜLLER"     ; Nepravda kvůli odlišné velikosti přehlasovaného U.
|00000020:0000000000000000 | DQ "012" == "12"            ; Nepravda, řetězce se neshodují.
|00000028:0000000000000000 | DQ "123" = 123              ; Nepravda, znaková konstanta "123"=3355185 se liší od čísla 123.
|00000030:                 | DQ "123" == 123             ; Syntaktická chyba; pravý operand není řetězcem.
|### E6321 String compare InsensEqual with non-string operand in expression ""123" == 123".
|00000030:</samp>
<p>Porovnávání nezávislé na velikosti písmen by se mělo používat na vestavěné elementy &euro;ASM,
jako jsou názvy registrů nebo datatypů, např.</p><pre>
 %IF '%1' !== 'ECX'
   %ERROR Only register ECX is expected as the first macro operand.
 %ENDIF</pre>
<p>V ostatních případech je vhodnější použít srovnání citlivé na velikost písmen,
neboť &euro;ASM pak nemusí nejprve převádět řetězce na shodnou velikost:</p><pre>
DoSomethingWithMemoryVar %MACRO
 %IF '%1[1]' !=== '['  ; Zjisti, zda první operand makra začíná lomenou závorkou.
   %ERROR The first operand should be a memory variable in [brackets].
 %ENDIF
%ENDMACRO DoSomethingWithMemoryVar</pre>
<p>Test složené závorky z předchozího příkladu selhává, pokud je prvním operandem makra
řetězec nebo znaková konstanta v uvozovkách, např.
<code>DoSomethingWithMemoryVar 'xyz'</code>. Operace porovnání řetězců vyvolá
<kbd>E6101 Expression "''' !=== '" is followed by unexpected character "[".</kbd> kvůli chybě syntaxe.
Jeden trik, jak se vyhnout chybě E6101, je porovnávat zdvojené hodnoty.
V tom případě se jednoduché i dvojité uvozovky navzájem escapují:</p><pre>
DoSomethingWithMemoryVar %MACRO
 %IF '%1[1]%1[1]' !=== '[['  ; Zjisti, zda první operand makra začíná lomenou závorkou.
   %ERROR The first operand should be a memory variable in [brackets].
 %ENDIF</pre>

<h5 id="NumericCompare" title="Compare numbers"><a href="#NumericExpressions">&uarr; Číselné porovnání</a></h5>

<p>Číselné porovnání používá jeden znak rovnítka <kbd>=</kbd>, případně ještě doplněný znaky
<kbd>&lt;</kbd> nebo <kbd>&gt;</kbd>
a může srovnávat hodnoty dvou prostých čísel nebo dvou adres v rámci téhož segmentu.</p>
<p>Číselné porovnání určí, která strana operace je větší.
Termín <dfn>above/below</dfn> se používá při srovnávání adres nebo čísel bez znamének.
Termín <dfn>greater/lower</dfn> se použije při srovnávání znaménkových čísel.
Operátory považující čísla za znaménková mají předřazen znak <kbd>#</kbd>.
Virtuální adresy jsou vždy bez znaménka, takže se nemůžeme zeptat, zda jsou &quot;greater&quot;
nebo &quot;lower&quot;.</p>
<samp>|00000000:FFFFFFFFFFFFFFFF | DQ 5  <  7              ; Pravda, 5 je pod 7.
|00000008:FFFFFFFFFFFFFFFF | DQ 5 #<  7              ; Pravda, 5 je menší než 7.
|00000010:0000000000000000 | DQ 5 #< -7              ; Nepravda, 5 není menší než -7.
|00000018:FFFFFFFFFFFFFFFF | DQ 5  < -7              ; Pravda, 5=0x0000_0000_0000_0005 je pod -7=0xFFFF_FFFF_FFFF_FFF9.
|00000020:FFFFFFFFFFFFFFFF | DQ  123   =  0123       ; Pravda, obě čísla jsou shodná.
|00000028:0000000000000000 | DQ "123" == "0123"      ; Nepravda, oba řetězce se liší.
|00000030:0000000000000000 | DQ "123"  = "0123"      ; Nepravda, obě strany se považují za znakové konstanty s různými hodnotami.
|00000038:                 | DQ "123"  = "000000123" ; "000000123" není číslo, je příliš velké na znakovou konstantu.
|### E6131 Character constant "123"  = "000000123" is too big for 64 bits.
|00000038:                 |</samp>

<h5 id="NumericArithmetic"><a href="#NumericExpressions">&uarr; Číselná aritmetika</a></h5>
<p>Podporované aritmetické operace jsou <em>Addition, Subtraction, Multiplication,
Division</em> a <em>Modulo</em> (zbytek po dělení).</p>
<p><em>Unární mínus</em> lze aplikovat pouze na skalární operandy.
<em>Unární plus</em> nemění hodnotu operandu; v seznamu operátorů je zařazen kvůli kompletnosti.
Sousedící binární a unární numerický operátor je v &euro;ASM akceptován, i když to vypadá divně.
Je to užitečné při operacích s nahrazenou hodnotou, jako <code>5 + %1</code>,
kde symbolický argument %1 je náhodou negativní, třeba <code>-2</code>.
Výraz je vyhodnocován jako
<code>5 + %1 <del>-&gt;</del> 5 + -2 <del>-&gt;</del> 5 + (-2) <del>-&gt;</del> 3</code>.</p>

<p>Nejvyšší přípustná hodnota celého čísla ve zdrojovém kódu &euro;ASM je
<code>0xFFFF_FFFF_FFFF_FFFF <del>-&gt;</del> 18_446_744_073_709_551_615</code>
jako bezznaménková, anebo <code>0x7FFF_FFFF_FFFF_FFFF <del>-&gt;</del> 9_223_372_036_854_775_808 </code> jako znaménková.
Přetečení během překladu je ignorováno u operací <em>Addition, Subtraction</em> a <em>Shift Logical</em>.
Chyba se ohlásí, pokud dojde k přetečení během <em>Multiplication</em>
a <em>Shift Arithmetic Left</em>, nebo pokud dojde k dělení nulou (division-by-zero)
během <em>Division</em> nebo <em>Modulo</em>.
Toto maximum nelze překročit ani u mezivýsledků, jako
<code>0x7FFF_FFFF_FFFF_FFFF * 2 / 2</code> (&euro;ASM hlásí chybu). Nicméně přeskupený kód
<code>0x7FFF_FFFF_FFFF_FFFFF * (2 / 2)</code> se přeloží dobře.</p>
<p>Přetečení není hlášeno během následujících číselných operací:</p>
<samp>|00000000:0E00000000000000 | DQ  2 + 3 * 4                                    ; Výsledek je 14.
|00000008:0200000000000000 | DQ 0xFFFF_FFFF_FFFF_FFF9 + 0x0000_0000_0000_0009 ; Výsledek je 2.
|00000010:0200000000000000 | DQ -7 + 9                                        ; Výsledek je 2 (0xFFFF_FFFF_FFFF_FFF9 + 0x0000_0000_0000_0009).
|00000018:0200010000000000 | DQ 0xFFF9 + 0x0009                               ; Výsledek je 65538 (0x0000_0000_0000_FFF9 + 0x0000_0000_0000_0009).
|00000020:                 |</samp>

<p>&euro;ASM kalkuluje s celočíselným ořezaným dělením a s <a class="EXTL" href="links.htm#Modulo">[Modulo]</a>
operací během překladu stejně jako strojová instrukce
<a class="EXT" href="../easource/iig.htm#IigIDIV">IDIV</a>.</p>
<p>Než se uplatní znaménkové dělení, dělenec i dělitel jsou nejprve interně převedeny
na pozitivní čísla. Teprve pak, po vydělení kladných čísel, je výsledek převeden na negativní,
pokud jeden z operandů (ale ne oba) byly negativní.
<br/>Zbytek po dělení se znaménky je převeden na negativní pouze pokud divident byl negativní.</p>
<samp>|00000000:                 |; Znaménkové dělení:
|00000000:0300000000000000 | DQ +14 #/ +4 ; +(0x0000_0000_0000_000E / 0x0000_0000_0000_0004) is +3.
|00000008:FDFFFFFFFFFFFFFF | DQ -14 #/ +4 ; -(0x0000_0000_0000_000E / 0x0000_0000_0000_0004) is -3.
|00000010:FDFFFFFFFFFFFFFF | DQ +14 #/ -4 ; -(0x0000_0000_0000_000E / 0x0000_0000_0000_0004) is -3.
|00000018:0300000000000000 | DQ -14 #/ -4 ; +(0x0000_0000_0000_000E / 0x0000_0000_0000_0004) is +3.
|00000020:                 |; Bezznaménkové dělení:
|00000020:0300000000000000 | DQ +14  / +4 ;  (0x0000_0000_0000_000E / 0x0000_0000_0000_0004) is 3.
|00000028:FCFFFFFFFFFFFF3F | DQ -14  / +4 ;  (0xFFFF_FFFF_FFFF_FFF2 / 0x0000_0000_0000_0004) is  4_611_686_018_427_387_900.
|00000030:0000000000000000 | DQ +14  / -4 ;  (0x0000_0000_0000_000E / 0xFFFF_FFFF_FFFF_FFFC) is 0.
|00000038:0000000000000000 | DQ -14  / -4 ;  (0xFFFF_FFFF_FFFF_FFF2 / 0xFFFF_FFFF_FFFF_FFFC) is 0.
|00000040:                 |; Zneménkové modulo:
|00000040:0200000000000000 | DQ +14 #\ +4 ; +(0x0000_0000_0000_000E \ 0x0000_0000_0000_0004) is +2.
|00000048:FEFFFFFFFFFFFFFF | DQ -14 #\ +4 ; -(0x0000_0000_0000_000E \ 0x0000_0000_0000_0004) is -2.
|00000050:0200000000000000 | DQ +14 #\ -4 ; +(0x0000_0000_0000_000E \ 0x0000_0000_0000_0004) is +2.
|00000058:FEFFFFFFFFFFFFFF | DQ -14 #\ -4 ; -(0x0000_0000_0000_000E \ 0x0000_0000_0000_0004) is -2.
|00000060:                 |; Bezznaménkové modulo:
|00000060:0200000000000000 | DQ +14  \ +4 ;  (0x0000_0000_0000_000E \ 0x0000_0000_0000_0004) is 2.
|00000068:0200000000000000 | DQ -14  \ +4 ;  (0xFFFF_FFFF_FFFF_FFF2 \ 0x0000_0000_0000_0004) is 2.
|00000070:0E00000000000000 | DQ +14  \ -4 ;  (0x0000_0000_0000_000E \ 0xFFFF_FFFF_FFFF_FFFC) is 14.
|00000078:F2FFFFFFFFFFFFFF | DQ -14  \ -4 ;  (0xFFFF_FFFF_FFFF_FFF2 \ 0xFFFF_FFFF_FFFF_FFFC) is 18_446_744_073_709_551_602.
|00000080:                 |</samp>

<h5 id="Shift" title="Shift operations"><a href="#NumericExpressions">&uarr; Posuvy</a></h5>
<p>Posuvy nejsou komutativní. Operand na levé straně je považován za 64bitový integer
a jeho hodnota bude posunuta vlevo či vpravo o počet bitů určený operandem na pravé straně.</p>
<p>Posuvy mají vyšší prioritu oproti jiným aritmetickým operacím, neboť korespondují
s výpočtem mocnin dvou a ne s násobením či dělením.
Tak například <code>1 &lt;&lt; 7</code> je ekvivalentní <code>1 * 2<sup>7</sup></code>.</p>
<blockquote>NASM vyhodnocuje výraz <code>4 + 3 &lt;&lt; 2</code> jako
<code>(4 + 3) &lt;&lt; 2 <del>-&gt;</del> 28</code>, zatímco &euro;ASM jako
<code>4 + (3 &lt;&lt; 2) <del>-&gt;</del> 16</code>.</blockquote>

<p>Bity vstupující do nejméně významného bitu (LSb) během operací <em>Shift Left</em> jsou vždy 0.
Bity vstupující do nejvýznamnějšího bitu (MSb) během operací <em>Shift Right</em>
jsou buď 0 (v případě <em>Shift Logical Right</em>),
nebo kopírují jeho předchozí hodnotu (v případě <em>Shift Arithmetic Right</em>),
zachovávajíce tak znaménko operandu.</p>
<p>Bity opouštějící LSb během <em>Shift Right</em> jsou zahazovány.
Bity opouštějící MSb během <em>Shift Left</em> jsou také zahazovány,
avšak &euro;ASM ohlásí chybu overflow <a class="EXT" href="../easource/msg.htm#MsgE">E6311</a>,
pokud se změnilo znaménko (udržované v MSb) výsledné hodnoty.
Citlivost na přetečení (overflow) v asm-time je tedy jediný rozdíl mezi operacemi
<em>Shift Arithmetic Left</em> a <em>Shift Logical Left</em>.</p>
<p>Operand vpravo od operátoru Shift může být libovolné číslo, nicméně pokud je větší než 64,
výsledkem posuvu je 0 s jednou výjimkou:
negativní číslo posunuté aritmeticky vpravo o víc než 64 bitů dává výsledek
<code>0xFFFF_FFFF_FFFF_FFFF <del>-&gt;</del> -1</code>.</p>
<p>Posun o 0 bitů nedělá nic. Posuv o negativní číslo jen obrací směr posuvu
zprava doleva a obráceně.</p>
<p>Operace <em>rotace</em> během asm-time nejsou podporovány.</p>
<samp>|00000000:0000010000000000 | DQ  1 << 16                    ; Výsledek je 65536.
|00000008:F4FFFFFFFFFFFFFF | DQ -3 #<< 2                    ; Výsledek je -12.
|00000010:8078675645342312 | DQ 0x1122_3344_5566_7788  << 4 ; Výsledek je 0x1223_3445_5667_7880.
|00000018:98A9BACBDCEDFE0F | DQ 0xFFEE_DDCC_BBAA_9988  >> 4 ; Výsledek je 0x0FFE_EDDC_CBBA_A998.
|00000020:98A9BACBDCEDFEFF | DQ 0xFFEE_DDCC_BBAA_9988 #>> 4 ; Výsledek je 0xFFFE_EDDC_CBBA_A998.
|00000028:0000000000000000 | DQ 0x8000_0000_0000_0000  << 1 ; Výsledek je 0x0000_0000_0000_0000.
|00000030:                 | DQ 0x8000_0000_0000_0000 #<< 1 ; Přetečení, MSb by se změnilo.
|### E6311 ShiftArithmeticLeft 64bit overflow in "0x8000_0000_0000_0000 #<< 1".
|00000030:                 |</samp>

<h5 id="BitwiseArithmetic" title="Bitwise operations"><a href="#NumericExpressions">&uarr; Bitová aritmetika</a></h5>
<p><em>Bitové operace NOT, AND, OR, XOR</em> provádějí logické operace s celým operandem bit po bitu.</p>
<samp>|0000:FA | DB   ~  5 ;            ~ 0000_0101b je 1111_1010b což je -6.
|0001:04 | DB 5 &amp; 12 ; 0000_0101b &amp; 0000_1100b je 0000_0100b což je 4.
|0002:0D | DB 5 | 12 ; 0000_0101b | 0000_1100b je 0000_1101b což je 13.
|0003:09 | DB 5 ^ 12 ; 0000_0101b ^ 0000_1100b je 0000_1001b což je 9.</samp>

<h5 id="BooleanAlgebra"><a href="#NumericExpressions">&uarr; Booleovská algebra</a></h5>
<p><em>Logické operace NOT, AND, OR, XOR</em> umějí operovat s čísly stejně jako s booleovskými hodnotami.
<br/>Každý operand, interně uložený jako nenulové 64bitové číslo, je převeden na booleovské
<em>pravda</em> (<code>0xFFFF_FFFF_FFFF_FFFF</code>) před vlastní logickou operací.
<br/>Operand s hodnotou 0 je považován za <em>nepravda</em>.</p>
<samp>|0000:FF | DB 3 &amp;&amp; 4 ; 0000_0011b &amp;&amp; 0000_0100b je TRUE &amp;&amp; TRUE (oba operandy jsou nenulové), tedy pravda.
|0001:00 | DB 3  &amp; 4 ; 0000_0011b  &amp; 0000_0100b nemají žádný společný bit, výsledek je 0000_0000b, tedy nepravda.</samp>

<h4 id="AddressExpressions" title="Address expressions"><a href="#Expressions">&uarr; Adresové výrazy</a></h4>

<p>Číselné výrazy operují s numerickými hodnotami, jako <code>1, 0x23, '4567'</code>
nebo se symboly reprezentujícími takové skalární hodnoty, jako <code>NumericSymbolTen EQU 10</code>.
Na druhé straně, většina symbolů ve skutečném programu reprezentuje hodnotu adresy ukazující na
určitou pozici v programovém kódu.</p>
<p>Zatímco prosté číslo (skalár) je interně uloženo v &euro;ASM v osmi bajtech,
adresa potřebuje přídavný prostor k udržování informace, do kterého segmentu patří.</p>
<blockquote id="SegmentHighway">Představte si, že řídíte automobil a minuli jste na dálnici kilometrovník označený <kbd>123</kbd>.
V tom vám telefonují vaši přátelé, že právě minuli kilometrovník <kbd>97</kbd>.
Jaká je vzdálenost mezi vašimi auty?
Odpověď je prostá jako odečítání dvou čísel pouze pokud obě auta jedou po téže dálnici.</blockquote>
<p>Operace prováděné s adresami jsou omezeny. Nemohou být násobeny, děleny, posouvány.
Jsou povoleny pouze dva druhy operací s adresami:</p>
<ol><li>K adresnímu symbolu může být přičteno nebo odečteno prosté číslo (skalár).
Výsledkem je opět adresní symbol; operace ovlivňuje pouze ofsetovou část adresy.</li>
<li>Dva symboly mohou být odečteny nebo porovnány, pokud oba leží v téže sekci.
Výsledkem je skalární číselná hodnota odpovídající rozdílu jejich ofsetů.</li></ol>

<h4 id="RegisterExpressions" title="Addressing modes"><a href="#Expressions">&uarr; Registrový výraz</a></h4>
<p id="MemVariables" title="Memory variables">Paměťové proměnné jsou adresovány ofsetem proti prvnímu bajtu segmentu,
kterému se říká <dfn>displacement</dfn>. Mohou být také doplněny za běhu obsahem jednoho nebo dvou registrů.
Takovému zápisu se říká <dfn>registrový výraz</dfn>.</p>
<p>Na rozdíl od instrukcí s číselnou hodnotou vestavěnou do instrukčního kódu, jako třeba
<code>ADD EAX,1234</code>, instrukce ukládající nebo čtoucí data z paměti musí mít celý operand uzavřený v hranatých závorkách <kbd>[ ]</kbd>.
Například <code>ADD EAX,[1234]</code>, kde 1234 je ofset proměnné typu DWORD v datovém segmentu, odkud bude načtena.</p>
<blockquote>MASM dovoluje vynechat hranaté závorky i v případě, že je operandem proměnná v paměti,
např. <code>ADD EAX,Something</code>.
Ubohý čtenář programu psaného v MASM pak musí vyhledat definici proměnné,
aby zjistil, zda byla definována v paměti (<code>Something DD 1</code>)
anebo jako konstanta (<code>Something EQU 1</code>).
Novější asemblery naštěstí tento nedostatek napravují.</blockquote>

<p>Adresní výraz může být doprovázen názvy registrů, stává se z něj <dfn>registrový výraz</dfn>.
Kompletní adresní výraz je definován schématem
<br/><dfn>segment: base + scale * index + displacement</dfn>
kde <br/><dfn>segment</dfn> je segmentový registr <code>CS, DS, ES, SS, FS, GS</code>,
<br/><dfn>base</dfn> je <code>BX, BP</code> v 16bitovém adresním módu, nebo
<code>EAX, EBX, ECX, EDX, EBP, ESP, ESI, EDI, R8D..R15D</code> v 32bitovém adresním módu, nebo
<code>RAX, RBX, RCX, RDX, RBP, RSP, RSI, RDI, R8..R15</code> v 64bitovém adresním módu,
<br/><dfn>scale</dfn> je numerický výraz vyhodnocený na prosté číslo <code>0, 1, 2, 4 or 8</code>,
<br/><dfn>index</dfn> je <code>SI, DI</code> v 16bitovém adresním módu, nebo
<code>EAX, EBX, ECX, EDX, EBP, ESI, EDI, R8D..R15D</code> v 32bitovém adresním módu, nebo
<code>RAX, RBX, RCX, RDX, RBP, RSI, RDI, R8..R15</code> v 64bitovém adresním módu,
<br/><dfn>displacement</dfn> je adresa nebo číselný výraz s šířkou nepřesahující adresní mód (16, 32, 64).</p>
<blockquote>Jiné asemblery povolují odlišnou syntaxi adresace paměti, např.
<code><del>MOV EAX,Displ[ESI]</del></code>,
<code><del>MOV EAX,dword ptr [Displ+ESI]</del></code>,
<code><del>MOV EAX,Displ+[4*ESI]</del></code>,
<code><del>MOV EAX,Displ+4*[ESI]+[EBX]</del></code>.
<br/>EuroAssembler vyžaduje, aby byl celý operand uzavřen do hranatých závorek:
<code>MOV EAX,[Disp+4*ESI+EBX]</code>.</blockquote>

<p>Pořadí komponent v registrovém výrazu je libovolné.
Kterákoli část může být vynechána.
<br/>Měřítko (scale) není povoleno v 16bitovém adresním módu a nelze je použít, pokud není specifikován indexregistr.
<br/>ESP a RSP nemohou být použity jako indexregistr (nelze je škálovat).
<br/>Adresní módy různých šířek nelze kombinovat, např. <code><del>[EBX+SI]</del></code>.
<br/>16bitový adresní mód není dostupný v 64bitovém  CPU módu.</p>

<table>
<caption>Registry povolené v adresních módech</caption>
<tr><th colspan="2">16bitový adresní mód v 16bitovém a 32bitovém segmentu</th></tr>
<tr><td>baseregistr</td><td>BX <sup>SS:</sup>BP</td></tr>
<tr><td>indexregistr</td><td>SI DI</td></tr>
<tr><td>displacement</td><td>16bitový integer se znaménkem, znaménkově roztažený na šířku segmentu</td></tr>
<tr><th colspan="2">32bitový adresní mód v 16bitovém a 32bitovém segmentu</th></tr>
<tr><td>baseregister</td><td>EAX EBX ECX EDX ESI EDI <sup>SS:</sup>EBP <sup>SS:</sup>ESP</td></tr>
<tr><td>indexregister</td><td>EAX EBX ECX EDX ESI EDI EBP</td></tr>
<tr><td>displacement</td><td>32bitový integer se znaménkem, znaménkově roztažený nebo oříznutý na šířku segmentu</td></tr>
<tr><th colspan="2">32bitový adresní mód v 64bitovém segmentu</th></tr>
<tr><td>baseregister</td><td>EAX EBX ECX EDX ESI EDI <sup>SS:</sup>EBP <sup>SS:</sup>ESP R8D..R15D</td></tr>
<tr><td>indexregister</td><td>EAX EBX ECX EDX ESI EDI EBP R8D..R15D</td></tr>
<tr><td>displacement</td><td>32bitový integer se znaménkem, znaménkově rozšířený na šířku segmentu</td></tr>
<tr><th colspan="2">64bitový adresní mód v 64bitovém segmentu</th></tr>
<tr><td>baseregister</td><td>RAX RBX RCX RDX RSI RDI <sup>SS:</sup>RBP <sup>SS:</sup>RSP R8..R15</td></tr>
<tr><td>indexregister</td><td>RAX RBX RCX RDX RSI RDI RBP R8..R15</td></tr>
<tr><td>displacement</td><td>32bitový integer se znaménkem, znaménkově rozšířený na šířku segmentu</td></tr>
<tr><th colspan="2">MOFFS adresní mód v 16bitovém, 32bitovém a 64bitovém segmentu</th></tr>
<tr><td>baseregister</td><td>žádný</td></tr>
<tr><td>indexregister</td><td>žádný</td></tr>
<tr><td>displacement</td><td>integer bez znaménka v šířce segmentu (16|32|64 bitů)</td></tr>
</table>

<p>Není-li <em>segmentový</em> registr explicitně specifikován, použije se k adresaci defaultní segment.
Pokud byl BP, EBP, RBP, ESP nebo RSP použit jako a baseregistr, defaultní segment je <code>SS</code>,
jinak <code>DS</code>.
Nedefaultní segmentový registr může být být specifikován buď jako explicitní
<a href="#StmentPrefix">instrukční prefix</a> <code>SEGCS SEGDS SEGES SEGSS SEGFS SEGGS</code>,
anebo jako segmentový registr, který se stává součástí registrového výrazu.
Segmentový registr může být ve výrazu oddělen buď dvojtečkou <kbd>:</kbd>
(segmentovým separátorem) nebo znaménkem plus <kbd>+</kbd> (indexovací operátor):</p>
<samp>|0000:268A04     |SEGES MOV AL,[SI]
|0003:268A04     |      MOV AL,[ES:SI]
|0006:268A04     |      MOV AL,[ES+SI]</samp>
<p>Existuje drobný rozdíl mezi implicitním a explicitním předepsáním segmentu:
pokud požaduje stejný segmentový registr, který je zároveň defaultní,
&euro;ASM emituje jeho prefix pouze byl-li uveden explicitně v prefixovém poli instrukce:</p>
<samp>|0000:8B04    |        MOV AX,[SI]
|0002:8B04    |        MOV AX,[DS:SI]
|0004:3E8B04  | SEGDS: MOV AX,[SI]
|0007:3E8B04  | SEGDS: MOV AX,[DS:SI]</samp>
<p>Viz také testy <a class="EXT" href="../eatests/t3021.htm">t3021</a>,
 <a class="EXT" href="../eatests/t3022.htm">t3022</a>,
 <a class="EXT" href="../eatests/t3023.htm">t3023</a> pro další příklady.</p>

<p>V registrových výrazech, kdy není použito škálování a není tedy jasné, který ze dvou registrů
je použit v roli indexregistru, &euro;ASM považuje dříve uvedený (levostranný) registr za bázový.
Takže ve výrazu <code>[ESI+EBP]</code> je ESI bázový registr a implicitní segment je DS,
zatímco v <code>[EBP+ESI]</code> je bázový registr EBP a implicitní segment je SS.</p>
<blockquote><p>Naštěstí se rolemi implicitních segmentů nemusíme trápit ve 32bitovém a 64bitovém
chráněném paměťovém modelu FLAT, kdy jsou oba registry SS a DS naplněny stejným segmentovým deskriptorem.</p>
<p>Třebaže operátory <kbd>*</kbd> nebo <kbd>+</kbd> v registrovém výrazu
vypadají jako běžné násobení či sčítání, specifikují zcela jinou operaci <em>Scaling</em> a <em>Indexing</em>,
pokud jsou aplikovány na registr. Samotné násobení a sčítání se provádí až za běhu procesoru.</p>
<p>Operace <em>Indexing</em> má nižší <a href="#Priority">prioritu</a>
než odpovídající <em>Multiplication</em>.
Tudíž výraz <code>[EBX + 5 + ESI * 2 * 2]</code> se vyhodnotí jako
<code>[EBX + 5 + ESI * (2 * 2)] <del>-&gt;</del> [EBX + 5 + ESI * 4]</code>.</p>
</blockquote>

<h4 id="DataExpressions" title="Data expressions"><a href="#Expressions">&uarr; Datové výrazy</a></h4>
<p>Datový výraz specifikuje statická data definovaná pseudoinstrukcí
<a href="#D">D</a> nebo pomocí <a href="#Literals">literálů</a>.
Formát datových výrazů je <br/><dfn>duplikátor * typ hodnota</dfn>, kde
<em>duplikátor</em> je nezáporné celé číslo, <em>typ</em> je primitivní
datový typ ve plné (<code>BYTE UNICHAR WORD DWORD QWORD TBYTE OWORD YWORD ZWORD INSTR</code>)
nebo zkrácené (<code>B U W D Q T S O Y Z I</code>) notaci, anebo jméno struktury.
Nepovinná <em>hodnota</em> určuje obsah datového pole, který je opakován
<em id="times" title="Times">duplikátor</em>-krát.</p>
<p><em>Duplikace</em> není komutativní operace; duplikátor musí být na levé straně
<em>duplikačního operátoru</em> <kbd>*</kbd>.
Výchozí duplikační hodnota je <kbd>1</kbd> (kdy data nejsou duplikována).
Vnořené duplikace nejsou v &euro;ASM podporovány.
Priorita duplikace je velmi nízká, datový výraz
<code>2 + 3 * B 4</code> se vyhodnotí jako pět bajtů, z nichž každý obsahuje hodnotu 4.
Příklad:</p>
<pre>D 3 * BYTE          ; Deklaruje tři bajty s neinicializovaným obsahem.
D W 0x5             ; Deklaruje slovo s obsahem 5.
D 2 * U "some text" ; Deklaruje řetězec v Unicode (UTF-16) obsahující "some textsome text".
D 3 * MyStruc       ; Deklaruje tři instance strukturované proměnné MyStruc.
</pre>
<p>Viz také <a href="#D">pseudoinstrukce D</a> a testy
<a class="EXT" href="../eatests/t2480.htm">t2480</a>,
<a class="EXT" href="../eatests/t2481.htm">t2481</a>,
<a class="EXT" href="../eatests/t2482.htm">t2482</a> pro více příkladů.</p>

<h4 id="SpecialExpressions"><a href="#Expressions">&uarr; Speciální výrazy</a></h4>
<h5><a href="#Membership">Členství &darr;</a></h5>
<h5><a href="#Range">Rozsah &darr;</a></h5>
<h5><a href="#Substring">Substring &darr;</a></h5>
<h5><a href="#Sublist">Sublist &darr;</a></h5>
<p>Následující výrazy nejsou počítány matematickým
<a class="EXT" href="../easource/exp.htm#ExpEval">evaluátorem výrazů</a>;
vyhodnocují se již při čtení a parsování zdrojového textu.</p>
<h5 id="Membership" title="Membership operations"><a href="#SpecialExpressions">&uarr; Členství</a></h5>
<p>Tečka <kbd>.</kbd> spojující dva identifikátory z nich učiní
<dfn id="FQN" title="FQN name">kvalifikované jméno</dfn> (FQN),
které vypadá jako identifikátor jmenného prostoru následovaný lokáním jménem.
FQN je nelokální, nikdy nezačíná tečkou.
Je-li například lokální symbol <code>.bar</code> deklarovaný v proceduře nebo struktuře
<code>Foo</code>,  &euro;ASM jej považuje za symbol s FQN názvem <code>Foo.bar</code>.</p>
<p><a href="#Namespace">Jmenný prostor (namespace)</a> může být rovněž lokální (začínat tečkou),
takže se operátor členství může vnořovat.</p>

<h5 id="Range" title="Range expressions"><a href="#SpecialExpressions">&uarr; Rozsah</a></h5>
<p><dfn>Rozsah</dfn> (range) je definováno jako dva číselné výrazy oddělené
<em>operátorem rozsahu</em>, což je <kbd>..</kbd> (dvě tečky)
a reprezentuje souvislou řadu celých čísel mezi těmito hodnotami, včetně prvé i poslední.</p>
<p>Operátor rozsahu má vlastnost zvanou <em>sklon</em> (<dfn id="Slope" title="Slope">slope</dfn>),
která může být negativní, nulová nebo pozitivní.
Sklon je definován jako znaménko rozdílu mezi pravou a levou hodnotou rozsahu. Příklady:</p>
<pre>
0 .. 15    ; Rozsah představuje šestnáct čísel od 0 do 15; sklon je pozitivní.
-5 .. -4   ; Rozsah představuje hodnoty -5 a -4; sklon je pozitivní.
3 .. 4 - 1 ; Rozsah představuje jednu hodnotu 3; sklon je nulový.
2..-2      ; Rozsah představuje pět hodnot 2, 1, 0, -1, -2; sklon je negativní.
</pre>
<h5 id="Substring" title="Substring operations"><a href="#SpecialExpressions">&uarr; Substring</a></h5>
<p id="Suboperations" title="Suboperations"><em>Substring</em> je operace vracející část vstupního textu.
Operátorem substring je <a href='#Range'>rozsah</a> uzavřený v hranatých závorkách <kbd>[]</kbd>.
Text je považován za sekvenci 8bitoých znaků (<strong>bajtů</strong>) a <em>rozsah</em>
určuje, které z nich budou použity.</p>

<pre>%Sample1 %SET ABCDEFGH ; Preprocesní %proměnná %Sample1 nyní obsahuje 8 znaků.
 DB "%Sample1[3..5]"   ; Toto se ve skutečnosti přeloží jako <code> DB "CDE"</code></pre>

<h5 id="Sublist" title="Sublist operations"><a href="#SpecialExpressions">&uarr; Sublist</a></h5>
<p>Operace <em>Sublist</em> se podobá operaci <a href="#Substring">Substring</a>
s tím rozdílem, že se používají složené závorky <kbd>{}</kbd> a že považuje vstupní text
za pole čárkou oddělených <strong>položek</strong> (pokud dochází k expanzi %proměnné), nebo
za sekvenci fyzických <strong>řádků</strong> (v případě inkluze souboru).</p>
<pre> INCLUDE "MySource.asm"{1..10} ; Vlož prvních deset řádků souboru "MySource.asm".
</pre>
<p> &nbsp; <strong>Společné vlastnosti suboperací <em>Substring</em> a <em>Sublist</em>:</strong></p>
<p>Suboperátor musí být připojen bez mezer.
<br/>Suboperaci lze připojit ve čtyřech případech:<ul>
<li><a href='#pcVariables'>k preprocesní %proměnné</a> v okamžiku její expanze,
např. <code>%MyVar[2..8]</code></li>
<li><a href='#FilenameStrings'>ke jménu souboru</a> v pseudoinstrukci INCLUDE a její rodině,
např. <code> INCLUDEBIN "tada.wav"[44..%&amp;]</code></li>
<li><a href="#FilePath">ke jménu zdrojového souboru</a> když byl <q>euroasm.exe</q> spuštěn z příkazového řádku,
např. <code>euroasm "MySource1.asm"{0..24}</code></li>
<li><a href='#OUTFILEeq'>ke jménu cílového souboru</a> ve volbě OUTFILE=,
např. <code>BootSec PROGRAM OutFile=&quot;boot.sec&quot;[0x7C01..0x7E00]</code>.</li>
</ul>
<p>Při aplikaci na jméno souboru toto musí být uvedeno v dvojitých uvozovkách.</p>
<h6>Znaky a položky se počítají počínaje číslem 1.</h6>
<h6>Číslo posledního členu je automaticky přiřazeno speciální proměnné <code>%&amp;</code>.</h6>
<p>Pořadové  číslo posledního znaku|položky|řádku je přiřazeno EuroAssemblerem
do <a href="#AutomaticVariables">automatické  preprocesní %proměnné</a> nazvané <kbd>%&amp;</kbd>.
Tato %proměnná je platná pouze uvnitř suboperace (uvnitř hranatých nebo složených závorek).</p>
<blockquote>Taky můžete použít pseudoinstrukci <a href="#pcSETS">%SETS</a> k získání počtu znaků
přiřazených %proměnné, a pseudoinstrukci <a href="#pcSETL">%SETL</a>
k získání počtu položek v ní obsažených (délka pole).
<br/>Můžete použít atributový operátor <a href="#FILESIZEha">FILESIZE#</a>
k získání počtu znaků v souboru v asm-time.</blockquote>
<p>V operaci <em>Substring</em> hodnota automatické %proměnné <code>%&amp;</code>
určuje počet znaků přiřazených substringované %proměnné
nebo (v případě suboperace souboru) určuje velikost souboru v bajtech.
<br/>V operaci <em>Sublist</em> reprezentuje pořadové číslo poslední neprázdné položky
v %proměnné, nebo (v případě suboperace souboru) určuje počet fyzických řádků v souboru.</p>
<samp>|4142432C4445462C2C4748492C4A4B4C |%Sample %SET ABC,DEF,,GHI,JKL
|0000:                            | ; %&amp; je nyní 16 v %Sample[%&amp;] a 5 v %Sample{%&amp;}.
|0000:4B4C                        | DB "%Sample[15..%&amp;]" ; DB "KL"
|0002:4445462C2C4748492C4A4B4C    | DB "%Sample{2..%&amp;}"  ; DB "DEF,,GHI,JKL"</samp>

<p>Suboperovaný název souboru musí být uzavřen v uvozovkách i když jeho jméno neobsahuje mezery.
Otevírací závorka musí bezprostředně následovat vstupní text
(jméno %proměnné anebo ukončující závorku souborového jména).
Mezi %proměnnou a levou závorkou suboperace nemohou být žádné mezery.</p>
<p>Suboperace jsou velmi tolerantní k hodnotám rozsahu.
Bez varování akceptuje neexistující znak či položku, např. je-li některý člen rozsahu
nulový nebo záporný. Rozsah s negativním sklonem prostě nevrací nic.
Rozsah s nulovým sklonem vrací jediný znak|položku|řádek, pokud je index mezi
<kbd>1</kbd> a <kbd>%&amp;</kbd>, jinak nevrací nic.</p>
<samp>|4142434445464748                    |%Sample %SET ABCDEFGH ; %Proměnná %Sample nyní obsahuje 8 znaků.
|0000:4142434445                     | DB "%Sample[-3..5]"  ; DB "ABCDE"
|0005:434445464748                   | DB "%Sample[ 3..99]" ; DB "CDEFGH"
|000B:43                             | DB "%Sample[ 3..3]"  ; DB "C"
|000C:                               | DB "%Sample[5..3]"   ; DB ""
|000C:4142434445464748205B352E2E335D | DB "%Sample [5..3]"  ; DB "ABCDEFGH [5..3]" ; Toto není suboperace.</samp>

<p>Suboperační rozsah sestává ze tří komponent:</p><ol>
<li>minimální index rozsahu</li>
<li>operátor rozsahu <kbd>..</kbd></li>
<li>maximální index rozsahu</li></ol>
<p>Pokud bude některá komponenta chybět, nahradí se výchozí hodnotou.
Defaultní minimální index je <kbd>1</kbd>. Defaultní maximální index je <kbd>%&amp;</kbd>.
<samp>|4142434445464748      |%Sample %SET ABCDEFGH ; Preprocesní %proměnná %Sample nyní obsahuje 8 znaků.
|0000:4142434445       | DB "%Sample[..5]" ; <del>-&gt;</del> DB "%Sample[1..5]" <del>-&gt;</del> DB "ABCDE"
|0005:434445464748     | DB "%Sample[3..]" ; <del>-&gt;</del> DB "%Sample[3..8]" <del>-&gt;</del> DB "CDEFGH"
|000B:4142434445464748 | DB "%Sample[..]"  ; <del>-&gt;</del> DB "%Sample[1..8]" <del>-&gt;</del> DB "ABCDEFGH"
|0013:4142434445464748 | DB "%Sample[]"    ; <del>-&gt;</del> DB "%Sample[1..8]" <del>-&gt;</del> DB "ABCDEFGH"</samp>

<p>Všechny následující zápisy jsou totožné co se týká expanze %variable:
<pre>%variable
%variable[1..%&amp;]
%variable[..%&amp;]
%variable[1..]
%variable[..]
%variable[]
%variable{1..%&amp;}
%variable{..%&amp;}
%variable{1..}
%variable{..}
%variable{}
</pre>
<p>Poslední řádek předchozího příkladu je užitečný, potřebujeme-li připojit nějaký text hned za %proměnnou,
např. <code>123</code> k jejímu obsahu.
Nemůžeme psát <code>%proměnná123</code>, neboť připojení číslic by změnilo jméno původní %proměnné.
Řešením je použití prázdné suboperace, která nemění obsah %proměnné, ale odděluje její jméno
od připojeného textu: <code>%proměnná[]123</code> nebo <code>%proměnná{}123</code>.</p>
<p>Pokud rozsah uvnitř závorek obsahuje pouze jedno číslo bez operátoru rozsahu,
považuje se současně za minimální i maximální index a bude expandován právě jeden znak|položka|řádek:
<code>%Sample1[3] <del>-&gt;</del> %Sample[3..3] <del>-&gt;</del> C</code>.</p>
<p>Suboperace se mohou řetězit. Řetěz se zpracovává zleva doprava. Příklad:
<samp>|4142432C4445462C2C4748492C4A4B4C  |%Sample %SET ABC,DEF,,GHI,JKL ; %&amp; je nyní 16 v %Sample[%&amp;] a 5 v %Sample{%&amp;}.
|0000:4A4B                         | DB "%Sample{4..5}[2..6]{2}"  ;  DB "JK"</samp>
<p>První sublist předchozího příkladu bere položky č. 4 a 5,
což dává seznam dvou položek <code>GHI,JKL</code>. Následující substring extrahuje znaky
od druhého do šestého z tohoto sublistu. což dává <code>HI,JK</code>.
Poslední operace sublist expanduje druhou položku, což jsou znaky <code>JK</code>.</p>

<p>Suboperace se mohou vnořovat. Vnitřní rozsah je vyhodnocuje před vnějším.:
<samp>|31323334353637383930  |%Sample %SET 1234567890
|0000:3233343536       | DB "%Sample[2..%Sample[6]]" ; <del>-&gt;</del> DB "%Sample[2..6]"  <del>-&gt;</del>  DB "23456"</samp>


<h3 id="Sections" title="Sections"><a href="#Elements">&uarr; Sekce</a></h3>
<p>Pro každou <a href="#Emit">emitující</a> instrukci generuje asembler
data nebo strojový kód, který bude nakonec vložen do výstupního souboru.
Naštěstí nemusíme psát celý program v přesném pořadí vyžadovaném výstupním formátem.
Generovaná data a kód jsou rozdělovány do svých výstupních <dfn>sekcí</dfn>.
Přepnutí do jiné sekce je prosté: stačí uvést v poli návěstí jméno sekce v hranatých závorkách <kbd>[ ]</kbd>.</p>

<blockquote>Předstvte si, že jako programátor diktujete program své sekretářce (EuroAssembleru).
Nadiktovali jste několik strojových instrukcí, které sekretářka zapsala na list papíru nazvaný <code>[TEXT]</code>.
Pak se rozhodnete diktovat jiný druh dat. Sekretářka vezmi jiný list, označí jej
<code>[DATA]</code> a začne psát tam. Později, až budete diktovat další strojové instrukce,
sekretářka vezme list označený <code>[TEXT]</code> a pokračuje v psaní tam,
kde minule skončila.
<br/>Můžete otevírat nové listy a podle libosti mezi nimi přeskakovat.
Až diktát skončí, použité listy budou secvaknuty dohromaty (slinkovány).</blockquote>

<p>V EuroAssembleru se používá termín <dfn>sekce</dfn> pro pojmenovaný úsek segmentu
charakterizovaný počáteční a koncovou adresou.
Každý segment má jednu nebo více sekcí. Ve výchozím stavu má segment jen jednu sekci
se shodným jménem, která vznikla při definici segmentu.</p>

<h3 id="Segments" title="Segments"><a href="#Elements">&uarr; Segmenty</a></h3>
<p>Architektura Intelu rozděluje paměť na <dfn>segmenty</dfn> ovládané segmentovými registry.
Segment je v &euro;ASM definován pseudoinstrukcí <a href="#SEGMENT">SEGMENT</a>.</p>
<blockquote>Za úsvitu počítačového věku programátoři vyžadovali více paměti,
než pouhých 256 bajtů nebo 64 kilobajtů adresovatelných 8bitovými a 16bitovými registry.
V před32bitových časech mohli designéři u Intelu zvolit spojení dvou 16bitových registrů,
jako <code>DX:AX</code> nebo <code>SI:BX</code> k získání nepředstavitelného adresového prostoru
4 GB, avšak neučinili tak. Místo toho zavedli 16bitové segmentové registry
specializované podle účelu adresované paměti:
registr CS pro strojový kód, DS pro data, SS pro zásobník, ES pro extra dočasné použití.
<br/>Segmentové registry jsou použity k adresování 16bajtových kusů paměti zvaných
<dfn id="Paragraph" title="Paragraph">paragrafy</dfn> (neboli octonary word, OWORD).
Lineární adresa v reálném módu CPU je počítána jako součet
<ul><li>16bitového nebo 32bitového ofsetu, a</li>
<li>paragrafové adresy získané z momentálně platného segmentového registru a vynásobené 16.</li></ul>
Používání segmentových registrů k adresaci 16bajtových paragrafů poskytlo 1 MB paměti
adresovatelné každým segmentovým registem, což se tenkrát jevilo jako dostatečné pro každého.
</blockquote>

<p>Obsah segmentového registru v <strong>reálném</strong> módu procesoru reprezentuje
<strong>paragrafovou adresu</strong> segmentu.
<br/>Obsah segmentového registru v chráněném (<strong>protected</strong>) módu reprezentuje
index do <strong>tabulky deskriptorů</strong>, která udržuje navíc přídavné informace o segmentu
vedle jeho adresy a velikostního limitu: šířku a přístupová práva.</p>
<blockquote>Tyto přídavné informace jsou fixní v reálném módu:<ul>
<li>segmentová počáteční adresa je určena jeho obsahem vynásobeným 16</li>
<li>velikostní limit je 64 KB v 16bitovém adresním módu</li>
<li>přístupová práva jsou <em>všechno je dovoleno</em></li>
<li>šířka segmentu je 16 bitů, avšak je povoleno i používání 32bitového ofsetu na CPU 386 a novějších.</li></ul>
</blockquote>

<p><strong>Segment v run-time</strong> je souvislý blok paměti adresovaný obsahem jednoho segmentového registru.</p>
<p><strong>Segment v link-time</strong> je pojmenovaná část objektového souboru, která může být
spojena se segmenty stejného jména z jiných linkovatelných souborů.</p>
<blockquote>V terminologii <a class="EXTL" href="../eadoc/links.htm#MS_PECOFF">[MS_PECOFF]</a> je linkovatelný segment
nazýván <em>section</em>. Myslím, že termín <em>segment</em> je vhodnější,
neboť COFF &quot;sekce&quot; se rozlišují přístupovými právy definovanými různými segmentovými registry,
tudíž i různými segmentovými deskriptory.
<br/>V našem přirovnání <a href="#SegmentHighway">segment-dálnice</a> jsou segmenty v protected módu
jako souběžné pruhy dálnice, takže mohou sdílet tytéž kilometrovníky (ofsety),
avšak každý pruh je určen pro odlišný typ vozidel.</blockquote>

<p><strong>Segment ve write-time</strong> je část zdrojového kódu
začínající povelem <dfn>přepnutí sekce</dfn>, a který končí přepnutím
na jinou sekci nebo koncem programu.</p>
<blockquote>V &euro;ASM není instrukce ENDS (end-of-segment).
Nelze říci <em>tato část zdrojového kódu nepatří žádnému segmentu</em>.
Už když začínáte psát první instrukci svého programu, tak patří
výchozímu (obálkovému) programu, a každý program implicitně definuje počáteční segmenty.
Nicméně pokud je definována struktura nebo numerická konstanta,
není důležité, který segment je momentálně platný, neboť struktury a skalární symboly
nepatří žádnému segmentu.</blockquote>
<p>Segmenty a sekce nemusejí být souvislé.
Ve skutečnosti je nesouvislost jejich hlavním <em>raison d'être</em>.
Dovoluje udržovat data ve zdrojovém textu poblíž kódu, který s nimi manipuluje,
což přispívá ke srozumitelnosti programu.</p>

<h3 id="Groups" title="Groups"><a href="#Elements">&uarr; Grupy</a></h3>
<p>Nejsou-li programové segmenty příliš velké, mohou být spojeny do segmentových grup (<dfn>GROUP</dfn>).
Celá grupa je pak adresována tímtéž segmentovým registrem.
Grupa je definována pseudoinstrukcí
<a href="#GROUP">GROUP</a>.</p>
<p>Příklad definice grupy: <code>[DGRP] GROUP [DATA],[STRINGS]</code>
definuje grupu s názvem <code>[DGRP]</code> do níž patří segmenty
<code>[DATA]</code> a <code>[STRINGS]</code>.</p>

<h3 id="Segmentation"><a href="#Elements">&uarr; Segmentace</a> (více o sekcích, segmentech, grupách)</h3>
<h4><a href="#SegmentationBase">Základní sekce &darr;</a></h4>
<h4><a href="#SegmentationLifeTime">Životnost segmentace &darr;</a></h4>
<h4><a href="#SegmentationImplicit">Implicitní segmenty &darr;</a></h4>
<h4><a href="#SegmentationNaming">Konvence pojmenování segmentů &darr;</a></h4>
<h4><a href="#SegmentationRegisters">Plnění segmentových registrů &darr;</a></h4>
<h4><a href="#SegmentationOrdering">Pořadí sekcí a segmentů &darr;</a></h4>
<h4><a href="#SegmentationMap">Zobrazení mapy segmentů &darr;</a></h4>
<p>Mezi segmentem a jeho sekcemi je v EuroAssembleru podobný vztah jako
mezi grupou a jejími segmenty.</p>

<h4 id="SegmentationBase"><a href="#Segmentation">&uarr; Základní sekce</a></h4>
<p>Jakmile je segment definován (pseudoinstrukcí <a href="#SEGMENT">SEGMENT</a>)),
automaticky je v něm vytvořena sekce se stejným jménem. tzv. <em>základní sekce</em>.
Případné další sekce mohou být vytvořeny později, povelem s názvem této další sekce
v poli návěstí. V &euro;ASM neexistuje direktiva SECTION.</p>
<p>Vlastnosti sekce (class=, purpose=, combine=, align=) jsou zděděny ze segmentu, do něhož patří.
Výjimkou je zarovnání (alignment) u speciálních sekcí pro literály <code>[@LT64] .. [@LT1], [@RT0], [@RT1]..</code>;
jejich zarovnání je odvozeno od dat, která se do nich zapisují.</p>

<h4 id="SegmentationLifeTime"><a href="#Segmentation">&uarr; Životnost segmentace</a></h4>
<p>Každý segment má jednu nebo více sekcí. Každá sekce patří do právě jednoho segmentu.
Asembler během překladu považuje všechny segmenty za začínající na virtuální adrese 0.
Na konci každého průchodu jsou sekce slinkovány do svých segmentů,
takže mohou začínat na vyšší adrese, kde skončila předešlá sekce.
Nicméně při prvním průchodu ještě není známa velikost sekcí,
takže i zde jsou sekce považovány za začínající na virtuální adrese 0.
Jakmile skončí poslední průchod, všechny sekce budou slinkovány,
tj. jejich emitovaný obsah a relokace spojeny do základní sekce totožné se segmentem.
Jakmile se dostane ke slovu linker, není si existence sekcí už vůbec vědom.</p>
<blockquote><p>Proč bychom měli dělit segmenty na sekce?
Ve skutečnosti nemusíme, vystačili bychom s jednou implicitní sekcí na segment.
Na druhé straně může být výhodnější ve velkých programech seskupovat podobná data dohromady;
můžeme chtít zvláštní sekce pro DWORD proměnné, pro čísla s pohyblivou čárkou, pro textové řetězce.
Může to mimo jiné ušetřit několik bajtů výplně pro zarovnávání, které by jinak bylo nutné při mísení proměnných
s různou velikostí. Takto jsou organizovány také sekce pro literály.</p>
<p>Další příležitostí, kdy se hodí sekce, je rychlé čtení dat z
read-only &quot;databází&quot; definovaných staticky v datovém segmentu.
<br/>Databázi si můžeme mentálně vizualizovat jako tabulku s mnoha řádky
a se sloupci obsahujícími datové položky v konstantní velikosti.
K rychlému výběru určitého řádku databáze je užitečné emitovat všechny položky z jednoho sloupce
sekvenčně do jejich zvláštní sekce, jednu po druhé.
Data každého sloupce budou mít svou vlastní sekci.
Šířka kolon by měla být doplněna na 1, 2, 4 nebo 8 bajtů, takže položky pak mohou být hledány
jedinou strojovou instrukcí <code>REPNE SCAS</code>. Jakmile bude položka nalezena,
rozdíl mezi obsahem registru rDI a začátku sekce identifikuje její databázový řádek.
Další položky z téhož řádku se pak vypočtou z této identifikace.
<br/>Tato metoda byla použita u vzorového projektu
<a class="EXTW" href="https://vitsoft.info/econv_cs.htm">
EuroConvertor</a> a také v samotném EuroAssembleru, kde přiřazuje adresy
zpracovávatele instrukcí (handleru) každé ze dvou tisíc mnemonických zkratek,
viz <a class="EXT" href="../easource/dict.htm#DictLookupIiSetup">DistLookupIiSetup</a>.
</p></blockquote>

<p>Každá grupa obsahuje jeden nebo více segmentů Každý segment patří do právě jedné grupy
(i když do ní nebyl vložen explicitně programátorem, během linkování bude vytvořena grupa se shodným názvem kvůli adresaci).
Kdykoli se sestavuje program ve spustitelném formátu, grupy budou fyzicky spojeny do paměťového obrazu &ndash; <em>image</em>.
Zaváděč spustitelného programu v reálném módu si není vědom existence grup ani segmentů.</p>

<h4 id="SegmentationImplicit" title="Segment implicit names"><a href="#Segmentation">&uarr; Implicitní segmenty a grupy</a></h4>
<p>Když &euro;ASM začíná překládat program, vytvoří nejprve implicitní skupiny a grupy.
Jejich názvy závisí na zvoleném programovém formátu:</p>
<table><caption>Implicitní segmenty</caption>
<tr><th>FORMAT=</th><th>Názvy segmentů</th></tr>
<tr><th>BIN</th><td>[BIN]</td></tr>
<tr><th>BOOT</th><td>[BOOT]</td></tr>
<tr><th>COM</th><td>[COM]</td></tr>
<tr><th>OMF | MZ</th><td>[CODE],[RODATA],[DATA],[BSS],[STACK]</td></tr>
<tr><th>COFF | PE | DLL | ELF | ELFX | ELFSO</th><td>[.text],[.rodata],[.data],[.bss]</td></tr>
</table>

<p>Nejste-li s implicitními názvy spokojeni, mohou být na začátku programu předefinovány
anebo vytvořena sada nových segmentů s odlišnými názvy.
Nepoužité segmenty (do nichž nebylo nic emitováno) nebudou zařazeny do výsledného souboru
a mohou být ignorovány.</p>
<p>Jakmile kompilace skončí a všechny segmenty z linkovaných modulů byly zkombinovány do hlavního programu,
&euro;ASM se dívá na segmenty, které nejsou v žádné grupě a vytvoří pro ně implicitní grupu,
přičemž bere do úvahy <a href="#MODELeq">paměťový model</a>:</p>
<p>Modely s <b>jedním kódovým segmentem</b> (TINY, SMALL, COMPACT) linkují všechen kód do jediné grupy,
bez ohledu na počet kódových segmentů, které mohly být v programu definovány.</p>
<p>Multikódové modely (MEDIUM, LARGE) ponechávají každý kódový segment v jeho vlastní grupě,
takže mezisegmentové skoky, volání a návraty by měly mít <code>JMP|CALL|RET DIST=FAR</code>.</p>
<p>Podobně <b>jednodatové modely</b> (TINY, SMALL, MEDIUM)
předpokládají, že se inicializovaná i neinicializovaná data vejdou do jedné grupy nepřesahující 64&nbsp;KB,
takže linker &euro;ASM přiřazuje všechny datové a bss segmenty této implicitní grupě a register DS
není třeba měnit během přístupu k datům z různých segmentů.</p>

<h4 id="SegmentationNaming"><a href="#Segmentation">&uarr; Konvence pojmenování segmentů</a></h4>
<p>Jména grup, segmentů a sekcí jsou vždy obklopena hranatými závorkami.</p>
<p>Začíná-li jméno tečkou, na rozdíl od symbolů před něj není interně připojován jmenný prostor (namespace).
Jména grup, segmentů a sekcí jsou vždy nelokální.</p>
<p>Počet znaků v jejich názvu je v principu libovolný, avšak může být omezen výstupním formátem programu.
V modulech OMF délka názvu segmentu nebo grupy nesmí přesáhnout 255 znaků.
Ve spustitelném formátu PE je jméno hlavičky segmentu ořezáno na 8 znaků.</p>
<p>&euro;ASM považuje všechna jména segmentů za citlivá na velikost písmen.
Potřebujete-li linkovat váš segment s objektovým modulem generovaným jiným kompilátorem,
jenž konvertuje segmentové názvy na velká písmena nebo je mění připojováním podtržítek,
měli byste tomu přizpůsobit svou konvenci pojmenovávání.</p>
<p>Segmentové jméno by mělo být unikátní, nemůžete definovat dva segmenty s identickým názvem
v jednom programu, s výjimkou implicitních segmentů, pokud dosud nebyly použity
(nic do nich nebylo emitováno). Je však možné definovat segmenty se stejným názvem
v jiných programech a spojovat je v link-time.
Takové segmenty pak budou spojovány v souladu s jejich vlastností <a class="EXT" href="#SegmentCOMBINEeq">COMBINE=</a>.</p>
<p>Názvy sekcí nemohou být duplikovány už z principu. Když se jméno sekce vyskytne
v programu podruhé, pouze přepne emitování do této sekce namísto vytváření nové.</p>
<p>Jména literálních sekcí začínají znaky @LT nebo @RT, raději se vyhněte vytváření sekcí začínající touto kombinací.</p>
<p>Se segmenty s dolarem <kbd>$</kbd> v názvu se zachází poněkud odlišně:
pokud souhlasí znaky na levé straně od tohoto znaku <kbd>$</kbd>, všechny takové segmenty
budou slinkovány jeden za druhým v abecedním pořadí.</p>
<p>Existují <a href="#SegmentPURPOSEeq">konvence</a>, jak jsou &quot;sekce&quot; pojmenovávány v modulech COFF,
kterým byste se měli přizpůsobit, chcete-li úspěšně linkovat programy v &euro;ASM s moduly vytvořenými jinými kompilátory.</p>

<h4 id="SegmentationRegisters"><a href="#Segmentation">&uarr; Plnění segmentových registrů</a></h4>
<p>Pokud &euro;ASM vytváří chráněné spustitelné 32bitové nebo 64bitové programy <b>ELFX</b> nebo <b>PE</b>,
nemusíme se vůbec zabývat segmenty, grupami nebo zásobníkem.
Všechny segmentové registry již OS Linux nebo Windows naplnil a zásobník byl nastaven automaticky.</p>
<p>Při spouštění programu s formátem <b>COM</b> operační systém DOS naplnil registry CS=DS=SS=ES
paragrafovou adresou struktury <a class="EXTL" href="links.htm#PSP">PSP</a>,
nastavil IP=100h a SP na konec zásobníkového segmentu, obvykle 0FFFEh. Zde se opět nemusíme o segmentové registry starat.</p>

<p>Jakmile je 16bitový spustitelný program (FORMAT=MZ) připraven v paměti ke startu,
jeho segmentové registry již byly nastaveny zaváděčem DOSu.
CS:IP byl nastaven na vstupní bod programu (ENTRY=), SS:SP byl nastaven na vrchol zásobníku,
avšak registry DS a ES byly nastaveny na <a class="EXTL" href="links.htm#PSP">PSP</a>,
což není náš datový segment. To bude třeba v kódu programu napravit.</p>
<p>V architektuře Intel není instrukce pro nastavení segmentového registru
přímým číslem, takže se to obchází přes obecný registr nebo zásobník:</p>
<pre>; Naplnění segmentového reigstru paragrafovou adresou segmentu [DATA]
;   použitím obecného registru (což je rychlejší):
MOV AX, PARA# [DATA]
MOV DS,AX
; nebo použitím strojového zásobníku (což je kratší):
PUSH PARA# [DATA]
POP DS</pre>
<p>Je na programátorovi, aby naplnil segmentový registr adresou jiného segmentu,
kdykoli mají být data z něho použita.
&euro;ASM nedělá žádné předpoklady ohledně obsahu segmentových registrů;
neexistuje v něm direktiva <span id="ASSUME" title="ASSUME">ASSUME</span>,
<span id="USING" title="USING">USING</span> ani <span id="WRT" title="WRT">WRT</span>.</p>

<h4 id="SegmentationOrdering" title="Segment order"><a href="#Segmentation">&uarr; Pořadí sekcí a segmentů</a></h4>
<p>Pořadí segmentů ve výstupním programu je obecně založeno na těchto parametrech:</p>
<ol><li>Účel segmentu, který implikuje přístupová práva Read|Write|Execute.</li>
<li>Pořadí, v jakém byly segmenty deklarovány ve zdrojovém textu.</li>
<li>Segmenty s dolarem <kbd>$</kbd> v názvu patřící do téže grupy
a jejichž znaky vlevo od <kbd>$</kbd> jsou identické,
jsou linkovány jako sousedící a řazeny abecedně podle názvu.</li></ol>

<p><strong>Pořadí sekcí</strong></p>
<p>Na konci každého průchodu jsou sekce slinkovány do segmentů v tomto pořadí:</p>
<ol><li>Bázová sekce, definovaná implicitně s každým segmentem.</li>
<li>Ostatní neliterální sekce v pořadí, jak byly deklarovány.</li>
<li>Datově literální sekce v klesajícím pořadí jejích zarovnání, tj.
(<code>[@LT64], [@LT32],..[@LT1]</code>).</li>
<li>Kódově literální sekce v abecedním pořadí (<code>[@RT0], [@RT1], [@RT2]..</code>).</li>
</ol>
<p><strong>Pořadí segmentů</strong></p>
<p>Segmenty se kombinují a spojují v link-time v tomto pořadí:</p>
<ol><li>Grupy inicializovaných segmentů v pořadí jejich definice v textu.</li>
<li>Inicializované segmenty nepatřící do žádné grupy.</li>
<li>Grupy neinicializovaných segmentů v pořadí jejich definice v textu.</li>
<li>Neinicializované segmenty nepatřící do žádné grupy.</li>
</ol>
<p>Segmenty v každé grupě jsou v pořadí, v jakém byly definovány ve zdrojovém kódu,
nikoli jak byly deklarovány v instrukci GROUP.</p>
<p>Při linkování spustitelného programu je každý segment přiřazen některé grupě,
přinejmenším své implicitní s identickým názvem.</p>
<blockquote>Implicitní grupy segmentů jsou použity interně pro relokační účely.
Programy v chráněném módu (MODEL=FLAT) se o segmentové registry příliš nestarají,
takže v programech pro Linux a Windows se segmenty ani grupami nemusíme zabývat.</blockquote>

<table><caption>Anatomie programu založeného na formátu COFF:</caption>
<tr><th>Název</th><th>Účel<br/>segmentu</th><th>Přístup</th><th>Velikost<br/>32bit | 64bit</th>
<th>Zarovnání v souboru<br/>32bit | 64bit</th><th>Poznámka</th></tr>
<tr><td><a class="EXT" href="../easource/pfmz.htm#PFMZ_DOS_HEADER"><em>Hlavička MZ DOS</em></a></td>
<td></td><td>RW</td><td>128 | 128</td><td></td><td>0) 2)</td></tr>
<tr><td><em>Program MZ stub</em></td><td></td><td>RW</td><td></td><td>16 | 16</td><td>0) 2)</td></tr>
<tr><td><em>Podpis PE</em></td><td></td><td>RW</td><td>4 | 4</td><td>32 | 32</td><td>0) 2)</td></tr>
<tr><td><a class="EXT" href="../easource/pfcoff.htm#PFCOFF_FILE_HEADER"><em>Hlavička souboru</em></a></td>
<td></td><td>R</td><td>20 | 20</td><td>16 | 16</td><td>0)</td></tr>
<tr><td><a class="EXT" href="../easource/pfpe.htm#PFPE_OPTIONAL_HEADER32"><em>&quot;Volitelná&quot;</em> hlavička</a></td>
<td></td><td>R</td><td>224 | 240</td><td>16 | 16</td><td>0) 2)</td></tr>
<tr><td><a class="EXT" href="../easource/pfcoff.htm#PFCOFF_SECTION_HEADER"><em>Hlavičky &quot;sekcí&quot;</em></a></td>
<td></td><td>R</td><td>NrOfSe*40</td><td>16 | 16</td><td>0)</td></tr>
<tr><td>.text</td><td>CODE</td><td>RX</td><td></td><td>FiAl|SeAl</td><td></td></tr>
<tr><td>.rodata</td><td>RODATA</td><td>R</td><td></td><td>FiAl|SeAl</td><td></td></tr>
<tr><td>.data</td><td>DATA</td><td>RW</td><td></td><td>FiAl|SeAl</td><td></td></tr>
<tr><td>.bss</td><td>BSS</td><td>RW</td><td></td><td>FiAl|SeAl</td><td></td></tr>
<tr><td>.idata</td><td>IMPORT+IAT</td><td>RWX</td><td></td><td>16|16</td><td>0) 2)</td></tr>
<tr><td>.edata</td><td>EXPORT</td><td>RW</td><td></td><td>16|16</td><td>0) 2) 5)</td></tr>
<tr><td>.reloc</td><td>BASERELOC</td><td>RW</td><td></td><td>16|16</td><td>0) 2)</td></tr>
<tr><td>.rsrc</td><td>RESOURCE</td><td>RW</td><td></td><td>16|16</td><td>0)</td></tr>
<tr><td><a class="EXT" href="../easource/pfcoff.htm#PFCOFF_SYMBOL"><em>Tabulka symbolů</em></a></td>
<td>(SYMBOLS)</td><td>R</td><td>NrOfSym*18</td><td>16 | 16</td><td>0) 1) 3)</td></tr>
<tr><td><em>Tabulka řetězců</em></td><td>(STRINGS)</td><td></td><td></td><td>4 | 4</td><td>0) 1) 3)</td></tr>
</table>

<table><caption>Anatomie programu založeného na formátu ELF:</caption>
<tr><th>Názve</th><th>Účel<br/>segmentu</th><th>Přístup</th><th>Velikost<br/>32bit | 64bit</th>
<th>Zarovnání v souboru<br/>32bit | 64bit</th><th>Poznámka</th></tr>
<tr><td><a class="EXT" href="../easource/pfelf.htm#PFELF_EHDR32"><em>Hlavička souboru</em></a></td>
<td></td><td>R</td><td>52 | 64</td><td></td><td>0)</td></tr>
<tr><td><a class="EXT" href="../easource/pfelf.htm#PFELF_PHDR32"><em>Hlavičky &quot;programů&quot;</em></a></td>
<td></td><td>R</td><td>NrOfPh*(32|56)</td><td>16 | 8</td><td>0) 2)</td></tr>
<tr><td><a class="EXT" href="../easource/pfelf.htm#PFELF_SHDR32"><em>Hlavičky &quot;sekcí&quot;</em></a></td>
<td></td><td>R</td><td>NrOfSe*(40|64)</td><td>8 | 16)</td><td>0)</td></tr>
<tr><td>.symtab</td><td>SYMBOLS</td><td></td><td>NrOfSym*(16|24)</td><td>16 | 8</td><td> </td></tr>
<tr><td>.hash</td><td>HASH</td><td>R</td><td></td><td>4 | 4</td><td>4)</td></tr>
<tr><td>.strtab</td><td>STRINGS</td><td></td><td></td><td>1 | 1</td><td></td></tr>
<tr><td>.shstrtab</td><td>STRINGS</td><td></td><td></td><td>1 | 1</td><td></td></tr>
<tr><td>.interp</td><td>RODATA</td><td>R</td><td></td><td>1 | 1</td><td>4)</td></tr>
<tr><td>.plt</td><td>PLT</td><td>RX</td><td>NrOfJmp*16</td><td>16</td><td>4)</td></tr>
<tr><td>.text</td><td>CODE</td><td>RX</td><td></td><td>FiAl|SeAl</td><td> </td></tr>
<tr><td>.rodata</td><td>RODATA</td><td>R</td><td></td><td>FiAl|SeAl</td><td> </td></tr>
<tr><td>.data</td><td>DATA</td><td>RW</td><td></td><td>FiAl|SeAl</td><td> </td></tr>
<tr><td>.bss</td><td>BSS</td><td>RW</td><td></td><td>FiAl|SeAl</td><td> </td></tr>
<tr><td>.dynamic</td><td>DYNAMIC</td><td>RW</td><td>NrOfRec*(8|16)</td><td>8 | 16</td><td>4)</td></tr>
</table>
<p>Poznámky:
<br/><b>0)</b> Speciální struktura bez vlastní hlavičky.
<br/><b>1)</b> Použito pouze v objektovém modulu.
<br/><b>2)</b> Použito pouze ve spustitelném programu.
<br/><b>3)</b> Použito ve spustitelném programu pokud EUROASM DEBUG=ENABLED.
<br/><b>4)</b> Použito ve spustitelném programu pokud je linkován s DSO.
</p>
<p>Přístupová práva:
<br/><b>R</b> Alokuj pamět a povol čtení.
<br/><b>W</b> Povol zápis.
<br/><b>X</b> Povol provádění instrukcí.
<br/><b>FiAl|SeAl</b> maximum z hodnot FileAlignment | SegmentAlignment.</p>

<h4 id="SegmentationMap"><a href="#Segmentation">&uarr; Zobrazení mapy segmentů</a></h4>
<p>Pseudoinstrukce <a href="#pcDISPLAY"><code>%DISPLAY Sections</code></a>
zapisuje do listingového souboru kompletní dosud deklarovanou mapu grup, segmentů a sekcí,
jeden objekt na jeden řádek, reprezentovaný ladicím oznámením
D1260 (grupa), D1270 (segment), D1280 (sekce).
Segment je odsazen dvěma mezerami, sekce čtyřmi mezerami.
<blockquote>Namísto <code>%DISPLAY Sections</code> bychom mohli zrovna tak použít
<code>%DISPLAY Segment</code> nebo <code>%DISPLAY Groups</code>, výsledek je identický.
Kterýkoli povel vždy zobrazuje celou mapu grup, segmentů a sekcí.</blockquote>
<p>Podobnou mapu tiskne &euro;ASM do listingu včetně konečných virtuálních adres,
ledaže by to bylo zakázáno volbou <code>PROGRAM LISTMAP=OFF</code>.</p>

<h3 id="Distance" title="Distance"><a href="#Elements">&uarr; Distance</a></h3>
<p>Termín <dfn>distance</dfn> specifikuje vzdálenost mezi dvěma adresami,
není to ale pouhý rozdíl dvou ofsetů. V &euro;ASM tento termín reprezentuje
jednu ze tří výčtových hodnot: <code>FAR, NEAR, SHORT</code>.</p>
<p>Distance mezi dvěma adresami je <em>FAR</em>, pokud obě náleží do různých
segmentů, jinak je <em>NEAR</em> nebo <em>SHORT</em>. Rozdíl ofsetů je
<em>SHORT</em>, pokud se vejde do 8bitového integeru se znaménkem, tedy -128..+127.</p>

<h3 id="Width" title="Width"><a href="#Elements">&uarr; Šířka</a></h3>
<p>&euro;ASM je 64bitový assembler, může rovněž kompilovat programy
pracující s 32 a 16 bitovými slovy.
Počet bitů, s nimiž CPU současně pracuje, se nazývá <dfn>šířka</dfn>
a je buď <code>16</code>, <code>32</code> nebo <code>64</code>.</p>
<h6>Šířka se vždy udává v bitech.</h6>
<p><em>Šířka</em> je vlastnost segmentu. Některé 32bitové formáty dovolují
používat segmenty různých šířek v jednom souboru.
Šířka adresního a operačního módu může být měněna <em>ad hoc</em>
instrukčními <a href="#Prefixes">prefixy</a> ATOGGLE, OTOGGLE.</p>
<p>Pseudoinstrukce <a href="#PROGRAM">PROGRAM</a>
má rovněž vlastnost <em>WIDTH=</em>. Ta stanovuje výchozí šířku všech segmentů
programu, u nichž nebyla explicitně změněna. Šířka programu je rovněž použita
k výběru formátu výstupního souboru, například zda má být
PE generován jako 32bitový nebo 64bitový.</p>

<h3 id="Size" title="Size"><a href="#Elements">&uarr; Velikost</a></h3>
<p>Velikost (size) je prosté nezáporné číslo určující počet bajtů
v objektu (registru, paměťové proměnné, struktuře, segmentu, souboru apod.).
Velikost řetězce je definována v bajtech, bez ohledu na to, zda je složen z ANSI nebo z WIDE znaků.</p>
<p>Velikost objektu může být zjištěna v asm-time pomocí atributového operátoru
<a href="#SIZEha">SIZE#</a> nebo <a href="#FILESIZEha">FILESIZE#</a>.</p>
<p>Velikost preprocesní %proměnné může být načtena pseudoinstrukcí <a href="#pcSETS">%SETS</a>.</p>
<h6>Velikost se vždy měří v bajtech.</h6>
<p id="SizeLimits" title="Limitation">Velikost a délka prvků EuroAssembleru
(identifikátorů, čísel, struktur, výrazů, počtu operandů atd.)
není z principu omezena, avšak velikosti jsou interně ukládány do 32bitových znaménkových integerů,
takže limit je 2_147_483_647 znaků. V praxi jsme ovšem omezeni velikostí dostupné paměti.</p>

<h3 id="Length" title="Length"><a href="#Elements">&uarr; Délka</a></h3>
<p>Tento termín se používá k počítání čárkou oddělených položek v seznamu (v poli),
např. počtu operandů v instrukci.
Kupříkladu v instrukci
<code>VPERMI2B XMM1,XMM2,XMM3,MASK=K4,ZEROING=ON</code> je délka pole operandů 5.</p>
<p>Délka pole obsaženého v %proměnné může být získána pseudoinstrukcí
<a href="#pcSETL">%SETL</a>.</p>

<h3 id="Namespace" title="Namespace"><a href="#Elements">&uarr; Jmenný prostor</a></h3>
<p>Názvy symbolů a struktur vytvořených v programu musí být unikátní.
U větších projektů může být udržování unikátních jmen obtížné, zvláště když více lidí
pracuje souběžně na různých částech programu.
Proto programátoři mohou používat <dfn>lokální</dfn> identifikátory,
které musí být unikátní pouze v úseku zdrojového kódu
zvaného <em>jmenný prostor</em> neboli <dfn>namespace</dfn>.
Jmenný prostor je rozsah zdrojového souboru definovaný pomocí <em>bloku jmenného prostoru</em>.
V &euro;ASM máme čtyři blokové psuedoinstrukce, které vytvářejí jmenný prostor: <code>PROGRAM, PROC,
PROC1, STRUC</code>. Název souboru je zároveň názvem jmenného prostoru.
Identifikátor je <em>lokální</em>, když jeho jméno začíná tečkou <kbd>.</kbd>.
Na rozdíl od standardních symbolů znak následující po této tečce může být číslice
a není chyba, pokud následující znaky tvoří  <a href="#ReservedSymbols">rezervovaný název</a>.
Příklady platných lokálních identifikátorů:
<code> .L1, .20, .AX</code>.</p>
<p>Názvy lokálních identifikátorů se v &euro;ASM udržují interně spojeny s názvem jmenného prostoru,
tvoří tak <a href="#FQN">kvalifikované jméno</a> (FQN).
Na lokální symboly můžeme odkazovat tímto .lokálním jménem pouze uvnitř jejich
jmenného prostoru; kvalifikovaným jménem můžeme odkazovat kdekoli v programu.</p>
<p>Jmenný prostor začíná na poli operace příkazu začátku bloku
a končí na poli operace konce bloku. Díky tomu samotný jmenný prostor
(návěstí bloku) může být rovněž lokální a jmenné prostory se mohou vnořovat.</p>
<pre>
MyProg <span class="outer">PROGRAM      ; PROGRAM zahajuje namespace <kbd>MyProg</kbd>.           ;
                                                                    ;
Main    <span class="inner">PROC        ; PROC zahajuje vnitřní namespace Main.         ;
  .10:   RET        ; Lokální návěstí; jeho FQN je <kbd>Main.10</kbd>.        ;
        ENDP</span> Main   ; Po ENDP jsme opět v namespace <kbd>MyProg</kbd>.        ;
                                                                    ;
.Local  <span class="inner">PROC        ; Jeho FQN je <kbd>MyProg.Local</kbd>.                    ;
  .10:   RET        ; FQN tohoto návěstí je <kbd>MyProg.Local.10</kbd>.       ;
        ENDP</span> .Local ; <kbd>MyProg.Local</kbd> namespace končí hned za ENDP.   ;
                                                                    ;
       ENDPROGRAM</span> MyProg
</pre>
<p id="InstanceNamespace">Vedle bloku jmenného prostoru je ještě jedna příležitost, kde je jmenný prostor použit:
pole operandů instrukce definující strukturovanou proměnnou
dočasně přebírá jmenný prostor struktury, z níž tvoříme její instanci:</p>
<pre>
DateProg <span class="outer">PROGRAM      ; PROGRAM zahajuje namespace <kbd>DateProg</kbd>.                   ;
                                                                                ;
Datum <span class='inner'>STRUC  ; Deklarace struktury Datum vytváří namespace <kbd>Datum</kbd>.              ;
.day   DB 0                                                                     ;
.month DB 0                                                                     ;
.year  DW 0                                                                     ;
      ENDSTRUC</span> Datum ; Namespace <kbd>Datum</kbd> končí hned za polem ENDSTRUC            ;
                                                                                ;
[.data] ; Jméno segmentu není lokální, namespace se zde ignoruje.               ;
Birthday DS Datum,<span class='inner'> .day=1, .month=1, .year=1970</span>                                 ;
                                                                                ;
; Předchozí instrukce definuje čtyřbajtovou paměťovou proměnnou                 ;
; zvanou Birthday v sekci [.data] a staticky nastavuje její členy.              ;
; Během definování proměnné "Birthday" &euro;ASM využívá vlastnosti                  ;
; deklarované jako Datum.day, Datum.month, Datum.year (B,B,W).                  ;
; Členové mohou být odkazováni jako Birthday.day, Birthday.month, Birthday.year.;</span>
</pre>


<h3 id="Scope" title="Scope"><a href="#Elements">&uarr; Scope</a></h3>
<h6>Scope je vlastnost symbolu, která určuje jeho viditelnost.</h6>
<p>Každý symbol definovaný v programu může být odkazován svým názvem
kdekoli uvnitř programu v asm-time.
Náš program (objektový modul) může být také slinkován s dalšími moduly a knihovnami,
které mohly rovněž využít stejná jména pro své symboly, ale to je v pořádku
a žádný konflikt nenastává, neboť programy jsou kompilovány každý zvlášť.
Toto je standardní chování, takové symboly mají <dfn>standardní privátní viditelnost</dfn>
omezenou na vnitřek jejich bloku PROGRAM..ENDPROGRAM.</p>
<p>Začíná-li název symbolu tečkou <kbd>.</kbd>, viditelnost takového
<dfn>privátního lokálního jména</dfn> je ještě užší, je limitována na nejmenší blok namespace,
v němž byl symbol definován (PROC..ENDPROC, STRUC..ENDSTRUC).</p>
<p>Na druhé straně ale programy slinkované z několika modulů
mohou potřebovat přistupovat k symbolům mimo jejich standardní privátní viditelnost,
například volat vstupní bod nějaké funkce z linkované knihovny.
Jména takových <em>globálních symbolů</em> by měla být unikátní mezi všemi linkovanými moduly.</p>

<table><caption>Scope definované v &euro;ASM</caption>
<tr><td colspan="2">private</td><td colspan="4"><u>G</u>lobal</td></tr>
<tr><td rowspan="2"><u>S</u>tandard</td><td rowspan="2">local</td><td colspan="2">statické linkování</td>
<td colspan="2">dynamické linkování</td></tr>
<tr><td><u>P</u>ublic</td><td><u>E</u>xtern</td><td>e<u>X</u>port</td><td><u>I</u>mport</td></tr></table>

<p>Vlastnost <em>scope</em> symbolu může být zjišťována v asm-time atributovým operátorem SCOPE#,
který vrací ASCII hodnotu velkého písmene zkratky pro jeho viditelnost, např.</p>
<pre>MySymbol EXTERN
MOV AL,SCOPE# MySymbol ; Toto je ekvivalentní k MOV AL,'E'</pre>

<p>Odpovídající zkratky viditelností jsou uvedeny ve výše uvedené  tabulce.
Stejné zkratky <code>'G','S','P','E','X','I'</code> jsou také použity,
pokud jsou vlastnosti symbolů vypsány povelem <code>%DISPLAY Symbols</code> a také v listingu při
LISTGLOBALS=ENABLED.</p>
<p>Viditelnost GLOBAL, PUBLIC, EXTERN, EXPORT a IMPORT může být explicitně deklarována
<a href="#PUBLIC">pseudoinstrukcí s tímto jménem</a>.
Viditelnost GLOBAL dále může být deklarována implicitně, tím že se jméno symbolu zakončí
pomocí dvou (nebo i více) dvojteček <kbd>::</kbd>. Symbol deklarovaný jako GLOBAL
bude viditelný jako PUBLIC (byl-li definován v programu) anebo je označen jako EXTERN
(pokud není v programu definován).</p>
<p>Zjednodušenou deklarací pomocí dvou dvojteček může být označena pouze viditelnost při statickém linkování (PUBLIC, EXTERN).
Má-li být symbol exportován (píšeme-li DLL) nebo má-li být dynamicky importován z jiné DLL,
použít dvě dvojtečky nestačí a potřebujeme buď explicitní deklaraci pomocí <code>EXPORT|IMPORT</code>,
anebo je vyžadováno <code>LINK importní_knihovna</code>.</p>
<pre>
Word1:  DW 1   ; Standardní privátní viditelnost.
Word2:: DW 2   ; Public scope deklarovaná implicitně (dvěma dvojtečkami).
Word3   PUBLIC ; Public scope deklarovaná explicitně.
Word4   GLOBAL ; Public nebo extern scope (podle existence definice Word4 v tomto programu).
Word5   GLOBAL ; Public nebo extern scope (podle existence definice Word5 v tomto programu).
Word6   EXTERN ; Externní scope. Symbol Word6 nesmí být v tomto programu definován.
Word4:         ; Definice symbolu Word4.
        MOV EAX,Word5 ; Reference externího symbolu Word5.
; Scope symbolu Word1 is PRIVATE.
; Scope symbolů Word2, Word3, Word4 je PUBLIC.
; Scope symbolů Word5, Word6 je EXTERN.
</pre>

<h3 id="DataTypes" title="Data types"><a href="#Elements">&uarr; Datové typy</a></h3>
<p>Důležitou vlastností textů a čísel uložených v počítačové paměti je
 <dfn>datový typ</dfn>, což je pravidlo určující, jak se má daný objekt interpretovat.
&euro;ASM rozeznává následující typy dat:</p>

<table>
<caption>Fundamentální datové typy</caption>
<tr><th>Jméno typu</th><th>Zkratka</th><th>Velikost</th><th>Auto<br>alignment</th><th>Šířka</th>
<th>Typické<br/>úložiště</th><th>Znakový<br/>řetězec</th><th>Celé<br/>číslo</th>
<th>Číslo<br/>s plovoucí tečkou</th><th>Spojený<br/>vektor</th></tr>
<tr><th>BYTE</th><th>B</th><td>1</td><td>1</td><td>8</td>
<td>R8</td><td>ANSI</td><td>8bit</td><td></td><td></td></tr>
<tr><th>UNICHAR</th><th>U</th><td>2</td><td>2</td><td>16</td>
<td>R16</td><td>WIDE</td><td></td><td></td><td></td></tr>
<tr><th>WORD</th><th>W</th><td>2</td><td>2</td><td>16</td>
<td>R16</td><td></td><td>16bit</td><td></td><td></td></tr>
<tr><th>DWORD</th><th>D</th><td>4</td><td>4</td><td>32</td>
<td>R32,ST</td><td></td><td>32bit</td><td>jednoduchá přesnost</td><td></td></tr>
<tr><th>QWORD</th><th>Q</th><td>8</td><td>8</td><td>64</td>
<td>R64,ST</td><td></td><td>64bit</td><td>dvojitá přesnost</td><td></td></tr>
<tr><th>TBYTE</th><th>T</th><td>10</td><td>8</td><td>80</td>
<td>ST</td><td></td><td></td><td>rozšířená přesnost</td><td></td></tr>
<tr><th>OWORD</th><th>O</th><td>16</td><td>16</td><td>128</td>
<td>XMM</td><td></td><td></td><td></td><td>4&times;D | 2&times;Q</td></tr>
<tr><th>YWORD</th><th>Y</th><td>32</td><td>32</td><td>256</td>
<td>YMM</td><td></td><td></td><td></td><td>8&times;D | 4&times;Q</td></tr>
<tr><th>ZWORD</th><th>Z</th><td>64</td><td>64</td><td>512</td>
<td>ZMM</td><td></td><td></td><td></td><td>16&times;D | 8&times;Q</td></tr>
</table>
<table><caption>Ostatní datové typy</caption>
<tr><th>Jméno typu</th><th>Zkratka</th><th>Velikost</th><th>Autoalign</th>
<th>Použití</th></tr>
<tr><th><em>Jméno_struktury</em></th><th>S</th><td><em>různá</em></td>
<td><em>Explicitní zarovnání STRUC,<br/>jinak šířka programu</em></td><td>strukturované proměnné</td></tr>
<tr><th>INSTR</th><th>I</th><td><em>různá</em></td><td>1</td><td>strojové instrukce</td></tr>
</table>
<p>Použití fundamentálních typů je často omezeno na jejich první písmeno.
Datové typy v plné nebo zkratkové notaci se používají pro explicitní definici
pseudoinstrukcí <a href="#D">D</a>, pro implicitní definici dat v <a href="#Literals">literálech</a>,
jako specifikaci zarovnání ALIGN= a v <a href="#InstructionModifiers">instrukčních modifikátorech</a>.</p>
<blockquote><p>&euro;ASM si je částečně vědom datových typů. Například při zpracování strojové instrukce
<code> INC [MemoryVariable]</code> se podívá, jak byla MemoryVariable
definována a podle toho vybírá příslušné zakódování (byte|word|dword).</p>
</blockquote>

<hr/>
<h3 id="Symbols" title="Symbol"><a href="#Elements">&uarr; Symboly</a></h3>
<h4><a href="#SymbolName">Jména symbolů &darr;</a></h4>
<h4><a href="#NumericSymbols">Číselné symboly &darr;</a></h4>
<h4><a href="#AddressSymbols">Adresní symboly &darr;</a></h4>
<h4><a href="#do">Symbol $ &darr;</a></h4>
<h4><a href="#Attributes">Atributy symbolu &darr;</a></h4>
<h4><a href="#Literals">Literální symboly &darr;</a></h4>

<p><dfn>Symbol</dfn> v asembleru je alias k číslu nebo k adrese.</p>
<h6>Rozeznáváme dva druhy symbolů: <dfn>číselný</dfn> a <dfn>adresní</dfn>.</h6>
<p>Číselný symbol odpovídá na otázku <em>kolik?</em> a adresní symbol odpovídá na dotaz
<em>kde?</em> (na které pozici v programu).</p>
<p>Číselný symbol je definován pseudoinstrukcí <a href="#EQU">EQU</a>
nebo jejím aliasem <kbd>=</kbd>, např. <code>Dozen EQU 12</code> nebo <code>Gross = 144</code>.
<br/>Adresní symbol je definován, pokud se jeho jméno objeví v instrukčním poli pro návěstí.</p>
<blockquote>Hodnota číselného symbolu je interně uchovávána v 8 bajtech (signed QWORD),
avšak adresní  symbol navíc vyžaduje přídavnou informaci o sekci, do níž náleží.
<br/>V &euro;ASM nelze definovat numerický symbol jako návěstí jiné instrukce než EQU,
nebo jako samostatné návěstí bez pole operace. Každá instrukce patří do nějaké sekce
(buď explicitně definované nebo implicitně vytvořené při startu programu.</blockquote>

<h4 id="SymbolName"><a href="#Symbols">&uarr; Jméno symbolu</a></h4>
<p>Jméno symbolu je identifikátor (písmeno nebo tečka volitelně následovaná dalšími písmeny, číslicemi a tečkami),
které není <a href="#ReservedSymbols"><dfn>rezervovaným jménem symbolu</dfn></a> (bez ohledu na velikost písmen).
<br/>Název symbolu může být vždy zakončen jednou nebo více dvojtečkami <kbd>:</kbd>,
což pomáhá jej identifikovat jako jméno symbolu.
Dvojtečka není součástí jména symbolu.
Symboly by měly mít sebevysvětlovací názvy.</p>
<blockquote>Zakončení názvu každého symbolu dvojtečkou <kbd>:</kbd> je dobrý zvyk jak při definování, tak i při odkazování na symbol,
třebaže mnoho jiných asemblerů toto nepodporuje.
Je pak jednodušší copy&amp;pastovat symbol, aniž bychom museli mazat dvojtečku na konci.
Dvojtečka pomáhá asembleru i lidskému čtenáři rozeznat jméno jako symbol
a chrání před chybou, pokud bychom zvolili jméno kolidující s některou z tisíců instrukčních mnemonik.
<br/>Názvy struktur, registrů (mimo segmentových) nebo názvy strojových instrukcí
nikdy dvojtečkou nekončí.</blockquote>
<h6>Jméno symbolu musí být v programu unikátní.</h6>
<p>Symboly a struktury mohou být referovány (použity v instrukci) ještě dříve, než jsou definovány.
Přesto je ale dobrou praxí definovat číselné symboly a struktury na počátku programu,
neboť <dfn>dopředné reference</dfn> vyžadují přídavné průchody a prodlužují čas kompilace.</p>

<table id="ReservedSymbols" title="Reserved symbols names"><caption>Rezervovaná jména symbolů</caption>
<tr><th>Kategorie</th><th>Rezervované jméno</th></tr><tr><td>Aktuální ofset v&nbsp;asm-time</td><td>$</td></tr>
<tr><td>Názvy segmentových registrů</td><td>CS, DS, ES, FS, GS, SS</td></tr>
<tr><td>Názvy prefixů</td><td>ATOGGLE, LOCK, OFTEN, OTOGGLE, REP, REPE, REPNE, REPNZ, REPZ, SEGCS, SEGDS,
SEGES, SEGFS, SEGGS, SEGSS, SELDOM, XACQUIRE, XRELEASE</td></tr>
</table>

<p>Jméno symbolu může obsahovat tečku <kbd>.</kbd>, která obvykle spojuje jmenný prostor s lokálním názvem symbolu.
Úvodní tečka <kbd>.</kbd> činí symbol <a href="#Scope">lokální</a>, jelikož jeho jméno je ve skutečnosti spojeno
se současným <a href="#Namespace">jmenným prostorem</a>.</p>
<p>Tvorba jmen symbolů kolidující se jmény registrů nebo instrukcí není doporučena.
Pokud opravdu potřebujete použít některé z těchto <a href="#NonRecommendedSymbols"><dfn>nedoporučených jmen</dfn></a> pro svůj symbol,
musí je následovat dvojtečka, např.</p><pre>
  Byte: DB 1    ; Definuj symbol se jménem "Byte".
  MOV AX,Byte:  ; Naplň AX ofsetem tohoto symbolu.</pre>
<p>V ostatních případech je zakončování jména dvojtečkou <kbd>:</kbd> dobrovolné, ale doporučené.</p>


<table id="NonRecommendedSymbols">
<caption>Nedoporučovaná jména symbolů</caption>
<tr><th>Kategorie</th><th>Nedoporučené jméno</th></tr>
<tr><td>Fundamentální datové typy</td>
<td>B, BYTE, D, DWORD, I, INSTR, O, OWORD, Q, QWORD, S, T, TBYTE, U, UNICHAR, W, WORD, Y, YWORD, Z, ZWORD</td></tr>
<tr><td>Názvy registrů</td><td>
AH, AL, AX, BH, BL, BND0, BND1, BND2, BND3, BP, BPB, BPL, BX, CH, CL, CR0, CR2, CR3, CR4, CR8,
CX, DH, DI, DIB, DIL, DL, DR0, DR1, DR2, DR3, DR6, DR7,
DX, EAX, EBP, EBX, ECX, EDI, EDX, ESI, ESP, K0, K1, K2, K3, K4, K5, K6, K7
MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7,
R10, R10B, R10D, R10L, R10W, R11, R11B, R11D, R11L, R11W, R12, R12B, R12D, R12L, R12W,
R13, R13B, R13D, R13L, R13W, R14, R14B, R14D, R14L, R14W, R15, R15B, R15D, R15L, R15W,
R8, R8B, R8D, R8L, R8W, R9, R9B, R9D, R9L, R9W, RAX, RBP, RBX, RCX, RDI, RDX, RSI, RSP,
SEGR6, SEGR7, SI, SIB, SIL, SP, SPB, SPL, ST0, ST1, ST2, ST3, ST4, ST5, ST6, ST7, TR3, TR4, TR5,
XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7, XMM8, XMM9, XMM10, XMM11, XMM12, XMM13, XMM14, XMM15,
XMM16, XMM17, XMM18, XMM19, XMM20, XMM21, XMM22, XMM23, XMM24, XMM25, XMM26, XMM27, XMM28, XMM30, XMM31
YMM0, YMM1, YMM2, YMM3, YMM4, YMM5, YMM6, YMM7, YMM8, YMM9, YMM10, YMM11, YMM12, YMM13, YMM14, YMM15,
YMM16, YMM17, YMM18, YMM19, YMM20, YMM21, YMM22, YMM23, YMM24, YMM25, YMM26, YMM27, YMM28, YMM30, YMM31
ZMM0, ZMM1, ZMM2, ZMM3, ZMM4, ZMM5, ZMM6, ZMM7, ZMM8, ZMM9, ZMM10, ZMM11, ZMM12, ZMM13, ZMM14, ZMM15,
ZMM16, ZMM17, ZMM18, ZMM19, ZMM20, ZMM21, ZMM22, ZMM23, ZMM24, ZMM25, ZMM26, ZMM27, ZMM28, ZMM30, ZMM31</td></tr>
<tr><td>Názvy pseudoinstrukcí</td>
<td>ALIGN, D, DB, DD, DI, DO, DQ, DS, DU, DW, DY, DZ,
ENDHEAD, ENDP, ENDP1, ENDPROC, ENDPROC1, ENDPROGRAM, ENDSTRUC,
EQU, EUROASM, EXTERN, GLOBAL, GROUP, HEAD, INCLUDE, INCLUDE1, INCLUDEBIN, INCLUDEHEAD, INCLUDEHEAD1,
PROC, PROC1, PROGRAM, PUBLIC, SEGMENT, STRUC</td></tr>
<tr><td>Mnemonické názvy strojových instrukcí</td><td>AAA, AAD, ... XTEST, viz <a class="EXT" href="../easource/ii.htm#IiHandlers">
IiHandlers</a> v &euro;ASM zdroji pro kompletní seznam.</td></tr>
</table>

<h4 id="NumericSymbols"><a href="#Symbols">&uarr; Číselné symboly</a></h4>
<p>Číselný symbol je definován pseudoinstrukcí <a href="#EQU">EQU</a>
nebo jejím aliasem <kbd>=</kbd>, který specifikuje prosté číslo, číselný výraz nebo jiný numerický symbol.
Příklady:</p>
<pre>BufferSize: EQU 16K
WM_KEYDOWN = 0x0100
Total      EQU 2*BufferSize
   MOV ECX,BufferSize
</pre>
<blockquote>Použití numerického symbolu namísto čísla má své výhody:<ul>
<li>Je-li název symbolu vhodně vybrán, např. <code>BufferSize</code>,
je samovysvětlující a nemusíme komentovat, proč jsme plnili ECX
zrovna touto hodnotou <code>16K</code>.</li>
<li>Pokud se později rozhodneme změnit <code>BufferSize</code> během vývoje programu,
je snazší tak učinit pouze na jednom místě, kde je definována.</li></ul></blockquote>

<h4 id="AddressSymbols"><a href="#Symbols">&uarr; Adresní symboly</a></h4>
<p>Adresní symbol je definován, když se vyskytne jako návěstí strojové instrukce nebo prefixu,
jako návěstí prázdné instrukce nebo pseudoinstrukce <a href="#D">D*</a>,
<a href="#PROC">PROC</a>, <a href="#PROC1">PROC1</a>.</p> Příklady: <pre>
[DATA]
SomeValue:   DD 4
[CODE]
             MOV EAX,[SomeValue:]
StartOfLoop: CALL SomeProcedure:
             DEC EAX
             JNZ  StartOfLoop:
</pre>
<p>Zatímco numerický symbol <code>BufferSize</code> byl zcela definován svou hodnotou,
v případě adresního symbolu <code>SomeValue</code> to není dostačující.
Instrukce <code>MOV EAX,SomeValue</code> plní EAX ofsetem symbolu,
tj. vzdáleností jeho pozice od začátku jeho segmentu.
Adresní symbol je definován dvěma vlastnostmi: jeho <dfn>segmentem</dfn> a jeho <dfn>ofsetem</dfn>.
Proto se adresnímu symbolu občas říká <dfn>vector</dfn> nebo <dfn>relativní symbol</dfn>
a číselný symbol je nazýván <dfn>skalár</dfn> nebo <dfn>absolutní symbol</dfn>
nebo <dfn>konstanta</dfn>.</p>
<blockquote>Symbol lze v EuroAssembleru vytvořit jednou z pěti metod:
<ol><li>Symbol je definován, pokud se jeho jméno vyskytne v poli návěstí.
Takový symbol reprezentuje adresu uvnitř segmentu a zároveň i data emitovaná touto instrukcí.
Instrukce může být prázdná (pouze návěstí) nebo může deklarovat <a href="#D">data</a>,
prefix nebo strojovou instrukci. Pseudoinstrukce <a href="#PROC">PROC</a>
a <a href="#PROC1">PROC1</a> také definují symbol, avšak pseudoinstrukce
<a href="#PROGRAM">PROGRAM</a>, <a href="#STRUC">STRUC</a> ani
<a href="#SEGMENT">SEGMENT</a> nikoli.</li>
<li>Externí a importované symboly jsou vytvářeny pseudoinstrukcí <a href="#EXTERN">EXTERN</a>,
<a href="#IMPORT">IMPORT</a> nebo <a href="#GLOBAL">GLOBAL</a>, nebo pokud jsou odkazovány se dvěma dvojtečkami
připojenými k jejich jménu. Externí symbol není v programu definován,
nesmí se objevit v poli návěstí (s výjimkou pseudoinstrukce EXTERN, která určuje jeho viditelnost).</li>
<li><a href="#Literals">Literální symbol</a> je vytvořen, když se objeví v programu poprvé.
Nemá explicitní jméno, ve skutečnosti je jeho název reprezentován
jeho hodnotou. Například instrukční kod <code> LEA ESI,[=D 123]</code>
vytváří literální symbol uložený v tabulce symbolů EuroAssembleru pod názvem <code>=D 123</code>.</li>
<li>&euro;ASM udržuje speciální dynamický symbol <code>$</code> pro každou sekci,
který reprezentuje současnou pozici asembleru v sekci.</li>
<li>Symbol může být také definován pseudoinstrukcí <a href="#EQU">EQU</a>
nebo jejím aliasem <kbd>=</kbd>. To je jediný způsob, jak definovat prostý numerický symbol.</li>
</ol></blockquote>

<h4 id="do" title="$ symbol"><a href="#Symbols">&uarr; Symbol $</a></h4>
<p>Speciální dynamický symbol <code>$</code> představuje adresu příští volné pozice
v emitovaném kódu na počátku překladu instrukce, v níž je zmíněn.
Hodnota tohoto symbolu není konstantní, ale &euro;ASM ji mění jakmile byla instrukce přeložena na strojový kód.</p>
<p>Programátor může měnit současnou hodnotu <kbd>$</kbd> pseudoinstrukcí
<a href="#EQU">EQU</a>, to odpovídá pseudoinstrukci ORG známé z jiných asemblerů.</p>
<h6 id="ORG" title="ORG">V &euro;ASM není pseudoinstrukce ORG, místo toho lze <kbd>$</kbd> změnit pseudoinstrukcí EQU.</h6>
<samp id="UNION" title="Union">|00000100:44444444 |DataDword  DD  0x44444444
|00000104:         |   ; Předefinování DataDword na unii dvou WORDů:
|00000100:         |   $       EQU DataDword  ; Vrať ukazatel emitování zpět.
|00000100:1111     |DataLoWord DW  0x1111     ; Znovu emituje odlišná data,
|00000102:2222     |DataHiWord DW  0x2222     ;  která přepíší původní hodnotu DataDword.
|00000104:         |</samp>
<p>Viz také test <a class="EXT" href="../eatests/t2551.htm">t2551</a>
nebo vzorový projekt <a class="EXT" href="../probin/boot16.htm">boot16</a>.

<hr/>
<h4 id="Attributes" title="Attributes"><a href="#Symbols">&uarr; Atributy symbolů, registů a souborů</a></h4>
<h5><a href="#SIZEha">SIZE# &darr;</a></h5>
<h5><a href="#TYPEha">TYPE# &darr;</a></h5>
<h5><a href="#REGTYPEha">REGTYPE# &darr;</a></h5>
<h5><a href="#SCOPEha">SCOPE# &darr;</a></h5>
<h5><a href="#OFFSETha">OFFSET# &darr;</a></h5>
<h5><a href="#SECTIONha">SECTION# &darr;</a></h5>
<h5><a href="#SEGMENTha">SEGMENT# &darr;</a></h5>
<h5><a href="#GROUPha">GROUP# &darr;</a></h5>
<h5><a href="#PARAha">PARA# &darr;</a></h5>
<h5><a href="#FILESIZEha">FILESIZE# &darr;</a></h5>
<h5><a href="#FILETIMEha">FILETIME# &darr;</a></h5>
<hr/>
<p>Několik vlastností symbolu zvaných <dfn>atributy</dfn> je k dispozici ke zpracování za běhu asembleru.
Jakmile je symbol definován, nabývá atributy automaticky.
Mohou být testovány přidáním operátoru atributu před jméno symbolu.
<dfn>Operátor atributu</dfn> je jeho definující identifikátor bezprostředně následovaný znakem <kbd>#</kbd>.
Objekt, jehož se operátor atributu týká, může být oddělen žádnou nebo několika mezerami a může být v závorkách.
Například <code>SIZE#SymbolName</code> nebo <code>SIZE# SymbolName</code> nebo <code>SIZE#(SymbolName)</code>.
Zapamatujte si, že v názvu symbolu záleží na velikosti písmen, avšak v názvu atributu nikoli.</p>
<p>Atributy <em>GROUP#</em>, <em>SEGMENT#</em> a <em>SECTION#</em> vracejí adresu, pokud jsou aplikovány na adresní symbol
a vracejí skalární nulu, jsou-li aplikovány na číselný symbol.
Ostatní atributy vždy vracejí skalár (prosté číslo).</p>

<h5 id="OFFSETha"><a href="#Attributes">&uarr; OFFSET#</a></h5>
<p>Atribut <em>OFFSET#</em> vrací ofset symbolu v jeho segmentu jako prosté číslo,
tj. počet bajtů mezi ním a počátkem jeho segmentu.
Je-li symbol číselný, atribut vrací jeho hodnotu.</p>
<p><code>Symbol</code> a <code>OFFSET#Symbol</code> jsou identické pouze pokud je
Symbol skalár, jinak to první představuje jeho adresu a to druhé prosté číslo.</p>
<p>Výraz <code>Symbol - SEGMENT#Symbol</code> je totožný s <code>OFFSET#Symbol</code>
jak pro numerický, tak i pro adresní symbol.</p>

<h5 id="PARAha"><a href="#Attributes">&uarr; PARA#</a></h5>
<p>Atribut <em>PARA#</em> představuje paragrafovou adresu začátku grupy, do níž symbol patří.
Je to hodnota, kterou je třeba načíst do segmentového registru použitého k adresování.
Je-li PARA# aplikován na numerický symbol, vrací skalární nulu.</p>

<h5 id="GROUPha"><a href="#Attributes">&uarr; GROUP#</a></h5>
<p>Atribut <em>GROUP#</em> reprezentuje adresu začátku grupy, do níž symbol patří,
tj. adresu prvního bajtu nejnižšího segmentu grupy.
Při aplikování na numerický symbol vrací skalární nulu.</p>

<h5 id="SEGMENTha"><a href="#Symbols">&uarr; SEGMENT#</a></h5>
<p>Atribut <em>SEGMENT#</em> představuje adresu začátku segmentu, do nějž symbol patří.
Při aplikování na numerický symbol vrací skalární nulu.</p>

<h5 id="SECTIONha"><a href="#Attributes">&uarr; SECTION#</a></h5>
<p>Atribut <em>SECTION#</em> reprezentuje adresu počátku sekce, do níž symbol patří.
Při aplikování na numerický symbol vrací skalární nulu.
Pokud symbol leží v defaultní sekci (se jménem stejným jako její segment),
jak SECTION# tak i SEGMENT# vracejí totožnou adresu.</p>

<h5 id="SCOPEha"><a href="#Attributes">&uarr; SCOPE#</a></h5>
<p>Atribut <em>SCOPE#</em> vrací číslo odpovídající ASCII hodnotě
velkého písmene odpovídajícího viditelnosti symbolu. To může být
<code>'E'</code> pro externí symboly, <code>'P'</code> pro public (veřejné) symboly,
<code>'X'</code> pro exportované symboly, <code>'I'</code> pro importované symboly,
<code>'S'</code> pro standardní privátní symboly, nebo <code>'?'</code>
pokud symbol není deklarován.</p>

<h5 id="SIZEha"><a href="#Attributes">&uarr; SIZE#</a></h5>
<p><em>SIZE#</em> představuje počet bajtů emitovaných instrukcí definující symbol.
Typicky je to velikost dat definovaných pseudoinstrukcí <a href="#D">D</a>
nebo délka strojové instrukce v bajtech.
Symboly definované pseudoinstrukcí <a href="#EQU">EQU</a> nebo definované v neemitující instrukci
mají atribut SIZE# rovný nule.</p>

<h5 id="TYPEha"><a href="#Attributes">&uarr; TYPE#</a></h5>
<p>Atribut <em>TYPE#</em> vrací číslo odpovídající ASCII hodnotě velkého písmena
korespondujícího s typem objektu. Může to být jeden z
<a href="#DataTypes">fundamentálních datových typů</a> <code>'B', 'U', 'W', 'D',
'Q', 'T', 'O', 'Y', 'Z'</code>, strukturovaný datový typ <code>'S'</code> nebo
strojová instrukce <code>'I'</code>, pokud byl symbol definován datovou pseudoinstrukcí <a href="#D">D</a>.
<br/>Numerické symboly vracejí hodnotu <code>'N'</code>.
<br/>Návěstí strojové instrukce nebo strojového prefixu vracejí atribut <code>'I'</code>.
<br/>Adresní symbol definovaný samotným návěstím, dále návěstí PROC a PROC1,
jakož i externí symbol vrací atribut typu <code>'A'</code> (jako Adresa).
<br/>Nedeklarovaný symbol vrací <code>'?'</code>.</p>
<blockquote>Dopředná reference symbolu o něm vytváří záznam v tabulce symbolů.
Nicméně při prvním průchodu je jeho typový atribut <code>'?'</code> (nedeklarovaný)
až dokud nebude nalezena jeho definice.
Na druhé straně aplikace atributu na nedefinovaný symbol jej nečiní <em>odkazovaným</em>,
tedy nezapisuje ho do tabulky symbolů.
Proto můžeme testovat přítomnost symbolu v programu pomocí <code>%IF TYPE#Symbol = '?'</code>.</blockquote>
<p>Vedle symbolů může být atribut TYPE# aplikován i na některé jiné objekty:
registr, strukturu, řetězec, výraz v závorkách <kbd>()</kbd> nebo <kbd>[]</kbd>.</p>
<p>TYPE# registru je <code>'R'</code> a jeho SIZE# se rovná šířce registru v bajtech
(1,2,4,8,10,16,32,64).</p>
<p>TYPE# struktury je <code>'S'</code> a SIZE# odpovídá její velikosti v bajtech.</p>

<samp>|[.data]                   |[.data]
|00000000:456E642E0D0A00   |Message D 'End.',13,10,0  ; Definováno jako DB or DU.
|[.text]                   |[.text]
|TRUE                      | %IF TYPE# Message = 'B'  ; Pokud je UNICODE vypnut,
|00000000:B907000000       |   MOV ECX,SIZE# Message  ;  naplň ECX jeho velikostí v bajtech (7).
|FALSE                     | %ELSE                    ; Jinak je UNICODE zapnut,
|                          |   MOV ECX,SIZE#Message/2 ; a SIZE# vrací 14 bajtů.
|                          | %ENDIF                   ; ECX je nyní 7 (délka Message ve znacích).</samp>
<blockquote><p>Proč používat SIZE# nebo TYPE# na symbol definovaný námi (programátorem), u kterého tedy předem známe jeho velikost a typ?
Pokud se později rozhodneme změnit text proměnné Message, nemusíme se obtěžovat přepočítáváním jeho délky.</p>
<p>Operátory atributů jsou často použity v makrech k určení, jakým druhem operandů bylo makro vyvoláno:
je-li to registr, datový symbol, přímá hodnota apod.
Potřebujeme-li v makru zjistit, zda poskytnutá hodnota <code>%1</code> je prosté číslo,
můžeme to otestovat dotazem <code>%IF TYPE# %1 = 'N'</code>.</p></blockquote>
<p>Viz testy <a class="EXT" href="../eatests/#Symbols">t16*</a> pro více příkladů na atributy.</p>
<p>Podrobnější diferenciace typu datového symbolu, kterou atribut TYPE# poskytuje, někdy není potřebná.
Můžeme například chtít vedět, zda operand makra <code>%1</code>
potřebuje relokaci. K tomu dochází, pokud je operandem adresní symbol nebo paměťová proměnná
obsahující adresní symbol.
Dotazy na <code>TYPE# DataSymbol</code> nebo <code>TYPE# [DataSymbol+RSI]</code>
mohou vracet 'A', 'B','W','D','Q','T' či jakýkoli typ dat, s nímž byl DataSymbol definován.
Jinak vrátí 'N', pokud bylo operandem číslo nevyžadující relokaci, jako třeba
<code>TYPE# MAX_PATH_SIZE</code> nebo <code>TYPE# [RBP-16]</code>.
Zde se bude hodit sjednocení všech druhů adresních a externích symbolů atributovým operátorem SEGMENT#,
který vrátí relokabilní adresu počátku segmentu, nezávisle na datatypu symbolu.
Atribut TYPE# aplikovaný na takový atribut SEGMENT# pak vždy vrátí hodnotu 'A'.
Na druhé straně <code>SEGMENT# ScalarSymbol</code> a <code>TYPE#(SEGMENT#ScalarSymbol)</code>
vrací 'N'.</p>
<pre>
%IF TYPE# (SEGMENT# %1) = 'A'
  ; %1 je adresový výraz vyžadující relokaci.
%ELSE
  ; %1 je nerelokabilní výraz.
%ENDIF</pre>
<blockquote>Všimněte si, že zřetězené atributy vyžadují závorky. To je kvůli tomu, že
operátory atributů mají shodnou prioritu, takže jsou vyhodnocovány zleva doprava,
a bez závorek by se první operátor snažil aplikovat na jiný unární operátor.
<br/>Viz test <a class="EXT" href="../eatests/t1695.htm">t1695</a> pro více příkladů.</blockquote>


<h5 id="REGTYPEha"><a href="#Attributes">&uarr; REGTYPE#</a></h5>
<p>Při aplikaci atributu TYPE# na registr se vrací hodnota <code>'R'</code>, bez ohledu na rodinu registrů.
Někdy ale může být užitečné znát přesný druh registru.
Atribut <em>REGTYPE#</em> vrací číslo reprezentující ASCII hodnotu velkého písmene
odpovídajího rodině registrů. Všeobecné registry (GPR) vracejí <code>'B', 'W', 'D'</code> nebo <code>'Q'</code>,
registry SIMD vracejí <code>'X', 'Y', 'Z'</code>, segmentové registry vracejí <code>'S'</code>
atd. Pro kompletní seznam viz tabulku <a href="#Registers">Registers</a>.
Je-li tento atribut aplikován na objekt, který není registr, vrací <code>'?'</code>.
Viz také test <a class="EXT" href="../eatests/t1662.htm">t1662</a>.</p>

<h5 id="FILESIZEha"><a href="#Attributes">&uarr; FILESIZE#</a></h5>
<h5 id="FILETIMEha"><a href="#Attributes">&uarr; FILETIME#</a></h5>
<p>Na rozdíl od předchozích atributů, FILESIZE# a FILETIME# mohou být aplikovány pouze na soubory
specifikované jejich jménem, které musí být obklopeno dvojitými uvozovkami <kbd>&quot;</kbd>.
Název souboru může být absolutní, relativní nebo bez cesty, vztahuje se k aktuálnímu adresáři v asm-time.</p>
<p>Oba atributy zjišťují vlastnosti souboru v čase překladu.</p>
<p><code>FILESIZE# "filename"</code> vrací počet bajtů v souboru,
nebo 0 pokud soubor neexistuje.
<br/><code>FILETIME# "filename"</code> vrací timestamp souboru,
tj. počet sekund od půlnoci UTC 1. ledna 1970 k jeho poslední modifikaci.
Vrací 0 pokud soubor nebyl nalezen.
Viz také test <a class="EXT" href="../eatests/t1690.htm">t1690</a>.
</p>

<h3 id="Literals" title="Literal"><a href="#Elements">&uarr; Literály</a></h3>
<p>Literální symboly neboli <dfn>literály</dfn> se  podobají standardním symbolům asembleru.
Rozdíl je v tom, že jim nemusíme explicitně vymýšlet unikátní jméno.
Literál je definován kdykoli je použit a jeho jméno je představováno rovnítkem <kbd>=</kbd>,
za kterým následuje <a href="#DataExpressions">datový výraz</a>,
např. <code>=D(5)</code> nebo <code>=B&quot;Some text.&quot;</code>.
Data mohou být duplikována, ale na rozdíl od pseudoinstrukce <a href="#D">D</a>
(která může mít více operandů) zde může být pouze jeden datový výraz.
Příklady instrukcí s literály:</p>
<pre>
DIV [=W(10)]   ; Vyděl číslo v DX:AX anonymní paměťovou proměnnou typu WORD s hodnotou 10.
MOV DX,=B"This is a literal message.$" ; Naplň DX ofsetem řetězce definovaného někde v rodata segmentu.
LEA ESI,[=D 0] ; Naplň ESI adresou paměťové proměnné typu DWORD obsahující hodnotu 0.
CALL =I"RET"   ; Proveď PUSH EIP a pak naplň EIP ofsetem strojové instruce RET definované někde v kódovém segmentu.
<del>LEA EBX,[=D 0,1,2,3]</del> ; Chyba: vícenásobná definice dat.
<del>MOV DX,=B"This is a literal message.",13,10</del> ; Chyba: vícenásobná definice dat.
</pre>
<blockquote>První příklad deklaruje proměnnou <code>=W(10)</code>.
Bez literálů bychom museli nadefinovat datovou proměnnou
<code>Ten DW 10</code> někde v datovém segmentu a přidělit jí explicitní unikátní jméno.</blockquote>
<p>Výhodou literálů je, že jim nemusíme vymýšlet jména a explicitně je deklarovat pseudoinstrukcí <a href="#D">D</a>.
Datový obsah je viditelný přímo v instrukci, která literál používá.</p>
<h6>Literály jsou automaticky zarovnány.</h6>
<p>Všechny literály jsou zarovnány podle svých <a href="#DataTypes">typů</a>,
např. <code>=D 5</code> je zarovnána DWORD bez ohledu na aktuální stav volby
<a href="#AUTOALIGNeq">EUROASM AUTOALIGN=</a>.</p>
<h6>Řetězcové literály jsou automaticky zakončeny znakem NUL.</h6>
<p>Řetězcové literály, jako <code>=B&quot;Some text&quot;</code> nebo <code>=U&quot;Some text&quot;</code>
jsou vždy implicitně zakončeny BYTE nebo UNICHAR nulou.
<br/>&euro;ASM dovoluje zjednodušenou deklaraci neduplikovaných literálních řetězců,
kdy typový identifikátor <code>B</code> nebo <code>U</code> je vynechán, např. <code>=&quot;Some text&quot;</code>.
Konkrétní typ řetězce (B nebo U) je pak určen %proměnnou <a href="#pcVariables">%^UNICODE</a>
nastavovanou pomocí <code>EUROASM UNICODE=ON|OFF</code>.</p>
<blockquote><p>Definice dat pomocí literálů nedovoluje programátorovi určit přesnou lokaci,
kam bude literál emitován. &euro;ASM vytváří služební sekci pro každý typ data v závislosti na jejich přirozeném zarovnání.
Sekce pro literály je vytvořena buď<ol>
<li>v posledním segmentu, který má PURPOSE=LITERAL a PURPOSE=RODATA|DATA,</li>
<li>nebo pokud žádný segment s účelem LITERAL neexistuje, pak v posledním segmentu s účelem RODATA,</li>
<li>nebo pokud segment s PURPOSE=RODATA neexistuje, pak v posledním segmentu s PURPOSE=DATA,</li>
<li>nebo pokud žádný segment DATA|RODATA neexistuje, vytvoří se implicitní segment s názvem <code>@LT</code> a účelem RODATA+LITERAL.</li></ol>

<p>Jména literálních sekcí jsou <code>[@LT64], [@LT32], [@LT16], [@LT8], [@LT4], [@LT2], [@LT1]</code>.
<br/>Literály s datatypem <code>INSTRUC</code>, jako třeba <code>=8*I"MOVSD"</code>,
jsou emitovány do služební sekce <code>[@RT0]</code>, která je obdobně vytvořena v segmentu
s účelem <code>PURPOSE=CODE+LITERAL</code>, nebo v posledním kódovém segmentu, pokud dosud neexistoval.</p>
<p>Opakovaně použité literály se shodnou deklarací jsou znovupoužity,
představují tutéž paměťovou proměnnou. Literály s nikoli doslovnou shodou, jako např.
<code>=W+4</code>, <code>=W 4</code> a <code>=W(2+2)</code> se ukládají zvlášť jako odlišné symboly,
ale jejich hodnota je znovupoužita, takže zabírá méně místa v sekci literálů.
Podobně literály <code>=B&quot;Some text&quot;</code>,
<code>=B'Some text'</code> a <code>=B 'Some text'</code> jsou tři odlišné symboly,
ale za běhu programu všechny tři dohromady okupují pouhých 9+1 bajtů paměti v literální sekci [@LT1].</p>
</blockquote>
<h6>Literály by se měly vždy považovat za paměťové proměnné pouze ke čtení.</h6>
<p>I když nelze bránit programátorovi v přepisování dat definovaných jako literál,
měly by být vždy považovány za read-only, jinak by to mohlo poškodit jinou část programu využívající těchže literálních dat.</p>

<table><caption>Srovnání standardních symbolů a literálů</caption>
<tr><th>Vlastnost</th><th>Standardní symbol</th><th>Literální symbol</th></tr>
<tr><th>Deklarace</th><td>Definovaný explicitně pseudoinstrukcí <a href="#D">D</a> či jejími klony, např. <code>Dozen: DD 12</code></td>
<td>Deklarovaný při jeho prvním využití v instrukci, např. <code>MOV ECX,=D 12</code></td></tr>
<tr><th>Jméno</th><td>Programátor musí symbolu určit unikátní název.</td>
<td>Název literálu je vytvořen automaticky z jeho hodnoty.</td></tr>
<tr><th>Umístění v cílovém kódu</th><td>Umístění dat symbolu je zcela v režii programátora.</td>
<td>Programátor nemůže přímo ovlivňovat jeho umístění.</td></tr>
<tr><th>Alignment</th><td>Je-li zarovnání požadováno, musí být vyždáno explicitně pseudoinstrukcí <a href="#ALIGN">ALIGN</a> nebo modifikátorem
<a href="#ALIGNeq">ALIGN=</a> nebo volbou <a href="#AUTOALIGNeq">EUROASM AUTOALIGN=ENABLED</a>.</td>
<td>Literály jsou vždy přirozeně zarovnány, jako by byla platná volba <code>EUROASM AUTOALIGN=ENABLED</code>.</td></tr>
<tr><th>Náplň zarovnání</th><td>Kvůli minimalizaci náplně pro zarovnávání by měl být programátor opatrný
při míchání proměnných s rozličnými velikostmi.</td>
<td>Literály všech velikostí jsou spojeny dohromady v klesajícím pořadí jejich velikostí,
což automaticky minimalizuje náplň mezi nimi.</td></tr>
<tr><th>Vícenásobné operandy</th><td>
Pseudoinstrukce <a href="#D">D</a> a její klony podporují vícenásobné operandy, např. <code>Hello DB "Hello, world",13,10,'$'</code>.</td>
<td>Vícenásobné operandy nejsou přípustné.</td></tr>
<tr><th>Zakončování nulou</th><td>Pouze na explicitní žádost, např. <code>Hello: DU "Hello, world",0</code>.</td>
<td>Automaticky, např. <code>MOV ESI,=U "Hello, world"</code>.</td></tr>
<tr><th>Duplikace</th><td>Podporována, např. <code>FourDoublePrecOnes: DY 4 * Q 1.0</code></td>
<td>Podporována, např. <code>VMOVUPD YMM7, [= 4 * Q 1.0]</code>.</td></tr>
<tr><th>Přepisování hodnoty</th><td>Přípustné podle potřeby.</td><td>Programátor by se ho měl vyvarovat.</td></tr>
</table>

<h3 id="Structures" title="Structure in assembly"><a href="#Elements">&uarr; Struktury</a></h3>
<p><dfn>Struktura</dfn> je deklarována zdrojovým kódem reprezentovaným blokem
<a href="#STRUC">STRUC..ENDSTRUC</a>. V bloku budou deklarovány názvy, datové typy, velikosti a ofsety členů struktury.
V terminologii objektového programování je struktura třídou (<em>class</em>)
a strukturovaná paměťová proměnná <em>objektem</em>. Příklad:</p>
<pre>
DATUM STRUC           ; Deklarace struktury DATUM.
 .Year  D W
 .Month D B
 .Day   D B
      ENDSTRUC DATUM

Today DS DATUM        ; Definice strukturované paměťové proměnné Today.
</pre>
<h6>Členové struktury by měli mít lokální jména (začínající tečkou <kbd>.</kbd>).
Deklarace struktury definuje blok <a href="#Namespace">jmenného prostoru</a>.</h6>
<p>Ve výše uvedeném příkladu struktura DATUM tvoří symboly <code>DATUM.Year, DATUM.Month, DATUM.Day</code>
s hodnotami <code>0, 2, 3</code>. Tyto symboly jsou absolutní (skaláry)
a dávají jména relativním ofsetům členů struktury.</p>
<p>Definice Today vytváří strukturovanou paměťovou proměnnou.
Současně jsou vytvořeny symboly <code>Today.Year, Today.Month, Today.Day</code>.
Jejich adresy jsou definovány někde v sekci [DATA] nebo [BSS],
nejsou to skaláry, nýbrž relokabilní adresy.</p>
<p>Hodnoty členů jsou nedefinovány (pokud byla strukturovaná proměnná definovaná v segmentu [BSS]),
anebo obsahuje samé nuly (pokud byla definovaná v segmentu [DATA]).
Členové strukturované proměnné mohly být definovány staticky v asm-time
klíčovými operandy, například <code>Today DS Datum, .Day=31</code>,
viz též pseudoinstrukci <a href="#DS">DS</a>. Při definování paměťové proměnné je v poli operandů dočasně platný jmenný prostor instrukce, viz
<a href="#InstanceNamespace">zde</a>.</p>
<p>Člen strukturované proměnné může být změněn přímo, pomocí </p>
<pre>MOV [Today.Month],12</pre>
<p>Rovněž bychom mohli použít registr ukazující na celou strukturovanou proměnnou
a využít tento registr k adresaci individuálních členů s relativními ofsety specifikovanými v deklaraci struktury:</p>
<pre> MOV EDI,Today
 MOV [EDI+DATUM.Month],12</pre>
<p>Více o strukturách viz <a href="#STRUC">zde</a>.</p>

<hr/>
<h3 id="pcVariables" title="%Variables"><a href="#Elements">&uarr; %Proměnné</a></h3>
<h4><a href="#UserVariables">Uživatelem definované %proměnné &darr;</a></h4>
<h4><a href="#FormalVariables">Formální %proměnné &darr;</a></h4>
<h4><a href="#AutomaticVariables">Automatické %proměnné &darr;</a></h4>
<h4><a href="#SystemVariables">Systémové %proměnné &darr;</a></h4>
<p>Program v &euro;ASM může používat <dfn>preprocesní proměnné</dfn> neboli <dfn>%proměnné</dfn>
k manipulaci se zdrojovým textem v asm-time.
Spolu s <a href='#MacroInstructions'>makroinstrukcemi</a> tvoří mocný aparát šetřící opakující se programátorskou práci.
Preprocesní aparát neovlivňuje cílový kód přímo, tak jak to dělá prostý asembler.
Namísto toho manipuluje se zdrojovým textem, který může být modifikován %proměnnými
a opakován preprocesními %pseudoinstrukcemi.</p>
<p>Preprocesní proměnné považují svůj obsah za sekvenci znaků, bez zkoumání jejich syntaktického významu.</p>
<p>Jakmile byl nastaven, může být obsah %proměnné použit (expandován) kdykoli se %proměnná vyskytne
ve zdrojovém textu (s výjimkou komentářů).
K expanzi dochází dříve, než je zdrojový řádek rozebrán na pole instrukce.
Ve výchozím stavu je expandován celý obsah %proměnné, avšak může být omezen operátory
<a href="#Substring">substring</a> a <a href="#Sublist">sublist</a>.</p>
<p>Viz také &euro;ASM funkci <a href="#EaFnPreprocessing">Předzpracování</a>.</p>

<table id="VariablesTable" title="Variables table">
<caption>Rodiny preprocesních %proměnných</caption>
<tr><th rowspan="2">Rodina %proměnných&nbsp;&#9658;</th><th rowspan="2">Uživatelem definované</th>
<th rowspan="2">Formální</th><th rowspan="2">Automatické</th>
<th colspan="3"> &nbsp; Systémové</th></tr>
<tr><th>EUROASM</th><th>PROGRAM</th><th>&euro;ASM</th></tr>
<tr><th>forma názvu</th><td>%identifikátor</td><td>%identifikátor</td><td>%speciální_znak</td>
<td>%^volba</td><td>%^volba</td><td>%^pevný</td></tr>
<tr><th>citlivost na velikost písmen v názvu</th><td>Ano</td><td>Ano</td><td>Ano</td><td>Ne</td><td>Ne</td><td>Ne</td></tr>
<tr><th>Znovupřiřaditelnost</th><td>explicitně<br/>pomocí %SET*</td>
<td>nepřímo v expanzi smyčky %FOR nebo makra</td>
<td>nepřímo expanzí makra</td>
<td>nepřímo pomocí<br/>parametru EUROASM</td>
<td>nepřímo pomocí<br/>parametru PROGRAM</td>
<td>Ne</td></table>
<hr/>

<h4 id="UserVariables" title="User %variables"><a href="#pcVariables">&uarr; Uživatelem definované %proměnné</a></h4>
<p>Jméno uživatelem definované %proměnné je tvořeno znakem procenta <kbd>%</kbd> následovaného
identifikátorem, který není <a href="#ReservedVariables"><dfn>rezervovaným názvem %proměnné</dfn></a>, bez ohledu na velikost písmen.
Identifikátor musí začínat písmenem a nemůže obsahovat tečku ani jiné speciální znaky.</p>
<h6>V uživatelem definovaném jménu %proměnné záleží na velikosti písmen.</h6>

<table id="ReservedVariables" title="Reserved %variables"><caption>Rezervovaná jména %proměnných</caption>
<tr><th>Kategorie</th><th>Rezervované jméno</th></tr>
<tr><td>Pseudoinstrukce</td><td>
%COMMENT,
%DEBUG,
%DISPLAY,
%DROPMACRO,
%ELSE,
%ENDCOMMENT,
%ENDFOR,
%ENDIF,
%ENDMACRO,
%ENDREPEAT,
%ENDWHILE,
%ERROR,
%EXITFOR,
%EXITMACRO,
%EXITREPEAT,
%EXITWHILE,
%FOR,
%IF,
%MACRO,
%PROFILE,
%REPEAT,
%SET,
%SET2
%SETA,
%SETB,
%SETC,
%SETE,
%SETL,
%SETS,
%SETX,
%SHIFT,
%UNTIL,
%WHILE
</td></tr>
</table>
<p>Uživatelsky definované %proměnné jsou přiřazeny nebo vytvářeny programátorem
pomocí jedné z rodiny pseudoinstrukcí <a href="#pcSET">%SET*</a>.</p>
<p>%Proměnné mohou být později přiřazovány odlišnou hodnotou, nemusejí být unikátní v rámci programu.</p>
<h6>Viditelnost uživatelem definovaných %proměnných začíná jejich prvním přiřazením a končí na konci zdrojového souboru.</h6>
<p>%Proměnné nemusejí být přiřazeny před prvním použitím (expanzí).
Nepřiřazené %proměnné expandují do ničeho (prázdný text).
Jednou přiřazenou %proměnnou nelze odřadit, v &euro;ASM neexistuje direktiva
<em id="pcUNSET" title="%UNSET">%UNSET</em>, <em>UNDEFINE</em> nebo <em>UNASSIGN</em>.
Nicméně přiřazení prázdné hodnoty (např. <code>%SomeVar %SET</code>) je ekvivalentní jejímu odřazení.
&euro;ASM nehlásí žádnou chybu, setká-li se s uživatelsky definovanou %proměnnou, která je prázdná,
která nebyla přiřazena dříve nebo která dosud nebyla ve zdrojovém textu vůbec zmíněna.</p>
<p>Viz také test <a class="EXT" href="../eatests/t7321.htm">t7321</a>.</p>

<table>
<caption>Rozdíly mezi symboly a %proměnnými</caption>
<tr><th>Symboly</th><th>Uživatelem definované %proměnné</th></tr>
<tr><td>jsou vlastností PROGRAMu</td>
<td>jsou vlastností EuroAssembleru</td></tr>
<tr><td>jejich název nikdy nezačíná %</td>
<td>jejich název vždy začíná %</td></tr>
<tr><td>mohou mít v názvu tečku</td>
<td>nikdy nemají tečku v názvu</td></tr>
<tr><td>jsou deklarovány v poli návěstí</td>
<td>jsou přiřazovány pomocí pseudoinstrukcí %SET*</td></tr>
<tr><td>mají atributy, jako TYPE# a SIZE#</td>
<td>jsou prosté kusy textu bez atributů</td></tr>
<tr><td>mohou být zmiňovány dopředu</td>
<td>nemohou být zmiňovány dopředu</td></tr>
<tr><td>musí být definovány právě jednou v programu</td>
<td>mohou být mnohokrát redefinovány</td></tr>
<tr><td>nemohou být odkazovány, nebyly-li deklarovány</td>
<td>mohou být zmiňovány bez deklarace</td></tr>
<tr><td>nemohou být předmětem operací sublist nebo substring</td>
<td>mohou být sublistovány a substringovány</td></tr>
</table>

<hr/>
<h4 id="FormalVariables" title="Formal %variables"><a href="#pcVariables">&uarr; Formální %proměnné</a></h4>
<p>Formální %proměnná expanduje na hodnotu řídicího parametru smyčky <a href="#pcFOR">%FOR</a>
anebo na hodnotu operandu v invokaci %MACRO.
Je reprezentována identifikátorem stojícím v poli návěstí příkazu %FOR,
nebo stojícím jako operand v prototypu %MACRO.</p>
<p>Viditelnost formální %proměnné je omezena na expandovaný blok.</p>
<pre>Count %FOR 1..8
        DB %Count
      %ENDFOR Count</pre>
<p>Předchozí příklad generuje osm instrukcí DB, které definují bajtové hodnoty 1 až 8.
Identifikátor <code>Count</code> použitý v příkazech %FOR a %ENDFOR je <dfn>řídicí %proměnná</dfn>,
a je dostupná uvnitř %FOR..%ENDFOR bloku jako formální %proměnná <code>%Count</code>.</p>
<p>Formální %proměnné se rovněž používají k přístupu k pojmenovaným operandům makra
během jejich expanze.
V dalším příkladu máme dvě <dfn>formální %proměnné</dfn> makroinstrukce
definované v definici %MACRO jako identifikátory <code>Where</code>
a <code>Stuff</code>. V těle makra jsou jejich hodnoty dostupné
jako formální %proměnné <code>%Where</code> a <code>%Stuff</code>.</p>
<pre>Fill %MACRO Where, Stuff=0   ; Definice makra Fill.
       MOV %Where,%Stuff
     %ENDMACRO Fill

; Volání (expanze) makra Fill:
   Fill [Counter], Stuff=255 ; Bude přeloženo jako <code>MOV [Counter],255</code>
   Fill EBX                  ; Bude přeloženo jako <code>MOV EBX,0</code>
</pre>
<p>Všimněte si, že formální %proměnné se píší bez znaménka procent když jsou deklarovány,
avšak <kbd>%</kbd> musí být předřazeno jejich jménu když jsou referovány v těle příkazů %FOR nebo %MACRO.
Toto je důležité pro dědění argumentů ve vnořených a rekurzivně volaných makroinstrukcích,
viz např. <a class="EXT" href="../eatests/t7233.htm">t7233</a>.</p>

<p>Viditelnost formálních proměnných má uvnitř bloku vyšší prioritu než uživatelem definované %proměnné
téhož jména, bez ohledu, zda byly přiřazeny vně nebo uvnitř bloku %FOR..%ENDFOR či %MACRO..%ENDMACRO.
Přiřazení nové hodnoty %proměnné s formálním jménem uvnitř makrobloku sice přiřadí
tuto novou hodnotu uživatelem definované proměnné, avšak uvnitř makrobloku
formální %proměnná převáží, viz test <a class="EXT" href="../eatests/t7347.htm">t7347</a> nebo
<a class="EXT" href="../eatests/t7362.htm">t7362</a>.
Po odchodu z makra bude přiřazená %proměnná opět viditelná.</p>

<hr/>

<h4 id="AutomaticVariables" title="Automatic %variables"><a href="#pcVariables">&uarr; Automatické %proměnné</a></h4>
<p>Automatické preprocesní %proměnné jsou tvořeny a udržovány EuroAssemblerem v čase překladu,
jejich názvy obsahují speciální znaky a na rozdíl od uživatelsky definovaných %proměnných
jejich hodnota nemůže být měněna pomocí pseudoinstrukcí <a href="#pcSET">%SET</a>.</p>
<p>Mají rovněž omezené Scope, jejich použití mimo svou viditelnost vede k chybě.</p>

<dl>
<dt id="pcam" title="%&amp; (subop size|length)">%&amp;</dt><dd><p>
<dfn>Suboperace velikost a suboperace délka</dfn> (procento následované ampersandem) <dfn><strong>%&amp;</strong></dfn> reprezentuje
počet znaků nebo počet položek v seznamu nebo počet fyzických řádků v suboperovaném objektu.
<br/>Jeho viditelnost &ndash; <strong>scope je omezena na suboperační závorky</strong> <kbd>[ ]</kbd>
nebo <kbd>{ }</kbd>.</p>
<p><dfn>Automatická suboperační proměnná <strong>%&amp;</strong></dfn>
se tvoří, když expanze vkládaného souboru nebo jiné %proměnné používá suboperace.</p>
<p>Jakmile je k %proměnné nebo ke jménu souboru připojen <strong>substring</strong> operátor <kbd>[ ]</kbd>,
automatická %proměnná <code>%&amp;</code> může být použita uvnitř hranatých závorek, např. <code>[1..%&amp;]</code>,
a představuje počet bajtů v expandované proměnné nebo ve vkládaném souboru.
<br>Pokud jsme například přidělili %proměnné pět písmen pseudoinstrukcí <code>%Proměnná %SET ABCDE</code>,
pak její velkost je 5 a povel <code> DB "%Proměnná[4..%&amp;]"</code> bude expandovat na <code> DB "DE"</code>.</p>
<p>Je-li k názvu proměnné připojen operátor <strong>sublist</strong> (pomocí složených závorek <kbd>{ }</kbd>),
 obsah této %proměnné se považuje za pole čárkou oddělených položek
a <code>%&amp;</code> reprezentuje jejich počet, tj. pořadové číslo poslední neprázdné položky.
<br/>Například pokud bylo nastaveno <code>%Reglist %SET ax,cx,dx,bx,bp</code>,
jeho délka je 5 operandů (položek) a instrukce <code> MOV %Reglist{3},%aReglist{%&amp;}</code>
se přeloží jako <code> MOV dx,bp</code>.</p>
<p>Pokud je tentýž operátor <kbd>{ }</kbd> připojen k názvu vkládaného (INCLUDE) souboru,
obsah souboru je považován za seznam fyzických řádků
a <code>%&amp;</code> reprezentuje počet řádků v souboru.
Například <code>INCLUDE &quot;file.inc&quot;{%&amp;-10 .. %&amp;}</code> vloží do zdrojového textu posledních deset řádků z &quot;file.inc&quot;.</p>
<p>Použití %proměnné <code>%&amp;</code> mimo závorky by vedlo k chybě.</p>
<h6>Indexy suboperací sahají od <code>1</code> do <code>%&amp;</code>.</h6></dd>
</dl>

<dl id="ExpansionCounter" title="Expansion counter">
<dt id="pcpt" title="%. (expansion counter)">%.</dt><dd>
<p><dfn>Počitadlo expanzí</dfn> (procento následované tečkou) <dfn><strong>%.</strong></dfn>
udržuje dekadické číslo inkrementované EuroAssemblerem při každé expanzi
preprocesního bloku a může být využito ke tvorbě unikátních návěstí v opakovaných blocích.
<br/>Jeho viditelnost &ndash; <strong>scope je omezena na tělo preprocesního bloku
%MACRO, %FOR, %WHILE, %REPEAT</strong>. Pokud je použito mimo tyto bloky, expanduje na 0, viz test
<a class="EXT" href="../eatests/t7362.htm">t7362</a>.</p>
<p>Je-li v makru nebo bloku %FOR, %WHILE, %REPEAT použito standardní nebo lokální návěstí,
a pokud je makro či blok expandováno více než jednou, symbol z návěstí by byl definován více než jednou,
což asembler považuje za chybu. Unikátnosti takového symbolu lze dosáhnout
začleněním <em>počitadla expanzí</em> do jeho názvu.</p>
<p>Viz příklad makra <a href="#AbortIf">AbortIf</a> níže.
Návěstí <code>Skip</code> je následováno <kbd>%.</kbd>, což dává symbol
<code>Skip%.</code> expandující na <code>Skip1</code>
a v budoucnu expandující na <code>Skip2</code> při dalším vyvolání makra AbortIf.</p>
<samp id="AbortIf">|00000008:                 |
|                          |AbortIf %MACRO Condition=, Errorlevel=1 ; Definice makra AbortIf.
|                          |        J%!Condition Skip%.: ; Použij invertovaný kód k přeskočení aborce.
|                          |        PUSH %Errorlevel     ; Připrav operand pro invokaci API.
|                          |        CALL ExitProcess::   ; Windows API pro ukončení programu.
|                          |Skip%.:                      ; Návěstí, kde program pokračuje.
|                          |        %ENDMACRO AbortIf
|00000008:                 |
|00000008:                 |      ; Příklad podmíněného zrušení:
|                          |      EUROASM ListMacro=Yes, ListVar=Yes ; Zobrazuj expandované instrukce.
|00000008:833D[04000000]00 |      CMP [Something],0                  ; Otestuj podmínku a pak vyvolej makro.
|0000000F:                 |      AbortIf Condition=E, Errorlevel=8  ; Program skončí, pokud Something je nulové.
|                          +AbortIf %MACRO Condition=, Errorlevel=1 ; Definice makra AbortIf.
|0000000F:7507             +        J%!Condition Skip%.: ; Použij invertovaný kód k přeskočení aborce.
|                          !JNE Skip1:
|00000011:6A08             +        PUSH %Errorlevel     ; Připrav operand pro invokaci API.
|                          !PUSH 8
|00000013:E8(00000000)     +        CALL ExitProcess::   ; Windows API pro ukončení programu.
|00000018:                 +Skip%.:                      ; Návěstí, kde program pokračuje.
|                          !Skip1:
|                          +        %ENDMACRO AbortIf
|00000018:                 |      ; Pokračování programu, nebyl-li ukončen.</samp>
<h6>Automatická %proměnná <code>%.</code> pomáhá vytvářet unikátní jména symbolů.</h6></dd>
</dl>

<dl>
<dd><p>Všechny následující <dfn>automatické %makroproměnné</dfn> mají viditelnost &ndash;
<strong>scope omezenu na tělo bloku %MACRO..%ENDMACRO</strong>.
Odkazují na operandy použité, když bylo makro vyvoláno (expandováno).</p></dd>

<dt id="pcco" title="%: (macro label)">%:</dt><dd>
<p>Je-li při vyvolání makra použito návěstí (label), je ve výchozím stavu umístěno k první expandované instrukci.
Toto chování lze přepsat použitím automatické %makroproměnné
<dfn><strong>%:</strong></dfn> (procento následované dvojtečkou) deklarované někde uvnitř definice makra.
Pouze jedno takové návěstí může být deklarováno v makru.
Přemístění návěstí makra k tomuto návěstí může ušetřit několik taktů
při skoku přes instrukce kódu, který by musel být přeskočen, viz tento příklad:</p>
<pre>
SaveCursor %MACRO Videopage=BH
   %IF TYPE#CursorSave != 'W' ; Pokud paměťová proměnná CursorSave dosud nebyla definována.
     JMP %:                   ; Přeskoč na +4 (pod DW 0) pokud bylo makro vloženo do toku instrukcí.
     CursorSave DW 0          ; Prostor k uložení kurzoru.
   %ENDIF
%: MOV AH,3                   ; Vstupní bod makra, kam by se jinak skákalo.
   MOV BH,%Videopage
   INT 10h                    ; Načti tvar kurzoru pomocí BIOS API.
   MOV [CursorSave],CX
 %ENDMACRO SaveCursor
  ...
Save: SaveCursor Videopage=0  ; Použij makro v programu.
  ...
  JMP Save:                   ; Skočí na instrukci <code>MOV AH,3</code>.
</pre>
<h6>Automatická %proměnná <code>%:</code> reprezentuje &quot;vstupní bod&quot; makra.</h6>
<p>Viz také test <a class="EXT" href="../eatests/t7215.htm">t7215</a>.</p>
</dd>

<dt id="pc1" title="%1 (ordinal operand)">%1</dt><dd><p><dfn>Pořadový operand</dfn> makra může být odkazován číslem.
Na rozdíl od dávkových souborů pro DOS a Windows jejich počet není omezen na 9,
ale může být libovolné pozitivní číslo, např. <strong>%11</strong>.
Samozřejmě, pokud jedenáctý operand není specifikován při volání makra, %11 expanduje do prázdna.
<br/>Viz také pseudoinstrukci <a href="#pcSHIFT">%SHIFT</a>.</p>
<p>Automatická %proměnná <strong>%0</strong> expanduje jméno samotného makra.</p></dd>

<dt>%Formal</dt><dd><p>Další metoda, jak odkazovat na operand makra (pořadový i klíčový)
je předřazení znaku procenta <dfn>formálnímu názvu</dfn> operandu.</p>
</dd>

<dt id="InvertedCondition" title="%!1 (inverted cond.code)">%!1 nebo %!Formal</dt><dd>
<p>Pokud je pořadovému číslu operandu nebo názvu formálního operandu předřazen znak pro
<em>logický operátor NOT</em> (vykřičník <kbd>!</kbd>), expanduje na <dfn>invertovaný podmínkový kód ordinálního operandu</dfn>.
To vyžaduje, aby referovaný operand skutečně obsahoval zkratku <a href="#ConditionCodesGeneral">podmínkového kódu</a>
(nezávisle na velikosti písmen) jako např. <code>E, NE, C</code> atd.
Obsah operandu bude nahrazen odpovídajícím <em>invertovaným kódem</em>.
&euro;ASM ohlásí chybu, pokud by operand neobsahoval platný podmínkový kód.</p>
<blockquote>NASM používá ke stejné funkcionalitě operátor unary-minus <kbd>-</kbd>.
Věřím, že operátor logical-not <kbd>!</kbd> je vhodnější k inverzi logické hodnoty.</blockquote>
<p>Viz makro<a href="#AbortIf">AbortIf</a> výše jako příklad.</p>
</dd>

<dt id="pcas" title="%* (ordinal list)">%*</dt><dd><p><dfn>Seznam pořadových operandů <strong>%*</strong></dfn>
(procento následované hvězdičkou) je naplněn všemi pořadovými operandy z volání makra. Operandy jsou odděleny čárkou.
Klíčové operandy jsou z listu vyřazeny.</p>
<blockquote><p>Operandy makra mohou být referovány více metodami.
Následující příklad demonstruje tři z nich:</p>
<pre>CopyStr %MACRO FirstOp, SecondOp, ThirdOp ; Prototyp makra.
          MOV ESI,%FirstOp ; Použij formální název operandu.
          MOV EDI,%2       ; Použij pořadové číslo operandu.
          MOV ECX,%*{3}    ; Použij třetí položku seznamu operandů.
          REP MOVSB
        %ENDMACRO CopyStr
          ...
        CopyStr Source, Dest, SIZE# Dest ; Vyvolání makra.
</pre></blockquote></dd>
<dt id="pcha" title="%# (number of ordinals)">%#</dt><dd><p>Délka seznamu pořadových operandů
(pořadové číslo posledního neprázdného operandu) je nastaveno do automatické %proměnné
<dfn>počtu ordinálů <strong>%#</strong></dfn> (procento následované znakem <kbd>#</kbd>)
a představuje počet pořadových operandů při volání makra
(ne počtu deklarovaného v prototypu makra).</p>
<blockquote>Stejná hodnota by také mohla být získána pomocí <code>%NrOfOrdinals %SETL %*</code>.</blockquote></dd>

<dt id="pceqas" title="%=* (keyword list)">%=*</dt><dd><p><dfn>Seznam klíčových operandů <strong>%=*</strong></dfn>
se podobá automatické %proměnné <strong>%*</strong>,
avšak obsahuje pouze čárkou oddělené operandy <code>klíč=hodnota</code> aktuálně použité v invokaci makra.</p>
<blockquote><p>Obě %proměnné %* a %=* mohou být použity k výrobě klonů maker s odlišnými názvy:</p>
<pre>copystr %MACRO
          CopyStr %*, %=*
        %ENDMACRO copystr</pre>
<p>Toto vytváří kopii předtím definovaného makra CopyStr avšak s odlišným názvem copystr.
Všechny operandy použité při invokaci makra copystr budou předány doslova původnímu makru CopyStr.</p></blockquote>
</dd>
<dt id="pceqha" title="%=# (number of keywords)">%=#</dt><dd><p><dfn>Délka seznamu klíčových operandů <strong>%=#</strong></dfn>
reprezentuje počet klíčových operandů aktuálně použitých v invokaci makra
(nikoli počtu deklarovanému v prototypu makra).
<br/>Viz též <a class="EXT" href="../eatests/t7364.htm">t7364</a>.
<blockquote>Stejná hodnota by také mohla být získána pomocí <code>%NrOfKeys %SETL %=*</code>.</blockquote>
</dd></dl>

<hr/>
<h4 id="SystemVariables" title="System %^variables"><a href="#pcVariables">&uarr; Systémové %proměnné</a></h4>
<h5><a href="#SystemVariablesEUROASM">EUROASM systémové %^proměnné &darr;</a></h5>
<h5><a href="#SystemVariablesPROGRAM">PROGRAM systémové %^proměnné &darr;</a></h5>
<h5><a href="#SystemVariablesEASM">&euro;ASM systémové %^proměnné &darr;</a></h5>
<p>EuroAssembler udržuje sbírku preprocesních %^proměnných s hodnotami konfiguračních parametrů.
Jejich hodnoty mohou být zjišťovány v asm-time.</p>
<p>Název systémové proměnné sestává z <code>%^</code> (procento a caret) následovaný jedním z výčtových identifikátorů.</p>
<h6>U systémových %^proměnných nezáleží na velikosti písmen.</h6>
<p>Hodnota systémové %^proměnné nemůže být přiřazena pseudoinstrukcemi %SET*;
je dynamicky udržována EuroAssemblerem a odpovídá současné platné hodnotě konfiguračního parametru.</p>
<code><del>%^DumpWidth %SETA 32</del> ; Použijte <strong>EUROASM DumpWidth=32</strong>.</code>
<h6>Systémové %^variables jsou pouze ke čtení.</h6>
<p>Programátor je může ovlivňovat pouze nepřímo, pomocí volby specifikované v
konfiguračním souboru <q><a href="../objlib/euroasm.ini">euroasm.ini</a></q>
nebo pomocí pseudoinstrukcí <a href="#EUROASM">EUROASM</a> a <a href="#PROGRAM">PROGRAM</a>.</p>

<table><caption>Systémové preprocesní %^proměnné</caption>
<tr><th>Kategorie</th><th>Názvy %^proměnných (case insensitive)</th></tr>
<tr><td>EUROASM</td><td>
%^AES,
%^AMD,
%^AutoAlign,
%^AutoSegment,
%^CET,
%^CodePage,
%^CPU,
%^CYRIX,
%^D3NOW,
%^Debug,
%^DisplayEnc,
%^DisplayStm,
%^Dump,
%^DumpAll,
%^DumpWidth,
%^EVEX,
%^FPU,
%^ImportPath,
%^IncludePath,
%^Interpreter,
%^Linkpath,
%^List,
%^ListFile,
%^ListInclude,
%^ListMacro,
%^ListRepeat,
%^ListVar,
%^LWP,
%^MaxInclusions,
%^MaxLinks,
%^MMX,
%^MPX,
%^MVEX,
%^NoWarn,
%^Profile,
%^Prot,
%^Prov,
%^RunPath,
%^RTF,
%^RTM,
%^SHA,
%^SIMD,
%^Spec,
%^SVM,
%^TBM,
%^TimeStamp,
%^TSX,
%^Undoc,
%^Unicode,
%^VIA,
%^VMX,
%^Warn,
%^XOP,
</td></tr>
<tr><td>PROGRAM</td><td>
%^DllCharacteristics,
%^Entry,
%^FileAlign,
%^Format,
%^IconFile,
%^ImageBase,
%^ListGlobals,
%^ListLiterals,
%^ListMap,
%^MajorImageVersion,
%^MajorLinkerVersion,
%^MajorOSVersion,
%^MajorSubsystemVersion,
%^MaxExpansions,
%^MaxPasses,
%^MinorImageVersion,
%^MinorLinkerVersion,
%^MinorOSVersion,
%^MinorSubsystemVersion,
%^Model,
%^OutFile,
%^SectionAlign,
%^SizeOfHeapCommit
%^SizeOfHeapReserve,
%^SizeOfStackCommit,
%^SizeOfStackReserve,
%^StubFile,
%^Subsystem,
%^TimeStamp,
%^Width,
%^Win32VersionValue,
</td></tr>
<tr><td>&euro;ASM</td><td>
%^Date,
%^Errorlevel,
%^EuroasmOs,
%^Pass,
%^Proc,
%^Program,
%^Section,
%^Segment,
%^SourceExt,
%^SourceFile,
%^SourceLine,
%^SourceName,
%^Time,
%^Version,
</td></tr>
</table>

<h5><a id="SystemVariablesEUROASM" href="#SystemVariables">&uarr; EUROASM systémové %^proměnné</a></h5>
<p>jsou přiřazeny hodnotami specifikovanými v sekci <code>[EUROASM]</code>
souboru <q><a class="EXT" href="../objlib/euroasm.ini">euroasm.ini</a></q>
nebo pseudoinstrukcí EUROASM.</p>
<p>Pro popis %^proměnných této kategorie viz příslušný klíč pseudoinstrukce
<a href="#EUROASM">EUROASM</a>.</p>

<h5><a id="SystemVariablesPROGRAM" href="#SystemVariables">&uarr; PROGRAM systémové %^proměnné</a></h5>
<p>jsou přiřazeny hodnotami specifikovanými v sekci <code>[PROGRAM]</code>
souboru <q><a class="EXT" href="../objlib/euroasm.ini">euroasm.ini</a></q>
nebo pseudoinstrukcí PROGRAM.</p>
<p>Pro popis %^proměnných této kategorie viz příslušný klíč pseudoinstrukce
<a href="#PROGRAM">PROGRAM</a>.</p>

<h5><a id="SystemVariablesEASM" href="#SystemVariables">&uarr; &euro;ASM systémové %^proměnné</a></h5>
<p>Hodnota těchto %^proměnných je udržována samotným &euro;ASM a programátor je nemůže přímo měnit. Jsou popsány zde:</p>

<dl><dt>%^Version</dt><dd>Osm dekadických číslic identifikuje verzi EuroAssembleru.
Číslo verze lze dešifrovat jako datum vydání &euro;ASM ve formátu YYYYMMDD.</dd>
<dt>%^Date, %^Time</dt><dd> Aktuální datum a čas překladu ve formátu YYYYMMDD, HHMMSS.
Tyto dvě proměnné jsou nastaveny pouze jednou když &euro;ASM startuje.
Všechny zdrojové soubory přeložené jedním povelem <code>euroasm source*.asm</code>
budou sdílet stejnou hodnotu %^Date a %^Time nastavené z lokálního času počítače, když byl <q>euroasm.exe</q> spuštěn.</dd>
<dt>%^Errorlevel</dt><dd>Aktuální hodnota návratového kódu.</dd>
<dt>%^EuroasmOs</dt><dd>identifikuje operační systém, na kterém EuroAssembler běží.
Obsahuje zkratku OS jako <kbd>Win</kbd> nebo <kbd>Lin</kbd>.
<br/>To nemusí nezbytně být operační systém, na němž by měl běžet výstupní program.</dd>
<dt>%^SourceFile, %^SourceName, %^SourceExt</dt><dd>
Tyto tři %^proměnné obsahují plné jméno <strong>zdrojového souboru včetně cesty</strong> ,
samotné <strong>jméno souboru</strong> bez cesty a přípony, a konečně
<strong>příponu</strong> (včetně vedoucí tečky <kbd>.</kbd>) aktuálně překládaného souboru.
&euro;ASM aktualizuje obsah těchto %^proměnných na začátku překladu a vždy když je vkládán (INCLUDE) nějaký soubor.
<br/>Jsou-li tyto %^proměnné užity v makru, namísto pozice uvnitř definice těla makra
určují pozici v jeho invokaci.</dd>
<dt>%^SourceLine</dt><dd>obsahuje číslo fyzického řádku v rámci aktuálního zdrojového souboru.
<br/>V mnohořádkových instrukcích (s pokračovacími řádky&nbsp;<kbd>\</kbd>) je to poslední fyzický řádek.
<br/>Je-li použita %^SourceLine v makru, namísto pozice uvnitř definice makra určuje pozici v jeho invokaci.</dd>
<dt>%^Pass</dt><dd> expanduje na číslo průchodu (1, 2, 3,,,) aktuálním programem.</dd>
<dt>%^Program</dt><dd>obsahuje název současného bloku PROGRAM..ENDPROGRAM.</dd>
<dt>%^Proc</dt><dd>je jméno aktuální procedury.
Tato %^proměnná je prázdná mimo bloky PROC..ENDPROC nebo PROC1..ENDPROC1.</dd>
<dt>%^Segment</dt><dd>je název aktuálního segmentu (bez hranatých závorek).</dd>
<dt>%^Section</dt><dd>je název aktuální sekce (bez složených závorek).</dd>
</dl>

<p>Kombinace &euro;ASM systémových %^proměnných je interně použita k identifikaci pozice instrukce v chybových oznámeních:
<code>&quot;%^SourceName%^SourceExt&quot;{%^SourceLine}</code>, např.
<code>&quot;HelloWorld.asm&quot;{3}</code></p>

<p>&euro;ASM %^proměnná <code>%^Section</code> může být použita k úschově a obnově aktuální sekce a segmentu v makrech.
Spolu s instrukcí <code>EUROASM PUSH</code> zaručuje, že prostředí EuroAssembleru nebude modifikováno expanzí makra,
ani když je makro požadovalo změnit.</p><pre>
aMacro %MACRO              ; Deklarace makra potřebujícího emitovat do své privátní sekce.
         EUROASM PUSH      ; Ulož všechny volby EUROASM na jeho vlastní zásobník.
%BackupSec %SET %^Section  ; Ulož aktuální jméno sekce do uživatelsky definované proměnné.
[.MacroPrivateSection]     ; Přepni do makrem požadované sekce.
               ...         ; Deklaruj tělo makra.
[%BackupSec]               ; Přepni zpět do origináoní sekce, ať už byla jakákoli.
         EUROASM POP       ; Obnov volby EUROASM.
        %ENDMACRO aMacro
</pre>

<p>Jiný příklad použití &euro;ASM %^proměnných:</p>
<pre>%MonthList %SET Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec
%Day %SETA %^DATE[7..8] ; Použití %SETA místo %SET plní %Day dekadickou hodnotou, aby se zbavila vedoucí nepodstatné nuly.
InfoMsg DB "This program was assembled with &euro;ASM %^EuroasmOs ver.%^Version",13,10
        DB "on %MonthList{%^Date[5..6]} %Day-th, %^Date[1..4] at %^Time[1..2]:%^Time[3..4].",13,10,0
; InfoMsg nyní obsahuje něco jako
;           This program was assembled with &euro;ASM Win ver.20081231
;           on Feb 8-th, 2009 at 22:05.
</pre>
<p><strong>Výčtovým volbám</strong>, jako %^CPU, %^FORMAT, %^MODEL atd.
bude přiřazen text s velkými písmeny. Mohou být testovány v asm-time pomocí operací pro
<a href="#StringCompare">porovnávání řetězců</a>.</p>
<p><strong>Číselným volbám</strong> jsou přiřazovány hodnoty v desítkovém zápisu.
Pozitivní znaménko <kbd>+</kbd> se vynechává. Mohou být testovány pomocí operací
<a href="#NumericCompare">porovnávání čísel</a>.</p>
<p><strong>Booleovské volby</strong>, např. <code>AutoSegment=, Priv=</code> atd.,
jsou přiřazovány odpovídajícícm systémovým %^proměnným <code>%^Autosegment, %^Priv</code>
jako <kbd>0</kbd> (nepravda) nebo <kbd>-1</kbd> (pravda), bez ohledu na to, zda byly specifikovány
pomocí výčtových hodnot ON/OFF, YES/NO, TRUE/FALSE nebo logickým výrazem.
Mohou být testovány pomocí <a href="#BooleanAlgebra">logických výrazů</a> anebo přímo jako operand %IF,
např. <code> %IF %^UNDOC</code>.</p>
<p><strong>Rozsahové volby EUROASM</strong> WARN= and NOWARN= jsou přiřazeny systémovým %^proměnným
<code>%^Warn, %^NoWarn</code> jako řetězy 3999 číslic <kbd>0</kbd> (nepravda) nebo <kbd>1</kbd> (pravda).
První číslice odpovídá momentálnímu stavu oznámení č. I0001, druhá č. I0002, poslední č. W3999.
<br/>Příklad: <code> %IF %^WARN[2820]</code> bude překládat následnou instrukci
pouze pokud je oznámení W2820 povoleno.</p>
<p>Systémové %^proměnné mohou být využity v makrech k varování, že prostředí EuroAssembleru
není nastaveno tak, jak je potřeba. Příklady:</p><pre>
 %IF "%^MODEL" !== "FLAT"
    %ERROR Macro "%0" is intended for flat memory model only.
 %ENDIF
 %IF %^SizeOfStackCommit < 16K
    %ERROR This recursive macro requires stack size at least 16 KB.
 %ENDIF
 %IF %^Width = 64 &amp;&amp; ! %^AMD
    %ERROR This 64-bit program for MS-Windows should have AMD=Enabled.
 %ENDIF
 %IF %^NoWarn[2101]
    %ERROR You shouldn't suppress W2101. Move unused symbols to an included file instead.
 %ENDIF
</pre>

<hr/>
<h2 id="Instructions"><a href="#top">&uarr; Instrukce</a></h2>
<h3><a href="#MachineInstructions">Strojové instrukce &darr;</a></h3>
<h3><a href="#PseudoInstructions">Pseudoinstrukce &darr;</a></h3>
<h3><a href="#MacroInstructions">Makroinstrukce &darr;</a></h3>

<h6><dfn>Instrukce</dfn> je identifikátor specifikovaný v poli <a href="#StmentOperation">operace</a> asemblovaného řádku.</h6>
<p>V asembleru rozeznáváme tři rody instrukcí:
<br/><dfn>strojové instrukce</dfn> vytvořené výrobcem CPU,
<br/><dfn>pseudoinstrukce</dfn> vytvořené výrobcem asembleru,
<br/><dfn>makroinstrukce</dfn> vytvořené programátorem.</p>
<hr/>
<h3 id="MachineInstructions"><a href="#Instructions">&uarr; Strojové instrukce</a></h3>
<h4><a href="#InstructionSuffixes">Instrukční přípony &darr;</a></h4>
<h4><a href="#InstructionModifiers">Instruční modifikátory &darr;</a></h4>
<h4><a href="#InstructionEnhancements">Vylepšení instrukcí &darr;</a></h4>
<h4><a href="#UndocInstructions">Nedokumentované instrukce &darr;</a></h4>
<p><dfn>Strojová instrukce</dfn> je nejelementárnější příkaz procesoru, aby provedl nějakou kalkulaci
nebo jinou manipulaci s daty za běhu programu.</p>

<p>EuroAssembler používá <dfn>Intelskou syntaxi</dfn>, kde první operand určuje
<em>cíl</em> (což je často zároveň jeden ze  zdrojových operandů),
za nímž může následovat druhý operand &ndash; <em>zdroj</em>.</p>
<blockquote>Tato syntaxe se používá v dokumentaci výrobců CPU a je použita i u většiny asemblerů,
s výjimkou v Unixu používaného <em>gas</em>, který preferuje
alternativní paradigma představovaného syntaxí <dfn>AT&amp;T</dfn> s přehozeným pořadím operandů.
Více rozdílů mezi syntaxí AT&amp;T a Intel je popsáno v <a class="EXTL" href="links.htm#ATTsyntax">[ATTsyntax]</a>.</blockquote>

<p>EuroAssembler implementuje mnemoniku strojových instrukcí jak byly definovány
 <a class="EXTL" href="links.htm#InstructionsFromVendors">výrobci procesorů</a>.
Rovněž implementuje několik <a  class="EXTL" href="links.htm#InstructionsFromOthers">
nedokumentovaných instrukcí</a> a rozšíření, které budou popsány níže.</p>
<h6>Strojové instrukce a jejich přípony jsou nezávislé na velikosti písmen.</h6>
<p>Některé strojové instrukce dovolují alternativní kódování stejné mnemoniky,
&euro;ASM preferuje to kratší, nebyl-li instruován jinak.
<br/><b>&euro;ASM respektuje menmoniku</b> zvolenou programátorem, proto nikdy nekóduje
třeba <code>LEA ESI,[MemoryVariable]</code> jako <code>MOV ESI,MemoryVariable</code>,
i když je druhý zápis o jeden bajt kratší.
Jsou pouze dvě výjimky, kdy není mnemonika dodržena:<ul>
<li>Krátké podmíněné skoky a smyčky procesoru 8086 mimo bajtový rozsah
jsou zakódovány jako kompozice proxy-skoku JMPN přeskočeného krátkým skokem nebo smyčkou s invertovanou podmínkou,
viz <a href="#InsEnhLOOP">NEAR a FAR LOOP a Jcc</a>.</li>
<li>Další výjimkou je <code>MOVZX r64,r/m32</code> implementované jako
<code>MOV r32,r/m32</code>, kdy využívá vedlejší efekt architektury IA-64
spočívající v nulování vyšší poloviny 64bitových registrů, pokud se zapisuje do jejich dolní poloviny.
Viz test <a class="EXT" href="../eatests/t3043.htm">t3043</a>.
</li></ul>

<h4 id="InstructionSuffixes"><a href="#MachineInstructions">Instrukční přípony &darr;</a></h4>
<p>Strojová instrukce může manipulovat s registry a paměťovými proměnnými různé šířky,
obvykle s operandy typu BYTE, WORD nebo DWORD. Avšak výrobce CPU definoval pro instrukce stejnou mnemoniku
bez ohledu na šířku dat.
Tak například <code>SUB [MemoryVariable],4</code> říká CPU, aby odečetl číslo 4 od obsahu
MemoryVariable, které mohlo být definováno jako DB, DW, DD nebo DQ.
&euro;ASM se podívá na typ MemoryVariable a vybere odpovídající zakódování odpovídající tomuto typu.
Ovšem ofset mohl být rovněž vyjádřen jako obsah registru nebo jako prosté číslo, např.
<code>SUB [ESI],4</code>, a typ proměnné je pak neznámý.
Jednou z metod jak sdělit EuroAssembleru, jaká šířka dat je žádoucí, je použití
<dfn>instrukční přípony</dfn>, což je jedno z písmen <kbd>B W D Q S N F</kbd>
připojené k mnemonickému názvu instrukce.</p>
<p id='Suffixable'>&euro;ASM dovoluje rozšiřovat mnemonickou příponou <kbd>B, W, D, Q</kbd> mnoho instrukcí se všeobecným účelem.</p>
<p>Instrukce pro předávání zpracování <code>CALL, JMP, RET</code> mohou být modifikovány příponou
<kbd>N</kbd> nebo <kbd>F</kbd> oznamující asembleru, zda je vzdálenost cíle
<em>NEAR</em> nebo <em>FAR</em>, tj. zda cíl patří do téhož segmentu nebo zda se jeho deskriptor má také měnit.
Instrukce pro nepodmíněný skok <code>JMP</code> může být rovněž doplněna příponou
<kbd>S</kbd>, je-li vzdálenost cíle zakódovatelná v 8 bitech (-128..+127).</p>

<table><tr><th>Instrukce &euro;ASM akceptující příponu</th><th>Přípona</th></tr>
<tr><td>ADC, ADD, AND, CMP, CMPS, CRC32, DEC, DIV, IDIV, IMUL, INC,
LODS, MOV, MOVS, MUL, NEG, NOT, OR, RCL, RCR, ROL, ROR, SAL, SAL2,
SAR, SBB, SCAS, SHL, SHR, STOS, SUB, TEST, TEST2, XOR</td>
<td>B,&nbsp;W,&nbsp;D,&nbsp;Q</td></tr>
<tr><td>BT, BTC, BTS, BTR, ENTER, HINT_NOP, IRET, LEAVE, POP, POPF, PUSH, PUSHF</td>
<td>W, D, Q </td></tr>
<tr><td>PUSHA, POPA</td><td>W, D</td></tr>
<tr><td>INS, MOVSX, MOVZX, OUTS</td><td>B, W, D</td></tr>
<tr><td>XLAT</td><td>B</td></tr>
<tr><td>CALL, RET</td><td>N, F</td></tr>
<tr><td>JMP</td><td>S, N, F</td></tr>
</table>
<p>Použití přípony je v mnoha případech zbytečné, neboť šířka paměťové proměnné může být odvozena z jeho atributu pro typ
anebo je šířka určena šířkou registru použitého jako jeden z operandů.
Pokud je šířka registru v konfliktu s příponou, ohlásí se chyba, např. v <code>MOVW AL,[ESI]</code>.</p>

<blockquote><p>Přípona je sporadicky použita i v jiných asemblerech, viz např. STOSB/W/D, OUTSB/W/D, RETN/F apod.
&euro;ASM pouze důsledně rozšiřuje toto vylepšení.</p>
<p>Mnemoniky mnoha instrukcí pro SIMD končí písmeny <code>~SS, ~SD, ~PS, ~PD</code>
rovněž specifikujícími typy operandů (Scalar/Packed Single/Double-precision).
&euro;ASM však toto nepovažuje za přípony instrukcí.</p>
<p>Existuje několik konfliktů mnemoniky s příponou s jinou instrukcí, jsou však řešitelné pomocí typu a počtu operandů:</p>
<samp>|00000000:                 | ; Standardní MOV versus MMX Move Doubleword:
|00000000:C7450800000000   | MOVD [EBP+8],0     ; Ulož číslo do paměťové proměnné typu DWORD (přípona ~D).
|00000007:0F7E4508         | MOVD [EBP+8],MM0   ; Ulož DWORD z registru MMX do paměti.
|0000000B:                 |
|0000000B:                 | ; Posun SHL versus Double Precision Shift:
|0000000B:C1650804         | SHLD [EBP+8],4     ; Posuň DWORD v paměti logicky vlevo o 4 bity (přípona ~D).
|0000000F:0FA4450804       | SHLD [EBP+8],EAX,4 ; Vysuň 4 bity z registru EAX doleva do pamětové proměnné.
|00000014:                 |
|00000014:                 | ; Porovnej řetězce versus Porovnej skalární FP číslo s dvojitou přesností:
|00000014:A7               | CMPSD              ; Porovnej DWORDy na [DS:ESI] a [ES:EDI] (přípona ~D).
|00000015:A7               | CMPSD [ESI],[EDI]  ; Totéž, dokumentováno explicitními operandy.
|00000016:F20FC2CA00       | CMPSD XMM1,XMM2,0  ; Porovnej dvě skalární FP čísla s dvojitou přesností na rovnost.
</samp>
</blockquote>

<hr>
<h4 id="InstructionModifiers"><a href="#MachineInstructions">&uarr; Instrukční modifikátory</a></h4>
<h5><a href="#CODEeq">CODE= &darr;</a></h5>
<h5><a href="#DATAeq">DATA= &darr;</a></h5>
<h5><a href="#IMMeq">IMM= &darr;</a></h5>
<h5><a href="#DISPeq">DISP= &darr;</a></h5>
<h5><a href="#SCALEeq">SCALE= &darr;</a></h5>
<h5><a href="#DISTeq">DIST= &darr;</a></h5>
<h5><a href="#ADDReq">ADDR= &darr;</a></h5>
<h5><a href="#PREFIXeq">PREFIX= &darr;</a></h5>
<h5><a href="#MASKeq">MASK= &darr;</a></h5>
<h5><a href="#ZEROINGeq">ZEROING= &darr;</a></h5>
<h5><a href="#EHeq">EH= &darr;</a></h5>
<h5><a href="#SAEeq">SAE= &darr;</a></h5>
<h5><a href="#ROUNDeq">ROUND= &darr;</a></h5>
<h5><a href="#BCSTeq">BCST= &darr;</a></h5>
<h5><a href="#OPEReq">OPER= &darr;</a></h5>
<h5><a href="#ALIGNeq">ALIGN= &darr;</a></h5>
<h5><a href="#NESTINGCHECKeq">NESTINGCHECK= &darr;</a></h5>
<p>Strojové instrukce se shodnou mnemonikou a funkčností mohou být někdy zakódovány
do různých strojových kódů. Například okamžitá hodnota operandu může být zakódována v jednom bajtu,
pokud nepřekračuje rozsah -128..+127, anebo může být zakódována jako celé slovo či dvojslovo.
Podobné pravidlo platí pro hodnotu displacementu v adresních výrazech.
Škálovaný adresní výraz, jako <code>[1*ESI+EBX]</code> může být kódován bez SIB
jako <code>[ESI+EBX]</code> nebo s využitím SIB a s explicitním škálovacím faktorem 1.</p>
<p>&euro;ASM preferuje kratší variantu, ale lze to změnit přídavným klíčovým operandem zvaným
<dfn>instrukční modifikátor</dfn>.
<blockquote><p>Jiné asemblery dekorují operandy speciálními direktivami
<code>byte, word, dword, qword, short, strict, near, far, ptr</code>
k dosažení požadovaného kódu, např. <code>add word ptr [StringOfBytes + 4], 0x20</code>
nebo <code>jmp short SomeLabel</code>.
Namísto těchto direktiv používá &euro;ASM buď příponu mnemoniky, nebo instrukční modifikátor.</p>
<p>Modifikátory pro AVX <code>MASK=, ZEROING=, SAE=, ROUND=, BCST=</code> jsou v &euro;ASM využívány
namísto nekonzistních a bídně dokumentovaných dekorátorů typu
<code>{k} {z} {ru-sae} {4to16} {uint16} {cdab}</code> navrhovaných v dokumentaci
<a class="EXTL" href="links.htm#IntelAVX512">[IntelAVX512]</a> a
<a class="EXTL" href="links.htm#IntelMVEX">[IntelMVEX]</a>.</blockquote>
<p>Typickou hodnotou modifikátoru je výčtová hodnota <code>BYTE, WORD, DWORD</code>.
Většinu modifikátorů lze zkrátit na jejich první písmeno.
U názvů ani hodnot instrukčních modifikátorů nezáleží na velikosti písmen.</p>
<p>Některé modifikátory jsou booleovské, jejich hodnota může být
<code>TRUE, YES, ON, ENABLE, ENABLED</code> pokud <em>pravda</em>,
a <code>FALSE, NO, OFF, DISABLE, DISABLED</code> v ostatních případech.
Logickým modifikátorem může být také výraz vyhodnocený jako nula (nepravda) nebo ne-nula (pravda),
viz <a href="#BooleansExt">boolovská rozšíření</a>.</p>
<p>Pokud &euro;ASM nemůže vyhovět požadovanému modifikátoru, ohlásí varování a ignoruje ho.</p>
<p>Volbou <code>EUROASM DISPLAYENC=ON</code> můžeme zapnout zobrazování aktuálně použitých modifikátorů.
V tom případě &euro;ASM doprovodí každou strojovou instrukci diagnostickým oznámením
D1080 explicitně dokumentujícím modifikátory použité při kódování instrukce.:</p>
<samp>|                          | EUROASM DISPLAYENC=ON
|00000000:694D10C8000000   | IMUL ECX,[EBP+16],200
|# D1080 Emitted size=7,DATA=DWORD,DISP=BYTE,SCALE=SMART,IMM=DWORD.
|00000007:                 |
|00000007:62F1ED2CF44D02&lt;5 | VPMULUDQ YMM1,YMM2,[EBP+40h],MASK=K4
|# D1080 Emitted size=7,PREFIX=EVEX,MASK=K4,ZEROING=OFF,DATA=YWORD,BCST=OFF,OPER=2,DISP=BYTE,SCALE=SMART.</samp>

<h5 id="CODEeq"><a href="#InstructionModifiers">&uarr; CODE=</a></h5>
<p>Jako dědictví po starších procesorech některé strojové instrukce mají více než jedno kódování.
Například instrukce <code>POP rAX</code> může být zakódována jako <kbd>0x58</kbd> nebo jako <kbd>0x8FC0</kbd>,
přičemž oba způsoby jsou funkčně ekvivalentní.
Modifikátor CODE= vybírá kódování, které má &euro;ASM použít.</p>
<p>Modifikátor může být <dfn>SHORT</dfn> nebo <dfn>LONG</dfn>
alias <dfn>S</dfn> nebo <dfn>L</dfn>. Jako výchozí se bere ten, který poskytuje kratší kód, obvykle <code>CODE=SHORT</code>.</p>
<p>Mají-li dvě kódování stejnou velikost, CODE=SHORT vybírá variantu s numericky nižším operačním kódem.</p>
<samp>|00000000:43           | INC EBX
|00000001:43           | INC EBX,CODE=SHORT ; Zděděné kódování Intel 8080, není dostupné v 64bitovém módu.
|00000002:FFC3         | INC EBX,CODE=LONG
|00000004:             |
|00000004:50           | PUSH EAX
|00000005:50           | PUSH EAX,CODE=SHORT ; Zděděné kódování Intel 8080, není dostupné v 64bitovém módu.
|00000006:FFF0         | PUSH EAX,CODE=LONG
|00000008:             |
|00000008:87CA         | XCHG ECX,EDX
|0000000A:87D1         | XCHG ECX,EDX,CODE=LONG ; Modifikátor zaměňuje operandy v komutativních operacích XCHG, TEST.
|0000000C:87D1         | XCHG EDX,ECX
|0000000E:87CA         | XCHG EDX,ECX,CODE=LONG
|00000010:             |
|00000010:C3           | RET
|00000011:C3           | RET CODE=LONG
|00000012:C20000       | RET CODE=SHORT ; Byl požadován numericky nižší operační kód 0xC2, který ale vyžaduje imm16.
|00000015:             |
|00000015:83C07F       | ADD EAX,127
|00000018:83C07F       | ADD EAX,127,CODE=LONG
|0000001B:057F000000   | ADD EAX,127,CODE=SHORT ; Byl požadován kratší operační kód 0x05, který ale neumí znaménkově roztáhnout imm8.</samp>
<blockquote>V některých případech volba numericky nižšího operačního kódu pomocí modifikátoru <code>CODE=SHORT</code>
může vést k delšímu zakódování, viz výše v příkladu <code>ADD r32,imm8</code>.</blockquote>

<h5 id="DATAeq"><a href="#InstructionModifiers">&uarr; DATA=</a></h5>
<p>Tento modifikátor ovlivňuje <dfn>velikost operandu</dfn>, tedy šířku dat, se kterými instrukce pracuje.
Může to být jedna z výčtových hodnot <dfn>BYTE, WORD, DWORD, QWORD, TBYTE, OWORD, YWORD, ZWORD</dfn>
neboli <dfn>B, W, D, Q, T, O, Y, Z</dfn>. Výchozí hodnota není specifikována.</p>
<p>Modifikátor DATA= má stejnou funkci jako <a href="#InstructionSuffixes">přípona mnemoniky</a>,
jsou pouze dva rozdíly:</p>
<ul><li>Přípona může být použita pouze s <a href='#Suffixable'>omezeným repertoárem</a> všeobecných instrukcí,
zatímco modifikátor DATA= může být aplikován na mnoho dalších instrukcí včetně FPU, MMX, SIMD.</li>
<li>Instrukční modifikátor není přísný příkaz, ale spíše jen nápověda.
Pokud aktuální data nemohou splnit požadavek modifikátoru DATA=, bude modifikátor
ignorován a &euro;ASM vydá varování. Pokud data neplní pořadavek přípony,
&euro;ASM to považuje za chybu.</li></ul>
<p>Existují další možnosti, jak řídit velikost operandu.
Je-li jedním z operandů <em>registr</em>, jeho šířka převládne a nelze to přepsat příponou ani modifikátorem.
Není-li šířka specifikována registrem, &euro;ASM se dívá na atribut TYPE# paměťového operandu.</p>
<p>Priorita specifikací velikosti dat:</p>
<ol><li>Šířka registrového operandu.</li>
<li>Přípona mnemoniky.</li>
<li>Modifikátor DATA=.</li>
<li>Typ paměťového operandu.</li></ol>
<p>Viz následující příklady:</p>
<samp>|00000000:00000000           |MemoryVariable  DB 0,0,0,0
|00000004:0107               | ADD [EDI],EAX                     ; Šířka je určena registrem (32 bitů).
|00000006:830701             | ADDD [EDI],1                      ; Šířka je určena příponou (32 bitů).
|00000009:66830701           | ADD [EDI],1,DATA=W                ; Šířka je určena modifikátorem (16 bitů).
|0000000D:800701             | ADDB [EDI],1,DATA=W               ; Šířka je určena příponou (8 bitů). Varování: modifikátor byl ignorován.
|## W2401 Modifier "DATA=WORD" could not be obeyed in this instruction.
|00000010:660107             | ADDB [EDI],AX                     ; Šířka je určena registrem (16 bitů). Chyba: přípona byla ignorována.
|### E6740 Impracticable operand-size requested with mnemonic suffix.
|00000013:8387[00000000]01   | ADDD [EDI+MemoryVariable],1       ; Šířka je určena příponou (32 bitů).
|0000001A:668387[00000000]01 | ADD [EDI+MemoryVariable],1,DATA=W ; Šířka je určena  modifikátorem (16 bitů).
|00000022:8087[00000000]01   | ADD [EDI+MemoryVariable],1        ; %Sířka je určena atributem TYPE# MemoryVariable = 'B' (8 bitů).
|00000029:800701             | ADD [EDI],1                       ; Chyba: Šířka nebyla určena.
|### E6730 Operand size could not be determined, please use DATA= modifier.
</samp>

<h5 id="IMMeq"><a href="#InstructionModifiers">&uarr; IMM=</a></h5>
<p>Některé instrukce kódují malou okamžitou hodnotu jako jeden bajt,
třebaže operují s celým slovem. Hodnota bajtu je znaménkově rozšířena procesorem za běhu programu.
<p>Modifikátor <code>IMM=</code> může nabývat hodnnot <dfn>BYTE, WORD, DWORD, QWORD</dfn> alias <dfn>B, W, D, Q</dfn>
a specifikuje, jak by měla být hodnota operandu zakódována v instrukci.</p>
<samp>|00000000:83D001        | ADC EAX,1
|00000003:83D001        | ADC EAX,1,IMM=BYTE
|00000006:81D001000000  | ADC EAX,1,IMM=DWORD</samp>

<h5 id="DISPeq"><a href="#InstructionModifiers">&uarr; DISP=</a></h5>
<p>Hodnota displacementu v adresním výrazu může být zakódována v jednom bajtu,
pokud se vejde do rozsahu -128..+127. Tato hodnota bude procesorem za běhu znaménkově roztažena.
Hodnoty mimo tento rozsah jsou zakódovány v plné velikosti, tj. jako 16tibitové nebo 32bitové slovo
v souladu s šířkou segmentu (která mohla být dočasně změněna prefixem ATOGGLE).
Toto je defaultní chování &euro;ASM.
Modifikátor <code>DISP=</code> může mít stejné hodnoty jako modifikátor <a href="#IMMeq">IMM=</a>
a určuje, zda má být displacement zakódován v plné velikosti nebo jako bajt.</p>
<samp>|00000000:2945FC        | SUB [EBP-4],EAX
|00000003:2945FC        | SUB [EBP-4],EAX,DISP=BYTE
|00000006:2985FCFFFFFF  | SUB [EBP-4],EAX,DISP=DWORD</samp>

<h5 id="SCALEeq"><a href="#InstructionModifiers">&uarr; SCALE=</a></h5>
<p><dfn>Škálováním</dfn> se rozumí vynásobení obsahu indexregistru v registrovém adresním výrazu hodnotou 0, 1, 2, 4 or 8 za běhu programu.
Modifikátor <code>SCALE=</code> může být buď <dfn>SMART</dfn> nebo <dfn>VERBATIM</dfn>
(případně zkráceně <dfn>S, V</dfn>). Výchozí hodnota je <code>SCALE=SMART</code>.
<br/>V módu <b>verbatim</b> se neprovádějí žádné optimalizace s indexovým a bázovým registrem;
škálování je zakódováno s <a class="EXT" href="../easource/ii.htm#IiModRM">bajtem SIB</a> i v případech, kdy je škálovací faktor 1 nebo 0.
Kódování s <code>SCALE=VERBATIM</code> používá pokud možno bajt SIB.
<br/>Ve <b>smart</b> módu (default) &euro;ASM zkouší rearanžovat registry a nepoužívat SIB, není-li to nezbytně nutné.
<br/>Optimalizační &quot;smart&quot; pravidla:
(<code>IR</code> je indexregister, <code>BR</code> je baseregister, <code>disp</code> je displacement):</p>
<ul><li><code>[0*IR+BR+disp] <del>&gt;</del> [BR+disp]</code>
<br/>Pseudoškálování faktorem nula je zcela vynecháno.</li>
<li><code>[1*IR+BR+disp] <del>&gt;</del> [IR+BR+disp]</code>
<br/>Škálování faktorem jedna se bere jako absence škálování.</li>
<li><code>[2*IR+disp] <del>&gt;</del> [BR+IR+disp]</code>
<br/>Škálování faktorem dvě bez bázového registru se zakóduje jako báze+index bez škálování.</li></ul>
<samp>|00000000:A011000000     | MOV AL,[0x11]                      ; Speciální kódování bez ModR/M.
|00000005:A011000000     | MOV AL,[0*ESI+0x11]                ; Speciální kódování bez ModR/M.
|0000000A:8A042511000000 | MOV AL,[0*ESI+0x11],SCALE=VERBATIM ; ModR/M a SIB. ESI není použito.
|00000011:               |
|00000011:8A4611         | MOV AL,[ESI+0x11]                  ; ModR/M bez SIB. ESI je báze
|00000014:8A4611         | MOV AL,[ESI+0x11],SCALE=SMART      ; ModR/M bez SIB. ESI je báze.
|00000017:8A442611       | MOV AL,[ESI+0x11],SCALE=VERBATIM   ; ModR/M bez SIB, ESI je báze.
|0000001B:8A4611         | MOV AL,[1*ESI+0x11]                ; ModR/M bez SIB. ESI je báze.
|0000001E:8A4611         | MOV AL,[1*ESI+0x11],SCALE=SMART    ; ModR/M bez SIB. ESI je báze.
|00000021:8A043511000000 | MOV AL,[1*ESI+0x11],SCALE=VERBATIM ; ModR/M plus SIB, ESI je index.
|00000028:               |
|00000028:8A443611       | MOV AL,[ESI+ESI+0x11]              ; ModR/M plus SIB. ESI je báze a index.
|0000002C:8A443611       | MOV AL,[2*ESI+0x11]                ; ModR/M plus SIB. ESI je báze a index.
|00000030:8A047511000000 | MOV AL,[2*ESI+0x11],SCALE=VERBATIM ; ModR/M plus SIB. ESI je index.
|00000037:               |
|00000037:8A442D11       | MOV AL,[EBP+EBP+0x11]              ; ModR/M plus SIB, EBP je báze a index.
|0000003B:8A442D11       | MOV AL,[2*EBP+0x11]                ; ModR/M plus SIB, EBP je báze a index.
|0000003F:8A046D11000000 | MOV AL,[2*EBP+0x11],SCALE=VERBATIM ; ModR/M plus SIB, EBP je index.</samp>
<blockquote>Všimněte si, že optimalizace pomocí SCALE=SMART může změnit roli registrů (báze|index)
a tudíž i defaultní segmentový registr (SS|DS) použitý k adresaci.
V paměťovém modelu FLAT je to obvykle jedno, jinak použijte SCALE=VERBATIM.</blockquote>
<p>Je-li zobrazování zakódování instrukcí povoleno pomocí <code>EUROASM DisplayEnc=Yes</code>,
modifikátor SCALE=VERBATIM říká, že bajt SIB byl emitován, jinak SCALE=SMART signalizuje, že SIB chybí.</p>

<h5 id="DISTeq"><a href="#InstructionModifiers">&uarr; DIST=</a></h5>
<p>Tento modifikátor určuje <a href="#Distance">distanci</a> cíle
v instrukcích pro <em>předání zpracování</em>.
Hodnotou modifikátoru je jedna z možností <dfn>FAR, NEAR, SHORT</dfn> alias <dfn>F, N, S</dfn>.</p>
<p><code>DIST=FAR</code> se použije, pokud je cíl v odlišném segmentu
a musí se změnit obsah registrů jak rIP, tak i CS.</p>
<p>Ve výchozím stavu &euro;ASM při přechodech uvnitř segmentu automaticky vybírá mezi
vzdáleností SHORT a NEAR v závislosti na rozdílu ofsetů.</p>
<p>Modifikátor DIST= plní stejnou funkci jako <a href="#InstructionSuffixes">
instrukční přípona</a>, jsou jen dva rozdíly:</p>
<ul><li>Příponu lze použít pouze u instrukcí <code>JMP, CALL, RET</code>,
zatímco modifikátor DIST= může být aplikován i na další instrukce pro předání zpracování:
<code>LOOPcc, Jcc, JrCXZ</code>.</li>
<li>Nelze-li instrukci zakódovat v souladu s požadovanou vzdáleností DIST=,
modifikátor se ignoruje a &euro;ASM vydává varování.
Nelze-li vyhovět příponě, &euro;ASM to považuje za chybu.</li></ul>
<p>Modifikátor <code>DIST=NEAR</code> nebo <code>DIST=FAR</code> může být také aplikován
na pseudoinstrukce <code>PROC, PROC1</code>.
Důsledkem nastavení procedury na DIST=FAR je to, že instrukce CALL a JMP na takovou proceduru
budou defaultně FAR a že instrukce RET uvnitř takové procedury také bude defaultně <code>DIST=FAR</code>.</p>
<samp>|[CODE1]              |[CODE1] SEGMENT
|0000:EB2A            |  JMP CloseLabel:              ; Zakódováno jako  DIST=SHORT.
|0002:E92701          |  JMP DistantLabel:            ; Zakódováno jako  DIST=NEAR.
|0005:EA[0000]{0000}  |  JMP FarLabel:                ; Zakódováno jako  DIST=FAR.
|000A:EB20            |  JMP CloseLabel:,DIST=SHORT   ; Zakódováno jako  DIST=SHORT.
|000C:E91D01          |  JMP DistantLabel:,DIST=SHORT ; Zakódováno jako  DIST=NEAR.
|## W2401 Modifier "DIST=SHORT" could not be obeyed in this instruction.
|000F:EA[0000]{0000}  |  JMP FarLabel:,DIST=SHORT     ; Zakódováno jako  DIST=FAR.
|## W2401 Modifier "DIST=SHORT" could not be obeyed in this instruction.
|0014:E91500          |  JMP CloseLabel:,DIST=NEAR    ; Zakódováno jako  DIST=NEAR.
|0017:E91201          |  JMP DistantLabel:,DIST=NEAR  ; Zakódováno jako  DIST=NEAR.
|001A:E9(0000)        |  JMP FarLabel:,DIST=NEAR      ; Zakódováno jako  DIST=NEAR.
|001D:EA[2C00]{0000}  |  JMP CloseLabel:,DIST=FAR     ; Zakódováno jako  DIST=FAR.
|0022:EA[2C01]{0000}  |  JMP DistantLabel:,DIST=FAR   ; Zakódováno jako  DIST=FAR.
|0027:EA[0000]{0000}  |  JMP FarLabel:,DIST=FAR       ; Zakódováno jako  DIST=FAR.
|002C:                |CloseLabel:
|002C:90909090909090~~|  DB 256 * B 0x90 ; Kód pro oddálení návěstí DistantLabel.
|012C:                |DistantLabel:
|[CODE2]              |[CODE2] SEGMENT
|0000:                |FarLabel:</samp>

<h5 id="ADDReq"><a href="#InstructionModifiers">&uarr; ADDR=</a></h5>
<p>Tento modifikátor vybírá <em>referenční rámec</em> při adresaci paměti v 64bitovém módu.
Dovolené hodnoty jsou <dfn>ABS, REL</dfn> nebo zkráceně <dfn>A, R</dfn>.
Ofset zakódovaný v instrukci s <b>absolutní</b> adresaci je vztažen
k <b>začátku segmentu</b>, který je v asm-time vždy 0.
<br/>Při <b>relativní</b> adresaci je ofset vztažen k pozici příští instrukce,
tedy k obsahu <b>registru RIP</b>.
<br/>V historických módech (16 a 32bitovém) je referenční rámec napevno <code>ADDR=REL</code> v instrukcích pro předání zpracování
(přímý JMP, CALL, LOOP, Jcc), a jako <code>ADDR=ABS</code> ve všech ostatních instrukcích.</p>

<p>Adresování vztažené k RIP je o jeden bajt kratší a nepotřebuje relokaci.
Proto je adresování s <code>ADDR=REL</code> preferováno jako výchozí v 64bitovém módu.
<br/>Explicitní výběr absolutní a RIP-relativní adresace má význam pouze
v 64bitovém módu pokud by absolutní adresa vyžadovala relokaci v link-time.
K tomu dochází, je-li paměťová proměnná specifikována jako adresní symbol
(nikoli prosté  číslo), a pokud v adresaci není zapojen bázový ani indexový registr.</p>
<samp>|00000000:00000000         | MemDword DD 0
|00000004:                 |
|00000004:0305F6FFFFFF     |  ADD EAX,[MemDword]          ; Zakódováno jako relativní adresace.
|0000000A:0305F0FFFFFF     |  ADD EAX,[MemDword],ADDR=REL ; Zakódováno jako relativní adresace.
|00000010:030425[00000000] |  ADD EAX,[MemDword],ADDR=ABS ; Zakódováno jako absolutní adresace.
|00000017:                 |
|00000017:034540           |  ADD EAX,[RBP+0x40]          ; Zakódováno jako absolutní adresace.
|0000001A:034540           |  ADD EAX,[RBP+0x40],ADDR=ABS ; Zakódováno jako absolutní adresace.
|0000001D:034540           |  ADD EAX,[RBP+0x40],ADDR=REL ; Zakódováno jako absolutní adresace.
|## W2401 Modifier "ADDR=REL" could not be obeyed in this instruction.</samp>

<h5 id="PREFIXeq"><a href="#InstructionModifiers">&uarr; PREFIX=</a></h5>
<p>Všechny následující modifikátory se vztahují pouze k instrukcím používajícím kódování <em>Advanced Vector eXtensions</em> (AVX).
Možné hodnoty prefixu jsou <dfn>XOP, VEX, VEX2, VEX3, MVEX, EVEX</dfn> (zkratky nejsou k dispozici).</p>
<p>Většina instrukcí AVX má mnemoniku prefixovánu písmenem <kbd>V~</kbd>.
Některé instrukce jsou definovány pouze jedním druhem AVX prefixů, ty pak nepotřebují explicitní modifikátor.
Pokud instrukce může být zakódována více různými prefixy, &euro;ASM defaultně vybírá ten nejkratší.</p>
<p>Prefix VEX existuje ve dvou variantách: VEX2 a VEX3. Delší kódování (VEX3) je automaticky vybráno,
pokud instrukce používá indexregistr nebo bázový registr R8..R15, případně pokud používá mapu operačních kódů 0F38 nebo 0F3A.</p>
<p>Prefix EVEX nebo MVEX bude použit namísto VEX pokud instrukce používá registr XMM16..XMM31, YMM16..YMM31, ZMM0..ZMM31, K0..K7,
nebo modifikátor EH=, SAE=, ROUND=, MASK=, ZEROING=, OPER=.</p>
<p>Instrukce kódovatelné jak pomocí EVEX, tak i MVEX používají jako default <code>PREFIX=EVEX</code>.
Software napsaný pro CPU Intel<sup>®</sup> Xeon Phi<sup>™</sup> musí explicitně žádat <code>PREFIX=MVEX</code> pro každou takovou
obojživelnou instrukci.
V tom případě je užitečné disablovat EVEX <code>EUROASM EVEX=DISABLED</code> a být tudíž varován, pokud některá instrukce MVEX
bude nedopatřením zakódována jako EVEX.
Explicitní specifikace modifikátoru <code>EH=</code> (který je použitelný pouze u MVEX)
rovněž vybírá prefix MVEX, psát <code>PREFIX=MVEX</code> v takovém případě není nutné.</p>


<table><caption>Vlastnosti CPU vyžadované použitím prefixů AVX</caption>
<tr><th>Prefix</th><th>Požadovaná volba EUROASM</th></tr>
<tr><td>XOP</td><td>SIMD=AVX, AMD=ENABLED, XOP=ENABLED</td></tr>
<tr><td>VEX</td><td>SIMD=AVX</td></tr>
<tr><td>MVEX</td><td>SIMD=AVX512, MVEX=ENABLED</td></tr>
<tr><td>EVEX</td><td>SIMD=AVX512, EVEX=ENABLED</td></tr>
</table>
<samp>|00000000:8FE868CCCB04   | VPCOMB XMM1,XMM2,XMM3,4 ; VPCOMB je definováno pouze s XOP.
|00000006:62F1FA082917   | VMOVNRAPD [RDI],ZMM2    ; VMOVNRAPD je definováno pouze s MVEX.
|0000000C:C5E958CB       | VADDPD XMM1,XMM2,XMM3   ; VADDPD je definováno s VEX,MVEX,EVEX.
|00000010:C5E958CB       | VADDPD XMM1,XMM2,XMM3,PREFIX=VEX
|00000014:C5E958CB       | VADDPD XMM1,XMM2,XMM3,PREFIX=VEX2
|00000018:C4E16958CB     | VADDPD XMM1,XMM2,XMM3,PREFIX=VEX3
|0000001D:62F1ED0858CB   | VADDPD XMM1,XMM2,XMM3,PREFIX=EVEX
|00000023:62F1ED4858CB   | VADDPD ZMM1,ZMM2,ZMM3,PREFIX=EVEX
|00000029:62F1E90858CB   | VADDPD ZMM1,ZMM2,ZMM3,PREFIX=MVEX</samp>

<h5 id="MASKeq"><a href="#InstructionModifiers">&uarr; MASK=</a></h5>
<p>Modifikátor <code>MASK=</code> (podobně jako <code>ZEROING=, EH=, SAE=, ROUND=, BCST=, OPER=</code>)
je aplikovatelný pouze s <em>Enhanced Advanced Vector eXtensions</em> (EVEX nebo MVEX).
MASK specifikuje, který <em>maskovací registr</em> je použit k řízení toho, které elementy (celá čísla nebo čísla s plovoucí tečkou)
mají být zapisována do cílového registru. Pouze ty elementy, jež mají nastaven odpovídající bit v maskovacím registru, budou zapsány.
Ostatní elementy jsou buď nulovány (pokud modifikátor <code>ZEROING=ON</code>) nebo zůstávají nezměněny (<code>ZEROING=OFF</code>).</p>
<p>Možné hodnoty parametru MASK= jsou <dfn>K0, K1, K2, K2, K3, K4, K5, K6, K7</dfn> nebo výraz vyhodnocený na číslo <dfn>0..7</dfn>.
Výchozí hodnota je <code>MASK=0</code>. Registr K0 je speciální, všechny jeho bity se berou jako nastavené,
takže maskování se neuplatňuje.</p>

<h5 id="ZEROINGeq"><a href="#InstructionModifiers">&uarr; ZEROING=</a></h5>
<p>Booleovský modifikátor <code>ZEROING=</code> určuje, zda elementy maskované obsahem maskovacího registru
by měly být <dfn>vynulovány</dfn> nebo ponechány beze změny, čemuž se říká <dfn>merging</dfn>.
Nemá význam, pokud je <code>MASK=K0</code> nebo pokud registr masky není vůbec specifikován.
Default je <code>ZEROING=OFF</code> (merging). Modifikátor lze aplikovat pouze s kódováním prefixu EVEX.</p>
<samp>|00000000:C5E958CB       | VADDPD XMM1,XMM2,XMM3        ; VADDPD je definován s VEX,MVEX,EVEX.
|00000004:62F1ED0C58CB   | VADDPD XMM1,XMM2,XMM3,MASK=4 ; Použití MASK= vynutí kódování prefixu EVEX.
|0000000A:62F1ED0C58CB   | VADDPD XMM1,XMM2,XMM3,MASK=K4,ZEROING=NO
|00000010:62F1ED8C58CB   | VADDPD XMM1,XMM2,XMM3,MASK=K4,ZEROING=YES</samp>

<h5 id="EHeq"><a href="#InstructionModifiers">&uarr; EH=</a></h5>
<p>Booleovský modifikátor <code>EH=</code> <dfn>(Eviction Hint)</dfn> lze aplikovat pouze na instrukce
zakódované s prefixem MVEX.
<code>EH=1</code> informuje CPU, že data jsou non-temporal a že patrně nebudou brzy znovu použita,
takže nemá význam je držet ve vyrovnávací paměti CPU. Týká se to pouze instrukcí typu registr-do paměti.</p>
<p>Hodnota EH je rovněž konzultována v instrukcích typu registr-do-registru, kde vybírá mezi
operacemi swizzle a statickým zaokrouhlováním.</p>

<h5 id="SAEeq"><a href="#InstructionModifiers">&uarr; SAE=</a></h5>
<p>Pokud je booleovský modifikátor <code>SAE=</code> <dfn>(Suppress All Exceptions)</dfn> zapnut,
instrukce nebude vyvolávat žádnou výjimku (přerušení) při operacích s plovoucí tečkou,
například když operovala s hodnotou <em>not-a-number</em>.
Instrukce s nastaveným <code>SAE=ON</code> se chová, jako by všechny bity registru MXCSR byly nastaveny.</p>
<p>V kódování EVEX je ve výchozím stavu SAE povoleno kdykoli je použito statické zaokrouhlování.
Toto chování nelze vypnout.</p>

<h5 id="ROUNDeq"><a href="#InstructionModifiers">&uarr; ROUND=</a></h5>
<p>Modifikátor <code>ROUND=</code> určuje statický <dfn>zaokrouhlovací mód</dfn>, lze jej aplikovat na instrukce
s prefixem EVEX nebo MVEX se <em>zaokrouhlovací sémantikou</em>, například pro konverzi
z dvojité na jednoduchou přesnost čísel s plovoucí tečkou.
Má čtyři možné hodnoty: <dfn>NEAR, UP, DOWN, ZERO</dfn> alias <dfn>N, U, D, Z</dfn>.</p>
<p>Statické zaokrouhlování je dostupné pouze v operacích typu registerZMM-do-registru ZMM,
ne pokud je některý operand v paměti nebo pokud jsou použity registry XMM nebo YMM.
Default je bez zaokrouhlování, v tom případě platí obecné zaokrouhlování řízené bity RM registru MXCSR.</p>

<h5 id="BCSTeq"><a href="#InstructionModifiers">&uarr; BCST=</a></h5>
<p>Booleovský modifikátor <code>BCST=</code> lze použít k povolení <dfn>data broadcasting</dfn> (vysílání) v operacích,
které čtou data z paměti. Pokud je <code>BCST=ENABLED</code>, zdrojový paměťový operand čte z paměti pouze jeden element
a jeho obsah je pak zkopírován (vyslán) do všech pozic cílového registru.</p>
<p>Výchozí stav je <code>BCST=OFF</code>. Broadcasting nelze použít u operací typu registr-do-registru.</p>
<samp>|00000000:62F16C48590E | VMULPS ZMM1,ZMM2,[RSI]           ; Vynásob 16 DWORD FP čísel v ZMM2 a 16 DWORD FP čísel na [RSI], ulož 16 součinů do ZMM1.
|00000006:62F16C58590E | VMULPS ZMM1,ZMM2,[RSI],BCST=ON   ; Vynásob 16 DWORD FP čísel v ZMM2 jedním FP číslem na [RSI], ulož 16 součinů do ZMM1.
|0000000C:62F16C4859CB | VMULPS ZMM1,ZMM2,ZMM3            ; Vynásob 16 DWORD FP čísel v ZMM2 a 16 DWORD FP čísel v ZMM3, ulož 16 součinů do ZMM1.
|00000012:62F16C7859CB | VMULPS ZMM1,ZMM2,ZMM3,ROUND=ZERO ; Totéž, zaokrouhli každý součin směrem k nule.</samp>

<h5 id="OPEReq"><a href="#InstructionModifiers">&uarr; OPER=</a></h5>
<p>Modifikátor <code>OPER=</code> kóduje druh <dfn>operace</dfn> prováděné za běhu se zdrojovým operandem.
Možné operace jsou <dfn>broadcasting, rounding, conversion, swizzling</dfn>.
Možnou hodnotou modifikátoru je číselný výraz vyhodnocený na číslo <dfn>0..7</dfn>.</p>
<p>Tato hodnota bude zakódována v bitech 6, 5, 4 32bitového prefixu EVEX nebo MVEX.
Bity jsou pojmenovány <b>S<sub>2</sub>, S<sub>1</sub>, S<sub>0</sub></b> ve specifikaci MVEX
<a class="EXTL" href="links.htm#IntelMVEX">[IntelMVEX]</a>, a <b>L', L, b</b> ve specifikaci EVEX
<a class="EXTL" href="links.htm#IntelAVX512">[IntelAVX512]</a>.
Tytéž bity jsou rovněž ovlivněny modifikátory <code>BCST=, ROUND=, SAE=</code> a šířkou registrů SIMD,
avšak přímé uvedení modifikátoru OPER= má vyšší prioritu, pokud by došlo ke konfliktu.</p>
<p>Modifikátor OPER= je jediný způsob, jak požadovat speciální konverzní nebo swizzle (míchací) operace pro instrukce
kódované pomocí MVEX a dostupné na Intel<sup>®</sup> Xeon Phi<sup>™</sup> procesoru.
Ne všechny operace z níže uvedené tabulky jsou dostupné u všech MVEX instrukcí,
dokumentace na <a class="EXTL" href="links.htm#IntelMVEX">[IntelMVEX]</a> by měla být prohlédnuta před použitím modifikátoru.</p>

<table><caption>Operace kódované s MVEX</caption>
<tr><th>OPER=</th><th>register-do-registru, EH=0</th><th>registr-do-registru, EH=1</th><th>paměť-do-registru</th><th>registr-do-paměti</th></tr>
<tr><th>0</th><td>no swizzle {dcba}</td><td>ROUND=NEAR,SAE=NO</td><td>no operation</td><td>no conversion</td></tr>
<tr><th>1</th><td>swap (inner) pairs {cdab}</td><td>ROUND=DOWN,SAE=NO</td><td>bcst 1 element {1to16} or {1to8}</td><td>not available</td></tr>
<tr><th>2</th><td>swap with two-away {badc}</td><td>ROUND=UP,SAE=NO</td><td>bcst 4 elements {4to16} or {4to8}</td><td>not available </td></tr>
<tr><th>3</th><td>cross-product swizzle {dacb}</td><td>ROUND=ZERO,SAE=NO</td><td>convert from {float16}</td><td>convert to {float16}</td></tr>
<tr><th>4</th><td>bcst <b>a</b> element across 4 {aaaa}</td><td>ROUND=NEAR,SAE=YES</td><td>convert from {uint8}</td><td>convert to {uint8}</td></tr>
<tr><th>5</th><td>bcst <b>b</b> element across 4 {bbbb}</td><td>ROUND=DOWN,SAE=YES</td><td>convert from {sint8}</td><td>convert to {sint8}</td></tr>
<tr><th>6</th><td>bcst <b>c</b> element across 4 {cccc}</td><td>ROUND=UP,SAE=YES</td><td>convert from {uint16}</td><td>convert to {uint16}</td></tr>
<tr><th>7</th><td>bcst <b>d</b> element across 4 {dddd}</td><td>ROUND=ZERO,SAE=YES</td><td>convert from {sint16}</td><td>convert to {sint16}</td></tr>
</table>

<table><caption>Operace kódované s EVEX</caption>
<tr><th>OPER=</th><th>registr-do-registru</th><th>paměť-do-registru</th></tr>
<tr><th>0</th><td>DATA=OWORD,SAE=NO</td><td>DATA=OWORD,BCST=OFF</td></tr>
<tr><th>1</th><td>DATA=ZWORD,SAE=YES,ROUND=NEAR</td><td>DATA=OWORD,BCST=ON</td></tr>
<tr><th>2</th><td>DATA=YWORD,SAE=NO</td><td>DATA=YWORD,BCST=OFF</td></tr>
<tr><th>3</th><td>DATA=ZWORD,SAE=YES,ROUND=DOWN</td><td>DATA=YWORD,BCST=ON</td></tr>
<tr><th>4</th><td>DATA=ZWORD,SAE=NO</td><td>DATA=ZWORD,BCST=OFF</td></tr>
<tr><th>5</th><td>DATA=ZWORD,SAE=YES,ROUND=UP</td><td>DATA=ZWORD,BCST=ON</td></tr>
<tr><th>6</th><td>reserved</td><td>reserved</td></tr>
<tr><th>7</th><td>DATA=ZWORD,SAE=YES,ROUND=ZERO</td><td>reserved</td></tr>
</table>
<samp>|00000000:62F16908DB4D01&lt;6 | VPANDD ZMM1,ZMM2,[RBP+40h],PREFIX=MVEX,OPER=0 ; No broadcast                 {16to16}.
|00000007:62F16918DB4D10&lt;2 | VPANDD ZMM1,ZMM2,[RBP+40h],PREFIX=MVEX,OPER=1 ; Vysílej jeden element        {1to16}.
|0000000E:62F16928DB4D04&lt;4 | VPANDD ZMM1,ZMM2,[RBP+40h],PREFIX=MVEX,OPER=2 ; Vysílej čtyři elementy       {4to16}.
|00000015:62F16948DB4D04&lt;4 | VPANDD ZMM1,ZMM2,[RBP+40h],PREFIX=MVEX,OPER=4 ; Konvertuj z {uint8}.
|0000001C:62F16958DB4D04&lt;4 | VPANDD ZMM1,ZMM2,[RBP+40h],PREFIX=MVEX,OPER=5 ; Konvertuj z {sint8}.
|00000023:62F16968DB4D02&lt;5 | VPANDD ZMM1,ZMM2,[RBP+40h],PREFIX=MVEX,OPER=6 ; Konvertuj z {uint16}.
|0000002A:62F16978DB4D02&lt;5 | VPANDD ZMM1,ZMM2,[RBP+40h],PREFIX=MVEX,OPER=7 ; Konvertuj z {sint16}.
|00000031:                 |
|00000031:62F1F9085A4D01&lt;6 | VCVTPD2PS ZMM1,[RBP+40h],PREFIX=MVEX,OPER=0 ; Bez vysílání                   {8to8}.
|00000038:62F1F9185A4D08&lt;3 | VCVTPD2PS ZMM1,[RBP+40h],PREFIX=MVEX,OPER=1 ; Vysílej jeden element          {1to8}.
|0000003F:62F1F9285A4D02&lt;5 | VCVTPD2PS ZMM1,[RBP+40h],PREFIX=MVEX,OPER=2 ; Vysílej čtyři elementy         {4to8}.
|00000046:                 |
|00000046:62F1F9085ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=0,OPER=0 ; Bez míchání                    {dcba}.
|0000004C:62F1F9185ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=0,OPER=1 ; Přehoď vnitřní páry            {cdab}.
|00000052:62F1F9285ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=0,OPER=2 ; Přehoď dva-pruč                {badc}.
|00000058:62F1F9385ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=0,OPER=3 ; Zamíchej křížový produkt       {dacb}.
|0000005E:62F1F9485ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=0,OPER=4 ; Vysílej element <b>a</b> do 4         {aaaa}.
|00000064:62F1F9585ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=0,OPER=5 ; Vysílej element <b>b</b> do 4         {bbbb}.
|0000006A:62F1F9685ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=0,OPER=6 ; Vysílej element <b>c</b> do 4         {cccc}.
|00000070:62F1F9785ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=0,OPER=7 ; Vysílej element <b>d</b> do 4         {dddd}.
|00000076:                 |
|00000076:62F1F9885ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=1,OPER=0 ; ROUND=NEAR,SAE=OFF {rn}.
|0000007C:62F1F9985ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=1,OPER=1 ; ROUND=DOWN,SAE=OFF {rd}.
|00000082:62F1F9A85ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=1,OPER=2 ; ROUND=UP,  SAE=OFF {ru}.
|00000088:62F1F9B85ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=1,OPER=3 ; ROUND=ZERO,SAE=OFF (rz).
|0000008E:62F1F9C85ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=1,OPER=4 ; ROUND=NEAR,SAE=ON  {rn-sae}.
|00000094:62F1F9D85ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=1,OPER=5 ; ROUND=DOWN,SAE=ON  {rd-sae}.
|0000009A:62F1F9E85ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=1,OPER=6 ; ROUND=UP,  SAE=ON  {ru-sae}.
|000000A0:62F1F9F85ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,EH=1,OPER=7 ; ROUND=ZERO,SAE=ON  {rz-sae}.
|000000A6:62F1F9F85ACA     | VCVTPD2PS ZMM1,ZMM2,PREFIX=MVEX,ROUND=ZERO,SAE=ON
|000000AC:62F1F9F85ACA     | VCVTPD2PS ZMM1,ZMM2,EH=1,ROUND=ZERO,SAE=ON</samp>

<h5 id="ALIGNeq"><a href="#InstructionModifiers">&uarr; ALIGN=</a></h5>
<p>Požadavek na zarovnání může být přidán ke kterékoli strojové instrukci
a také k pseudoinstrukcím
<a href="#D">D</a>, <a href="#PROC">PROC</a>, <a href="#PROC1">PROC1</a>, <a href="#STRUC">STRUC</a>.
V kapitole <a href="#Alignment">alignment</a> jsou uvedeny přípustné hodnoty.
Tento instrukční modifikátor má stejný efekt, jako by před instrukcí byla explicitní pseudoinstrukce <a href="#ALIGN">ALIGN</a>.</p>

<h5 id="NESTINGCHECKeq"><a href="#InstructionModifiers">&uarr; NESTINGCHECK=</a></h5>
<p>Tento modifikátor může být připojen pouze k pseudoinstrukcím
<a href="#PROC">PROC</a>, <a href="#PROC">ENDPROC</a>, <a href="#PROC1">PROC1</a>, <a href="#PROC1">ENDPROC1</a>.
Jeho hodnota je logická, default je <code>NESTINGCHECK=ON</code>. Vypnutí kontroly vnoření
vypíná chybové oznámení při nesouhlasu identifikátorů na začátku a konci bloku,
což je potřebné k zavedení vazeb mezi některými pseudoinstrukcemi.
Viz definici maker <a class="EXT" href="../maclib/stdcal32.htm#Procedure">Procedure</a> a
<a class="EXT" href="../maclib/stdcal32.htm#EndProcedure">EndProcedure</a> jako příklad.</p>

<h4 id="InstructionEnhancements"><a href="#MachineInstructions">&uarr; Vylepšení instrukcí</a></h4>
<h5><a href="#InsEnhFPU">Defaultní registry FPU &darr;</a></h5>
<h5><a href="#InsEnhStrings">Operandy řetězcových instrukcí &darr;</a></h5>
<h5><a href="#InsEnhXLAT">XLAT s odlišnou bází &darr;</a></h5>
<h5><a href="#InsEnhLOOP">LOOP s odlišným čítačem &darr;</a></h5>
<h5><a href="#InsEnhLOOPNear">NEAR a FAR LOOP a JrCXZ &darr;</a></h5>
<h5><a href="#InsEnhJccNear">NEAR a FAR Jcc &darr;</a></h5>
<h5><a href="#InsEnhMultipleOperands">Vícenásobné operandy PUSH, POP, INC, DEC &darr;</a></h5>
<h5><a href="#InsEnhAA">Operandy AAD, AAM &darr;</a></h5>
<h5><a href="#InsEnhTEST">TEST registru sám sebou &darr;</a></h5>
<h5><a href="#InsEnhShiftAndRotate">Druhý operand posuvů a rotací &darr;</a></h5>
<h5><a href="#InsEnhNOP">No-operation &darr;</a></h5>
<h5><a href="#InsEnhPINSR">Zdrojový registr PINSR &darr;</a></h5>
<h5><a href="#InsEnhBLEND">Třetí operand BLENDVPD, BLENDVPS, PBLENDVB &darr;</a></h5>
<h5><a href="#InsEnhMASKMOV">První operand MASKMOVQ, MASKMOVDQU &darr;</a></h5>
<h5><a href="#InsEnhVER">VERR, VERQ, LAR, LSL &darr;</a></h5>

<p>Některé instrukce architektury IA-64 pracují s pevně stanovenými registry.
&euro;ASM akceptuje dobrovolnou explicitní specifikaci takových registrů;
což poslouží jako dokumentace pro lidského čtenáře a může být také využito
ke specifikaci šířky adresy nebo k určení nedefaultního segmentového registru.</p>

<h5 id="InsEnhFPU"><a href="#InstructionEnhancements">&uarr; Defaultní registry FPU</a></h5>
<p>Unární instrukce FPU (jednotky s pohyblivou tečkou) s implicitní destinací ST0
mohou tento registr explicitně uvádět na místě prvního operandu, nebo jej mohou vynechat.
V mnoha dalších instrukcích FPU je defaultní cílový registr ST0
a defaultní zdrojový registr ST1, v tom případě jeden nebo oba operandy mohou být vynechány.
Viz ovladače instrukcí
<a class="EXT" href="../easource/iif.htm#IifFNOP">FNOP</a>,
<a class="EXT" href="../easource/iif.htm#IifFCMOVB">FCMOVB</a>,
<a class="EXT" href="../easource/iif.htm#IifFADD">FADD</a>,
<a class="EXT" href="../easource/iif.htm#IifFIADD">FIADD</a>,
<a class="EXT" href="../easource/iif.htm#IifFADDP">FADDP</a>,
<a class="EXT" href="../easource/iif.htm#IifFXCH">FXCH</a>,
<a class="EXT" href="../easource/iif.htm#IifFCOM">FCOM</a>.</p>

<samp>|00000000:000000000000F03F   |Mem  DQ 1.0
|00000008:                   |
|00000008:DAC1               | FCMOVB          ; ST0 = ST1 if Below.
|0000000A:DAC1               | FCMOVB ST0,ST1  ; ST0 = ST1 if Below.
|0000000C:                   |
|0000000C:DAC7               | FCMOVB ST0,ST7  ; ST0 = ST7 if Below.
|0000000E:DAC7               | FCMOVB ST7      ; ST0 = ST7 if Below.
|00000010:                   |
|00000010:D8C1               | FADD            ; ST0 += ST1.
|00000012:D8C1               | FADD ST0,ST1    ; ST0 += ST1.
|00000014:                   |
|00000014:DC05[00000000]     | FADD ST0,[Mem]  ; ST0 += [Mem].
|0000001A:DC05[00000000]     | FADD [Mem]      ; ST0 += [Mem].
|00000020:                   |
|00000020:DCC7               | FADD ST7,ST0    ; ST7 += ST0.
|00000022:DCC7               | FADD ST7        ; ST7 += ST0.
|00000024:                   |
|00000024:D9E9               | FLDL2T          ; ST0 = log<sub>2</sub>10.
|00000026:D9E9               | FLDL2T ST0      ; ST0 = log<sub>2</sub>10.</samp>

<h5 id="InsEnhStrings"><a href="#InstructionEnhancements">&uarr; Operandy řetězcových instrukcí</a></h5>
<p>Řetězcové instrukce implicitně adresují zdroj jako paměť <code>[DS:rSI]</code>
nebo port <code>DX</code>, a cíl jako paměť <code>[ES:rDI]</code> nebo port <code>DX</code>.
Vedle jejich bezoperandové verze &euro;ASM toleruje operandy explicitně určující tento zdroj a cíl
s možným přepsáním segmentu a změnou adresní šířky.</p>
<samp>|00000000:AC       | LODSB
|00000001:AC       | LODSB [DS:ESI] ; Defaultní segment je DS, addresní šířka je 32.
|00000002:2EAC     | LODSB [CS:ESI] ; Přepsání segmentu.
|00000004:67AC     | LODSB [SI]     ; Změna adresní šířky.
|00000006:         |
|00000006:AA       | STOSB
|00000007:AA       | STOSB [EDI]
|00000008:         |
|00000008:AE       | SCASB
|00000009:AE       | SCASB [EDI]
|0000000A:         |
|0000000A:A5       | MOVSD
|0000000B:A5       | MOVSD [EDI],[ESI]
|0000000C:2667A5   | MOVSD [DI],[ES:SI] ; Změna adresní šířky a cílového segmentu.
|0000000F:         |
|0000000F:666D     | INSW
|00000011:666D     | INSW  [ES:EDI],DX
|00000013:         |
|00000013:6E       | OUTSB
|00000014:6E       | OUTSB DX,[DS:ESI]
|00000015:2E6E     | OUTSB DX,[CS:ESI] ; Změna zdrojového segmentu.</samp>


<h5 id="InsEnhXLAT"><a href="#InstructionEnhancements">&uarr; XLAT s odlišnou bází</a></h5>
<p>Výchozí překladová tabulka je implicitně adresována jako <code>[DS:rBX]</code>.
&euro;ASM akceptuje volitelný paměťový operand, který může specifikovat přepsání segmentu
a odlišnou šířku bázového registru.</p>

<h5 id="InsEnhLOOP"><a href="#InstructionEnhancements">&uarr; LOOP s odlišným čítačem</a></h5>
<p>Registr smyčky LOOP může být specifikován jako nepovinný druhý operand.</p>

<samp>|00000000:D7       | XLAT
|00000001:D7       | XLATB          ; XLAT a XLATB jsou identické.
|00000002:D7       | XLATB [DS:EBX] ; Segment DS je default, přepis není potřeba.
|00000003:26D7     | XLATB [ES:EBX] ; Přepsání segmentu.
|00000005:67D7     | XLATB [BX]     ; Změna adresní šířky z 32 na 16 bitů.
|00000007:         |
|00000007:E2F6     | LOOP $-8
|00000009:E2F6     | LOOP $-8,ECX   ; Výchozí čítač ve 32bitovém módu je ECX.
|0000000B:67E2F5   | LOOP $-8,CX    ; Registr čítače (jeho adresní šířka) změněna na 16 bitů.</samp>


<h5 id="InsEnhLOOPNear"><a href="#InstructionEnhancements">&uarr; NEAR a FAR LOOP a JrCXZ</a></h5>
<p>Smyčky nejsou v &euro;ASM omezeny na krátkou vzdálenost -128..127.
Pokud je cíl skoku instrukcí <code>LOOP, LOOPcc, JCXZ, JECXZ, JRCXZ</code> FAR nebo NEAR,
&euro;ASM místo něj přeloží tři instrukce:</p>
<code class="PRE">LOOP $+2+2              ; Skoč na proxy-skok místo na originální cíl.
JMPS $+JMPSsize+JMPsize ; Přeskoč proxy-skok, jakmile smyčka skončila (rCX je nula).
JMP target              ; NEAR nebo FAR nepodmíněný proxy-skok na původní cíl.</code>
<samp>|[CODE1]                            |[CODE1] SEGMENT
|00000000:E366                      | JECXZ CloseLabel:
|00000002:E364                      | JECXZ CloseLabel:,DIST=SHORT
|00000004:E302EB05E95B000000        | JECXZ CloseLabel:,DIST=NEAR
|0000000D:E302EB07EA[68000000]{0000}| JECXZ CloseLabel:,DIST=FAR
|00000018:                          |
|00000018:E302EB05E947010000        | JECXZ DistantLabel:
|00000021:E302EB05E93E010000        | JECXZ DistantLabel:,DIST=SHORT
|## W2401 Modifier "DIST=SHORT" could not be obeyed in this instruction.
|0000002A:E302EB05E935010000        | JECXZ DistantLabel:,DIST=NEAR
|00000033:E302EB07EA[68010000]{0000}| JECXZ DistantLabel:,DIST=FAR
|0000003E:                          |
|0000003E:E302EB07EA[00000000]{0000}| JECXZ FarLabel:
|00000049:E302EB07EA(00000000){0000}| JECXZ FarLabel:,DIST=SHORT
|## W2401 Modifier "DIST=SHORT" could not be obeyed in this instruction.
|00000054:E302EB05E9(00000000)      | JECXZ FarLabel:,DIST=NEAR
|0000005D:E302EB07EA[00000000]{0000}| JECXZ FarLabel:,DIST=FAR
|00000068:                          |CloseLabel:
|00000068:909090909090909090909090~~|  DB 256 * B 0x90 ; Kód k oddálení DistantLabel.
|00000168:                          |DistantLabel:
|[CODE2]                            |[CODE2] SEGMENT
|00000000:                          |FarLabel:</samp>

<h5 id="InsEnhJccNear"><a href="#InstructionEnhancements">&uarr; NEAR a FAR Jcc</a></h5>
<p>Podmíněný skok na vzdálenost překračující bajtový limit -128..127 byl zaveden s generací procesoru 386.
Pokud má náš program běžet také na starších CPU,
NEAR a FAR podmíněný skok bude EuroAssemblerem přeložen jako dvě instrukce:</p>
<code class="PRE">J!cc $+J!ccsize+JMPsize ; Přeskoč proxy-skok, pokud platí invertovaná podmínka
JMP target              ; NEAR nebo FAR nepodmíněný skok na původní cíl.</code>
<p>Proxy-skok namísto standardního NEAR podmíněného skoku existujícího v CPU=386
bude  přeložen, jsou-li splněny tři podmínky:<ol>
<li>Vzdálenost do cíle přesahuje bajtový rozsah,</li>
<li>šířka segmentu je 16 bitů,</li>
<li>volba EUROASM CPU= je 286 nebo nižší.</li></ol>
<samp>|[CODE1]                |[CODE1] SEGMENT WIDTH=16
|                       | EUROASM CPU=386
|0000:7419              | JE CloseLabel:   ; Standardní SHORT podmíněný skok.
|0002:0F841501          | JE DistantLabel: ; Standardní NEAR podmíněný skok, dostupný na CPU=386 a novějších.
|0006:7505EA[0000]{0000}| JE FarLabel:     ; FAR nepodmíněný proxy-skok přeskočený invertovaným J!cc.
|                       | EUROASM CPU=086  ; Následující instrukce by měly běhat i na starých strojích typu PC/XT.
|000D:740C              | JE CloseLabel:   ; Standardní SHORT podmíněný skok.
|000F:7503E90701        | JE DistantLabel: ; NEAR nepodmíněný proxy-skok přeskočený invertovaným J!cc.
|0014:7505EA[0000]{0000}| JE FarLabel:     ;  FAR nepodmíněný proxy-skok přeskočený invertovaným J!cc.
|001B:                  |CloseLabel:
|001B:9090909090909090~~|  DB 256 * B 0x90 ; Kód k oddálení DistantLabel.
|011B:                  |DistantLabel:
|[CODE2]                |[CODE2] SEGMENT
|0000:                  |FarLabel:</samp>

<h5 id="InsEnhMultipleOperands"><a href="#InstructionEnhancements">&uarr; Vícenásobné operandy PUSH, POP, INC, DEC</a></h5>
<p>Ve většině asemblerů mohou mít instrukce PUSH, POP, INC, DEC právě jeden operand.
&euro;ASM neomezuje počet operandů, jsou prováděny jeden za druhým ve specifikovaném pořadí.
Je-li použit instrukční modifikátor nebo přípona, bude aplikována na všechny operandy.
<samp>|00000000:57FF370FA06A04   | PUSH EDI,[EDI],FS,4
|00000007:590FA18F0658     | POP  ECX,FS,[ESI],EAX
|0000000D:40FF07           | INC  EAX,[EDI],DATA=DWORD
|00000010:48664AFEC9       | DEC  EAX,DX,CL</samp>

<h5 id="InsEnhAA"><a href="#InstructionEnhancements">&uarr; Operandy AAD, AAM</a></h5>
<p>Instrukce <a class="EXT" href="../easource/iig.htm#IigAAD">AAD</a>
a <a class="EXT" href="../easource/iig.htm#IigAAM">AAM</a> používají jako výchozí radix číslo 10
pro adjustování AL před dělením nebo po násobení čísel uložených ve formátu BCD.
V &euro;ASM tyto operace akceptují volitelný 8bitový operand, např. <code>AAD 16</code>.
<samp>|00000000:D40A  | AAM
|00000002:D40A  | AAM 10
|00000004:D410  | AAM 16
|00000006:D50A  | AAD
|00000008:D50A  | AAD 10
|0000000A:D510  | AAD 16</samp>

<h5 id="InsEnhTEST"><a href="#InstructionEnhancements">&uarr; TEST registru sám sebou</a></h5>
<p>Pokud oba operandy instrukce TEST určují tentýž registr, druhý operand může být vynechán.</p>

<h5 id="InsEnhShiftAndRotate"><a href="#InstructionEnhancements">&uarr; Druhý operand posuvů a rotací</a></h5>
<p>Je-li počet bitů, o který se má rotovat nebo posouvat v instrukcích
RCL, ROL, SAL, SHL, RCR, ROR, SAR, SHR roven jedné, druhý operand může být vynechán.</p>
<samp>|00000000:85D2     | TEST EDX,EDX
|00000002:85D2     | TEST EDX     ; Druhý operand TEST je defaultně identický s prvním.
|00000004:         |
|00000004:D1D0     | RCL EAX,1
|00000006:D1D0     | RCL EAX      ; Vynechaný počet bitů je roven jedné.
|00000008:D165F8   | SHL [EBP-8],1,DATA=DWORD
|0000000B:D165F8   | SHL [EBP-8],DATA=DWORD</samp>

<h5 id="InsEnhNOP"><a href="#InstructionEnhancements">&uarr; No-operation</a></h5>
<p>Instrukce, která nedělá nic (no-operation) kromě zabírání určitého času a zvětšování IP registru
je ve všech x86 procesorech implementována jako jednobajtový NOP, konkrétně <code>XCHG rAX,rAX</code> (operační kód 0x90).
Počínaje Pentium II (<code>CPU=686</code>) Intel zavedl dedikované mnohobajtové NOP instrukce
s kódy 0x18..0x1F prefixované 0x0F.
Mnohobajtový NOP je k zarovnávání vhodnější než série jednobajtových NOPů,
neboť se z paměti načítá jako jeden celek najednou.
Na starších CPU tento NOP musí být emulován staršími instrukcemi, jako <code>XCHG reg,reg</code> nebo <code>LEA reg,[reg]</code>.</p>
<p><a class="EXTL" href="../eadoc/links.htm#Sandpile">[Sandpile]</a> a <a class="EXTL" href="../eadoc/links.htm#NasmInsns">[NasmInsns]</a>
definují jejich mnemoniky jako nedokumentované instrukce <code>HINT_NOP0, HINT_NOP1, HINT_NOP2..63</code>.
s jedním operandem požadované délky.
Namísto zahlcení seznamu instrukcí 64 novými mnemonikami zavádí &euro;ASM
pouze jednu mnemoniku <code>HINT_NOP</code> (s možnými příponami <code>HINT_NOPW, HINT_NOPD, HINT_NOPQ</code>)
s ordinálním číslem definovaným v prvním operandu a specifikací paměti odsunutou na místo druhého operandu.</p>

<samp>|00000000:0F18D9             | HINT_NOP  03q,ECX
|00000003:660F18E1           | HINT_NOP  04q,CX
|00000007:66670F182C         | HINT_NOPW 05q,[SI]
|0000000C:66670F187400       | HINT_NOPW 06q,[SI],DISP=BYTE
|00000012:0F18BE00000000     | HINT_NOPD 07q,[ESI],DISP=DWORD
|00000019:0F19043500000000   | HINT_NOPD 10q,[1*ESI],DISP=DWORD,SCALE=VERBATIM
|00000021:                   |
|00000021:90                 | NOP1
|00000022:6690               | NOP2
|00000024:0F1F00             | NOP3
|00000027:0F1F4000           | NOP4
|0000002B:0F1F442000         | NOP5
|00000030:660F1F442000       | NOP6
|00000036:0F1F8000000000     | NOP7
|0000003D:0F1F842000000000   | NOP8
|00000045:660F1F842000000000 | NOP9</samp>
<p>Kromě toho &euro;ASM implementuje ještě bezoperandové instrukce <code>NOP1, NOP2, NOP3, NOP4, NOP5, NOP6, NOP7, NOP8, NOP9</code>
zabírající specifikovaný počet bajtů a respektující aktuální úroveň a mód CPU.</p>

<table class="SMALL" id="TableNOP"><caption>No-operation encoding</caption>
<tr><th>Mnemonika</th><th>Operační kód (hexa)</th><th>Ekvivalentní instrukce v syntaxi &euro;ASM</th></tr>
<tr><th colspan="3">16bit mode, CPU=086</th></tr>
<tr><td>NOP1</td><td>90</td><td>XCHG AX,AX</td></tr>
<tr><td>NOP2</td><td>87C9</td><td>XCHG CX,CX</td></tr>
<tr><td>NOP3</td><td>9087C9</td><td>XCHG AX,AX ; XCHG CX,CX</td></tr>
<tr><td>NOP4</td><td>87C987D2</td><td>XCHG CX,CX ; XCHG DX,DX</td></tr>
<tr><td>NOP5</td><td>9087C987D2</td><td>XCHG AX,AX ; XCHG CX,CX ; XCHG DX,DX</td></tr>
<tr><td>NOP6</td><td>87C987D287DB</td><td>XCHG CX,CX ; XCHG DX,DX ; XCHG BX,BX</td></tr>
<tr><td>NOP7</td><td>9087C987D287DB</td><td>XCHG AX,AX ; XCHG CX,CX ; XCHG DX,DX ; XCHG BX,BX</td></tr>
<tr><td>NOP8</td><td>87C987D287DB87E4</td><td>XCHG CX,CX ; XCHG DX,DX ; XCHG BX,BX ; XCHG SP,SP</td></tr>
<tr><td>NOP9</td><td>9087C987D287DB87E4</td><td>XCHG AX,AX ; XCHG CX,CX ; XCHG DX,DX ; XCHG BX,BX ; XCHG SP,SP</td></tr>
<tr><th colspan="3">16bit mode, CPU=686</th></tr>
<tr><td>NOP1</td><td>90</td><td>NOP DATA=WORD</td></tr>
<tr><td>NOP2</td><td>6690</td><td>OTOGGLE NOP</td></tr>
<tr><td>NOP3</td><td>666790</td><td>OTOGGLE ATOGGLE NOP</td></tr>
<tr><td>NOP4</td><td>670F1F00</td><td>NOP [EAX],DATA=WORD</td></tr>
<tr><td>NOP5</td><td>670F1F4000</td><td>NOP [EAX],DATA=WORD,DISP=BYTE</td></tr>
<tr><td>NOP6</td><td>670F1F442000</td><td>NOP [EAX+0*EAX],DATA=WORD,SCALE=VERBATIM,DISP=BYTE</td></tr>
<tr><td>NOP7</td><td>66670F1F442000</td><td>NOP [EAX+0*EAX],DATA=DWORD,SCALE=VERBATIM,DISP=BYTE</td></tr>
<tr><td>NOP8</td><td>670F1F8000000000</td><td>NOP [EAX],DATA=WORD,DISP=DWORD</td></tr>
<tr><td>NOP9</td><td>670F1F842000000000</td><td>NOP [EAX+0*EAX],DATA=WORD,SCALE=VERBATIM,DISP=DWORD</td></tr>
<tr><th colspan="3">32bit mode, CPU=386</th></tr>
<tr><td>NOP1</td><td>90</td><td>XCHG EAX,EAX,DATA=DWORD</td></tr>
<tr><td>NOP2</td><td>6690</td><td>XCHG AX,AX,DATA=WORD</td></tr>
<tr><td>NOP3</td><td>8D4000</td><td>LEA EAX,[EAX],DATA=DWORD</td></tr>
<tr><td>NOP4</td><td>8D442000</td><td>LEA EAX,[EAX+0*EAX],DATA=DWORD,SCALE=VERBATIM,DISP=BYTE</td></tr>
<tr><td>NOP5</td><td>3E8D442000</td><td>LEA EAX,[DS:EAX+0*EAX],DATA=DWORD,SCALE=VERBATIM,DISP=BYTE</td></tr>
<tr><td>NOP6</td><td>8D8000000000</td><td>LEA EAX,[EAX],DATA=DWORD,DISP=DWORD</td></tr>
<tr><td>NOP7</td><td>8D842000000000</td><td>LEA EAX,[EAX+0*EAX],DATA=DWORD,SCALE=VERBATIM,DISP=DWORD</td></tr>
<tr><td>NOP8</td><td>3E8D842000000000</td><td>LEA EAX,[DS:EAX+0*EAX],DATA=DWORD,SCALE=VERBATIM,DISP=DWORD</td></tr>
<tr><td>NOP9</td><td>663E8D842000000000</td><td>LEA AX,[DS:EAX+0*EAX],DATA=WORD,SCALE=VERBATIM,DISP=DWORD</td></tr>
<tr><th colspan="3">32bit mode, CPU=686</th></tr>
<tr><td>NOP1</td><td>90</td><td>NOP DATA=DWORD</td></tr>
<tr><td>NOP2</td><td>6690</td><td>NOP DATA=WORD</td></tr>
<tr><td>NOP3</td><td>0F1F00</td><td>NOP [EAX],DATA=DWORD</td></tr>
<tr><td>NOP4</td><td>0F1F4000</td><td>NOP [EAX],DATA=DWORD,DISP=BYTE</td></tr>
<tr><td>NOP5</td><td>0F1F442000</td><td>NOP [EAX+0*EAX],DATA=DWORD,SCALE=VERBATIM,DISP=BYTE</td></tr>
<tr><td>NOP6</td><td>660F1F442000</td><td>NOP [EAX+0*EAX],DATA=WORD,SCALE=VERBATIM,DISP=BYTE</td></tr>
<tr><td>NOP7</td><td>0F1F8000000000</td><td>NOP [EAX],DATA=DWORD,DISP=DWORD</td></tr>
<tr><td>NOP8</td><td>0F1F842000000000</td><td>NOP [EAX+0*EAX],DATA=DWORD,SCALE=VERBATIM,DISP=DWORD</td></tr>
<tr><td>NOP9</td><td>660F1F842000000000</td><td>NOP [EAX+0*EAX],DATA=WORD,SCALE=VERBATIM,DISP=DWORD</td></tr>
<tr><th colspan="3">64bit mode, CPU=X64</th></tr>
<tr><td>NOP1</td><td>90</td><td>NOP DATA=DWORD</td></tr>
<tr><td>NOP2</td><td>6690</td><td>NOP DATA=WORD</td></tr>
<tr><td>NOP3</td><td>0F1F00</td><td>NOP [RAX],DATA=DWORD</td></tr>
<tr><td>NOP4</td><td>0F1F4000</td><td>NOP [RAX],DATA=DWORD,DISP=BYTE</td></tr>
<tr><td>NOP5</td><td>0F1F442000</td><td>NOP [RAX+0*RAX],DATA=DWORD,SCALE=VERBATIM,DISP=BYTE</td></tr>
<tr><td>NOP6</td><td>660F1F442000</td><td>NOP [RAX+0*RAX],DATA=WORD,SCALE=VERBATIM,DISP=BYTE</td></tr>
<tr><td>NOP7</td><td>0F1F8000000000</td><td>NOP [RAX],DATA=DWORD,DISP=DWORD</td></tr>
<tr><td>NOP8</td><td>0F1F842000000000</td><td>NOP [RAX+0*RAX],DATA=DWORD,SCALE=VERBATIM,DISP=DWORD</td></tr>
<tr><td>NOP9</td><td>660F1F842000000000</td><td>NOP [RAX+0*RAX],DATA=WORD,SCALE=VERBATIM,DISP=DWORD</td></tr>
<tr><th>Mnemonika</th><th>Operační kód (hexa)</th><th>Ekvivalentní instrukce v syntaxi &euro;ASM</th></tr>
</table> <br class="CLEAR"/>

<h5 id="InsEnhPINSR"><a href="#InstructionEnhancements">&uarr; Zdrojový registr PINSR</a></h5>
<p>Instrukce PINSRB, PINSRW, PINSRD (vlož Byte/Word/Dword do cílového registru XMM)
akceptují jako zdrojový operand č.2 ne pouze obecný registr (GPR) odpovídající šířky,
ale i širší registr. Bude z něj použit pouze nejnižší BYTE|WORD|DWORD.</p>

<samp>|00000000:660F3A20C902   | PINSRB XMM1,CL,2
|00000006:660F3A20C902   | PINSRB XMM1,CX,2
|0000000C:660F3A20C902   | PINSRB XMM1,ECX,2
|00000012:               |
|00000012:660FC4C902     | PINSRW XMM1,CX,2
|00000017:660FC4C902     | PINSRW XMM1,ECX,2</samp>

<h5 id="InsEnhBLEND"><a href="#InstructionEnhancements">&uarr; Třetí operand BLENDVPS, BLENDVPD, PBLENDVB</a></h5>
<p>Instrukce proměnného mísení používá pevně implikovaný registr XMM0 jako maskovací registr.
&euro;ASM dovoluje explicitní specifikaci tohoto registru jako třetí operand.</p>

<samp>|00000000:660F3815CA     | BLENDVPD XMM1,XMM2
|00000005:660F3815CA     | BLENDVPD XMM1,XMM2,XMM0
|0000000A:               |
|0000000A:660F3814CA     | BLENDVPS XMM1,XMM2
|0000000F:660F3814CA     | BLENDVPS XMM1,XMM2,XMM0
|00000014:               |
|00000014:660F3810CA     | PBLENDVB XMM1,XMM2
|00000019:660F3810CA     | PBLENDVB XMM1,XMM2,XMM0</samp>

<h5 id="InsEnhMASKMOV"><a href="#InstructionEnhancements">&uarr; První operand MASKMOVQ, MASKMOVDQU</a></h5>
<p>Maskovatelné kopírování do paměti používá jako pevný cíl destinaci [DS:rDI].
&euro;ASM dovoluje explicitní specifikaci cílové paměti jako volitelný první operand.</p>
<samp>|00000000:0FF7CA         | MASKMOVQ MM1,MM2
|00000003:0FF7CA         | MASKMOVQ [DS:EDI],MM1,MM2 ; Defaultní destinace je [DS:EDI].
|00000006:260FF7CA       | MASKMOVQ [ES:EDI],MM1,MM2 ; Přepis segmentu.
|0000000A:               |
|0000000A:660FF7CA       | MASKMOVDQU XMM1,XMM2
|0000000E:660FF7CA       | MASKMOVDQU [DS:EDI],XMM1,XMM2 ; Defaultní destinace je [DS:EDI].
|00000012:26660FF7CA     | MASKMOVDQU [ES:EDI],XMM1,XMM2 ; Přepis segmentu.</samp>


<h5 id="InsEnhVER"><a href="#InstructionEnhancements">&uarr; VERR, VERW, LAR, LSL </a></h5>
<p>Segmentový deskriptor u systémových instrukcí VERR, VERW (operand 1) a LAR, LSL (operand 2)
může být specifikován jako 16bitová paměťová proměnná anebo 16, 32 nebo 64bitový obecný registr GPR (bude použito jen dolních 16 bitů).</p>

<samp>|00000000:0F00E6    | VERR SI
|00000003:0F00E6    | VERR ESI
|00000006:          |
|00000006:0F00EE    | VERW SI
|00000009:0F00EE    | VERW ESI
|0000000C:          |
|0000000C:660F02C6  | LAR AX,SI
|00000010:660F02C6  | LAR AX,ESI
|00000014:0F02C6    | LAR EAX,SI
|00000017:0F02C6    | LAR EAX,ESI
|0000001A:          |
|0000001A:660F03C6  | LSL AX,SI
|0000001E:660F03C6  | LSL AX,ESI
|00000022:0F03C6    | LSL EAX,SI
|00000025:0F03C6    | LSL EAX,ESI</samp>

<h4 id="UndocInstructions"><a href="#MachineInstructions">Nedokumentované instrukce &darr;</a></h4>
<p>&euro;ASM implementuje několik instrukcí, které nejsou dokumentovány v oficiálních specifikacích výrobců CPU.
Nemusejí fungovat se všemi generacemi procesorů a vyžadují explicitní volbu <code>EUROASM UNDOC=ENABLED</code>.</p>
<p>Pro informaci viz jejich obslužné procedury (handlery)
<a class="EXT" href="../easource/iic.htm#IicBB0_RESET">BB0_RESET</a>,
<a class="EXT" href="../easource/iig.htm#IigCMPXCHG486">CMPXCHG486</a>,
<a class="EXT" href="../easource/iif.htm#IifF4X4">F4X4</a>,
<a class="EXT" href="../easource/iif.htm#IifFCOM2">FCOM2</a>,
<a class="EXT" href="../easource/iif.htm#IifFCOMP5">FCOMP5</a>,
<a class="EXT" href="../easource/iif.htm#IifFFREEP">FFREEP</a>,
<a class="EXT" href="../easource/iif.htm#IifFMUL4X4">FMUL4X4</a>,
<a class="EXT" href="../easource/iif.htm#IifFNSETPM">FNSETPM</a>,
<a class="EXT" href="../easource/iif.htm#IifFRSTPM">FRSTPM</a>,
<a class="EXT" href="../easource/iif.htm#IifFSBP1">FSBP1</a>,
<a class="EXT" href="../easource/iif.htm#IifFSBP2">FSBP2</a>,
<a class="EXT" href="../easource/iif.htm#IifFSBP3">FSBP3</a>,
<a class="EXT" href="../easource/iif.htm#IifFSTDW">FSTDW</a>,
<a class="EXT" href="../easource/iif.htm#IifFSTP1">FSTP1</a>,
<a class="EXT" href="../easource/iif.htm#IifFSTP8">FSTP8</a>,
<a class="EXT" href="../easource/iif.htm#IifFSTP9">FSTP9</a>,
<a class="EXT" href="../easource/iif.htm#IifFSTSG">FSTSG</a>,
<a class="EXT" href="../easource/iif.htm#IifFXCH4">FXCH4</a>,
<a class="EXT" href="../easource/iif.htm#IifFXCH7">FXCH7</a>,
<a class="EXT" href="../easource/iis.htm#IisHCF">HCF</a>,
<a class="EXT" href="../easource/iis.htm#IisHINT_NOP">HINT_NOP</a>,
<a class="EXT" href="../easource/iis.htm#IisIBTS">IBTS</a>,
<a class="EXT" href="../easource/iig.htm#IigICEBP">ICEBP</a>,
<a class="EXT" href="../easource/iig.htm#IigINT1">INT1</a>,
<a class="EXT" href="../easource/iis.htm#IisJMPE">JMPE</a>,
<a class="EXT" href="../easource/iis.htm#IisLOADALL">LOADALL</a>,
<a class="EXT" href="../easource/iis.htm#IisLOADALL286">LOADALL286</a>,
<a class="EXT" href="../easource/iis.htm#IisPREFETCHWT1">PREFETCHWT1</a>,
<a class="EXT" href="../easource/iig.htm#IigPSRAQ">PSRAQ</a>,
<a class="EXT" href="../easource/iig.htm#IigSAL2">SAL2</a>,
<a class="EXT" href="../easource/iig.htm#IigSALC">SALC</a>,
<a class="EXT" href="../easource/iig.htm#IigSETALC">SETALC</a>,
<a class="EXT" href="../easource/iic.htm#IicSMINTOLD">SMINTOLD</a>,
<a class="EXT" href="../easource/iig.htm#IigTEST2">TEST2</a>,
<a class="EXT" href="../easource/iis.htm#IisUD0">UD0</a>,
<a class="EXT" href="../easource/iis.htm#IisUD1">UD1</a>,
<a class="EXT" href="../easource/iis.htm#IisUD2A">UD2A</a>,
<a class="EXT" href="../easource/iig.htm#IigUMOV">UMOV</a>,
<a class="EXT" href="../easource/iis.htm#IisXBTS">XBTS</a>,
<a class="EXT" href="../easource/iiy.htm#IiyVLDQQU">VLDQQU</a>.</p>

<h3 id="PseudoInstructions" title="Pseudoinstructions"><a href="#Instructions">&uarr; Pseudoinstrukce</a></h3>
<h4><a href="#ALIGN">ALIGN &darr;</a></h4>
<h4><a href="#D">D, DB, DU, DW, DD, DQ, DT, DO, DY, DZ, DI, DS &darr;</a></h4>
<h4><a href="#ENDHEAD">ENDHEAD &darr;</a></h4>
<h4><a href="#ENDP">ENDP &darr;</a></h4>
<h4><a href="#ENDP1">ENDP1 &darr;</a></h4>
<h4><a href="#ENDPROC">ENDPROC &darr;</a></h4>
<h4><a href="#ENDPROC1">ENDPROC1 &darr;</a></h4>
<h4><a href="#ENDPROGRAM">ENDPROGRAM &darr;</a></h4>
<h4><a href="#ENDSTRUC">ENDSTRUC &darr;</a></h4>
<h4><a href="#EQU">EQU &darr;</a></h4>
<h4><a href="#eq">= &darr;</a></h4>
<h4><a href="#EUROASM">EUROASM &darr;</a></h4>
<h4><a href="#EXTERN">EXTERN &darr;</a></h4>
<h4><a href="#EXPORT">EXPORT &darr;</a></h4>
<h4><a href="#GLOBAL">GLOBAL &darr;</a></h4>
<h4><a href="#GROUP">GROUP &darr;</a></h4>
<h4><a href="#HEAD">HEAD &darr;</a></h4>
<h4><a href="#IMPORT">IMPORT&darr;</a></h4>
<h4><a href="#INCLUDE">INCLUDE &darr;</a></h4>
<h4><a href="#INCLUDE1">INCLUDE1 &darr;</a></h4>
<h4><a href="#INCLUDEBIN">INCLUDEBIN &darr;</a></h4>
<h4><a href="#INCLUDEHEAD">INCLUDEHEAD &darr;</a></h4>
<h4><a href="#INCLUDEHEAD1">INCLUDEHEAD1 &darr;</a></h4>
<h4><a href="#LINK">LINK &darr;</a></h4>
<h4><a href="#PROC">PROC &darr;</a></h4>
<h4><a href="#PROC1">PROC1 &darr;</a></h4>
<h4><a href="#PROGRAM">PROGRAM &darr;</a></h4>
<h4><a href="#PUBLIC">PUBLIC &darr;</a></h4>
<h4><a href="#SEGMENT">SEGMENT &darr;</a></h4>
<h4><a href="#STRUC">STRUC &darr;</a></h4>
<h4><a href="#pcCOMMENT">%COMMENT &darr;</a></h4>
<h4><a href="#pcDEBUG">%DEBUG &darr;</a></h4>

<h4><a href="#pcDISPLAY">%DISPLAY &darr;</a></h4>
<h4><a href="#pcDROPMACRO">%DROPMACRO &darr;</a></h4>
<h4><a href="#pcELSE">%ELSE &darr;</a></h4>
<h4><a href="#pcENDCOMMENT">%ENDCOMMENT &darr;</a></h4>
<h4><a href="#pcENDFOR">%ENDFOR &darr;</a></h4>
<h4><a href="#pcENDIF">%ENDIF &darr;</a></h4>
<h4><a href="#pcENDMACRO">%ENDMACRO &darr;</a></h4>
<h4><a href="#pcENDREPEAT">%ENDREPEAT &darr;</a></h4>
<h4><a href="#pcENDWHILE">%ENDWHILE</a></h4>
<h4><a href="#pcERROR">%ERROR &darr;</a></h4>
<h4><a href="#pcEXITFOR">%EXITFOR &darr;</a></h4>
<h4><a href="#pcEXITMACRO">%EXITMACRO &darr;</a></h4>
<h4><a href="#pcEXITREPEAT">%EXITREPEAT &darr;</a></h4>
<h4><a href="#pcEXITWHILE">%EXITWHILE</a></h4>
<h4><a href="#pcFOR">%FOR &darr;</a></h4>
<h4><a href="#pcIF">%IF &darr;</a></h4>
<h4><a href="#pcMACRO">%MACRO &darr;</a></h4>
<h4><a href="#pcPROFILE">%PROFILE &darr;</a></h4>
<h4><a href="#pcREPEAT">%REPEAT &darr;</a></h4>
<h4><a href="#pcSET">%SET &darr;</a></h4>
<h4><a href="#pcSETA">%SETA &darr;</a></h4>
<h4><a href="#pcSETB">%SETB &darr;</a></h4>
<h4><a href="#pcSETC">%SETC &darr;</a></h4>
<h4><a href="#pcSETE">%SETE &darr;</a></h4>
<h4><a href="#pcSETL">%SETL &darr;</a></h4>
<h4><a href="#pcSETS">%SETS &darr;</a></h4>
<h4><a href="#pcSETX">%SETX &darr;</a></h4>
<h4><a href="#pcSET2">%SET2 &darr;</a></h4>
<h4><a href="#pcSHIFT">%SHIFT &darr;</a></h4>
<h4><a href="#pcUNTIL">%UNTIL &darr;</a></h4>
<h4><a href="#pcWHILE">%WHILE</a></h4>
<p><dfn id="Derectives" title="Directives">Pseudoinstrukce</dfn> (také se jim říká <dfn>direktivy</dfn>)
jsou příkazy asembleru formálně podobné běžným strojovým instrukcím
&mdash; mnoho z nich může mít pole návěstí a operandy.
Některé pseudoinstrukce (ALIGN a D) mohou dokonce emitovat data a kód.</p>
<h6>U jmen pseudoinstrukcí a jejich klíčových operandů nezáleží na velikosti písmen.</h6>

<hr/>
<h4 id="EUROASM"><a href="#PseudoInstructions">&uarr; EUROASM</a></h4>
<h5><a href="#AUTOALIGNeq">AUTOALIGN= &darr;</a></h5>
<h5><a href="#AUTOSEGMENTeq">AUTOSEGMENT= &darr;</a></h5>
<h5><a href="#CODEPAGEeq">CODEPAGE= &darr;</a></h5>
<h5><a href="#CPUeq">CPU= &darr;</a></h5>
<h5><a href="#CPUfeatures"><em>Rozšíření CPU</em> <small>ABM=, AES=, AMD=, AVX=, AVX512=, CET=, CYRIX=, D3NOW=, EVEX=, FMA=, FPU=, LWP=, MMX=, MPX=, MVEX=, PRIV=, PROT=, RTM=, SGX=, SHA=, SPEC=, SVM=, TSX=, UNDOC=, VIA=, VMX=, XOP= &darr;</small></a></h5>
<h5><a href="#DEBUGeq">DEBUG= &darr;</a></h5>
<h5><a href="#DISPLAYENCeq">DISPLAYENC= &darr;</a></h5>
<h5><a href="#DISPLAYSTMeq">DISPLAYSTM= &darr;</a></h5>
<h5><a href="#DUMPALLeq">DUMPALL= &darr;</a></h5>
<h5><a href="#DUMPeq">DUMP= &darr;</a></h5>
<h5><a href="#DUMPWIDTHeq">DUMPWIDTH= &darr;</a></h5>
<h5><a href="#INCLUDEPATHeq">INCLUDEPATH= &darr;</a></h5>
<h5><a href="#LINKPATHeq">LINKPATH= &darr;</a></h5>
<h5><a href="#LISTeq">LIST= &darr;</a></h5>
<h5><a href="#LISTFILEeq">LISTFILE= &darr;</a></h5>
<h5><a href="#LISTINCLUDEeq">LISTINCLUDE= &darr;</a></h5>
<h5><a href="#LISTMACROeq">LISTMACRO= &darr;</a></h5>
<h5><a href="#LISTREPEATeq">LISTREPEAT= &darr;</a></h5>
<h5><a href="#LISTVAReq">LISTVAR= &darr;</a></h5>
<h5><a href="#MAXINCLUSIONSeq">MAXINCLUSIONS= &darr;</a></h5>
<h5><a href="#MAXLINKSeq">MAXLINKS= &darr;</a></h5>
<h5><a href="#NOWARNeq">NOWARN= &darr;</a></h5>
<h5><a href="#PROFILEeq">PROFILE= &darr;</a></h5>
<h5><a href="#RUNPATHeq">RUNPATH= &darr;</a></h5>
<h5><a href="#SIMDeq">SIMD= &darr;</a></h5>
<h5><a href="#UNICODEeq">UNICODE= &darr;</a></h5>
<h5><a href="#WARNeq">WARN= &darr;</a></h5>

<p>Pseuodinstrukcí EUROASM programátor ovlivňuje různá nastavení EuroAssembleru samotného
- <dfn>volby EUROASM</dfn>. Příslušná volba je určena klíčovým operandem.
Stejné klíče jsou použity také v sekci <code>[EUROASM]</code> konfiguračního souboru
<a class="EXT" href="../objlib/euroasm.ini">euroasm.ini</a>.</p>
<p>Volby specifikované touto pseudoinstrukcí přepisují defaultní volby z konfiguračního souboru.
Jména voleb nezávisí na velikosti písmen.</p>
<p>Aktuální hodnota každé volby může být získána pomocí
<a href="#SystemVariablesEUROASM">EUROASM systémových %^proměnných</a> se shodným jménem, například
<code> InfoMsg DB "This program uses code page %^CODEPAGE.",13,10,0</code></p>
<p>Volbám očekávajícím booleovskou hodnotu může být předloženo výčtové slovo <code>TRUE, YES, ON, ENABLE, ENABLED</code>
nebo <code>FALSE, NO, OFF, DISABLE, DISABLED</code> nebo mohou obsahovat
<a href="#BooleanAlgebra">logický výraz</a>.</p>
<p>Vedle klíčových operandů pseudoinstrukce EUROASM rozeznává ještě dva pořadové operandy
s výčtovou hodnotou <dfn>PUSH</dfn> nebo <dfn>POP</dfn>.
&euro;ASM udržuje speciální <em>zásobník voleb</em> a tyto dvě direktivy dovolují
uschovat a obnovit celý soubor voleb EuroAssembleru na tento zásobník.
To se hodí u maker, které dočasně vyžadují nějakou neobvyklou volbu.
Slepé nastavení takové volby by mělo vedlejší efekt na instrukce následující po vyvolání makra
(EUROASM je <a href="#ProgStrucVerSwitch">přepínací instrukce</a>).
Proto je lepší uložit aktuální volby na jejich zásobník na počátku makra
a obnovit je na jeho konci. Příklad:</p>
<pre>SomeMacro %MACRO  ; Definice makra.
            EUROASM PUSH, NOWARN=2102 ; Ulož všechny volby a pak potlač varování W2102.
             ; Tady budou instrukce, které mohou vyvolat W2102.
             ...
            EUROASM POP ; Obnov zásobník voleb, W2102 již není potlačena.
          %ENDMACRO SomeMacro
</pre>

<h5 id="AUTOALIGNeq"><a href="#EUROASM">&uarr; AUTOALIGN=</a></h5>
<p>Booleovská volba s výchozí hodnotou <code>AUTOALIGN=ON</code>. Paměťové proměnné
definované nebo rezervované pseudoinstrukcí <a href="#D">D</a> budou implicitně zarovnány
v souladu se svým typem (<a href="#DataTypes">TYPE#</a>).</p>
<blockquote><p>K zarovnaným proměnným může CPU přistupovat rychleji,
na druhé straně tato volba může nafouknout velikost programu, pokud jsou data různých typů
často mísena. Je proto lepší manuálně seskupovat datové položky stejných velikostí.</blockquote>
<h6>Proměnné definované jako <a href="#Literals">literály</a> jsou automaticky zarovnány
nezávisle na stavu <code>EUROASM AUTOALIGN=</code>.</h6>
<p>Strukturované datové proměnné (definované pomocí <code> DS <em>structure_name</em></code>)
se nezarovnávají podle svého největšího členu, jsou zarovnány na šířku segmentu
(WORD, DWORD or QWORD) pokud je AUTOALIGN=ENABLED.
<h6>Autoalignment nefunguje uvnitř definice struktury.</h6>
<p>Programátor by měl definovat strukturu s ohledem na přirozené zarovnání jejich členů.
To je zvláště důležité v 64bitovém módu, kde API vyžaduje zarovnaná data.
Během konverze špatně navržených 32bitových struktur se musely uměle vkládat výplňové členy
typu DWORD zarovnávající délky na QWORD a zaokrouhlující délku struktury na násobek osmi.
Viz například WinAPI strukturu <a class="EXT" href="../maclib/winsgui.htm#MSG">MSG</a>.</p>
<p>Autoalignment se neaplikuje na strojové instrukce.
Chcete-li proceduru zarovnanou na počátek stránky vyrovnávací paměti (kvůli lepší výkonnosti),
měla by být zarovnána explicitně, např.<code>Rapid PROC ALIGN=OWORD</code>.</p>


<h5 id="AUTOSEGMENTeq"><a href="#EUROASM">&uarr; AUTOSEGMENT=</a></h5>
<p>Booleovská volba s výchozí hodnotou <code>AUTOSEGMENT=ON</code>.
Sekce, do níž &euro;ASM emituje, je automaticky změněna, aby byla v souladu s účelem
(<a href="#SegmentPURPOSEeq">PURPOSE=</a>) segmentu.</p>
<p>Jedná-li se o <strong>strojovou instrukci</strong> nebo strojový prefix nebo <a href="#PROC">PROC</a>,
&euro;ASM přepne do naposledy definované sekce s účelem <strong>PURPOSE=CODE</strong>.
<br/>Podobně, pokud pseudoinstrukce D a její klony včetně <a href="#D">DI</a>
<strong>definuje nebo rezervuje data</strong>, současná sekce je přepnuta na poslední sekci
typu <strong>DATA nebo BSS</strong>.</p>
<p>Pseudoinstrukce <a href="#ALIGN">ALIGN</a>, <strong>makra a všechny neemitující operace</strong>,
jako např. <a href="#EQU">EQU</a> nebo samotné návěstí, <strong>nemění</strong> současnou sekci.</p>
<blockquote>Spoléháte-li na autosegmentaci, vyvarujte se případu, kdy nová sekce
začíná voláním makra, pseudoinstrukcí ALIGN nebo samotným návěstím. Takové povely
nepřepnou současnou sekci. Možná budete chtít vložit <code>NOP</code> nebo <code>PROC</code>
k přepnutí do kódové sekce, <code>DB 0</code> k přepnutí na data, anebo <code>DB</code> k přepnutí na BSS sekci.
Příklad:
<pre>      EUROASM AUTOSEGMENT=ON
Hello PROGRAM FORMAT=PE, ENTRY=Main:
       INCLUDE winapi.htm; Základní makra.
Title  DB "World!",0     ; <abbr>Korektně automaticky přepla do [.data].</abbr>
<del>Main:  StdOutput Title   ; <abbr>Makro nepřeplo do [.text], jak bylo asi očekáváno.</abbr></del>
       TerminateProgram
      ENDPROGRAM Hello   ; <abbr>Hello.exe zde nefunguje, neboť ENTRY je v sekci [.data]. </abbr></pre>
<p>Návěstí Main: chybně zůstalo v předchozí sekci [.data].
Náorava je prostá:<ul><li>vložit strojovou instrukci <code>Main: NOP</code></li>
<li>nebo vytvořit proceduru <code>Main: PROC</code></li>
<li>nebo přepnout ručně: <code>[.text]</code> nad řádkem <code>Main: StdOutput Title</code></li></ul>
<pre>      EUROASM AUTOSEGMENT=ON
Hello PROGRAM FORMAT=PE, ENTRY=Main:
       INCLUDE winapi.htm; Základní makra.
Title  DB "World!",0     ; <abbr>Korektně automaticky přepla do [.data].</abbr>
Main:  PROC              ; <abbr>Korektně automaticky přepla do [.text].</abbr>
        StdOutput Title
        TerminateProgram
       ENDPROC Main:
      ENDPROGRAM Hello   ; <abbr>Hello.exe works as expected.</abbr></pre>
</blockquote>
<h6>Každé explicitní přepnutí sekce zneplatní jako vedlejší efekt volbu AUTOSEGMENT.</h6>
<p>AUTOSEGMENT= je slabá volba, je automaticky vypínána, když programátor změní aktuální sekci
uvedením <code>[jména_sekce]</code> v poli návěstí.</p>
<blockquote>Potřebujete-li udržet AUTOSEGMENT zapnutý po ruční změně sekce,
musíte pak tuto volbu explicitně znovu zapnout pomocí <code>EUROASM AUTOSEGMENT=ON</code>,
anebo uložit její stav pomocí <code>EUROASM PUSH</code> a pak jej obnovit pomocí <code>EUROASM POP</code>.</blockquote>

<h5 id="CODEPAGEeq"><a href="#EUROASM">&uarr; CODEPAGE=</a></h5>
<p>&euro;ASM umí používat řetězce v Unicode za běhu programu, ale definice dat ve zdrojovém kódu
je i tak definována v bajtech. Volba CODEPAGE= říká EuroAssembleru. která kódová stránka by měla být aktuálně použita
k převodu bajtů zdrojového kódu na Unicode v asm-time.</p>
<p>Kódová stránka může být určena přímou 16bitovou celočíselnou hodnotou podle
<a class="EXTL" href="../eadoc/links.htm#CodePageMS">[CodePageMS]</a>,
např. <code>CODEPAGE=1253</code> pro řeckou abecedu.</p>

<p>Hodnoty CODEPAGE= mohou být rovněž určeny jako výčtové slovo, např.
<code>CODEPAGE=CP852, CODEPAGE=WINDOWS-1252, CODEPAGE=ISO-8859-2</code> atd.
Pro kompletní seznam viz <a class="EXT" href="../easource/dict.htm#DictCodePages">DictCodePages</a>
U jmen těchto specifikací nezáleží na velikosti písmen.</p>
<blockquote>Přestože některé tyto konstanty mohou vypadat jako aritmetické rozdíly,
jsou rozeznávány doslova a nejsou vyhodnocovány jako čísla.</blockquote>
<p>Výchozí a zároveň doporučená hodnota je <code>CODEPAGE=UTF-8</code>.
Viz též <a href="#ProgStrucCharCode">kódování znaků</a> výše.</p>

<h5 id="INCLUDEPATHeq"><a href="#EUROASM">&uarr; INCLUDEPATH=</a></h5>
<p>Jestliže je v pseudoinstrukci z rodiny INCLUDE* specifikován soubor bez cesty,
&euro;ASM jej bude hledat v adresářích definovaných ve volbě <code>EUROASM INCLUDEPATH=</code>.
Cesty zde mohou být odděleny středníkem <kbd>;</kbd> nebo čárkou <kbd>,</kbd> a celý seznam cest
by měl být v uvozovkách.
Jako oddělovač složek lze použít zpětné <kbd>\</kbd> i dopředné <kbd>/</kbd> lomítko.
Poslední lomítko může být vynecháno. Výchozí hodnotou je <code>INCLUDEPATH="./,./maclib,../maclib,"</code>.</p>
<blockquote>Tato syntaxe nepovoluje názvy složek začínající či končící mezerou,
ovšem takových jmen byste se měli vyvarovat i z jiných důvodů.</blockquote>

<h5 id="LINKPATHeq"><a href="#EUROASM">&uarr; LINKPATH=</a></h5>
<p>Je-li linkovaný soubor specifikován bez cesty, &euro;ASM jej bude hledat
v adresářích definovaných ve volbě <code>EUROASM LINKPATH=</code>.
Cesty zde mohou být odděleny středníkem <kbd>;</kbd> nebo čárkou <kbd>,</kbd> a celý seznam cest
by měl být v uvozovkách.
Jako oddělovač složek lze použít zpětné <kbd>\</kbd> i dopředné <kbd>/</kbd> lomítko.
Poslední lomítko může být vynecháno. Výchozí hodnotou je <code>LINKPATH="./,./objlib,../objlib,"</code>.</p>

<h5 id="RUNPATHeq"><a href="#EUROASM">&uarr; RUNPATH=</a></h5>
<p>Je-li dynamicky sdílený objekt (DSO neboli objekt ELFSO) specifikován bez cesty,
Linuxový dynamický linker jej bude hledat v adresářích definovaných touto volbou
<code>EUROASM RUNPATH=</code>.
Výchozí hodnotou je <code>RUNPATH="./,./objlib,../objlib,"</code>.</p>

<h5 id="MAXINCLUSIONSeq"><a href="#EUROASM">&uarr; MAXINCLUSIONS=</a></h5>
<p>Parametr MAXINCLUSIONS omezuje maximální povolený počet úspěšných provedení příkazů INCLUDE*.
Brání to ve vyčerpání prostředků, pokud bychom omylem zadali rekurzivní smyčku INCLUDE.</p>
<p>Výchozí hodnota je <code>EUROASM MAXINCLUSIONS=64</code>.</p>

<h5 id="MAXLINKSeq"><a href="#EUROASM">&uarr; MAXLINKS=</a></h5>
<p>Tento parametr omezuje maximální povolený počet linkování souborů. Opět to chrání
před rekurzivní smyčkou příkazů LINK.</p>
<p>Výchozí hodnotou je <code>EUROASM MAXLINKS=64</code>.</p>

<h5 id="CPUeq" title="CPU levels"><a href="#EUROASM">&uarr; CPU=</a></h5>
<p>Ne všechny strojové instrukce architektury IA-32 jsou dostupné na všech typech procesorů.
Tato volba EUROASM určuje minimální (nejstarší) model CPU, na kterém má program běžet.
Možnosti jsou <br/><dfn>086</dfn> alias <dfn>8086</dfn>,
<br/><dfn>186</dfn>, <br/><dfn>286</dfn>, <br/><dfn>386</dfn>, <br/><dfn>486</dfn>,
<br/><dfn>586</dfn> alias <dfn>PENTIUM</dfn>,
<br/><dfn>686</dfn> alias <dfn>P6</dfn>,
<br/><dfn>X64</dfn>.
<br/>Výchozí hodnota je <code>EUROASM CPU=586</code>. 64bitové programy potřebují povolit <code>EUROASM CPU=X64</code>.</p>
<blockquote>EuroAssembler se chová, jako když vyšší verze CPU podporuje všechny instrukce předchozích verzí.</blockquote>

<h5 id="CPUfeatures" title="CPU features"><a href="#EUROASM">&uarr; Rozšíření CPU</a></h5>
<p>Následující skupina booleovských voleb říká EuroAssembleru, která rozšíření procesoru
jsou vyžadována na cílovém počítači.
Ve výchozím stavu jsou všechny volby vypnuty, musíte explicitně povolit každé rozšíření, pro něž budete programovat.</p>
<p><code>ABM=</code>: instrukce <em>Advanced Bit Manipulation</em>.</p>
<p><code>AES=</code> instrukce <em>Advance Encryption Standard</em> (AESNI).</p>
<p><code>AMD=</code> instrukce specifické pro výrobce CPU <em>AMD</em>.</p>
<p><code>CET=</code> instrukce Control-flow Enforcement Technology. </p>
<p><code>CYRIX=</code> instrukce specifické pro výrobce CPU <em>CYRIX</em>.</p>
<p><code>D3NOW=</code> instrukce <em>3DNow!</em> od AMD.</p>
<p><code>EVEX=</code> instrukce AVX-512 kódované s prefixem <em>EVEX</em>.</p>
<p><code>FMA=</code>: instrukce <em>Fused Multiply-Add</em>.</p>
<p><code>FPU=</code> instrukce pro <em>Floating-Point Unit</em> (matematický koprocesor).</p>
<p><code>LWP=</code> instrukce pro <em>LightWeight Profiling</em> od AMD.</p>
<p><code>MMX=</code>: instrukce pro <em>MultiMedia Extensions</em>.</p>
<p><code>MPX=</code>: instrukce pro <em>Memory Protection Extensions</em>.</p>
<p><code>MVEX=</code> instrukce AVX-512 kódované s prefixem <em>MVEX</em>.</p>
<p><code>PRIV=</code>: instrukce v <em>privilegovaném módu</em>.</p>
<p><code>PROT=</code>: instrukce v <em>chráněném módu</em>.</p>
<p><code>SGX=</code>: instrukce pro <em>Software Guard Extensions</em>.</p>
<p><code>SHA=</code> instrukce pro  <em>Secure Hash Algorithm</em> od Intelu.</p>
<p><code>SPEC=</code> ostatní <em>speciální</em> instrukce.</p>
<p><code>SVM=</code>: instrukce pro <em>Shared Virtual Memory</em>.</p>
<p><code>TSX=</code>: instrukce pro <em>Transactional Synchronization Extensions</em> od Intelu.</p>
<p><code>UNDOC=</code> <em>nedokumentované</em> instrukce.</p>
<p><code>VIA=</code> instrukce specifické pro výrobce CPU <em>VIA Geode</em>.</p>
<p><code>VMX=</code> instrukce pro <em>Virtual Machine Extensions</em>.</p>
<p><code>XOP=</code> instrukce AVX kódované s prefixem <em>XOP</em> od AMD.</p>

<h5 id="SIMDeq"><a href="#EUROASM">&uarr; SIMD=</a></h5>
<p>Tato volba definuje, která generace instrukcí <dfn>Single Instruction Multiple Data</dfn> (SIMD)
je vyžadována k překladu následných instrukcí.
Možné výčtové hodnoty jsou
<br/><dfn>SSE1</dfn> alias <dfn>SSE</dfn> alias booleovské <em>pravda</em>,
<br/><dfn>SSE2</dfn>,
<br/><dfn>SSE3</dfn>,
<br/><dfn>SSSE3</dfn>,
<br/><dfn>SSE4</dfn>,
<br/><dfn>SSE4.1</dfn>,
<br/><dfn>SSE4.2</dfn>,
<br/><dfn>AVX</dfn>,
<br/><dfn>AVX2</dfn>,
<br/><dfn>AVX512</dfn>.
Výchozí hodnotou je <code>SIMD=DISABLED</code> (neočekávají se žádné instrukce SIMD).</p>

<blockquote>Volby <a href="#CPUeq">generace CPU</a>, <a href="#CPUfeatures">rozšíření CPU</a>,
<a href="#SIMDeq">generace SIMD</a>
neomezují &euro;ASM v překladu instrukcí pro vyšší procesor, avšak
pokud strojová instrukce vyžaduje generaci momentálně nepovolenou volbami EUROASM,
bude vydáno varování. To by mělo upozornit, že program nepoběží na každém PC,
případně že jste se dopustili překlepu v menmonice.</blockquote>

<h5 id="DISPLAYSTMeq"><a href="#EUROASM">&uarr; DISPLAYSTM=</a></h5>
<h5 id="DISPLAYENCeq"><a href="#EUROASM">&uarr; DISPLAYENC=</a></h5>
<p>Tyto dvě booleovské volby jsou určeny k ladění samotného procesu překladu,
viz také pseudoinstrukci <a href="#pcDISPLAY">%DISPLAY</a>.
Jsou-li volby povoleny, &euro;ASM vkládá pod každou asemblovanou instrukci
diagnostické oznámení zobrazující, jak byla instrukce rozdělena do polí
a jaké <a href="#InstructionModifiers">instrukční modifikátory</a> byly použity
při jejím zakódování.Příklad:</p><pre>
    EUROASM DISPLAYSTM=ON
.L: MOV EAX,[ESI+16],ALIGN=DWORD
    EUROASM DISPLAYSTM=OFF, DISPLAYENC=ON
    LEA EDX,[ESI+16]
    ADD EAX,EDX</pre>
<p>Listing předchozího příkladu:</p>
<samp>|                  |    EUROASM DISPLAYSTM=ON
|00000000:8B4610   |.L: MOV EAX,[ESI+16],ALIGN=DWORD
|# D1010 **** DISPLAYSTM ".L: MOV EAX,[~~ALIGN=DWORD  "
|# D1020 label=".L"
|# D1040 machine operation="MOV"
|# D1050 ordinal operand number=1,value="EAX"
|# D1050 ordinal operand number=2,value="[ESI+16]"
|# D1060 keyword operand,name="ALIGN",value="DWORD"
|                  |    EUROASM DISPLAYSTM=OFF, DISPLAYENC=ON
|# D1010 **** DISPLAYSTM "EUROASM DISPL~~SPLAYENC=ON  "
|# D1040 pseudo operation="EUROASM"
|# D1060 keyword operand,name="DISPLAYSTM",value="OFF"
|# D1060 keyword operand,name="DISPLAYENC",value="ON"
|00000003:8D5610   |    LEA EDX,[ESI+16]
|# D1080 Emitted size=3,DATA=DWORD,DISP=BYTE,SCALE=SMART,ADDR=ABS.
|00000006:01D0     |    ADD EAX,EDX
|# D1080 Emitted size=2,CODE=SHORT,DATA=DWORD.</samp>


<h5 id="DUMPeq"><a href="#EUROASM">&uarr; DUMP=</a></h5>
<h5 id="DUMPWIDTHeq"><a href="#EUROASM">&uarr; DUMPWIDTH=</a></h5>
<h5 id="DUMPALLeq"><a href="#EUROASM">&uarr; DUMPALL=</a></h5>
<p>Volby DUMP=, DUMPWIDTH= and DUMPALL= ovlivňují vzhled sloupce s emitovaným kódem v souboru listingu.</p>
<p>Booleovská volba <code>DUMP=</code> kompletně vypíná tento sloupec;
listing pak kopíruje zdrojový text takřka doslovně. Výchozí hodnota je <code>DUMP=ON</code>.</p>
<p>DUMPWIDTH= nastavuje šířku levého sloupce v listingu, neboli určuje počet znaků,
které se vejdou mezi počáteční <kbd>|</kbd> a koncovou svislou čáru <kbd>|</kbd> (včetně těchto dvou znaků).
Výchozí hodnota je <code>DUMPWIDTH=27</code>, což vyhovuje pro instrukce dlouhé až 8 bajtů.</p>
<p>Povolená hodnota tohoto parametru je mezi 16 a 128 znaky.</p>
<p>Vypisovaná data sestávají z ofsetu (4 nebo 8 hexadecimálních číslic),
separátoru <kbd>:</kbd> a dvou hexadecimálních číslic na každý bajt generovaného kódu.</p>
<p>Je-li generovaný kód delší, než se vejde do sloupce dumpu,
booleovská volba <code>DUMPALL=</code> rozhoduje, zda zbytek kódu bude zahozen
(vypuštění je indikováno tildou <kbd>~</kbd> místo posledního znaku),
nebo zda do listingu budou vkládány přídavné řádky, dokud nebude všechen generovaný kód vypsán.
Výchozí volba je <code>DUMPALL=OFF</code>.</p>
<p>Viz také popis <a href="#ListingFile">souboru listingu</a>.</p>
<blockquote>Opatrně s povolováním DUMPALL=ON s dlouhými definicemi dat, jako
<code> DB 2048 * B 0</code>, které mohou zahltit listing mnoha řádky bezcenného výpisu.</blockquote>

<h5 id="LISTFILEeq"><a href="#EUROASM">&uarr; LISTFILE=</a></h5>
<p>Volba určuje název souboru s listingem. Jako výchozí volba se používá
<code>LISTFILE="%^SourceName%^SourceExt.lst"</code>, tedy kopie jména a přípony zdrojového souboru,
ke které se připojí <code>.lst</code>.
<br/>Není-li určeno jinak, listing se vytváří ve stejném adresáři jako jeho zdrojový soubor.
Ke každému zdrojovému souboru se generuje jeho listing.</p>

<h5 id="LISTeq"><a href="#EUROASM">&uarr; LIST=</a></h5>
<h5 id="LISTINCLUDEeq"><a href="#EUROASM">&uarr; LISTINCLUDE=</a></h5>
<h5 id="LISTMACROeq"><a href="#EUROASM">&uarr; LISTMACRO=</a></h5>
<h5 id="LISTREPEATeq"><a href="#EUROASM">&uarr; LISTREPEAT=</a></h5>
<h5 id="LISTVAReq"><a href="#EUROASM">&uarr; LISTVAR=</a></h5>

<p>Rodina booleovských voleb EUROASM LIST* určuje, co se bude zapisovat do souboru listingu.
LIST=OFF zcela potlačí generování listingu, dokud není opět zapnut pomocí LIST=ON.
Výchozí volba je <code>LIST=ON</code>.
<br/>Vypnutí byť jen malé části listingu způsobí, že již nebude znovupoužitelný jako zdrojový soubor,</p>
<p>Obsah souboru importovaného pomocí INCLUDE* je ve výchozím stavu vynechán z listingu (<code>LISTINCLUDE=OFF</code>).
Pokud je tato volba zapnuta (<code>LISTINCLUDE=ON</code>), z pseudoinstrukce INCLUDE se stane komentář
a pod ní budou uvedeny všechny instrukce ze souboru.</p>
<p>LISTMACRO= určuje, zda instrukce z expanze makra budou zobrazeny v listingu.
Výchozí stav je  <code>LISTMACRO=OFF</code>, kdy je zobrazena pouze invokace (volání) makra.</p>
<p>Volba LISTREPEAT= se podobá LISTMACRO= až na to, že řídí vypisování
obsahu bloků %FOR, %WHILE a %REPEAT.
<br/>Ve výchozím stavu (<code>LISTREPEAT=OFF</code>) se vypisuje pouze první iterace bloku.</p>
<p>Pokud se v instrukci vyskytuje preprocesní %proměnná a pokud je volba <code>EUROASM LISTVAR=ON</code>,
instrukce je v listingu duplikována pod původní instrukcí jako její komentář, avšak
%proměnné jsou přitom nahrazeny expandovaným textem. Výchozí volba je <code>LISTVAR=OFF</code>.</p>
<p>Viz také popis <a href="#ListParameters">listingového souboru</a> výše.</p>

<h5 id="UNICODEeq"><a href="#EUROASM">&uarr; UNICODE=</a></h5>
<p>Booleovská volba UNICODE= určuje šířku znaků.
Jsou-li neurčité řetězce definovány bez typového určení B nebo U pomocí <code> D "neurčitý řetězec"</code>
nebo <code>="literální neurčitý řetězec"</code>, tato volba určuje, zda se mají považovat
za řetězce bajtů (8bitových znaků) nebo unichar (16bitových znaků).</p>
<p>Hodnota UNICODE signalizovaná %^proměnnou <code>%^UNICODE</code> je rovněž konzultována
v makrech a definicích struktur, které mají odlišné verze pro ANSI (8bitové) nebo WIDE (16bitové) kódování.
<br/>Dále je konzultována v makrech <a class="EXT" href="../maclib/winapi.htm#WinAPI">WinAPI (32 bitů)</a>
a <a class="EXT" href="../maclib/winabi.htm#WinABI">WinABI (64 bitů)</a> k určení verze
Windows API funkce (ANSI nebo WIDE), jež má být volána.</p>
<blockquote><p>Mnoho funkcí ve WinAPI očekává specifikaci délky řetězců ve <strong>znacích</strong>
namísto v bajtech. Atributový operátor SIZE# vrací velikost řetězce vždy v <strong>bajtech</strong>.
Tento rozpor se dá vyřešit pomocí systémové %^proměnné %^UNICODE:</p>
<pre>aString D "String" ; Symbol aString definuje 6 bajtů, pokud UNICODE=OFF anebo 12 bajtů, pokud UNICODE=ON.
  %IF %^UNICODE  ; Symbol je ve WIDE verzi.
     MOV ECX, SIZE# aString / 2
  %ELSE          ; Symbol je v ANSI verzi.
     MOV ECX,SIZE# aString
  %ENDIF         ; ECX je nyní naplněn počtem <b>znaků</b> v aString.</pre>
<p>Vychytralejší řešení využívá faktu, že %^UNICODE (a všechny další booleovské %^proměnné)
expanduje buď do 0 nebo do -1, a že posun vlevo o negativní hodnotu je kalkulován jako posun vpravo o negovanou hodnotu.
Je-li %^UNICODE=-1, velikost v bajtech bude posunuta doprava o 1 bit, což odpovídá dělění dvěma:</p>
<pre>aString D "String" ; Symbol aString definuje 6 bajtů, pokud UNICODE=OFF anebo 12 bajtů, pokud UNICODE=ON.
  MOV ECX, SIZE# aString << %^UNICODE  ; ECX je nyní naplněn počtem <b>znaků</b> v aString.</pre>
</blockquote>

<h5 id="DEBUGeq"><a href="#EUROASM">&uarr; DEBUG=</a></h5>
<p>Tato booleovská volba specifikuje, zda má být přeložena ladicí verze programu.
Když je <code>EUROASM DEBUG=ENABLED</code>, linker zařazuje tabulku symbolů
nebo další ladicí informace do výstupního programu (formátu PE).
Makra mohou měnit své chování v závislosti na podmínce <code> %IF %^DEBUG</code>.
</p><p>Konečné vydání vašeho programu by mělo být přeloženo s touto vobou vypnutou.</p>

<h5 id="PROFILEeq"><a href="#EUROASM">&uarr; PROFILE=</a></h5>
<p>Tato booleovská volba specifikuje, zda má být přeložena profilovatelná verze programu.
Profilování zatím v této verzi &euro;ASM není implementováno.
</p><p>Konečné vydání vašeho programu by mělo být přeloženo s touto vobou vypnutou.</p>

<h5 id="WARNeq"><a href="#EUROASM">&uarr; WARN=</a></h5>
<h5 id="NOWARNeq"><a href="#EUROASM">&uarr; NOWARN=</a></h5>
<p>Volby WARN= a NOWARN= určují, která informační a varovná oznámení
mají být vydávána během činnosti asembleru.
Pomocí NOWARN= lze potlačit oznámení s identifikátorem pod 4000.
Potlačená oznámení nemají vliv na konečnou hodnotu ERRORLEVEL.
Uživatelem definovaná oznámení (U5000..U5999) a chyby s vyšší závažností potlačit nelze.</p>
<p>Hodnotou volby je buď číslo, nebo rozsah čísel (range), která by neměla přesáhnout 3999.
Operandy WARN= a NOWARN= se mohou v pseudoinstrukci EUROASM opakovat,
budou zpracovány zleva doprava. Například <code>EUROASM NOWARN=0600..0999, WARN=705</code>
potlačí informativní oznámení I0600 až I0999 s výjimkou oznámení I0705, které zůstává povoleno.</p>
<p>Výchozí hodnota je <code>WARN=0..3999</code> (všechna oznámení povolena}.</p>

<hr/>
<h4 id="PROGRAM"><a href="#PseudoInstructions">&uarr; PROGRAM </a></h4>
<h4 id="ENDPROGRAM"><a href="#PseudoInstructions">&uarr; ENDPROGRAM</a></h4>
<h5><a href="#DLLCHARACTERISTICSeq">DLLCHARACTERISTICS= &darr;</a></h5>
<h5><a href="#ENTRYeq">ENTRY= &darr;</a></h5>
<h5><a href="#FILEALIGNeq">FILEALIGN= &darr;</a></h5>
<h5><a href="#FORMATeq">FORMAT= &darr;</a></h5>
<h5><a href="#ICONFILEeq">ICONFILE= &darr;</a></h5>
<h5><a href="#IMAGEBASEeq">IMAGEBASE= &darr;</a></h5>
<h5><a href="#LISTLITERALSeq">LISTLITERALS= &darr;</a></h5>
<h5><a href="#LISTGLOBALSeq">LISTGLOBALS= &darr;</a></h5>
<h5><a href="#LISTMAPeq">LISTMAP= &darr;</a></h5>
<h5><a href="#MAJORIMAGEVERSIONeq">MAJORIMAGEVERSION= &darr;</a></h5>
<h5><a href="#MAJORLINKERVERSIONeq">MAJORLINKERVERSION= &darr;</a></h5>
<h5><a href="#MAJOROSVERSIONeq">MAJOROSVERSION= &darr;</a></h5>
<h5><a href="#MAJORSUBSYSTEMVERSIONeq">MAJORSUBSYSTEMVERSION= &darr;</a></h5>
<h5><a href="#MAXEXPANSIONSeq">MAXEXPANSIONS= &darr;</a></h5>
<h5><a href="#MAXPASSESeq">MAXPASSES= &darr;</a></h5>
<h5><a href="#MINORIMAGEVERSIONeq">MINORIMAGEVERSION= &darr;</a></h5>
<h5><a href="#MINORIMAGEVERSIONeq">MINORIMAGEVERSION= &darr;</a></h5>
<h5><a href="#MINORLINKERVERSIONeq">MINORLINKERVERSION= &darr;</a></h5>
<h5><a href="#MINOROSVERSIONeq">MINOROSVERSION= &darr;</a></h5>
<h5><a href="#MINORSUBSYSTEMVERSIONeq">MINORSUBSYSTEMVERSION= &darr;</a></h5>
<h5><a href="#MODELeq">MODEL= &darr;</a></h5>
<h5><a href="#OUTFILEeq">OUTFILE= &darr;</a></h5>
<h5><a href="#SECTIONALIGNeq">SECTIONALIGN= &darr;</a></h5>
<h5><a href="#SIZEOFHEAPCOMMITeq">SIZEOFHEAPCOMMIT= &darr;</a></h5>
<h5><a href="#SIZEOFHEAPRESERVEDeq">SIZEOFHEAPRESERVED= &darr;</a></h5>
<h5><a href="#SIZEOFSTACKCOMMITeq">SIZEOFSTACKCOMMIT= &darr;</a></h5>
<h5><a href="#SIZEOFSTACKRESERVEDeq">SIZEOFSTACKRESERVED= &darr;</a></h5>
<h5><a href="#STUBFILEeq">STUBFILE= &darr;</a></h5>
<h5><a href="#SUBSYSTEMeq">SUBSYSTEM= &darr;</a></h5>
<h5><a href="#TIMESTAMPeq">TIMESTAMP= &darr;</a></h5>
<h5><a href="#WIDTHeq">WIDTH= &darr;</a></h5>
<h5><a href="#WIN32VERSIONVALUEeq">WIN32VERSIONVALUE= &darr;</a></h5>

<p>Pseudoinstrukce PROGRAM a ENDPROGRAM definují blok zdrojového kódu, který generuje samostatný výstupní soubor.
V mnoha jiných asemblerech je to celý zdrojový soubor, který vytváří výstupní soubor, někdy zvaný
<em>modul</em> nebo <em>jednotka kompilace</em>. Například povel
<code>nasm -f win32 HelloWorld.asm -o HelloWorld.obj</code> instruuje NetWide Assembler, aby z celého zdrojového souboru <q>HelloWorld.asm</q>
vygeneroval soubor ve formátu COFF <q>HelloWorld.obj</q>.
V &euro;ASM může být z jednoho zdrojového souboru generován více než jeden výstupní soubor
povelem  <code>euroasm HelloWorld.asm</code>, pokud zdrojový soubor obsahuje více než jeden blok PROGRAM..ENDPROGRAM.</p>
<p>Návěstí pseudoinstrukce PROGRAM reprezentuje název výstupního programu.
I když nedefinuje symbol, jméno musí dodržovat pravidla pro názvy symbolů, tj. písmeno následované dalšími písmeny a číslicemi.
Tentýž identifikátor může být použit jako první a jediný operand odpovídající pseudoinstrukce ENDPROGRAM.</p>
<p>Jeden zdrojový soubor může obsahovat více programových bloků a tyto se mohou vnořovat.
Každý blok PROGRAM..ENDPROGRAM se překládá do jiného výstupního souboru.</p>
<p>Symboly definované v programu nejsou viditelné mimo svůj blok PROGRAM.ENDPROGRAM.
Chce-li program volat návěstí z jiného programu, musí být označeno jako EXTERN a PUBLIC,
i kdyby oba programy ležely v jednom zdrojovém souboru nebo kdyby byl jeden vnořen ve druhém.</p>
<p>Na druhé straně preprocesní %proměnné, definice maker a volby EUROASM jsou viditelné v celém zdrojovém souboru
a mohou tak přenášet informace mezi programy v asm-time.
Viz vzorový program <a class="EXT" href="../prowin32/locktest.htm">LockTest</a> jako příklad.</p>

<p>Pseudoinstrukce PROGRAM má spoustu klíčových parametrů specifikujících vlastnosti výstupního souboru.
Stejné klíče jsou použity v oddílu <code>[PROGRAM]</code> konfiguračního souboru
<a class="EXT" href="../objlib/euroasm.ini">euroasm.ini</a></p>
<p>Hodnoty všech voleb programu mohou být zjišťovány v asm-time pomocí
<a href="#SystemVariablesPROGRAM">systémových %^proměnných</a>.
Například v oznámení <code>InfoMsg DB "This is a %^WIDTH-bit program.",13,10,0</code>
bude systémová %^proměnná <code>%^WIDTH</code> nahrazena aktuální šířkou programu (16, 32 nebo 64).</p>
<blockquote>Na rozdíl od klíčových parametrů EUROASM, které ovlivňovaly pouze část souboru,
volby u pseudoinstrukce PROGRAM ovlivňují celý program <em>en bloc</em>.
Nemůžeme mít půlku programu s grafickým subsystémem a zbytek s konzolovým.
Proto jsou volby <code>LISTMAP=, LISTGLOBALS=, LISTLITERALS=</code>
vlastnostmi pseudoinstrukce <a href="#PROGRAM"> PROGRAM</a>, ale <code>LISTINCLUDE=, LISTMACRO=, LISTREPEAT=, LISTVAR=</code>
jsou vlastnostmi <a href="#EUROASM">EUROASM</a>.</blockquote>

<h5 id="FORMATeq"><a href="#PROGRAM">&uarr; FORMAT=</a></h5>
<p>Formát a souborová přípona výstupního souboru je určena tímto parametrem programu.</p>
<table>
<caption>Výchozí vlastnosti formátů</caption>
<tr><th>FORMAT=</th><th>Přípona<br/>výstupního souboru</th><th>Šířka<br/>programu</th>
<th>Paměťový<br/>model<th>Popis formátu</th></tr>
<tr><th>BIN</th><td>.bin</td><td>16bits</td><td>TINY<td>Binární soubor</td></tr>
<tr><th>BOOT</th><td>.sec</td><td>16bits</td><td>TINY<td>Bootovatelný soubor</td></tr>
<tr><th>COM</th><td>.com</td><td>16bits</td><td>TINY<td>Spustitelný soubor DOS/CPM</td></tr>
<tr><th>ELF</th><td>.o</td><td>32bits</td><td>FLAT<td>Linkovatelný objektový modul</td></tr>
<tr><th>ELFX</th><td>.x</td><td>32bits</td><td>FLAT<td>Spustitelný soubor pro Linux</td></tr>
<tr><th>ELFSO</th><td>.so</td><td>32bits</td><td>FLAT<td>Dynamicky sdílený soubor pro Linux</td></tr>
<tr><th>OMF</th><td>.obj</td><td>16bits</td><td>SMALL<td>Linkovatelný objektový modul</td></tr>
<tr><th>LIBOMF</th><td>.lib</td><td>16bits</td><td>SMALL<td>Objektová knihovna ve formátu OMF</td></tr>
<tr><th>MZ</th><td>.exe</td><td>16bits</td><td>SMALL<td>Spustitelný program pro DOS</td></tr>
<tr><th>COFF</th><td>.obj</td><td>32bits</td><td>FLAT<td>Linkovatelný objektový modul</td></tr>
<tr><th>LIBCOF</th><td>.lib</td><td>32bits</td><td>FLAT<td>Objektová knihovna ve formátu COFF</td></tr>
<tr><th>PE</th><td>.exe</td><td>32bits</td><td>FLAT<td>Spustitelný program pro MS-Windows</td></tr>
<tr><th>DLL</th><td>.dll</td><td>32bits</td><td>FLAT<td>Dynamická knihovna pro MS-Windows</td></tr>
</table>
<p>Výchozí formát (při vynechání <code>PROGRAM FORMAT=</code>) je <code>BIN</code>.
Viz také <a href="#PgmFormats">programové formáty</a> níže pro více podrobností.</p>

<h5 id="WIDTHeq"><a href="#PROGRAM">&uarr; WIDTH=</a></h5>
<p>Tento parametr určuje šířku a mód programu:</p>
<ul><li>16bitový mód</li> <li>32bitový mód </li>
<li>64bitový mód (vyžaduje 64bitový procesor, volba <code>EUROASM CPU=X64</code> by měla být také nastavena.)</li></ul>
<p>Programová šířka zároveň představuje výchozí šířku všech jeho segmentů.
Její hodnotou je číselný výraz vyhodnocený jako <strong>16, 32, 64</strong>, nebo <strong>0</strong>.
Prázdná nebo nulová hodnota (výchozí stav) určuje, že šířku programu má stanovit interně &euro;ASM
v souladu s výchozími šířkami v tabulce <a href="#FORMATeq">FORMAT=</a>.
Nicméně pokud je <a href="#SEGMENT">segment</a> definován, můžeme mu předepsat odlišnou šířku.
&euro;ASM neprotestuje proti mísení 16bitových a 32bitových segmentů v jednom programu.</p>

<h5 id="MODELeq"><a href="#PROGRAM">&uarr; MODEL=</a></h5>
<p>Paměťový model určuje velikosti a distance kódu a dat.
Jeho hlavní funkcí je nastavit výchozí hodnotu vzdáleností (DIST) pro segmenty a procedury v programu.</p>
<p>Programová volba MODEL= se bere v úvahu v procedurách (PROC, PROC1)
a v instrukcích předávání zpracování (JMP, CALL, RET) bez explicitně stanovené distance.
<br/>V monokódových modelech (TINY,SMALL,COMPACT,FLAT) je výchozí vzdálenost DIST=NEAR.
<br/>V mnohokódových modelech (MEDIUM,LARGE,HUGE) je výchozí vzdálenost DIST=FAR.
<br/>V monodatových modelech (TINY,SMALL,MEDIUM,FLAT) jsou všechna data adresována relativně k začátku datové grupy.
<br/>V mnohodatových modelech (COMPACT,LARGE,HUGE) je na programátorovi, aby naplnil segmentový registr
paragrafovou adresou dat, než k nim bude přistupováno.</p>
<table>
<caption>Vlastnosti implikované paměťovým modelem</caption>
<tr><th rowspan="2">MODEL=</th><th colspan="3">Výchozí vlastnosti segmentu</th>
<th colspan="3">Vlastnosti při linkování</th><th colspan="2">Obvyklé využití</th></tr>
<tr><th>Distance <br/>CODE</th><th>Distance<br/>DATA</th><th>Šířka<br/>segmentu</th>
<th>Mnoho-<br/>kódový</th><th>Mnoho-<br/>datový</th>
<th>Překrývání<br/>segmentů</th><th>Mód<br/>CPU</th><th>Použito ve formátech</th></tr>
<tr><th>TINY</th><td>NEAR</td><td>NEAR</td><td>16</td><td>ne</td><td>ne</td><td>ano</td><td>real</td><td>COM</td></tr>
<tr><th>SMALL</th><td>NEAR</td><td>NEAR</td><td>16</td><td>ne</td><td>ne</td><td>ne</td><td>real</td><td>MZ, OMF</td></tr>
<tr><th>MEDIUM</th><td>FAR</td><td>NEAR</td><td>16</td><td>ano</td><td>ne</td><td>ne</td><td>real</td><td>MZ, OMF</td></tr>
<tr><th>COMPACT</th><td>NEAR</td><td>FAR</td><td>16</td><td>ne</td><td>ano</td><td>ne</td><td>real</td><td>MZ, OMF</td></tr>
<tr><th>LARGE</th><td>FAR</td><td>FAR</td><td>16</td><td>ano</td><td>ano</td><td>ne</td><td>real</td><td>MZ, OMF</td></tr>
<tr><th>HUGE</th><td>FAR</td><td>FAR</td><td>32</td><td>ano</td><td>ano</td><td>ne</td><td>real</td><td>MZ, OMF</td></tr>
<tr><th>FLAT</th><td>NEAR</td><td>NEAR</td><td>32,64</td><td>ne</td><td>ne</td><td>ano</td><td>protected</td><td>ELF, PE, DLL, COFF</td></tr>
</table>
<p>Prázdná hodnota (výchozí stav) určuje, že paměťový model má stanovit interně &euro;ASM
v souladu s hodnotou v tabulce <a href="#FORMATeq">FORMAT=</a>.</p>

<h5 id="SUBSYSTEMeq"><a href="#PROGRAM">&uarr; SUBSYSTEM=</a></h5>
<p><dfn>Subsystém</dfn> je číselný identifikátor v hlavičce souboru Portable Executable,
který specifikuje, zda MS-Windows má vytvářet novou konzolu když PE program startuje.
Hodnotou subsystému je číslo nebo jedno ze slov vyjmenovaných v této tabulce:</p>
<table>
<caption>Tabulka subsystémů</caption>
<tr><th>SUBSYSTEM=</th><th>Hodnota</th><th>Poznámka</th></tr>
<tr><th>0</th><th>0</th><td>Neznámý subsystém.</td></tr>
<tr><th>1</th><th>NATIVE</th><td>Subsystém není použit (ovladač zařízení).</td></tr>
<tr><th>2</th><th>GUI</th><td>Grafický subsystém MS-Windows.</td></tr>
<tr><th>3</th><th>CON</th><td>Konzolový (znakový) subsystém MS-Windows.</td></tr>
<tr><th>5</th><th>OS2</th><td>Znakový subsystém OS/2.</td></tr>
<tr><th>7</th><th>POSIX</th><td>Znakový subsystém Posix.</td></tr>
<tr><th>8</th><th>WXD</th><td>Nativní ovladač MS-Windows 95/98.</td></tr>
<tr><th>9</th><th>WCE</th><td>Grafický subsystém MS-Windows CE.</td></tr>
</table>
<p>Výchozí hodnota je <code>SUBSYSTEM=CON</code>.
Změňte ji na <code>SUBSYSTEM=GUI</code>, pokud váš spustitelný program
vytváří grafická okna, místo aby se spokojil se standardním textovým vstupem a výstupem.</p>


<h5 id="ENTRYeq"><a href="#PROGRAM">&uarr; ENTRY=</a></h5>
<p>Tento parametr určuje adresu, od které začíná běžet spustitelný program.
Obvykle je to návěstí, jehož adresa bude vložena do CS:rIP
když zaváděč předává zpracování programu při jeho spuštění.</p>
<p>Výchozí hodnota parametru je prázdná,
v tom případě ji &euro;ASM nastaví na 0 pokud <code>PROGRAM FORMAT=BIN</code>
nebo na 256 pokud <code>PROGRAM FORMAT=COM</code> nebo na 0x7C00 pokud <code>PROGRAM FORMAT=BOOT</code>.
U ostatních spustitelných programů &euro;ASM ohlásí chybu, když ENTRY= nebylo zadáno.</p>

<h5 id="MAXPASSESeq" title="Final pass"><a href="#PROGRAM">&uarr; MAXPASSES=</a></h5>
<p>Tento parametr omezuje počet průchodů zdrojovým kódem od pseudoinstrukce PROGRAM
až po ENDPROGRAM. O počtu průchodů rozhoduje &euro;ASM,
tento parametr pouze určuje horní limit.</p>
<p>EuroAssembler opakuje průchody, dokud se mění ofsety symbolů.
Jakmile jsou všechny stabilní, provede poslední (finální) průchod.</p>
<p id="FixingPass" title="Fixing pass">Za určitých (vzácných) okolností
to může vést k oscilacím délky emitovaného kódu kvůli optimalizacím délky
SHORT a NEAR skoků. V tom případě by &euro;ASM vyžadoval další a další průchody.
Jakmile se číslo průchodu přiblíží k %^MAXPASSES-1,
tento předposlední průchod se označí jako <dfn>fixing pass</dfn>.
V tomto průchodu mohou ofsety pouze růst ke vyšším hodnotám;
nadbytečné místo se zaplňuje bajty prázdné operace NOP.
Viz test <a class="EXT" href="../eatests/t7181.htm">t7181</a>
coby příklad oscilujícího programu s fixing průchodem.</p>
<blockquote>Výchozí hodnotou je MAXPASSES=32.
Asi ji budete potřebovat zvýšit jen v extrémních případech programů
se spoustou maker a podmíněných konstruktů.
Ve svých programech jsem dosáhl maxima 44 průchodů spotřebovaných
během překladu modulu <a class="EXT" href="../easource/iiz.htm">iiz.htm</a>.
</blockquote>

<h5 id="MAXEXPANSIONSeq"><a href="#PROGRAM">&uarr; MAXEXPANSIONS=</a></h5>
<p>Parametr MAXEXPANSIONS= omezuje počet expanzí bloků typu %FOR, %WHILE, %REPEAT nebo %MACRO.
&euro;ASM deklaruje číselnou vlastnost programu zvanou <kbd>%.</kbd>
a zvyšuje její hodnotu při expanzi bloku. Jakmile hodnota přesáhne volbu MAXEXPANSIONS,
&euro;ASM vydá oznámení o chybě a další expanze zastaví.
<br/>Výchozí hodnota je MAXEXPANSIONS=65536.</p>
<blockquote><p>Tento mechanismus chrání &euro;ASM před vyčerpáním paměťových prostředků,
pokud některá špatně napsaná preprocesní smyčka včas neskončí.</p>
<p>Totéž počitadlo expanzí se využívá k udržování hodnoty <a href="#ExpansionCounter">automatické %proměnné</a> <kbd>%.</kbd>.</p>
</blockquote>

<h5 id="OUTFILEeq"><a href="#PROGRAM">&uarr; OUTFILE=</a></h5>
<p>Volba <dfn>OUTFILE=</dfn> specifikuje jméno spustitelného nebo linkovatelného výstupního souboru.
Jméne je vztaženo k aktuálnímu adresáři, není-li specifikováno jinak.
Výchozí hodnotou je <code>OUTFILE="%^PROGRAM"</code> následovaný <a href="#FORMATeq">příponou</a> určenou volbou FORMAT=.
<br/>Kupříkladu <code>Hello PROGRAM FORMAT=MZ</code> generuje výstupní soubor <code>&quot;Hello.exe&quot;</code>.</p>
<p>Na jméno výstupního souboru lze aplikovat operátor(y) <a href="#Suboperations">suboperace</a>,
například <code>OutFile=&quot;MyData.bin&quot;[1..256]</code> zkompiluje celý modul v paměti,
avšak pouze prvních 256 bajtů bude zapsáno do výstupního souboru <q>MyData.bin</q>. Viz také vzorový program
<a class="EXT" href="../probin/binboot.htm">binboot.htm</a> jako praktický příklad využití suboperace substring.</p>

<h5 id="STUBFILEeq"><a href="#PROGRAM">&uarr; STUBFILE=</a></h5>
<p>Volba <dfn>STUBFILE=</dfn> má význam pouze u spustitelných souborů ve formátu PE nebo DLL.
<dfn>Stub</dfn> je 16bitový program formátu MZ, který se dostane ke slovu, když je soubor určený pro Windows
nedopatřením spuštěn v 16bitovém operačním systému (DOS).
Obvykle je jeho úlohou pouze informovat uživatele, že <em>this program requires MS-Windows</em>.</p>
<p>Je-li volba STUBFILE prázdná (default), &euro;ASM použije svůj vlastní vestavěný
soubor <a class="EXT" href="../easource/coffstub.htm">stub</a>.
Jinak zde očekává předem zkompilovaný spustitelný MZ program.
Byl-li STUBFILE= specifikován bez cesty, &euro;ASM jej hledá v cestách určených volbou
<code>EUROASM LINKPATH=</code>.</p>
<blockquote>Předepsaný 16bitový program <em>stub</em> může mít stejnou funkcionalitu
jako hlavní aplikace pro 32bitové Windows.
 Takový spustitelný program pak pracuje stejně v DOSu i v MS-Windows.
Jako ukázku viz vzorový projekt <a class="EXT" href="../prowin32/locktest.htm">LockTest</a>.</blockquote>

<h5 id="ICONFILEeq"><a href="#PROGRAM">&uarr; ICONFILE=</a></h5>
<p>Volba <dfn>ICONFILE=</dfn> by měla definovat existující soubor obsahující pouze ikonu pro Windows,
která pak bude vestavěna do segmentu zdrojů [.rsrc] našeho programu ve formátu PE nebo DLL.
Tato ikona bude graficky reprezentovat výstupní program v prostředí Windows (Plocha, Průzkumník atd.).
<br/>Byl-li soubor ikony specifikován bez cesty, bude se hledat v některém adresáři určeném volbou <code>EUROASM LINKPATH=</code>.</p>
<p>Výchozí hodnotou je <code>EUROASM ICONFILE=&quot;euroasm.ico&quot;</code>,
což představuje ikonu <img width="16" height="16" alt="Icon" src="../objlib/euroasm.ico"/> dodávanou
s EuroAssemblerem ve složce <code>objlib</code>.</p>
<p>Volba ICONFILE= se uplatní pouze pokud žádný soubor <strong>resources</strong> není linkován do výstupního programu,
jinak se ignoruje a bude místo něj použita první ikona ze souboru <em>resources</em>.</p>
<p>Je-li parametr <code>ICONFILE=</code> prázdný, ikona není použita
a &euro;ASM sekci <em>resources</em> vůbec nevytváří.</p>

<h5 id="LISTMAPeq"><a href="#PROGRAM">&uarr; LISTMAP=</a></h5>
<h5 id="LISTGLOBALSeq"><a href="#PROGRAM">&uarr; LISTGLOBALS=</a></h5>
<h5 id="LISTLITERALSeq"><a href="#PROGRAM">&uarr; LISTLITERALS=</a></h5>
<p>Tyto tři volby určují, která přídavná informace bude vypisována
na konec listingového souboru.
Viz test <a class="EXT" href="../eatests/t8302.htm">t8302</a> jako příklad formátu ListMap a ListGlobals.</p>
<p>Je-li LISTLITERALS=ON, obsah datové a kódové literální sekce
@LT16, @LT8, @LT4, @LT2, @LT1, @RT0 bude vypsán do listingu.
Viz test <a class="EXT" href="../eatests/t1711.htm">t1711</a> jako příklad formátu ListLiterals. </p>

<h5 id="TIMESTAMPeq"><a href="#PROGRAM">&uarr; TIMESTAMP=</a></h5>
<p>Tato volba specifikuje nominální čas poskytovaný systémovým %^proměnným EuroAssembleru
%^DATE a %^TIME, a který bude také zabudován do některých struktur COFF formátu:
<a class="EXT" href="../easource/pfcoff.htm#PFCOFF_FILE_HEADER">
PFCOFF_FILE_HEADER.TimeDateStamp</a>,
<a class="EXT" href="../easource/pflibcof.htm#PFLIBCOF_IMPORT_OBJECT_HEADER">
PFLIBCOF_IMPORT_OBJECT_HEADER.TimeDateStamp</a>,
<a class="EXT" href="../easource/pfrsrc.htm#PFRSRC_RESOURCE_DIRECTORY">
PFRSRC_RESOURCE_DIRECTORY.TimeDateStamp</a>.</p>
<p>Hodnota tohoto parametru představuje počet sekund, které uběhly od půlnoci
1. ledna 1970, UTC.
Pokud je nastavena na -1 nebo nechána prázdnou (výchozí stav),
bude nastavena podle systémového časovače při startu <q>euroasm.exe</q>.
<br/>TIMESTAMP= lze využít ke zfalšování času, kdy byl cílový program vytvořen.</p>


<h5 id="DLLCHARACTERISTICSeq"><a href="#PROGRAM">&uarr; DLLCHARACTERISTICS=</a></h5>
<h5 id="FILEALIGNeq"><a href="#PROGRAM">&uarr; FILEALIGN=</a></h5>
<h5 id="IMAGEBASEeq"><a href="#PROGRAM">&uarr; IMAGEBASE=</a></h5>
<h5 id="MAJORIMAGEVERSIONeq"><a href="#PROGRAM">&uarr; MAJORIMAGEVERSION=</a></h5>
<h5 id="MAJORLINKERVERSIONeq"><a href="#PROGRAM">&uarr; MAJORLINKERVERSION=</a></h5>
<h5 id="MAJOROSVERSIONeq"><a href="#PROGRAM">&uarr; MAJOROSVERSION=</a></h5>
<h5 id="MAJORSUBSYSTEMVERSIONeq"><a href="#PROGRAM">&uarr; MAJORSUBSYSTEMVERSION= </a></h5>
<h5 id="MINORIMAGEVERSIONeq"><a href="#PROGRAM">&uarr; MINORIMAGEVERSION=</a></h5>
<h5 id="MINORLINKERVERSIONeq"><a href="#PROGRAM">&uarr; MINORLINKERVERSION=</a></h5>
<h5 id="MINOROSVERSIONeq"><a href="#PROGRAM">&uarr; MINOROSVERSION=</a></h5>
<h5 id="MINORSUBSYSTEMVERSIONeq"><a href="#PROGRAM">&uarr; MINORSUBSYSTEMVERSION=</a></h5>
<h5 id="SECTIONALIGNeq"><a href="#PROGRAM">&uarr; SECTIONALIGN= </a></h5>
<h5 id="SIZEOFHEAPCOMMITeq"><a href="#PROGRAM">&uarr; SIZEOFHEAPCOMMIT=</a></h5>
<h5 id="SIZEOFHEAPRESERVEDeq"><a href="#PROGRAM">&uarr; SIZEOFHEAPRESERVED=</a></h5>
<h5 id="SIZEOFSTACKCOMMITeq"><a href="#PROGRAM">&uarr; SIZEOFSTACKCOMMIT=</a></h5>
<h5 id="SIZEOFSTACKRESERVEDeq"><a href="#PROGRAM">&uarr; SIZEOFSTACKRESERVED=</a></h5>
<h5 id="WIN32VERSIONVALUEeq"><a href="#PROGRAM">&uarr; WIN32VERSIONVALUE=</a></h5>
<p>Ostatní parametry pseudoinstrukce PROGRAM jsou obvykle důležité pouze v souborech rodiny COFF
(PE, DLL, COFF), kde tvoří PE header. Pro jejich podrobnější popis viz
<a class="EXTL" href="links.htm#MS_PECOFF">[MS PECOFF]</a>.
Neměňte jejich výchozí hodnoty, pokud nevíte, co děláte.</p>

<h4 id="SEGMENT"><a href="#PseudoInstructions">&uarr; SEGMENT</a></h4>
<h5><a href="#SegmentPURPOSEeq">PURPOSE= &darr;</a></h5>
<h5><a href="#SegmentWIDTHeq">WIDTH= &darr;</a></h5>
<h5><a href="#SegmentALIGNeq">ALIGN= &darr;</a></h5>
<h5><a href="#SegmentCOMBINEeq">COMBINE= &darr;</a></h5>
<h5><a href="#SegmentCLASSeq">CLASS= &darr;</a></h5>

<p>Pseudoinstrukce <dfn>SEGMENT</dfn> deklaruje paměťový segment a určuje jeho vlastnosti.
Každá deklarace segmentu zároveň deklaruje sekci stejného jména.
Další sekce tohoto segmentu mohou být deklarovány později,
instrukcí s názvem sekce v poli návěstí, např.
<br/><code>[Strings] ; Deklaruj sekci [Strings] v aktuálním segmentu. </code>.</p>
<p>Jméno segmentu je zadáno v poli návěstí a vypadá jako identifikátor v hranatých závorkách.
Vlastnosti segmentu se zadávají pomocí klíčových operandů.</p>

<p>&euro;ASM automaticky deklaruje několik <strong>výchozích segmentů</strong> když začíná překládat program.
Ve většině případů to stačí a není třeba explicitně deklarovat další segmenty.
Počet a účel výchozích segmentů záleží na <a href="#SegmentationImplicit">programovém formátu</a>.
Pokud tyto výchozí segmenty nebyly v programu použity (nic do nich nebylo emitováno),
budou zahozeny a vůbec se neobjeví v cílovém souboru.
Dochází k tomu, pokud jsme nebyli spokojeni s výchozími segmenty
a deklarovali své vlastní s odlišnými názvy a vlastnostmi.</p>

<h5 id="SegmentPURPOSEeq"><a href="#SEGMENT">&uarr; PURPOSE=</a></h5>
<p>Klíčový operand SEGMENT PURPOSE= určuje, pro jaký druh informací je segment určen.
Parametr je důležitý v chráněném módu (formáty ELFX, PE, DLL), kdy <em>přístupové bity deskriptoru</em>
řídí operávnění číst, zapisovat a provádět obsah segmentu.</p>
<table><caption>Tabulka účelů segmentu</caption>
<tr><th>PURPOSE=</th><th>Alias</th><th>Přístup</th><th>Výchozí jméno</th><th>Obsahuje</th></tr>
<tr><th>CODE</th><th>TEXT</th><td>read, execute</td><td><code>[.text]|[CODE]</code></td><td>Programový kód (instrukce) <sup>(1)</sup></td></tr>
<tr><th>RODATA</th><th>RDATA</th><td>read</td><td><code>[.rodata]|[RODATA]</code></td><td>Inicializovaná data pouze ke čtení <sup>(1)</sup></td></tr>
<tr><th>DATA</th><th>IDATA</th><td>read, write</td><td><code>[.data]|[DATA]</code></td><td>Inicializovaná data <sup>(1)</sup></td></tr>
<tr><th>BSS</th><th>UDATA</th><td>read, write</td><td><code>[.bss]|[BSS]</code></td><td>Neinicializovaná data <sup>(1)</sup></td></tr>
<tr><th>STACK</th><th></th><td>read, write</td><td><code>[STACK]</code></td><td>Strojový zásobník <sup>(1)</sup></td></tr>
<tr><th>LITERALS</th><th>LITERAL</th><td>read  </td><td><small>parazituje na jiných data/code segmentech</small></td><td>Literální sekce <sup>(2)</sup></td></tr>
<tr><th>DRECTVE</th><th></th><td>discarded</td><td><code>[.drectve]</code></td><td>Direktivy pro linker <sup>(3)</sup></td></tr>
<tr><th><th></th><td></td><td></td><td></td></tr>
<tr><th>PHDR<th></th><td></td><td></td><td>Hlavičky programu <sup>(4)</sup></td></tr>
<tr><th>INTERP<th></th><td></td><td></td><td>Dynamický interpreter <sup>(4)</sup></td></tr>
<tr><th>SYMBOLS<th></th><td></td><td><code>[.symtab] | [.dynsym]</code></td><td>Symboly <sup>(4)</sup></td></tr>
<tr><th>HASH<th></th><td></td><td><code>[.hash]</code></td><td>Kontrolní součty jmen symbolů <sup>(4)</sup></td></tr>
<tr><th>STRINGS<th></th><td></td><td><code>[.strtab] | [.dynstr] | [.shstrtab]</code></td><td>Jména symbolů nebo sekcí <sup>(4)</sup></td></tr>
<tr><th>DYNAMIC<th></th><td></td><td><code>[.dynamic]</code></td><td>Dynamické záznamy <sup>(4)</sup></td></tr>
<tr><th>RELOC<th></th><td></td><td><code>[.rel(a)*]</code></td><td>Relokace <sup>(4)</sup></td></tr>
<tr><th>GOT<th></th><td></td><td><code>[.got]</code></td><td>GOT - tabulka ofsetů <sup>(4)</sup></td></tr>
<tr><th>PLT<th></th><td></td><td><code>[.plt]</code></td><td>PLT - tabulka procedur <sup>(4)</sup></td></tr>
<tr><th><th></th><td></td><td></td><td></td></tr>
<tr><th>EXPORT</th><th></th><td></td><td><code>[.edata]</code></td><td>Dynamické exporty <sup>(4)</sup></td></tr>
<tr><th>IMPORT</th><th></th><td></td><td><code>[.idata]</code></td><td>Dynamické importy <sup>(4)</sup></td></tr>
<tr><th>RESOURCE</th><th></th><td></td><td><code>[.rsrc]</code></td><td>Resources <sup>(4)</sup></td></tr>
<tr><th>EXCEPTION<th></th><td></td><td><code>[.pdata]</code></td><td>Run-time přerušení <sup>(5)</sup></td></tr>
<tr><th>SECURITY<th></th><td></td><td></td><td>Certifikáty <sup>(5)</sup></td></tr>
<tr><th>BASERELOC<th></th><td>discarded</td><td><code>[.reloc]</code></td><td>Load-time relokace <sup>(4)</sup></td></tr>
<tr><th>DEBUG<th></th><td></td><td><code>[.debug]</code></td><td>Data pro debuger <sup>(5)</sup></td></tr>
<tr><th>COPYRIGHT<th>ARCHITECTURE</th><td></td><td></td><td>Architektura <sup>(5)</sup></td></tr>
<tr><th>GLOBALPTR<th></th><td></td><td></td><td>RVA globálního pointeru <sup>(5)</sup></td></tr>
<tr><th>TLS<th></th><td></td><td><code>[.tls]</code></td><td>Paměť vlákna <sup>(5)</sup></td></tr>
<tr><th>LOAD_CONFIG<th></th><td></td><td></td><td>Načtení konfigurace <sup>(5)</sup></td></tr>
<tr><th>BOUND_IMPORT<th></th><td></td><td></td><td>Bound import <sup>(5)</sup></td></tr>
<tr><th>IAT<th></th><td></td><td><code>[.idata]</code><td>Importní adresní tabulka <sup>(4)</sup></td></tr>
<tr><th>DELAY_IMPORT<th></th><td></td><td></td><td>Zpožděný import <sup>(5)</sup></td></tr>
<tr><th>CLR<th></th><td></td><td><code>[.cormeta]</code></td><td>Metadata CLR <sup>(5)</sup></td></tr>
<tr><th>RESERVED<th></th><td></td><td></td><td>Reservováno <sup>(5)</sup></td></tr>
</table>
Poznámky:
<br/><sup>(1)</sup> Základní účely používané ve všech programových formátech.
<br/><sup>(2)</sup> Programátor může určit, který rodata|data|code segment by měl hostovat literální symboly.
<br/><sup>(3)</sup> Umělá sekce pro přenos informací ve formátu COFF.
<br/><sup>(4)</sup> Speciální sekce přímo používané EuroAssmeblerem. Neměly by být nikdy definovány explicitně.
<br/><sup>(5)</sup> Speciální sekce, jejich obsah není podporován v &euro;ASM. Programátor může zahrnout takové sekce
do PE souboru, ale obsah pak musí být explicitně určen (pomocí D nebo INCLUDEBIN), viz <a href="#FormatPE">program format PE</a>.

<p>Segmenty se speciálními jmény <sup>(4),(5)</sup> budou označeny na odpovídající pozici
v tabulce DataDirectory ve &quot;volitelné&quot; hlavičce souboru PE nebo DLL.</p>
<p>Ačkoli operand PURPOSE= akceptuje pouze výčtové hodnoty vyjmenované ve výše uvedené tabulce,
mohou být kombinovány použitím operátoru <em>Addition</em>&nbsp;<kbd>+</kbd> nebo
<em>Bitwise&nbsp;OR</em>&nbsp;<kbd>|</kbd>, např.
<br/><code>[TINY] SEGMENT PURPOSE=CODE|DATA|BSS|STACK</code>
nebo <br/><code>[.rodata] SEGMENT PURPOSE=DATA+LITERALS</code>.</p>

<p>Není-li prametr PURPOSE= uveden, &euro;ASM jej odhadne podle jeho třídy (class) nebo [názvu]
za použití těchto pravidel:</p><ol>
<li>Pokud se jméno přesně shoduje s některým účelem vyjmenovaným v tabulce nahoře, bude použit tento účel.</li>
<li>Obsahuje-li jméno řetěz <code>STACK</code>, bude použit <code>PURPOSE=STACK</code>.</li>
<li>Obsahuje-li jméno řetěz <code>BSS</code> nebo <code>UDATA</code>, bude použit <code>PURPOSE=BSS</code>.</li>
<li>Obsahuje-li jméno řetěz <code>DATA</code>, bude použit <code>PURPOSE=DATA</code>.</li>
<li>Jinak bude použit <code>PURPOSE=CODE</code>.</li></ol>
<p><code>PURPOSE=LITERALS</code> je použit spolu s CODE nebo DATA a pouze navrhuje, že by tento segment
měl hostovat literální sekce.
Neby-li žádný segment explicitně označen s PURPOSE=LITERAL, &euro;ASM vybere poslední datový nebo kódový segment,
jakmile narazí na literální symbol.</p>
<blockquote>Odhad účelu se nejprve dívá na vlastnost <code>SEGMENT CLASS=</code>,
a pouze pokud je prázdná, dívá se na jméno segmentu.Tento mechanismus je použit
se segmenty definovanými ve formátu OMF k předání jejich účelu do linkovaného spustitelného souboru.</blockquote>

<h5 id="SegmentWIDTHeq"><a href="#SEGMENT">&uarr; WIDTH=</a></h5>
<p>Šířkou segmentu může být numerický výraz vyhodnocený jako 16, 32 nebo 64.
Jako výchozí hodnota (při vynechání) je šířka segmentu určena
<a href="#FORMATeq">šířkou programu</a>.</p>

<h5 id="SegmentALIGNeq"><a href="#SEGMENT">&uarr; ALIGN=</a></h5>
<p>Tento parametr požaduje zarovnání segmentu v paměti za běhu.
Výchozí hodnotou je <code>ALIGN=OWORD</code> (16 bajtů).</p>
<p>Speciální ELF a PE segmenty, jako [.symtab], [.strtab], [.reloc] atd. mohou mít odlišné zarovnání.</p>

<h5 id="SegmentCOMBINEeq"><a href="#SEGMENT">&uarr; COMBINE=</a></h5>
<p>Tento parametr specifikuje, jak budou segmenty z jiných programových modulů
kombinovány při linkování. Je to důležité u programů typu MZ (16bitový pro DOS)
sestavovaného z více modulů. Možné hodnoty:</p>
<dl>
<dt>PUBLIC</dt>
<dd>Všechny segmenty se shodným názvem budou spojeny dohromady.
Celková velikost je součtem jejich velikostí, s příhlédnutím k jejich zarovnání.
Toto je výchozí volba.</dd>
<dt>PRIVATE</dt>
<dd>Privátní segmenty nebudou spojovány s ostatními, ať již mají shodný název nebo ne.</dd>
<dt>COMMON</dt>
<dd>Všechny COMMON segmenty se stejným jménem budou linkovány na tutéž adresu,
takže se navzájem překrývají. Jejich celková velikost odpovídá
délce nejdelšího segmentu.
Datové proměnné deklarované v COMMON segmentech budou sdíleny mezi samostatně překládanými moduly.</dd>
<dt>STACK</dt>
<dd>Metoda STACK je stejná jako PUBLIC,
navíc ukazatel SS:SP v cílovém EXE souboru bude nastaven na konec segmentu.</dd>
</dl>

<h5 id="SegmentCLASSeq"><a href="#SEGMENT">&uarr; CLASS=</a></h5>
<p>Hodnotou parametru CLASS= je nepovinný identifikátor. Může být použit linkerem
k odhadnutí účelu segmentu (CODE|DATA|BSS) v objektových formátech,
které nepřenášejí informaci o účelu segmentů (OMF).</p>


<h4 id="GROUP"><a href="#PseudoInstructions">&uarr; GROUP</a></h4>
<p>Tato pseudoinstrukce určuje <strong>adresní rámec</strong>
a vyjmenovává segmenty adresovatelné jedním segmentovým registrem.</p>
<p>Grupy segmentů se uplatní ve velkých 16bitových programech v reálném módu.
Pouze 16bitový segment může být členem grupy.</p>
<p>Jméno grupy je definováno v poli návěstí pseudoinstrukce GROUP.
Jména jejich segmentů jsou v poli operandů. všechna jména jsou v hranatých závorkách <kbd>[ ]</kbd>.
Jméno grupy se může shodovat se jménem prvního segmentu. Příklad:
<br/><code>[DGROUP] GROUP [DATA],[STRINGS]</code>.
<br/>Segmenty patřící do grupy mohou být definovány před nebo po instrukci GROUP.
Tato pseudoinstrukce nemá žádné klíčové operandy.</p>
<p>Vztah mezi grupou a jejími segmenty v době linkování se podobá vztahu
mezi segmentem a jeho sekcemi v době překladu.</p>

<hr/>

<h4 id="PROC"><a href="#PseudoInstructions">&uarr; PROC</a></h4>
<h4 id="ENDPROC"><a href="#PseudoInstructions">&uarr; ENDPROC</a> neboli
<a id="ENDP" href="#PseudoInstructions">&uarr; ENDP</a></h4>
<h5><a href="#ProcDISTeq">DIST= &darr;</a></h5>
<h5><a href="#ProcALIGNeq">ALIGN= &darr;</a></h5>
<h5><a href="#ProcNESTINGCHECKeq">NESTINGCHECK= &darr;</a></h5>

<p>Pseudoinstrukce <dfn>PROC</dfn> a <dfn>ENDPROC</dfn> deklarují blok procedury a její jmenný prostor.
Procedura často končí strojovou instrukcí RET, takže blok může být volán pomocí <em>CALL</em>.
Po vykonání se <em>vrací</em> zpět za instrukci CALL.</p>
<p>Povinné návěstí pseudoinstrukce <code>PROC</code> deklaruje symbol, který je zároveň názvem procedury.
Stejný identifikátor může být použit jako první a zároveň jediný operand odpovídající pseudoinstrukce <code>ENDPROC</code>.
<br/>Místo ENDPROC lze také používat její variantu ENDP.</p>
<p>Pseudoinstrukce <code>ENDPROC</code> může rovněž definovat své vlastní návěstí.
To však nereprezentuje adresu návratu ze subprogramu, nýbrž ukazuje na kód následující po bloku PROC..ENDPROC.
Návěstí ENDPROC je užitečné pouze, pokud je PROC..ENDP blok využit k definování jmenného prostoru
a ne jako volatelný blok podprogramu. Příklady:</p>
<pre>SubPgm:PROC ; Definuj PROC jako <b>volatelný podprogram</b>.
          ; Instrukce procedury jsou zde.
          TEST JakásiPodmínka
          JC .Abort:  ; Jdi k návratu a pak pod instrukci <code>CALL SubPgm:</code>.
          TEST JináPodmínka
          JC .End:    ; Jdi pod pseudoinstrukci <code>.End: ENDP</code>. <del>Patrně ne to, co  programátor chtěl.</del>.
          ; Další instrukce procedury.
.Abort:   RET         ; Návrat pod instrukci <code>CALL SubPgm:</code>.
.End:  ENDP SubPgm:</pre>
<pre>NameSp:PROC ; Definuj PROC jako <b>průchozí blok</b>.
          ; Instrukce procedury jsou zde.
          TEST JakásiPodmínka
          JC .End:  ; Jdi pod pseudoinstrukci <code>.End:  ENDP NameSp:</code>.
          ; Další instrukce procedury. Chybí zde RET.
.End:  ENDP NameSp: ; Pokračuj pod touto instrukcí.</pre>

<p>Pseudoinstrukce <code>PROC, ENDPROC, PROC1, ENDPROC1</code> neemitují žádný strojový kód.</p>
<p>Skok na <code>ENDPROC</code> se liší od skoku na makroinstrukci
<code>EndProcedure</code> definovanou v
<a class="EXT" href="../maclib/#CallMaclibs">makroknihovně volacích konvencí</a>.</p>


<blockquote><p>K čemu vlastně jsou procedury dobré?
Mohli bychom se bez nich snadno obejít, avšak zabalení kusu kódu do PROC..ENDPROC má svoje výhody:</p>
<ul><li>Kód je lépe strukturován a snazší k porozumění.</li>
<li>&euro;ASM kontroluje správné spárování návěstí, což je zvláště důležité, pokud jsou procedury vnořeny.</li>
<li>Je jasné, kde procedura končí. Nemusíme prohlíže kód a hledat, která z instrukcí RET je poslední,
když potřebujeme zkopírovat proceduru do jiného programu.</li>
<li>Každý blok PROC..ENDP definuje svůj vlastní jmenný prostor a zabraňuje tak konfliktům
lokálních jmen v proceduře použitých.</li>
</ul></blockquote>

<h5 id="ProcDISTeq"><a href="#PROC">&uarr; DIST=</a></h5>
<p>Pseudoinstrukce PROC a PROC1 akceptují klíčové operandy DIST= and ALIGN=.
<dfn>DIST=</dfn> nastavuje vzdálenost procedury (NEAR nebo FAR).
Když je <code>DIST=FAR</code>, všechna volání této procedury jsou FAR, a všechny instrukce RET uvnitř této procedury jsou jako výchozí rovněž FAR.
(lze to ovšem změnit přípomou instrukce, tedy CALLN/CALLF, RETN/RETF).
Výchozí hodnota tohoto parametru zavísí na <a href="#MODELeq">paměťovém modelu</a>.</p>

<h5 id="ProcALIGNeq"><a href="#PROC">&uarr; ALIGN=</a></h5>
<p>Výchozí zarovnání procedury je <code>ALIGN=BYTE</code>.
Pro lepší výkonnost může být užitečné doplnit často volané procedury parametrem
<code>PROC ALIGN=OWORD</code>, pokud není nárůst délky programu problém.</p>

<h5 id="ProcNESTINGCHECKeq"><a href="#PROC">&uarr; NESTINGCHECK=</a></h5>
<p>Tato booleovská volba dovoluje vypnout kontrolu párování návěstí v bloku PROC..ENDPROC.
Má to jen vyjímečné uplatnění v makrech simulujících vestavěné pseudoinstrukce,
které potřebují ošálit kontext, jako je
<a class="EXT" href="../maclib/stdcal32.htm#Procedure">Procedure</a> a
<a class="EXT" href="../maclib/stdcal32.htm#EndProcedure">EndProcedure</a>.</p>
<p>Viz také instrukční modifikátor <a href="#NESTINGCHECKeq">NESTINGCHECK=</a>.</p>
<blockquote>Pseudoinstrukce PROC neakceptuje pořadové parametry proceduře předávané.
Místo toho mohou být operandy předávány v registrech nebo na zásobníku.
<a class="EXT" href="../maclib/#CallMaclibs">Makroknihovny volacích konvencí</a>
dodávané s EuroAssemblereme ale definují makra <dfn>Procedure</dfn>
a <dfn>EndProcedure</dfn> s podobnou funkcí jako PROC a ENDPROC,
které naopak dovolují předávání libovolného počtu operandů jako parametru maker,
když je Procedura volána.</blockquote>

<h4 id="PROC1"><a href="#PseudoInstructions">&uarr; PROC1 </a></h4>
<h4 id="ENDPROC1"><a href="#PseudoInstructions">&uarr; ENDPROC1</a> neboli
<a id="ENDP1" href="#PseudoInstructions">&uarr; ENDP1</a></h4>
<p>Pseudoinstrukce <dfn>PROC1</dfn> a <dfn>ENDPROC1</dfn> se podobají na
PROC a ENDPROC, avšak jsou tu dva rozdíly:</p>
<ol><li><p>Procedura deklarovaná blokem PROC1..ENDPROC1 se může vyskytnout v programu více než jednou.
Opakované deklarace PROC1..ENDPROC1 se stejným návěstím jsou ignorovány
a <strong>emitovány pouze jednou</strong>.</p>
<blockquote><p>Předurčuje to použití PROC1 k definici <a href="#EaFnRfSemiinlineMacro">
napůl-inline maker</a>, které obsahují jak volání procedury, tak i proceduru samotnou.
Když je procedura definována v makru pomocí PROC1..ENDPROC1, takové makro může být voláno mnohokrát,
ale volaná procedura bude přeložena a emitována pouze jednou, během první expanze makra.</p></blockquote></li>
<li>Blok definovaný pomocí PROC1..ENDPROC1 není emitován do aktuální sekce.
&euro;ASM místo toho automaticky přepne do <strong>odlišné kódové sekce</strong>
a k původní sekci se vrátí až po zpracování ENDPROC1.
Sekce, do níž &euro;ASM přepíná, se jmenuje <code>[@RT1]</code>
a je automaticky zřízena v segmentu s účelem <code>PURPOSE=CODE+LITERAL</code>
nebo v naposledy definovaném kódovém segmentu.
V některých případech může &euro;ASM použít také sekce <code>[@RT2]</code>, <code>[@RT3]</code> atd.
K tomu dochází, pokud kód uvnitř bloku PROC1..ENDPROC1 obsahuje další napůl-inline makra,
takže aktuální sekce již je <code>[@RT1]</code> a &euro;ASM musí zvolit odlišnou sekci.
<blockquote><p>Emitování procedur do odlišné sekce než hlavní program má také výhodu,
že taková procedura nemusí být přeskakována pomocí JMP. Často to vede ke kratšímu programu,
neboť skok přes napůl-inline makro nemusí přeskakovat celé tělo procedury,
což by jinak mohlo překročit 128 bajtovou hranici a vyžadovat delší variantu skokové instrukce.</p></blockquote>
</li></ol>

<h4 id="HEAD"><a href="#PseudoInstructions">&uarr; HEAD</a></h4>
<h4 id="ENDHEAD"><a href="#PseudoInstructions">&uarr; ENDHEAD</a></h4>
<p>Blok deklarovaný pseudoinstrukcemi <dfn>HEAD</dfn> a <dfn>ENDHEAD</dfn>
pouze vymezuje oddíl zdrojového kódu.
Tento oddíl může být vložen do jiného zdrojového souboru pseudoinstrukcí <a href="#INCLUDEHEAD">INCLUDEHEAD</a>
nebo <a href="#INCLUDEHEAD1">INCLUDEHEAD1</a>.
Blok obvykle obsahuje interface programovacího objektu
(definice struktur, maker, konstant), které potřebujeme vložit
do jiných, separátně překládaných modulů.</p>
<p>Návěstí pseudoinstrukce HEAD může být použito jako identifikátor bloku,
avšak nevytváří symbol. V jednom zdrojovém souboru může být definováno více než jeden blok HEAD..ENDHEAD.
Pokud jsou tyto bloky vnořeny jeden do druhého, bude vložen celý vnější (delší) blok.</p>
<blockquote><p>Jazyky bez takového mechanismu musejí ukládat interface do separátních hlavičkových souborů.
S pomocí HEAD.ENDHEAD je můžeme udržovat spolu s implementačním tělem v jednom kompaktním souboru.</p></blockquote>

<h4 id="INCLUDE"><a href="#PseudoInstructions">&uarr; INCLUDE</a></h4>
<p>Tato pseudoinstrukce začleňuje zdrojový soubor s názvem specifikovaným jako její operand
do hlavního zdrojového textu. Příkaz INCLUDE je virtuálně nahrazen obsahem inkludovaného souboru.</p>
<p>Inkluze mohou být vnořeny, tj. vložený soubor může obsahovat další povely INCLUDE.</p>
<p>Dvojité uvozovky mohou být vynechány, pokud jméno souboru obsahuje pouze alfanumerické znaky bez mezer a punktuace.</p>
<p>Každá pseudoinstrukce INCLUDE může mít neomezený počet operandů, např.
<code> INCLUDE "Win*.htm", ./MyConstants.asm, C:\MyLib\*.inc</code>.</p>
<p>Je-li soubor specifikován bez cesty, bude hledán ve složkách definovaných volbou <a href="#INCLUDEPATHeq">EUROASM INCLUDEPATH=</a>.
Obsahuje-li jméno souboru aspoň jedno lomítko nebo dvojtečku
<kbd> / \ : </kbd>, znamená to, že bylo specifikováno s vlastní <strong>cestou</strong> a <code>INCLUDEPATH=</code>
se v takovém případě ignoruje.</p>
<p>Název souboru může obsahovat <strong>žolíkové znaky</strong> <kbd> * ?</kbd>, v tom případě
&euro;ASM začlení všechny soubory odpovídající masce. Pořadí inkluze záleží na operačním systému.</p>
<p>Chování INCLUDE je popsáno v této tabulce:</p>
<table>
<tr><th>Cesta</th><th>Žolík</th><th>Příklad</th>
<th>Pokud je nalezen aspoň jeden soubor</th><th>Pokud nebyl nalezen žádný soubor</th></tr>
<tr><td>Ne</td><td>Ne</td><td><q>file.inc</q></td><td>Hotovo, nehledej dále v INCLUDEPATH.</td><td>Error E6914.</td></tr>
<tr><td>Ano</td><td>Ne</td><td><q>./file.inc</q></td><td>Hotovo.</td><td>Error E6914.</td></tr>
<tr><td>Ne</td><td>Ano</td><td><q>file*.inc</q></td><td>Prohledávej další soubory v INCLUDEPATH.</td><td>Nic nebylo vloženo, nehlas žádnou chybu.</td></tr>
<tr><td>Ano</td><td>Ano</td><td><q>./file*.inc</q></td><td>Pokračuj v hledání v dané cestě.</td><td>Nic nebylo vloženo, nehlas žádnou chybu.</td></tr>
</table>
<p>Pokud byl bezprostředně za jméno souboru přidán operátor <a href="#Substring">substring</a>
nebo <a href="#Sublist">sublist</a>, bude vložena pouze část takového souboru.
Příklad: <code> INCLUDE &quot;file.inc&quot;{%&amp;-20..%&amp;}</code>
začlení posledních dvacet řádků <q>file.inc</q>
(<a href="#AutomaticVariables">automatická %proměnná</a> <code>%&amp;</code>
reprezentuje počet řádků v souboru).
Jméno souboru musí být v uvozovkách, pokud je použita suboperace.
Pokud název souboru obsahuje žolíkové znaky <kbd>* ?</kbd>,
suboperace se bude vztahovat na všechny soubory vyhovující masce.</p>

<h4 id="INCLUDE1"><a href="#PseudoInstructions">&uarr; INCLUDE1</a></h4>
<p>Pseudoinstrukce <dfn>include jednou</dfn> se chová stejně jako <code>INCLUDE</code>,
ale nejprve se podívá, zda už nebyl vložen stejný soubor
(se stejnou velikostí a obsahem, bez ohledu na jméno).
V takovém případě jej přeskočí.</p>
<blockquote>Používání INCLUDE1 namísto INCLUDE dovoluje vyřešit vzájemné závislosti zdrojových knihoven.
Pokud některá knihovna používá makra, struktury a konstanty definované v jiné knihovně,
můžeme volat <code>INCLUDE1 jiná.knihovna</code>.</blockquote>

<h4 id="INCLUDEHEAD"><a href="#PseudoInstructions">&uarr; INCLUDEHEAD</a></h4>
<p>Pseudoinstrukce <dfn>INCLUDEHEAD</dfn> začleňuje ze jmenovaného souboru pouze obsah bloků
<a href="#HEAD">HEAD..ENDHEAD</a>. Viz test <a class="EXT" href="../eatests/t2420.htm">t2420</a>.
Neexistuje-li ani jeden blok HEAD..ENDHEAD, nebo pokud je nekompletní (chybí ENDHEAD),
&euro;ASM ohlásí chybu.</p>
<p>Pokud je použita suboperace, je nejprve aplikována na celý soubor
a bloky HEAD..ENDHEAD jsou hledány až v takto ořezaném zdroji.</p>

<h4 id="INCLUDEHEAD1"><a href="#PseudoInstructions">&uarr; INCLUDEHEAD1</a></h4>
<p>INCLUDEHEAD1 a INCLUDE1 se ignorují, pokud soubor nebo jen část z něho již byly vloženy do hlavního programu
pomocí INCLUDE, INCLUDE1, INCLUDEHEAD nebo INCLUDEHEAD1.</p>
<blockquote>Knihovna se považuje za již vloženou, pokud byla inkludována
jako celek pomocí INCLUDE nebo INCLUDE1, pokud její interface byl inkludován
pomocí INCLUDEHEAD nebo INCLUDEHEAD1, nebo pokud byla inkludována pouze její suboperovaná část.</blockquote>

<h4 id="INCLUDEBIN"><a href="#PseudoInstructions">&uarr; INCLUDEBIN</a></h4>
<p>Na rozdíl od INCLUDE a INCLUDEHEAD nechápe tato pseudoinstrukce obsah souboru
jako zdrojový kód k přeložení, ale emituje jeho obsah tak jak je na pozici určenou
aktuálním ukazatelem <kbd>$</kbd> aktuální sekce.</p>
<blockquote><p>Vložení binárních dat by nemělo být zaměňováno s linkováním;
neaktualizuje relokabilní adresy ani nespojuje externí symboly.
Například povel
<code>INCLUDEBIN "C:\WINNT\Media\chimes.wav"[0x2C..]</code>
přeskočí prvních 0x2C bajtů hlavičky WAV ve zvukovém souboru a zavede jen zbytek
(syrové hudební vzorky) do překládaného cíle, jako by byly definovány pomocí DB.
</p><p>Viz též test <a class="EXT" href="../eatests/t2470.htm">t2470</a>.</p>
</blockquote>

<h4 id="LINK"><a href="#PseudoInstructions">&uarr; LINK</a></h4>
<p>Pseudoinstrukce <dfn>LINK</dfn> určuje soubor(y), které by měly být linkovány do aktuálního programu.</p>
<p>Každý ordinální operand reprezentuje název souboru, může mít žolíkové znaky <kbd>* ?</kbd>
a může být specifikován bez anebo s cestou. Relativní cesta odkazuje na aktuální adresář.</p>
<p>Neobsahuje-li jméno souboru cestu, bude hledáno ve všech adresářích definovaných volbou
<code>EUROASM LINKPATH=</code>.
Na rozdíl od inkludovaných souborů zde suboperace nejsou podporovány.</p>
<blockquote>Linkovatelné soubory mají speciální interní strukturu,
která by patrně byla suboperací poškozena.</blockquote>
<p>Pozice příkazu LINK v programu není důležitá,
k samotnému linkování dojde až bude poslední průchod programu končit.
Pořadí linkovaných souborů však respektuje pořadí, v němž se objevily v příkazech LINK.
Příklady:</p>
<pre> LINK Subproc.obj, "..\My modules\W*.obj"</pre>
<p>Viz také <a href="#EaFnLinkStatic">statické linkování</a> pro další informace</p>


<h4 id="PUBLIC"><a href="#PseudoInstructions">&uarr; PUBLIC</a></h4>
<p>Pseudoinstrukce <code>GLOBAL, PUBLIC, EXTERN, EXPORT, IMPORT</code> nastavují
<a href="#Scope">viditelnost</a> symbolu, což bude použito při <a href="#EaFnLink">linkování</a>.</p>
<p>Symbol, jehož viditelnost se deklaruje, může být v poli návěstí nebo v poli operandů nebo v obojím.
Více než jeden symbol může být deklarován jedním povelem.
Dotyčné symboly mohou být odkazovány dopředu nebo zpětně.</p>
<h6>Explicitní deklarace viditelnosti se může objevit potom nebo předtím, než je symbol definován či odkazován.</h6>
<p>Příklad explicitní deklarace čtyř symbolů: <code> Sym1 PUBLIC Sym2, Sym3, Sym4</code></p>
<p>Deklarace symbolu jako PUBLIC pouze sděluje EuroAssembleru, že symbol,
který byl či bude definován někde jinde v programu, by měl být odkazovatelný
z jiných staticky linkovaných modulů.
Deklarace PUBLIC zatím symbol nevytváří, ve skutečnosti musí být definován
někde jinde v tomtéž programu.</p>

<h4 id="EXTERN"><a href="#PseudoInstructions">&uarr; EXTERN</a></h4>
<p>Pseudoinstrukce <code>EXTERN symbol</code> říká EuroAssembleru, že tento symbol není definován v programu,
takže odkazy na jeho adresu musí být v link-time záplatovány.
Bylo by chybou definovat symbol deklarovaný jako EXTERN
v tomtéž modulu. Místo toho bude symbol hledán v ostatních modulech
v čase linkování a pouze linker může ohlásit chybu, pokud jej nenajde.</p>

<h4 id="GLOBAL"><a href="#PseudoInstructions">&uarr; GLOBAL</a></h4>
<p>Pseudoinstrukci GLOBAL lze použít ke zjednodušení nakládání s viditelnostmi
PUBLIC a EXTERN. Pokud je symbol deklarován jako GLOBAL,
chová se buď jako PUBLIC nebo jako EXTERN, v závislosti na tom, zda byl či nebyl definován ve stejném programu.</p>
<blockquote>
Programátor ovšem ví, jestli symbol patří do aktuálního programu nebo ne, tak proč je deklarace
PUBLIC a EXTERN duplikována pomocí GLOBAL?
Mějme program PgmA definující PUBLIC symbol SymA a odkazující na EXTERN symbol SymB.
Podobně program PgmB definuje SymB a odkazuje na SymA:
<pre>
PgmA PROGRAM
      PUBLIC SymA
      EXTERN SymB
      CALL SymB: ; Reference na externí symbol.
SymA: RET        ; Definice public symbolu.
     ENDPROGRAM PgmA

PgmB PROGRAM
      PUBLIC SymB
      EXTERN SymA
      CALL SymA: ; Reference na externí symbol.
SymB: RET        ; Definice public symbolu.
     ENDPROGRAM PgmB</pre>
Nahradíme-li deklarace PUBLIC a EXTERN pomocí GLOBAL,
stejná deklarace bude moci být použita ve všechn staticky linkovaných programech
a můžeme ji copy&amp;pastovat nebo inkludovat, což je snazší k údržbě.:
<pre>
PgmA PROGRAM
      GLOBAL SymA, SymB
      CALL SymB: ; Reference na externi symbol.
SymA: RET        ; Definice public symbolu.
     ENDPROGRAM PgmA

PgmB PROGRAM
      GLOBAL SymA, SymB
      CALL SymA: ; Reference na externí symbol.
SymB: RET        ; Definice public symbolu.
     ENDPROGRAM PgmB</pre>
Další <em>raison d'être</em> direktivy GLOBAL je zpětná kompatibilita s NASM,
který nezná direktivu PUBLIC a používá místo ní GLOBAL.
</blockquote>

<h4 id="IMPORT"><a href="#PseudoInstructions">&uarr; IMPORT</a></h4>
<p>Viditelnosti IMPORT a EXPORT se používají při <a href="#EaFnLinkDynamic">dynamickém linkování</a>,
kdy náš program volá importovanou funkci z DLL.
Tato pseudoinstrukce akceptuje klíčový parametr <code>LIB=</code>,
jenž specifikuje soubor knihovny. Parametr LIB= lze vynechat, pokud jsou symboly importovány
z výchozí knihovny MS-Windows <q>kernel32.dll</q>.
<br/>Knihovní soubor nemusí být v uvozovkách, pokud dodržuje DOSové konvence 8.3.
Knihovna je vždy specifikována bez cesty. Operační systém má svoje vlastní pravidla
(<a class="EXTL" href="../eadoc/links.htm#WinDllSearchOrder">[WinDllSearchOrder]</a>)
týkající se adresářů, v nichž se mají knihovny hledat v bind-time.</p>

<h4 id="EXPORT"><a href="#PseudoInstructions">&uarr; EXPORT</a></h4>
<p>Viditelnost EXPORT se použije, když vytváříme dynamickou knihovnu;
deklaruje symboly, které mají být importovány jinými programy.
Podobně jako u PUBLIC, symbol označený pro EXPORT musí být dříve či později definován v programu.</p>
<p>Pseudoinstrukce EXPORT rozeznává dva klíčové parametry
<code>FWD=</code> a <code>LIB=</code> specifikující, že exportovaný symbol (jméno funkce)
je ve skutečnosti poskytováno jinou dynamickou knihovnou (definovanou pomocí LIB=)
pod odlišným názvem symbolu (definovaným pomocí FWD=). Příklad: <pre>
kernel32 PROGRAM FORMAT=DLL
          EXPORT EnterCriticalSection, LIB="NTDLL.dll", FWD=RtlEnterCriticalSection
          ; Další kernelové funkce.
         ENDPROGRAM kernel32
</pre>
<p>Knihovna "kernel32.dll" nabízí API funkci RtlEnterCriticalSection, která je ve skutečnosti
poskytována knihovnou "NTDLL.dll". V jiné verzi MS-Windows může být poskytnuta
odlišnou knihovnou "XPDLL.dll", ale programy importující funkci
z <em>proxy knihovny</em> "kernel32.dll" nebudou potřebovat aktualizaci ani rekompilaci.</p>

<h4 id="ALIGN"><a href="#PseudoInstructions">&uarr; ALIGN</a></h4>
<p>Tato pseudoinstrukce je určena k explicitnímu <a href="#Alignment">
zarovnání</a> aktuálního sekčního ukazatele <kbd>$</kbd>. Kupříkladu
<code>ALIGN OWORD</code> v kódové sekci bude emitovat několik (0 až 15)
bajtů instrukce NOP, takže další instrukce bude emitována na adresu zarovnanou k octwordu (16).
V datové sekci ALIGN používá bajt NUL (<kbd>0x00</kbd>)
namísto NOP (<kbd>0x90</kbd>) jako výplň.</p>
<p>Operand může být specifikován v krátké nebo dlouhé notaci:
<code>B, U, W, D, Q, T, O, Y, Z, BYTE, UNICHAR, WORD, DWORD, QWORD, TBYTE, OWORD, YWORD, ZWORD</code>
nebo jako aritmetický výraz vyhodnocovaný na mocninu dvou:
<code>1, 2, 4, 8, 16, 32, 64, 128, 256, 512</code>.
<br/><code>ALIGN TBYTE</code> zarovnává na 8.</p>
<p>Pseudoinstrukce ALIGN nesmí mít návěstí, ale může mít dva operandy.
Ten druhý je určen k záměrnému &quot;odrovnání&quot;; nemusí být mocninou dvou,
ale musí být menší než první operand. Například
<code>ALIGN OWORD, QWORD</code> zarovná <kbd>$</kbd> na lichý násobek osmi.
<br/><code>ALIGN 8,2</code> zarovná aktuální ofset na druhý bajt osmibajtového slova.
Tomu vyhovují ofsety 2, 10, 18, 26 atd.</p>


<h4 id="STRUC"><a href="#PseudoInstructions">&uarr; STRUC</a></h4>
<h4 id="ENDSTRUC"><a href="#PseudoInstructions">&uarr; ENDSTRUC</a></h4>
<p><dfn>Struktura</dfn> reprezentuje virtuální sekci datových deklarací,
kterou si lze představit jako masku nebo mřížku položenou nad kusem paměti.
Struktura je deklarována blokem STRUC..ENDSTRUC.
Jediné instrukce použitelné v bloku jsou</p>
<ol><li>definice dat specifikované pseudoinstrukcí <a href="#D">D</a>
a jejími klony, buď inicializované, nebo neinicializované</li>
<li>instrukce pro explicitní zarovnání (pseudoinstrukce <a href="#ALIGN">
ALIGN</a>)</li>
<li>pseudoinstrukce STRUC a ENDSTRUC (&euro;ASM dovoluje vnořené definice struktur)</li>
<li>řádkové a značkovací komentáře</li></ol><samp>
|[.data]                   ::::Section changed.
|00000000:                 |                      ; Příklad deklarace struktury:
|[MyStruc]                 |MyStruc: STRUC
|00000000:................ |.Member1  D Q         ; Neinicializovaný člen typu QWORD.
|00000008:........         |.Member2  D D         ; Neinicializovaný člen typu DWORD.
|0000000C:........         |          D D         ; Neinicializovaný anonymní člen typu DWORD.
|00000010:FF               |.Member3  D B 255     ; Inicializovaný čle typu BYTE.
|00000011:..               |.Member4  D B         ; Neinicializovaný člen typu BYTE.
|00000012:............     |          ALIGN QWORD ; Zvětši velikost MyStruc na násobek QWORD.
|00000018:                 |        ENDSTRUC MyStruc
|[.data]                   ::::Section changed.
|00000000:                 |
|00000000:                 |
|00000000:18000000         |        DD SIZE# MyStruc    ; MyStruc je dlouhá 0x18 bajtů.
|00000004:53000000         |        DD TYPE# MyStruc    ; Typ kterékoli struktury je 'S'.
|00000008:00000000         |        DD SEGMENT# MyStruc ; Segment/sekce/ofset kterékoli struktury je skalární nula.
|0000000C:                 |</samp>
<p>Deklarace struktury neemituje žádná data do cílového souboru.
Data budou emitována nebo rezervována až když bude struktura skutečně použita v datové definici
(v pseudoinstrukci <a href="#D">D nebo DS</a>).
Říkáme tomu, že struktura bude <em>instanciována</em>.
<br/>Jsou-li v definici struktury definována inicializovaná data,
budou použita k inicializaci odpovídajících členů při její instancionizaci.
(pseudoinstrukcí D nebo DS), ledaže by byly explicitně redefinovány.</p>
<p>Definici dat ve struktuře musí mít lokální jména (začínající tečkou <kbd>.</kbd>).
<br/>To dovoluje použít <ol><li>stejná jména jako členy různých struktur</li>
<li>a vyvarovat se konfliktu jmen, jsou-li definovány vícenásobné objekty téže struktury.</li></ol>
<p>Každý člen dostává svůj ofset relativní k začátku struktury.
Nezaáleží na tom, jaká programová sekce byla aktuální při deklaraci struktury.
Každá deklarace dočasně vytváří svou vlastní pseudosekci s virtuální adresou 0.</p>
<p>Struktura musí dostat unikátní <dfn>název</dfn>
definovaný v poli návěstí instrukce STRUC a volitelně také v poli operandu instrukce ENDSTRUC.</p>
<p>Na velikost struktury můžeme odkazovat pomocí atributu <code>SIZE#Jméno_struktury</code>.</p>
<p>Pseudoinstrukce STRUC akceptuje klíčový operand ALIGN= specifikující zarovnání instancí struktury,
pokud je <code>EUROASM AUTOALIGN=ON</code>.
<br/>Není-li zarovnání explicitně požadováno v deklaraci STRUC,
bude použito zarovnání závislé na šířce programu (<code>PROGRAM WIDTH=</code>), tedy WORD, DWORD nebo QWORD.</p>
<p>Viz testy <a class="EXT" href="../eatests/t2500.htm">t2500</a>,
<a class="EXT" href="../eatests/t2501.htm">t2501</a>,
<a class="EXT" href="../eatests/t2504.htm">t2504</a> pro více příkladů deklarací struktur.</p>

<h4 id="D"><a href="#PseudoInstructions">&uarr; D, DB, DU, DW, DD, DQ, DT, DO, DY, DZ, DI, DS</a></h4>
<p>Inicializovaná i neinicializovaná data jsou definována a rezervována pseudoinstrukcí <dfn>D</dfn>.
Je-li v ní specifikována statická hodnota, data jsou <dfn>definována</dfn>.
Pokud je hodnota vynechána, data jsou <dfn>rezervována</dfn>.
Je-li nastavena volba <code>EUROASM AUTOSEGMENT=ON</code>, data typu INSTR způsobí přepnutí do kódové sekce,
všechny ostatní definice dat přepínají do datové sekce a
rezervace dat do sekce <em>bss</em> (neinicializovaná data).</p>
<samp>|[.data]                   ::::Section changed.
|00000000:                 |; <abbr>Definice celých čísel:</abbr>
|00000000:01               |  D BYTE 1 ; Definuj integer typu BYTE s hodnotou 1 za použití dlouhého typového jména.
|00000001:00               ....AutoAlignment stuff.
|00000002:0200             |  D W 2    ; Definuj integer typu WORD s hodnotou 2 za použití zkratky typu.
|00000004:03000000         |  D D 3    ; Definuj integer typu DWORD s hodnotou 3.
|00000008:0400000000000000 |  D Q 4    ; Definuj integer typu QWORD s hodnotou 4.
|00000010:                 |; <abbr>Definice čísel s plovoucí tečkou:</abbr>
|00000010:0000A040         |  D D 5.0  ; Definuj FP číslo s jednoduchou přesností s hodnotou 5.
|00000014:00000000         ....AutoAlignment stuff.
|00000018:0000000000001840 |  D Q 6.0  ; Definuj FP číslo s dvojitou přesností s hodnotou 6.
|00000020:00000000000000E0~|  D T 7.0  ; Definuj FP číslo s rozšířenou přesností s hodnotou 7.
|0000002A:                 |  ; <abbr>Definice řetězců:</abbr>
|0000002A:4279746573       |  D B "Bytes"    ; Definuj řetězec bajtů
|0000002F:00               ....AutoAlignment stuff.
|00000030:55006E0069006300~|  D U "Unichars" ; Definuj řetězec unicharů.
|00000040:4368617273       |  D   "Chars"    ; Definuj řetězec znaků (záleží na volbě UNICODE=).
|00000045:                 |  ; <abbr>Definice instrukčního kódu:</abbr>
|[.text]                   ::::Section changed.
|00000000:90               |  D INSTR "NOP"  ; Definuj operační kód instrukce NOP za použití dlouhého typového jména.
|00000001:C3               |  D I "RET"      ; Definuj operační kód instrukce RET za použití krátkého typového jména.
|00000002:                 |  ; <abbr>Rezervace řetězců:</abbr>
|[.bss]                    ::::Section changed.
|00000000:................ |  D 8 * B  ; Rezervuj místo pro řetězec dlouhý 8 bajtů.
|00000008:................~|  D 9 * U  ; Rezervuj místo pro řetězec dlouhý 9 unicharů.
|0000001A:                 |  ; <abbr>Rezervace čísel:</abbr>
|0000001A:....             |  D W      ; Rezervuj místo pro 1 WORD.
|0000001C:........         |  D D      ; Rezervuj místo pro 1 DWORD.
|00000020:................ |  D Q      ; Rezervuj místo pro 1 QWORD.
|00000028:................~|  D T      ; Rezervuj místo pro 1 TBYTE.
|00000032:                 |  ; <abbr>Rezervace vektorů:</abbr>
|00000032:................~....AutoAlignment stuff.
|00000040:................~|  D O      ; Rezervuj místo pro 1 OWORD (může obsahovat 2*QWORD nebo 4*DWORD).
|00000050:................~....AutoAlignment stuff.
|00000060:................~|  D Y      ; Rezervuj místo pro 1 YWORD (může obsahovat 4*QWORD nebo 8*DWORD).
|00000080:................~|  D Z      ; Rezervuj místo pro 1 ZWORD (může obsahovat 8*QWORD nebo 16*DWORD).
|000000C0:                 |</samp>
<p>Viz test <a class="EXT" href="../eatests/t2482.htm">t2482</a> pro další příklady.</p>
<p>Každý operand pseudoinstrukce <code>D</code> je <a href="#DataExpressions">datový výraz</a>.</p>
<p>K mnemonice <code>D</code> může být připojena přípona
<code>B, U, W, D, Q, T, O, Y, Z, I, S</code>. Tato přípoda definuje výchozí datový typ
použitý, pokud nebyl výslovně specifikován v operandu.
Například <code>DD 2,3,4</code> definuje tři proměnné DWORD se statickými hodnotami 2, 3 a 4.</p>
<p>Přípona zároveň určuje typ symbolu, který definuje data.
V definici <code>Sym1 DQ B 1, W 2, D 4</code> přípona Q určuje, že typ symbolu Sym1 je QWORD, třebaže
tento symbol definuje pouze bajt, slovo a dvojslovo.</p>
<h6>V jedné instrukci D se mohou míchat různé datové typy.</h6>
<p>Výchozí typ určený příponou může být přepsán v operačním poli
explicitním datovým type v krátké nebo dlouhé notaci.
Operandy bez explicitní redefinice berou svůj typ z přípony instrukce D, např.
<code>DB 27, "$", W 120</code> definuje dva bajty následované jedním slovem.
Datatypy v operandu mohou být také specifikovány dlouhým typovým názvem, např.
<code>DB 27, "$", WORD 120</code>.
<br/>Viz test <a class="EXT" href="../eatests/t2481.htm">t2481</a> pro další příklady.</p>

<h6>Data mohou být duplikována.</h6>
<p>Například <code>TranslateTable: D 256 * BYTE</code> rezervuje 256 neinicializovaných bajtů.
<br/>Není-li duplikace použita, výchozí duplikační hodnota (duplikátor) je 1.
Negativní duplikátor není povolen.
<br/>Duplikátor 0 nedefinuje ani nerezervuje žádná data, ale stále poskytuje datový typ svému symbolu
a pokud je <code>AUTOALIGN=ON</code>, zarovnává aktuální ofset <kbd>$</kbd>.</p>
<p>Není-li použita žádná přípona, výchozí datový typ se bere z prvního neprázdného operandu
např. <code>D D 2,3,4</code> definuje tři DWORDy  s hodnotami 2,3 a 4.
Není-li výchozí typ určen, jako např. <code>D 2</code>, &euro;ASM oznámí chybu.</p>

<p>Jedinou výjimkou, kdy datový typ nemusí být specifikován,
je definice textového řetězce s vynecháním specifikátoru B nebo U,
např. <code>D "Nějaký text."</code>. V tom případě bude datovým typem <kbd>BYTE</kbd> nebo <kbd>UNICHAR</kbd>
v závislosti na aktuální hodnotě volby <code>EUROASM UNICODE=</code>.</p>
<h6>Data nejsou definována ani rezervována, pokud není použit žádný operand.</h6><pre>
L1: D  B 5      ; Definuj jeden bajt s hodnotou 5.       TYPE#L1='B', SIZE#L1=1.
L2: D  2*WORD 3 ; Definuj dvě slova s hodnotou 3.        TYPE#L2='W', SIZE#L2=4.
L3: DW W        ; Rezervuj jedno slovo.                  TYPE#L3='W', SIZE#L3=2.
L4: DW 0*D      ; Nezerezvuj nic, jen zarovnej na WORD.  TYPE#L4='W', SIZE#L4=0.
L5: DQ          ; Nerezervuj nic, jen zarovnej na QWORD. TYPE#L5='Q', SIZE#L5=0.
L6: D           ; Nedělej nic.                           TYPE#L6='A', SIZE#L6=0.</pre>
<blockquote>Na rozdíl od jiných asemblerů vynechaný operand neemituje žádná data,
&euro;ASM vyžaduje, aby byl specifikován typ operandu a případně i jeho hodnota,
bez ohledu zda je operace D s příponou nebo bez ní.
Kupříkladu <code>DB</code> rezervuje jeden bajt dat v MASM,
avšak nedělá nic v &euro;ASM. Použijte místo toho <code>D B</code> nebo <code>DB B</code>.</blockquote>

<p id="DI">EuroAssembler umí definovat <strong>strojový kód</strong> instrukce jako data
pomocí pseudoinstrukce <dfn>DI</dfn>. Ta se podobá pseudoinstrukcím DB nebo DU,
ale obsah řetězce není doslovně emitován, nýbrž nejprve přeložen asemblerem.
Text v uvozovkách operandu DI by měla být platná
<a href="#MachineInstructions">strojová instrukce</a>,
může mít prefix a operandy, ale ne návěstí.</p>
<p>Například <code> DI "SEGES:MOVSB"</code> definuje bajty 0x26,0xA4.
<br/><code> D 8*I"MOVSD"</code> definuje osm bajtů 0xA5.
<br/>Viz test <a class="EXT" href="../eatests/t2515.htm">t2515</a> pro další příklady instrukce DI.</p>

<p id="DS"><strong>Strukturovaná paměťová proměnná</strong> je definována pseudoinstrukcí
<code> DS <em>jméno_struktury</em></code> nebo jen <code> D <em>jméno_struktury</em></code>.</p>
<h6>V instrukci D může být definován pouze jeden strukturovaný objekt.</h6>
<p>&euro;ASM nedovoluje vícenásobné operandy při definici strukturovaného objektu,
jako <code><del> DS MyStruc1, Mystruc2</del></code>.
Duplikace je ale podporována, např. <code> DS 4*MyStruc</code>.</p>
<p>Členy struktury mohou být přepsány staticky, pomocí klíčových operandů.
Klíčem je lokání jméno člena bezprostředně následované rovnítkem <kbd>=</kbd>
a novou hodnotou tohoto člena.
<a href="#Namespace">Jmenný prostor</a> pole operandů v instrukci DS je dočasně změněn
na jmenný prostor deklarace struktury.</p>
<p>Instance struktury MyStruc deklarované výše v příkladu <a href="#STRUC">STRUC</a>
mohla být definována jako <code> MyObject DS MyStruc, .Member2=2, .Member4=4</code>.
To inicializuje obsah MyObject.Member2 na DWORD integer 2, a obsah
MyObject.Member4 na BYTE integer 4.
Obsah MyObject.Member3 je již staticky definován jako BYTE integer 255,
ostatné členy MyObject zůstávají neinicializovány.
<br/>Je-li aspoň jeden člen inicializován, objekt je při AUTOSEGMENT=ENABLED
emitován do datové sekce namísto bss, neinicializované členy jsou naplněny nulami.
Viz též test <a  class="EXT" href="../eatests/t2510.htm">t2510</a>.</p>

<h4 id="EQU"><a href="#PseudoInstructions">&uarr; EQU</a></h4>
<h4 id="eq"><a href="#PseudoInstructions">&uarr; =</a></h4>
<p>Pseudoinstrukce <dfn>EQU</dfn> (nebo její synonymum <dfn>=</dfn>)
definuje symbol uvedený v jejím poli návěstí.
Tato pseudoinstrukce musí mít právě jeden operand
specifikující adresu nebo číselnou hodnotu symbolu.</p>
<p>Instrukce <code>Label:EQU $</code> nebo <code>Label:= $</code>
jsou ekvivalentní k <code>Label:</code>, tj. specifikaci samotného návěstí,
což přiřazuje adresu návěstí k hodnotě Label.</p>
<p>EQU je jediný způsob, jak definovat prostý číselný symbol,
jako třeba <code>FILE_ATTRIBUTE_ARCHIVE = 00000020h</code>.</p>
<p>Viz kteroukoli <a class="EXT" href="../maclib/">makroknihovnu</a> v říši PROGRAM
jako příklad definic numerických symbolů, např.
<a class="EXT" href="../maclib/winsfile.htm#Constants">winsfile.htm</a>.</p>

<h4 id="pcCOMMENT"><a href="#PseudoInstructions">&uarr; %COMMENT</a></h4>
<h4 id="pcENDCOMMENT"><a href="#PseudoInstructions">&uarr; %ENDCOMMENT</a></h4>
<p>Tyto pseudoinstrukce definují <a href="#BlockComments">blokovou poznámku</a>,
tedy rozsah zdrojového kódu ignorovaný EuroAssemblerem.
V poli návěstí %COMMENT může být identifikátor dávající bloku jméno,
avšak netvoří symbol.
Stejný identifikátor může být použit jako operand instrukce %ENDCOMMENT.
Pomáhá to ke kontrole správného spojení %COMMENT &amp; %ENDCOMMENT,
zejména pokud jsou poznámky vnořeny.</p>

<h4 id="pcDROPMACRO"><a href="#PseudoInstructions">&uarr; %DROPMACRO</a></h4>
<p>%DROPMACRO říká EuroAssembleru, aby zapomenul dříve deklarované makroinstrukce.
Jedna pseudoinstrukce %DROPMACRO může zapomenout jedno nebo více maker specifikovaných jako její operand(y),
např. <code> %DROPMACRO Macro1, Macro2, Macro3</code>.</p>
<p>Taky může zapomenou všechna dosud deklarovaná makra pomocí <code>%DROPMACRO *</code>.
<p>Viz příklad <a href="#DroppingMacro">%DROPMACRO example</a> níže.</p>

<h4 id="pcIF"><a href="#PseudoInstructions">&uarr; %IF</a></h4>
<h4 id="pcELSE"><a href="#PseudoInstructions">&uarr; %ELSE</a></h4>
<h4 id="pcENDIF"><a href="#PseudoInstructions">&uarr; %ENDIF</a></h4>
<p>Instrukce mezi %IF a %ENDIF se překládají pouze tehdy, pokud podmínka
v prvním (a jediném) operandu pseudoinstrukce je vyhodnocena jako <em>pravda</em>.
%IF akceptuje <a href="#BooleansExt">booleovská rozšíření</a>
a rovněž akceptuje prázdný operand, který je vždy vyhodnocen jako <em>nepravda</em>.</p>
<p>Uvnitř bloku %IF..%ENDIF se může vyskytnout pseudoinstrukce %ELSE,
který obrací logiku: instrukce mezi %IF a %ELSE
se překládají, pokud je podmínka v %IF <em>pravda</em> a instrukce
mezi %ELSE a %ENDIF se překládají, pokud je podmínka %IF <em>nepravda.</em>.</p>
<p>Pseudoinstrukce %IF může mít identfikátor v poli pro návěstí,
který netvoří symbol, ale identifikuje blok.
Stejný identifikátor může být použit v poli operandu instrukcí %ELSE a %ENDIF.</p>

<h4 id="pcFOR"><a href="#PseudoInstructions">&uarr; %FOR</a></h4>
<h4 id="pcEXITFOR"><a href="#PseudoInstructions">&uarr; %EXITFOR</a></h4>
<h4 id="pcENDFOR"><a href="#PseudoInstructions">&uarr; %ENDFOR</a></h4>
<p>Pseudoinstrukce %FOR a %ENDFOR vytvářejí blok, jenž je překládán opakovaně
pro každý pořadový operand %FOR.
V poli návěstí %FOR musí být identifikátor. Není to symbol,
místo toho definuje formální preprocesní %proměnnou, která je dostupná
v těle bloku %FOR..%ENDFOR (a nikde jinde).
Jméno této %proměnné sestává ze znaménka procenta <kbd>%</kbd> následovaného identifikátorem.</p>
<p>Operandem může být libovolný element: registr, číslo, výraz, řetězec.
Formální %proměnné bude postupně přiřazován každý z pořadových operandů
a blok bude emitován s touto hodnotou.
Následující příklad definuje smyčku %FOR se třemi operandy a emituje tři paměťové proměnné:</p>
<pre>data %FOR "a", 3*B(5), "Long text"
       D %data
     %ENDFOR data
</pre> bude expandováno na
<samp>|00000000:61                 +       D "a"
|00000001:050505             +       D 3*B(5)
|00000004:4C6F6E672074657874 +       D "Long text"
|0000000D:                   |</samp>

<p>Zopakování identifikátoru v poli operandu instrukcí %ENDFOR a %EXITFOR je dobrovolné
a slouží ke kontrole správného párování blokových instrukcí.</p>
<p>Operandem %FOR rovněž může být číselný <a href="#Range">rozsah</a>;
blok pak bude emitován pro každou celočíselnou hodnotu z tohoto rozsahu.
Sklon rozsahu může být negativní, krok řídicí formální %proměnné
pak je <kbd>-1</kbd> namísto <kbd>+1</kbd>.</p>
<pre>
i  %FOR  0..5    ; Sklon je pozitivní, tedy krok je +1.
      DB "A"+%i  ; Definuj bajty "A","B","C","D","E","F".
   %ENDFOR i
j  %FOR 'z'..'x' ; Sklon je negativní, tedy krok je -1.
      DB %j      ; Definuj bajty 'z','y','x'.
   %ENDFOR j
</pre>
<p>Viz také test <a class="EXT" href="../eatests/t2640.htm">t2640</a>.</p>
<p>%FOR akceptuje celočíselný klíčový parametr <code>STEP=</code>
explicitně určující krok, kterým je %proměnná inkrementována při použití rozsahu.
Výchozí hodnotou je nula (<code>STEP=0</code>), která má speciální význam:
efektivní krok je pak buď <kbd>+1</kbd> nebo <kbd>-1</kbd>
v závislosti na sklonu rozsahu.</p>
<p>Oba druhy operandů (výčtový a rozsah) se mohou kombinovat.
Je-li STEP= explicitně stanoven a jeho znaménko se liší od sklonu v operandu rozsahu,
smyčka není v tom případě překládána.
Na druhé straně, pokud je STEP= vynechán nebo nastaven na <kbd>0</kbd>,
rozsahy obou sklonů mohou být kombinovány v jednom bloku %FOR
a každý z operandů rozsahu obdrží svůj vhodný krok <kbd>+1</kbd> nebo <kbd>-1</kbd>.
Ukázka:</p>
<pre>
a %FOR 1..3, 6..4, 7
     ; Blok je přeložen s %a = 1,2,3,6,5,4,7.
   %ENDFOR

b %FOR 0..64, 256, 400..300, 512, STEP=16
     ; Blok je přeložen s %b = 0,16,32,48,64,256,512.
   %ENDFOR
</pre>
<p>Má-li formální %proměnná bloku %identické jméno s jinou předtím uživatelsky definovanou %proměnnou,
formální %proměnná převáží a ta uživatelsky definovaná není v bloku %FOR..%ENDFOR viditelná.
Viz test <a class="EXT" href="../eatests/t2641.htm">t2641</a>.</p>
<p>Pokud &euro;ASM narazí na pseudoinstrukci <code>%EXITFOR</code>,
přeruší překlad dalších instrukcí bloku %FOR..%ENDFOR
a pokračuje pod %ENDFOR bez ohledu na to, kolik nezpracovaných operandů ještě zbývá.</p>
<pre>
i  %FOR 0..9
     DB %i
     %IF %i>=3
       %EXITFOR i
     %ENDIF
     DB "a" + %i
   %ENDFOR i ; Definuje bajty  0,"a",1,"b",2,"c",3
</pre>
<p>Ve vnořených blocích %FOR..%ENDFOR může být formální proměnná (první a jediný operand %EXITFOR)
použita ke specifikaci, který z vnořených bloků má být opuštěn.
Viz test <a class="EXT" href="../eatests/t2642.htm">t2642</a> jako příklad.</p>


<h4><a id="pcWHILE" href="#PseudoInstructions">&uarr; %WHILE</a></h4>
<h4><a id="pcEXITWHILE" href="#PseudoInstructions">&uarr; %EXITWHILE</a></h4>
<h4><a id="pcENDWHILE" href="#PseudoInstructions">&uarr; %ENDWHILE</a></h4>
<p>Blok instrukcí mezi %WHILE a %ENDWHILE se překládá asemblerem opakovaně
dokud podmínka v prvním (a jediném) operandu %WHILE je <em>pravda</em>.
Je-li podmínka <em>nepravda</em> už při vstupu do bloku, bude celý přeskočen.</p>
<p>V poli návěstí %WHILE a v poli operandu %ENDWHILE a %EXITWHILE může být stanoven identifikátor
pro vizuální svázání, který však netvoří symbol.</p>
<p>Na rozdíl od <a href="#pcFOR">%FOR</a>, který dočasně deklaruje a udržuje svou vlastní řídicí %proměnnou,
%WHILE to nedělá. Je na programátorovi, aby deklaroval nějakou uživatelskou %proměnnou
před vstupem do bloku a pak ji uvnitř %WHILE..%ENDWHILE měnil a testoval. Příklad:</p>
<pre>
%i  %SETA 3        ; Definuj uživatelskou %proměnnou %i, která bude řídit expanzi bloku.
Id1 %WHILE %i      ; Opakuj blok, dokud je %i nenulové. Id1 je identifikátor bloku.
C%i:  DB %i
%i    %SETA %i - 1 ; Změň řídicí proměnnou %i.
    %ENDWHILE Id1  ; Konec smyčky. Identifikátor souhlasí.
; Instrukce emitované blokem %WHILE..%ENDWHILE: <kbd>C3: DB 3</kbd>, <kbd>C2: DB 2</kbd>, <kbd>C1: DB 1</kbd>.
</pre>
<p>%EXITWHILE v bloku způsobí přeskočení zbytku instrukcí,
&euro;ASM bude pokračovat pod %ENDWHILE.</p>
<p>Viz testy <a class="EXT" href="../eatests/t2700.htm">t2700</a>,
<a class="EXT" href="../eatests/t2701.htm">t2701</a>,
<a class="EXT" href="../eatests/t2702.htm">t2702</a>.</p>

<h4 id="pcREPEAT"><a href="#PseudoInstructions">&uarr; %REPEAT</a></h4>
<h4 id="pcEXITREPEAT"><a href="#PseudoInstructions">&uarr; %EXITREPEAT</a></h4>
<h4 id="pcENDREPEAT"><a href="#PseudoInstructions">&uarr; %ENDREPEAT</a> alias</h4>
<h4 id="pcUNTIL"><a href="#PseudoInstructions">&uarr; %UNTIL</a></h4>
<p>Podmíněný blok %REPEAT..%ENDREPAT se podobá na %WHILE..%ENDWHILE,
avšak logika je obrácená. %REPEAT nepřijímá návěstí ani operand.
Instrukce v bloku jsou přeloženy vždy aspoň jednou.
Test řídicí podmínky je v poli operandu %ENDREPEAT;
pokud se vyhodnotí jako <em>nepravda</em>, &euro;ASM bude blok opakovaně překládat.
Namísto mnemoniky <code>%ENDREPEAT</code> lze použít alias <code>%UNTIL</code>.</p>
<p>Blok %REPEAT..%ENDREPEAT taky může používat identifikátor ke kontrole spárování.
Na rozdíl od ostatních blokových instrukcí je ale pozice blokového identifikátoru odlišná:
může být specifikován jako první operand %REPEAT
a zopakován v poli návěstí %ENDREPEAT (neboli %UNTIL).</p>
<pre>
%i  %SETA 3           ; Definuj %proměnnou %i, která bude řídit expanzi bloku.
    %REPEAT Id1       l Id1 je pouze identifikátor bloku, jinak nemá význam.
      C%i: DB %i
      %i %SETA %i - 1 ; Změň řídicí %proměnnou i.
Id1 %UNTIL %i = 0     ; Konec smyčky. Identifikátor souhlasí.
; Instrukce emitované blokem %REPEAT..%UNTIL block: <kbd>C3: DB 3</kbd>, <kbd>C2: DB 2</kbd>, <kbd>C1: DB 1</kbd>.
</pre>
<p>%EXITREPEAT v bloku způsobí přeskočení zbývajících instrukcí;
&euro;ASM bude pokračovat pod %ENDREPEAT.</p><p>Viz testy
<a class="EXT" href="../eatests/t2750.htm">t2750</a>,
<a class="EXT" href="../eatests/t2751.htm">t2751</a>,
<a class="EXT" href="../eatests/t2752.htm">t2752</a>.</p>

<h4 id="pcSET"><a href="#PseudoInstructions">&uarr; %SET</a></h4>
<p>Pseudoinstrukce %SET spolu s ostatními členy této rodiny
jsou určeny k přiřazení hodnoty do
<a href="#UserVariables">preprocesních %proměnných</a>.
Přiřazovaná %proměnná bude v poli návěstí této pseudoinstrukce.</p>
<p>%SET přiřazuje seznam operandů jako doslovný <strong>text</strong>,
včetně oddělujících čárek. Pouze mezery mezi mnemonikou (%SET) a seznamem operandů
a také mezery za posledním operandem jsou vynechány.
Podobně jsou mezery vynechány při použití <a href="#StmentLineCont">pokračování řádku</a>.</p>
<pre>%CardList %SET Hearts, Diamonds, Clubs, Spades  ; Comment
</pre>
<p>%CardList nyní obsahuje řetězec
<kbd>Hearts, Diamonds, Clubs, Spades</kbd>
(31 znaků včetně mezer a čárek).</p>
<p>Viz test <a class="EXT" href="../eatests/t2810.htm">t2810</a>.</p>


<h4 id="pcSETA"><a href="#PseudoInstructions">&uarr; %SETA</a></h4>
<p>%SETA akceptuje <strong>aritmetické</strong> výrazy. Budou vyhodnoceny
a pak přiřazeny %proměnné jako dekadické číslo.
Pokud operand %SETA není platným výrazem, ohlásí se chyba.</p>
<p>Je-li použit více než jeden operand, každá hodnota je vložena
jako odpovídající položka do %proměnné, které je přiřazováno. Příklad:</p>
<pre>%Value %SETA PoolEnd - PoolBegin
%Sizes %SETA 2+3, 4, ,-5*2</pre>
<p>Rozdíl mezi ofsety <kbd>PoolEnd</kbd> a <kbd>PoolBegin</kbd>
v předchozím příkladu je spočítán a přiřazen do %proměnné %Value jako dekadické číslo.
<br/>%Proměnná %Sizes nyní obsahuje text <kbd>5,4,,-10</kbd> (8 znaků).
Individuální položky ze %Sizes mohou být získány pomocí operace <a href="#Sublist">sublist</a>,
jako třeba <code>%Sizes{2}</code>.</p>
<p>Viz test <a class="EXT" href="../eatests/t2821.htm">t2821</a>.</p>
<blockquote>%SETA je vhodnější pro modifikaci kontrolní proměnné v preprocesních smyčkách,
jako <code>%i %SETA %i+1</code>.
I když textové přiřazení pomocí <code>%i %SET %i+1</code> by také fungovalo,
s pseudoinstrukcí %SET není výraz počítán okamžitě a mohli bychom skončit
s něčím jako <code>+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1</code>
po patnácté expanzi.</blockquote>

<h4 id="pcSETB"><a href="#PseudoInstructions">&uarr; %SETB</a></h4>
<p>%SETB se podobá %SETA, ale akceptuje <a href="#BooleansExt">rozšířené</a>
<strong>booleovské</strong> výrazy, které po vyhodnocení přiřazuje v podobě
binárních číslic <kbd>1</kbd> a <kbd>0</kbd>.
<p>Viz též test <a class="EXT" href="../eatests/t2831.htm">t2831</a>.</p>
<p>Na rozdíl od %SETA, binární číslice nejsou odděleny čárkami, je-li
více než jeden operand použit v pseudoinstrukci %SETB.
Položky mohou být získány pomocí operace <a href="#Substring">substring</a>.
Příklad:</p>
<pre>
%TooBig %SETB 5 > 4                   ; %Proměnné %TooBig je přiřazena hodnota znaku 1 (pravda).
%Flags  %SETB %TooBig, 2,,3>2,off,4,, ; %Flags je přiřazena hodnota 110101.
        %IF %Flags[1]                 ; Pravda, vyhodnotí 1. člen %Flags, tj. %TooBig, tj. 1.
Flags:  DB %Flags[]b                  ; Přeloží se jako Flags: DB 110101b.
</pre>

<h4 id="pcSETC"><a href="#PseudoInstructions">&uarr; %SETC</a></h4>
<p>%SETC akceptuje matematický výraz ve svém operandu, který se musí vyhodnotit
na prosté číslo ne vyšší než 255 a ne menší než -128.
Výsledek pak bude přiřazen jako <strong>znak</strong>
s touto vypočtenou hodnotou ASCII bajtu.
Příklad:</p>
<pre>
%Quote %SETC """" ; Přiřadí znak "uvozovka" (ASCII 33).
%Tab   %SETC 9    ; Přiřadí znak "tabelátor" (ASCII 9).
%NBSP  %SETC -1   ; Přiřadí znak "nepřerušitelná mezera" (ASCII 255).
</pre>
<p>Podobně jako %SETB, mohou být definovány vícenásobné operandy
a výsledné znaky nejsou oddělovány čárkami.</p>
<pre>
%Hexadigits %SETC 'A','B','C','D','E','F'
; %Hexadigits nyní obsahuje šest znaků ABCDEF.
</pre>
<p>Viz test also <a class="EXT" href="../eatests/t2841.htm">t2841</a>.</p>
<blockquote>%SETC dovoluje přiřazení speciálních znaků, což by jinak nemuselo být možné
kvůli syntaktickým pravidlům &euro;ASM.
<br/><code>%Space %SETC 32</code> přiřazuje jednu mezeru.
Téhož bychom mohli dosáhnout pomocí
<br/><code>%QuotedSpace %SET " "</code> a suboperací vybrat pouze druhý ze tří přiřazených znaků:
<br/><code>%Space %SET %QuotedSpace[2]</code>.</blockquote>

<h4 id="pcSETE"><a href="#PseudoInstructions">&uarr; %SETE</a></h4>
<p>Tato pseudoinstrukce čte <strong>environmentovou</strong> proměnnou operačního systému
v době překladu (asm-time) a přiřazuje ji preprocesní %proměnné.
Jméno environmentové proměnné je specifikováno v poli operandu
bez uvozovek, procent či dolarů, např.</p>
<pre>
%OS %SETE OS
Msg: DB "This program was assembled at %OS system."
</pre>
<p>&euro;ASM oznámí varování W2520 pokud je požadovaná proměnná prázdná nebo není definována.</p>
<p>%SETE dovoluje načítat více než jednu environmentovou proměnnou,
jejich hodnoty budou přiřazeny bez uvovozek a odděleny čárkami.
Příklad: <pre>
%CpuInfo %SETE PROCESSOR_ARCHITECTURE, PROCESSOR_IDENTIFIER, \
               PROCESSOR_LEVEL, PROCESSOR_REVISION</pre>
<blockquote>Na mém starém počítači to přiřadí následující text do %CpuInfo:
<br/><code>x86,x86 Family 15 Model 1 Stepping 2, GenuineIntel,15,0102</code>.
Kvůli čárce vložené do hodnoty %PROCESSOR_IDENTIFIER%
nemusí být snadné načítat individuální komponenty pomocí sublistu %CpuInfo{4}.
Takže je lepší použít %SETE pouze pro jednu environmentovou proměnnou.</blockquote>

<h4 id="pcSETS"><a href="#PseudoInstructions">&uarr; %SETS</a></h4>
<p>%SETS se dívá na %proměnnou ve svém poli prvního operandu
a přiřazuje jeho velikost (<strong>size</strong>), tj. počet bajtů, které jeho hodnota okupuje.</p>
<pre>
%SomeVar        %SET  ABC, DEF
%SomeSize       %SETS %SomeVar  ; %SomeSize je nyní <kbd>8</kbd> (3 písmena + čárka + mezera + 3 písmena).
%SizeOfSomeSize %SETS %SomeSize ; %SizeOfSomeSize je nyní <kbd>1</kbd> (jedna číslice).
</pre>
<p>%SETS musí mít právě jeden operand, který vypadá jako preprocesní %proměnná
(procento následované identifikátorem).</p>
<p>Viz test <a class="EXT" href="../eatests/t2861.htm">t2861</a>.</p>

<h4 id="pcSETL"><a href="#PseudoInstructions">&uarr; %SETL</a></h4>
<p>%SETL se podobá na %SETS, avšak přiřazuje délku (<strong>length</strong>)
obsahu %proměnné, tj počet čárkou oddělených položek.</p>
<pre>
%SomeVar            %SET  ABC, DEF
%SomeLength         %SETL %SomeVar    ; %SomeLength je nyní <kbd>2</kbd> (2 čárkou oddělené položky).
%LengthOfSomeLength %SETL %SomeLength ; %LengthOfSomeLength je nyní <kbd>1</kbd> (jedna položka).
</pre>
<p>%SETL musí mít právě jeden operand, který vypadá jako preprocesní %proměnná
(procento následované identifikátorem).</p>
<p>Vzi test <a class="EXT" href="../eatests/t2866.htm">t2866</a>.</p>

<h4 id="pcSET2"><a href="#PseudoInstructions">&uarr; %SET2</a></h4>
<p>Uvažme, jak se překládá povel <code>%Var1 %SET %Var2</code>.
&euro;ASM nejprve expanduje %Var2 a výsledek expanze přiřadí do %Var1.
První dvě slova nejsou expandována, neboť <code>%Var1</code>
je právě přiřazovaný cíl, a <code>%SET</code> je rezervované jméno, které se neexpanduje nikdy.</p>
<p>%SET2 je podobné jako %SET, ale pole operandů je <strong>expandováno 2 krát</strong>
před samotným přiřazením. Každá expanze &quot;spolkne&quot; jeden znak procenta.</p>
<pre>
%V1 %SET "A"
%V2 %SET "B"
%V3 %SET "C"
i   %FOR 1..3
      %DataExp %SET2 %%V%i
      DB %DataExp
    %ENDFOR i ; Emituje <kbd>DB "A"</kbd>, <kbd>DB "B"</kbd>, <kbd>DB "C"</kbd>.
</pre>
<p>Viz také test <a class="EXT" href="../eatests/t2871.htm">t2871</a>.</p>
<blockquote>Pseudoinstrukce %SET2 se uplatní pouze v některých speciálních makrech, jako
<a class="EXT" href="../maclib/stdcal32.htm#EndProcedure">EndProcedure</a>,
kde je použita k expandování %proměnné s dosud neznámým, dynamicky se měnícím jménem.</blockquote>

<h4 id="pcSETX"><a href="#PseudoInstructions">&uarr; %SETX</a></h4>
<p>Když jsou překládány pseudoinstrukce z rodiny SET*,
&euro;ASM neexpanduje slovo v poli návěstí v pseudoinstrukcích jako
<code>%Label %SET* cokoli</code>.
Toto platí pro %SET, %SETA, %SETB, %SETC, %SETU, %SETE, %SETS, %SETL, %SET2
ale nikoli pro %SETX. V této pseudoinstrukci je pole návěstí rovněž <strong>expandováno</strong>.
Po expanzi návěstí se %SETX chová stejně jako obyčejné %SET,
což znamená, že vyžaduje platné jméno %proměnné v poli návěstí.
Kupříkladu <code>%%Var1 %SETX ABC</code>
je ekvivalentní s <code>%Var1 %SET ABC</code>.</p>
<p>Použitím %SETX můžeme přiřazovat %proměnné, jejichž jména nejsou explicitně určena
a dynamicky se mění. Příklad:</p>
<pre>
i %FOR 1..4
     %%M%i %SETX %i  ; Totéž jako <kbd>%M1 %SET 1</kbd>, <kbd>%M2 %SET 2</kbd> atd.
  %ENDFOR  ; Přiřadily se hodnoty 1,2,3,4 %proměnným %M1,%M2,%M3,%M4.
</pre>
<p>Viz také test <a class="EXT" href="../eatests/t2881.htm">t2881</a>.</p>
<blockquote>%SETX se uplatní ve speciálních makrech, jako
<a class="EXT" href="../maclib/stdcal32.htm#Procedure">Procedure</a>,
kde je použito k přiřazování adres ze zásobníkového rámce (např. EBP+12)
%proměnným, jejichž název nebyl určen v době psaní makra.</blockquote>


<h4 id="pcMACRO"><a href="#PseudoInstructions">&uarr; %MACRO</a></h4>
<h4 id="pcEXITMACRO"><a href="#PseudoInstructions">&uarr; %EXITMACRO</a></h4>
<h4 id="pcENDMACRO"><a href="#PseudoInstructions">&uarr; %ENDMACRO</a></h4>
<p>Blok instrukcí ohraničený pseudoinstrukcemi %MACRO a %ENDMACRO se nazývá
<dfn>deklarace makra</dfn>. Identifikátor v poli návěstí %MACRO
je <dfn>název makra</dfn>.
<br/>Pseudoinstrukce %MACRO spolu se svými operandy tvoří <dfn>prototyp makra</dfn>,
který deklaruje jméno makra a dává jména jeho argumentům.
Jakmile bylo deklarováno, makro může být v programu <dfn>expandováno</dfn> mnohokrát.</p>
<p>Dokud &euro;ASM čte instrukce deklarace makra ve zdrojovém textu,
neemituje žádná data. Instrukce z těla makra bydou emitovány
až když je makro expandováno, uvedením jména
<a href="#MacroInstructions">makroinstrukce</a> v programu.</p>
<p>Pseudoinstrukce %EXITMACRO umožňuje přerušit emitování například
když byla detekována nějaká chyba.</p>
<p>Jak %EXITMACRO, tak %ENDMACRO mohou mít uvedeno jméno makra
v poli operandu ke zvýraznění párování bloku.</p>
<p>Příklad definice a expanze makra:</p>
<pre>
AlignEAX %MACRO       ; Makro pro zaokrouhlení EAX na násobek 4.
           ADD EAX,3
           AND EAX,-4
         %ENDMACRO AlignEAX

         MOV EAX,13
         AlignEAX     ; Po expanzi makra bude EAX obsahovat 16.
</pre>
<p>Pro více informací viz kapitolu <a href="#MacroInstructions">Makroinstrukce</a>.</p>

<h4 id="pcSHIFT"><a href="#PseudoInstructions">&uarr; %SHIFT</a></h4>
<p>Pseudoinstrukce %SHIFT je užitečná pouze v makru.
Snižuje pořadové číslo operandů makra o hodnotu definovanou svým operandem.
%SHIFT nemůže mít návěstí a má povolen pouze jeden operand,
který se vyhodnotí na prosté číslo. Při jeho vynechání se předpokládá hodnota <kbd>1</kbd>.</p>
<p><code>%SHIFT 0</code> nedělá nic.
%SHFT s negativním číslem invertuje směr posunu operandů.</p>
<p>Účinek operace %SHIFT je omezen pouze je-li k operandům makra přistupováno
podle jejich pořadových čísel, jako %1, %2 atd.
Přístup k operandům pomocí formálních jmen zůstává operací %SHIFT nenarušen.</p>
<p>Operandy vysunuté vlevo z pozice %1 do pozice nula nebo negativní
již nebudou nadále přístupné pomocí pořadových čísel, avšak nejsou navždy ztraceny,
neboť mohou být posunuty zpět pomocí negativního argumentu pseudoinstrukce %SHIFT.</p>
<samp>|              |Sample %MACRO Oper1, Oper2, Oper3
|              |L1: DB %1, %Oper1
|              |    %SHIFT 1
|              |L2: DB %1, %Oper1
|              |    %SHIFT 2
|              |L3: DB %1, %Oper1
|              |    %ENDMACRO Sample
|0000:         |
|0000:         |Sample  0x44, 0x55, 0x66, 0x77
|              +Sample %MACRO Oper1, Oper2, Oper3
|0000:4444     +L1: DB %1, %Oper1
|              +    %SHIFT 1
|0002:5544     +L2: DB %1, %Oper1
|              +    %SHIFT 2
|0004:7744     +L3: DB %1, %Oper1
|              +    %ENDMACRO Sample
|0006:         |</samp>
<p>Viz také test <a class="EXT" href="../eatests/t7221.htm">t7221</a>.</p>


<h4 id="pcERROR"><a href="#PseudoInstructions">&uarr; %ERROR</a></h4>
<p>Pseudoinstrukce %ERROR vloží uživatelsky definované oznámení do listingu
a na standardní výstup oznámení.
Oznámení se podobá těm, která jsou generována samotným &euro;ASM.
%ERROR se často používá v makroinstrukcích a obvykle varuje programátora,
že makro nebylo použito očekávaným způsobem.</p>
<p>Uživatelská oznámení mají kód závažnosti <kbd>U</kbd> a úroveň 5,
tedy někde mezi varováním a chybou.
Programátor může určit identifikátor zprávy nepovinným klíčovým operandem
<code>ID=</code>, který může specifikovat prosté číslo mezi
<kbd>5000</kbd> a <kbd>5999</kbd>.
%ERROR rovněž akceptuje číslo identifikátoru v rozmězí <kbd>0..999</kbd>
a v tom případě k němu interně přidává <kbd>5000</kbd>. Výchozí hodnotou je <kbd>0</kbd>,
takže uživatelsky definované oznámení má identifikaci <kbd>U5000</kbd>,
nebylo-li (použitím <code>ID=</code>) určeno jinak.</p>
<p>Text oznámení nemusí být v uvozovkách.
Pokud sestává z více než jednoho operandu, budou spojeny doslova, včetně uvozovek a čárek.
Příklady:</p>
<code>%ERROR Id=5123, Došlo k chybě. Zkuste to znovu.</code>
<p>Viz test <a class="EXT" href="../eatests/t2581.htm">t2581</a> pro více příkladů.</p>


<h4 id="pcDISPLAY"><a href="#PseudoInstructions">&uarr; %DISPLAY</a></h4>
<p>Pseudoinstrukce %DISPLAY je určena k získávání informací o interních objektech EuroAssembleru.
Každý takový objekt je zobrazen formou ladicího oznámení se závažností <kbd>1</kbd>.
Oznámení je zobrazeno na standardní konzole (v každém průchodu)
a v listingu (v posledním průchodu).
<br/>%DISPLAY je aktivní i v neemitujících pasážích, jako bloky zakomentované pomocí
%COMMENT nebo %IF. Je určen k vyšetřování postupů &euro;ASM, pokud něco nefunguje dle očekávání.</p>

<p id="DisplayObj">Pseudoinstrukce %DISPLAY přijímá libovolný počet operandů &ndash; kategorií specifikujících
druh objektů, které chceme zkontrolovat. Kategorie mohou být uvedeny jako pořadové nebo klíčové operandy
s hodnotou určující <dfn>filtr</dfn>, který může omezit počet zobrazených řádků.
Názvy kategorií nezávisí na velikosti písmen, ale hodnota filtru ano.
Hodnota filtru specifikuje prvních několik znaků z názvu objektů, které chceme zobrazit.
Hodnota filtru může končit hvězdičkou <kbd>*</kbd>, ale ta není povinná a bez ní to funguje stejně.
Například instrukce <code>%DISPLAY Macros=Alig</code> zobrazí všechna makra, jejich jména začínají
&quot;Alig&quot;.</p>

<p>Operandy pseudoinstrukce %DISPLAY mají poněkud uvolněnou syntaxi.
Kategorie objektu (pořadový nebo klíčový operand) může být zkrácen.
Stačí uvést tolik znaků, kolik je potřeba k identifikaci kategorie.
Například <code>%DISPLAY se</code> zobrazí mapu všech segmentů a jejich sekcí.
<code>%DISPLAY File</code> zobrazuje seznam vstupních souborů (zdrojový a vložené knihovny).
<code>%DISPLAY sym=Num*, sym=En</code> zobrazí symboly, jejichž jména začínají <kbd>Num</kbd> nebo <kbd>En</kbd>.</p>
<p><code>%DISPLAY UserVar</code>, <code>%DISPLAY UserVar=*</code> a <code>%DISPLAY user=</code> fungují stejně
(prázdný filtr propustí všechna jména %proměnných).
Nefiltrovatelné kategorie, jako segmenty, kontextový zásobník, automatické makro %proměnné,
vždy zobrazují kompletní seznam, případná hodnota filtru se ignoruje.</p>
<p>Při specifikaci filtru uživatelsky definovaných a systémových %proměnných
může být počáteční znak procenta <kbd>%</kbd>, případně <kbd>%^</kbd> vynechán,
anebo musí být procento zdvojeno (jinak by byla proměnná expandována na svůj obsah).
<code>%DISPLAY UserVar=Loc</code>, <code>%DISPLAY us=Loc*</code> a <code>%DISPLAY user=%%Loc</code>
mají shodnou funkci: zobrazují aktuální obsah uživatelsky definovaných %proměnných,
jejichž jména začínají na <kbd>%Loc</kbd>.</p>

<table><caption>Kategorie %DISPLAY</caption>
<tr><th>Operand %DISPLAY</th><th>Oznámení</th><th>Filtr</th><th>Řazení</th><th>Zobrazované objekty</th></tr>
<tr><td><b>Al</b>l</td><td>D1100..D1900</td><td>ano</td><td>abecední</td>
<td>Všechny níže specifikované objekty (zkratka pro <b>Fil,Ch,Se,St,Co,Sym,L,Rel,M,V</b>).</td></tr>
<tr><td><b>Fil</b>es</td><td>D1150..D1190</td><td>ignorován</td><td>přirozené</td><td><a href="#SourceFile">Zdrojové soubory</a> vložené do programu.</td></tr>
<tr><td><b>Ch</b>unks</td><td>D1200..D1240</td><td>ignorován</td><td>přirozené</td><td>Kusy zdrojového kódu.</td></tr>
<tr><td><b>Se</b>ctions</td><td>D1250..D1290</td><td>ignorován</td><td>přirozené</td><td>Mapa grup, segmentů a sekcí.</td></tr>
<tr><td><b>Se</b>gments</td><td>D1250..D1290</td><td>ignorován</td><td>přirozené</td><td>Mapa grup, segmentů a sekcí.</td></tr>
<tr><td><b>G</b>roups</td><td>D1250..D1290</td><td>ignorován</td><td>přirozené</td><td>Mapa grup, segmentů a sekcí.</td></tr>
<tr><td><b>St</b>ructures</td><td>D1300..D1340</td><td>ano</td><td>abecední</td><td><a href="#STRUC">Struktury</a> deklarované v programu.</td></tr>
<tr><td><b>Co</b>ntext</td><td>D1350..D1390</td><td>ignorován</td><td>dle zásobníku</td><td>Kontextový zásobník <a href="#ProgStrucVerBlock">blokových instrukcí</a>.</td></tr>
<tr><td><b>Sym</b>bols</td><td>D1400..D1450</td><td>ano</td><td>abecední</td>
<td>Všechny explicitně definované symboly (zkratka pro <b>Fix,Unf,Unr,Ref</b>).</td></tr>
<tr><td>&nbsp; <b>Unf</b>ixedSymbols</td><td>D1410..D1450</td><td>ano</td><td>abecední</td><td>Symboly, jejichž vlastnosti dosud nejsou stabilní.</td></tr>
<tr><td>&nbsp; <b>Fix</b>edSymbols</td><td>D1420..D1450</td><td>ano</td><td>abecední</td><td>Symboly, jejichž vlastnosti již jsou fixovány.</td></tr>
<tr><td>&nbsp; <b>Unr</b>eferencedSymbols</td><td>D1430..D1450</td><td>ano</td><td>abecední</td><td>Dosud nepoužité symboly.</td></tr>
<tr><td>&nbsp; <b>Ref</b>erencedSymbols</td><td>D1440..D1450</td><td>ano</td><td>abecední</td><td>Aspoň jednou zmíněné symboly.</td></tr>
<tr><td><b>L</b>iteralSymbols</td><td>D1500..D1540</td><td>ignorován</td><td>abecední</td><td>Všechny <a href="#Literals">literály</a>. </td></tr>
<tr><td><b>Rel</b>ocations</td><td>D1550..D1590</td><td>ignorován</td><td>přirozené</td><td>Relokační záznamy.</td></tr>
<tr><td><b>M</b>acros</td><td>D1600..D1690</td><td>ano</td><td>abecední</td><td><a href="#MacroInstructions">Makroinstrukce</a> dosud definované.</td></tr>
<tr><td><b>V</b>ariables</td><td>D1700..D1790</td><td>ano</td><td>abecední</td>
<td>Všechny preprocesní %proměnné momentálně nastavené (zkratka pro <b>Au,Fo,Us,Sys</b>).</td></tr>
<tr><td>&nbsp; <b>Au</b>tomaticVariables</td><td>D1710..D1730</td><td>ignorován</td><td>fixní</td><td><a href="#AutomaticVariables">Automatické</a> makro %proměnné.</td></tr>
<tr><td>&nbsp; <b>Fo</b>rmalVariables</td><td>D1740..D1750</td><td>ano</td><td>abecední</td><td><a href="#FormalVariables">Formální</a> <em>makro/for</em> %proměnné.</td></tr>
<tr><td>&nbsp; <b>Us</b>erVariables</td><td>D1760..D1770</td><td>ano</td><td>abecední</td><td><a href="#UserVariables">Uživatelem definované</a> preprocesní %proměnné.</td></tr>
<tr><td>&nbsp; <b>Sys</b>temVariables</td><td>D1780..D1790</td><td>ano</td><td>abecední</td><td><a href="#SystemVariables">Systémové</a> preprocesní %^proměnné.</td></tr>
</table>
<p>Zobrazené oznámení zpravidla obsahuje jméno objektu, jeho <a href="#Attributes">atributy</a> a další vlastnosti.
<p>Operandy Groups, Segments, Sections jsou stejné, kterýkoli z nich vždy zobrazuje kompletní strom.
<br/>Řádky D1260 s grupami zobrazuje názvy grup.
<br/>Řádky D1270 se segmenty jsou odsazeny dvěma mezerami a zobrazují účel, šířku, zarovnání, kombinování, třídu, zdroj.
<br/>Řádky D1280 se sekcemi jsou odsazeny o čtyři mezery a zobrazují adresu, velikost, zarovnání, referenci, zdroj.</p>

<p>Vlastnost <dfn>src=</dfn> specifikuje, zda soubor nebo kus zdroje je</p>
<ul><li><b>main</b> - hlavní zdroj (specifikovaný na příkazovém řádku),</li>
<li>lokální <b>konfig</b>urční soubor <q>euroasm.ini</q></li>
<li>nebo <b>inkludovaný</b> zdrojový soubor.</li></ul>
<p>Vlastnost Chunku <dfn>type=</dfn> určuje informaci obsaženou v tomto kusu zdrojového textu:</p>
<ul><li><b>source</b> - normální zdrojový soubor,</li>
<li><b>binary</b> - data vkládaná pomocí <a href="#INCLUDEBIN">IncludeBin</a>,</li>
<li>původní instrukce <b>Include</b> (bude nahrazena obsahem souboru),</li>
<li>nebo <b>resolved</b> - včetně IncludePath a žolíkových znaků resolvovaných na unikátní jméno souboru.</li></ul>

<p>Booleovská vlastnost <dfn>ref=</dfn> specifikuje, zda symbol, struktura nebo sekce byly použity
(referovány aspoň jednou v programu). Členové skupiny jsou automaticky brány jako <em>used</em>,
když je struktura definována.
<br/>Podobnou vlastností je <dfn>fix=</dfn> specifikující, zda ofset tohot symbolu je již fixní, tj. stabilní mezi průchody.
<br/>Vlastnost kontextu <dfn>emit=</dfn> informuje, zda je blok v normálním (emitujícím) stavu,
nebo zda je jím pouze procházeno bez generování kódu či dat.</p>
<p>Kontextová vlastnost <dfn>%.=</dfn> zobrazuje momentální hodnotu <a href="#AutomaticVariables">
expanzního počitadla</a> v tomto bloku.</p>
<p>Vlastnost <dfn>src=</dfn> identifikuje pozici ve zdrojovém textu, kde byl zobrazovaný objekt definován,
ve standardní podobě <kbd>&quot;FileName&quot;{LineNumber}</kbd>.</p>

<p>Automatické a formální %proměnné jsou definovány pouze při expanzi %macro nebo %for,
tj. pokud je příkaz <code>%DISPLAY Auto,Formal</code> vložen do těla %MACRO..%ENDMACRO nebo %FOR..%ENDFOR.
a makro je pak voláno.</p>
<p>Viz testy <a class="EXT" href="../eatests/t2917.htm">t2901..t2917</a>
pro příklady volání %DISPLAY.</p>

<blockquote><p>Na rozdíl od jiných instrukcí je %DISPLAY živá i v neemitujících blocích.
Opatrně se zařazováním nefiltrované instrukce %DISPLAY v opakujících se preprocesních smyčkách
(%FOR, %WHILE, %REPEAT), jelikož to může podstatně zahltit výstup.</p>
<p>Hlavním účelem %DISPLAY je hledat chybu v asm-time,
kdy &euro;ASM nepracuje podle očekávání.
Spolu s volbami <a href="#EUROASM">EUROASM</a>
<code>DISPLAYSTM=, DISPLAYENC=</code> a s volbami <a href="#PROGRAM">PROGRAM</a>
<code>LISTGLOBALS=, LISTLITERALS=, LISTMAP=</code> poskytuje %DISPLAY silnou zbraň.
<br/>Pro vyšetřování programu za běhu použijte <i>debugger</i>
nebo makro <a class="EXT" href="../maclib/debug.htm#Debug">Debug</a>.</blockquote>

<h4 id="pcDEBUG"><a href="#PseudoInstructions">&uarr; %DEBUG </a></h4>
<h4 id="pcPROFILE"><a href="#PseudoInstructions">&uarr; %PROFILE</a></h4>
<p>Tyto pseudoinstrukce jsou rezervovány pro další rozšiřování EuroAssembleru,
nejsou zatím implementovány. Viz také booleovské volby EUROASM
<a href="#DEBUGeq">DEBUG=</a> a <a href="#PROFILEeq">PROFILE=</a>.</p>

<hr/>

<h3 id="MacroInstructions"><a href="#Instructions">&uarr; Macroinstrukce</a></h3>
<p>Makro je definováno blokem instrukcí (tělem makra)
mezi pseudoinstrukcemi <a href="#pcMACRO">%MACRO</a> a <a href="#pcENDMACRO">%ENDMACRO</a>.
Samotná pseudoinstrukce %MACRO, neboli (<dfn id="MacroPrototype" title="Prototype">
prototyp makra</dfn>) musí mít návěstí, které bude později použito k vyvolání makra
(neboli k jeho <em>expanzi</em>).</p>
<h6>Makro musí být definováno dříve, než je vyvoláno.</h6>
<p>Instrukce, která má jméno dříve definovaného makra ve svém poli operace,
se nazývá  <dfn>makroinstrukce</dfn> nebo zkrátka jen <dfn>makro</dfn>.
Bude nahrazeno instrukcemi z bloku
<code>%MACRO..%ENDMACRO</code>.
<br/>Makrem může být pevný statický sled instrukcí, jako</p><pre>
CarriageReturn %MACRO
                 MOV AH,2  ; 3 instrukce mezi %MACRO a %ENDMACRO jsou tělem makra.
                 MOV DL,13
                 INT 21h
               %ENDMACRO CarriageReturn
</pre>
<p>Užitečnější jsou makra, která mohou modifikovat expandované instrukce
v závislosti na operandech, se kterými jsou volány.
Makro bývá voláno s operandy dostupnými v těle makra jako
formální %proměnné nebo jako pořadové %proměnné <code>%1, %2, %3,...</code>.
Operandy v makrodefinici mohou dostat dočasné <a href="#FormalVariables">formální</a>
symbolické jméno; uvnitř makra jsou pak dostupné pod tímto formálním jménem
prefixovaným znakem procenta <kbd>%</kbd>.
Nebo mohou být referovány svým pořadovým číslem, rovněž prefixovaným znakem procenta <kbd>%</kbd>.
Klíčové operandy jsou dostupné pouze svým formálním jménem (klíčem) prefixovaným znakem procenta <kbd>%</kbd>.
Příklady:</p>
<pre>
Copy %MACRO Source, Destination, Size=ECX ; Instrukci %MACRO se říká <b>prototyp</b> makra.
       MOV ESI, %Source      ; nebo MOV ESI, %1
       MOV EDI, %Destination ; nebo MOV EDI, %2
       MOV ECX, %Size
       REP MOVSB
     %ENDMACRO Copy
</pre>
<p>Předchozí makro nepotřebně přesouvá počet kopírovaných bajtů (Size)
do registru ECX i když už tam jsou v době jeho volání.
V tom případě může být expandovaná instrukce <code>MOV ECX,ECX</code> uspořena:</p>
<pre>
Copy %MACRO Source, Destination, Size=ECX
       MOV ESI, %Source
       MOV EDI, %Destination
       %IF "%Size" !== "ECX"
         MOV ECX, %Size
       %ENDIF
       REP MOVSB
     %ENDMACRO Copy
</pre>
<p>Nyní když je makro voláno s parametry <code>Copy From, To, Size=ecx</code>
nebo jako <code>Copy From, To</code>, žádná nadbytečná instrukce <code>MOV ECX,ECX</code>
do něj nebude expandována.</p>
<p>Pokud by jméno formální makro %proměnné náhodou kolidovalo se jménem některé
dříve uživatelem definované %proměnné, viditelnost uživatelské %proměnné
je dočasně potlačena ve prospěch formální %proměnné. Viz test <a class="EXT"
href="../eatests/t7347.htm">t7347</a>.
<br/><a href="#AutomaticVariables">Automatické %proměnné</a>, jako
<kbd>%*, %#, %:, %1, %2,,,</kbd> nejsou viditelné vně těla makra.

<h6>Všechna makra v EuroAssembleru mohou mít proměnný počet operandů.</h6>
<p>Počet operandů specifikovaný při volání makra nemusí odpovídat
počtu operandů zadanému při jeho deklaraci.
Je-li makro voláno <strong>s méně</strong> pořadovými operandy než deklaruje jeho prototyp,
&euro;ASM to nepovažuje za chybu a tiše expanduje chybějící operandy do ničeho (do prázdna).
<br/>Je-li makro vyvoláno s <strong>více</strong> operandy, než specifikuje jeho prototyp,
tyto nadbytečné operandy nejsou k dispozici pod formálními jmény,
ale stále mohou být referovány pomocí automatického pořadového čísla, jako %2, %3 atd.
Viz též pseudoinstrukci <a href="#pcSHIFT">%SHIFT</a>.</p>
<p>Je-li při invokaci makra vynechán <strong>klíčový operand</strong>,
ponechává si výchozí hodnotu deklarovanou v definici makra.
Přidání dobrovolného klíčového operandu dovoluje rozšířit funkčnost makroinstrukce
bez narušení zpětné kompatibility.
Uvažujme toto prosté makro:</p>
<pre>
Write %MACRO TextPtr,TextSize ; Zapiš text na standardní výstup.
   MOV DX,%TextPtr
   MOV CX,%TextSize
   MOV BX,1       ; Handle standardního výstupu.
   MOV AH,40h     ; Zapiš řetězec DS:DX do souboru nebo zařízení.
   INT 21h        ; Vyvolej službu DOS.
 %ENDMACRO Write</pre>
<p>Později můžeme chtít použít toto makro pro zápis i do jiných zařízení, než standardní výstup.
Rozšiříme je tedy klíčovým operandem <code>Handle=</code> s předdefinovanou výchozí hodnotou
standardního výstupu:</p>
<pre>
Write %MACRO TextPtr,TextSize,Handle=1 ; Zapiš text na standardní výstup nebo do zařízení.
   MOV DX,%TextPtr
   MOV CX,%TextSize
   MOV BX,%Handle ; Handle požadovaného zařízení.
   MOV AH,40h     ; Zapiš řetězec DS:DX do souboru nebo zařízení.
   INT 21h        ; Vyvolej službu DOS.
 %ENDMACRO Write</pre>
<p>Nyní je možné zapisovat i do jiných zařízení, například do řádkové tiskárny pomocí
<code> Write Message,80,Handle=4</code>.
Rozšířené makro Write je zpětně kompatibilní.
Ani když náš starý program obsahuje aktualizovanou makroknihovnu
s vylepšeným makrem Write, nemusíme jej rekompilovat.</p>

<p id="DroppingMacro">Podobně jako <a href="#UserVariables">preprocesní %proměnné</a>,
mohou být <strong>makra redefinována</strong>. Není to ale obvyklé a &euro;ASM
bude v tom případě varovat oznámením W2512.
Jednou definované makro může být oddefinováno pseudoinstrukcí <a href="#pcDROPMACRO">%DROPMACRO</a>.</p>
<p>Příklad situace, kdy může být zapomenutí makra užitečné, je emulace strojové instrukce
makrem se stejným jménem.
<br/>Strojová instrukce BSWAP, která reverzuje pořadí bajtů v 32bitovém registru,
nebyla dostupná, dokud se neobjevil procesor Intel 80386.
Přehození pořadí bylo u starších CPU řešitelné makrem, pomocí tří instrukcí ROR nebo ROL.
Pokud zjistíme, že náš program poběží na Pentiu, můžeme zapomenout na makro
a &euro;ASM bude překládat <code>BSWAP</code> jako nativní strojovou instrukci.</p>
<samp>|00000000:          |
|                   |BSWAP %MACRO reg32 ; Makro k záměně bajtů v registru.
|                   |       %IF TYPE# %reg32 <> 'R' || SIZE# %reg32 <> 4
|                   |         %ERROR 'Makro "BSWAP" očekává 32bitový GPR jako operand.'
|                   |         %EXITMACRO BSWAP
|                   |       %ENDIF
|                   |%reg16 %SET %reg32[2..3] ; Název dolní poloviny registru reg32 (vynechej písmeno <kbd>E</kbd>).
|                   |       ROL %reg16,8
|                   |       ROL %reg32,16
|                   |       ROL %reg16,8
|                   |      %ENDMACRO BSWAP
|00000000:          |
|00000000:BA78563412|      MOV EDX,0x12345678
|00000005:          |      BSWAP EDX    ; Očekávaný výsledek je EDX=0x78563412.
|                   +BSWAP %MACRO reg32 ; Makro k záměně bajtů v registru.
|FALSE              +       %IF TYPE# %reg32 <> 'R' || SIZE# %reg32 <> 4
|                   +         %ERROR 'Makro "BSWAP" očekává 32bitový GPR jako operand.'
|                   +         %EXITMACRO BSWAP
|                   +       %ENDIF
|4458               +%reg16 %SET %reg32[2..3] ; Název dolní poloviny registru reg32 (vynechej písmeno <kbd>E</kbd>).
|00000005:66C1C208  +       ROL %reg16,8
|00000009:C1C210    +       ROL %reg32,16
|0000000C:66C1C208  +       ROL %reg16,8
|                   +      %ENDMACRO BSWAP
|                   |      ; Pokud je CPU aspoň 486 nebo vyšší, preferuje strojovou instrukci.
|                   |      %DROPMACRO BSWAP
|00000010:0FCA      |      BSWAP EDX  ; Tentokrát zaměň pořadí bajtů nativní instrukcí.
|00000012:          |
</samp>
<p>Pokročilý makrojazyk EuroAssembleru dovoluje měnit programovací styl.
Můžeme tvořit makroinstrukce, které napodobují funkce vyššího programovacího jazyka
Viz makra <code>Ii*</code> ve zdrojovém souboru &euro;ASM <a class="EXT"
href="../easource/ii.htm">ii.htm</a> jako příklad pseudojazyka vyvinutého
pro inteligentní popis konverze instrukcí do strojového kódu.</p>
<p>Pokud něco nefunguje podle očekávání, je vždy možné
se podívat na generovaný kód expandovaných makroinstrukcí
a zůstat u prostého asembleru.</p>

<hr/>
<h2 id="PgmFormats" title="Formats"><a href="#top">&uarr; Programové formáty</a></h2>
<h3><a href="#FormatBIN">BIN &darr;</a></h3>
<h3><a href="#FormatBOOT">BOOT &darr;</a></h3>
<h3><a href="#FormatCOM">COM &darr;</a></h3>
<h3><a href="#FormatMZ">MZ &darr;</a></h3>
<h3><a href="#FormatOMF">OMF &darr;</a></h3>
<h3><a href="#FormatLIBOMF">LIBOMF &darr;</a></h3>
<h3><a href="#FormatCOFF">COFF &darr;</a></h3>
<h3><a href="#FormatLIBCOF">LIBCOF &darr;</a></h3>
<h3><a href="#FormatELF">ELF &darr;</a></h3>
<h3><a href="#FormatELFX">ELFX &darr;</a></h3>
<h3><a href="#FormatELFSO">ELFSO &darr;</a></h3>
<h3><a href="#FormatPE">PE &darr;</a></h3>
<h3><a href="#FormatDLL">DLL &darr;</a></h3>
<h3><a href="#FormatRSRC">RSRC &darr;</a></h3>
<h3><a href="#FormatWidth">Šířka formátů &darr;</a></h3>

<p>Cílem činnosti &euro;ASM je výstupní soubor v některém z formátů
vybraném volbou <code>PROGRAM FORMAT=</code>.
Jsou tři kategorie výstupních souborů EuroAssembleru:</p>

<ol><li><strong>Linkovatelný soubor</strong> (také nazývaný <em>modul</em>
nebo <em>objektový soubor</em>) je určen ke spojení s jinými moduly a knihovnami
do konečného spustitelného souboru nebo do objektové knihovny.
<br/>&euro;ASM umí generovat tři hlavní standardy objektových souborů:
<strong>ELF, OMF</strong> a <strong>COFF</strong>. Extenze objektových souborů je <q>.o</q> nebo <q>.obj</q>.</li>

<li><strong>Knihovna</strong> je kolekce modulů připravená být linkována na požádání do konečného spustitelného souboru.
&euro;ASM generuje několik druhů knihoven:
<ul><li>LIBOMF, LIBCOF - <strong>objektové knihovny</strong> obsahují staticky linkovanelné objektové moduly.</li>
<li>LIBOMF, LIBCOF - <strong>importní knihovny</strong> obsahují reference na dynamicky linkované funkce importované z MS-Windows.</li>
<li>LIBOMF, LIBCOF - <strong>smíšené knihovny</strong>, které jsou kombinacemi obou.</li>
<li>DLL - <strong>dynamicky linkovatelné knihovny MS-Windows.</strong>,</li>
<li>ELFSO - <strong>dynamicky sdílené objekty</strong>, nicméně v této verzi linkovatelné EuroAssemblerem pouze staticky.</li>
</ul>
<p>Defaultní přípona objektové nebo importní knihovny je <q>.lib</q>, v případě dynamické knihovny to je <q>.so</q> nebo <q>.dll</q>.</li>

<li><strong>Spustitelný soubor</strong> (také nazývaný <em>image</em>)
může být zaveden a spuštěn shellem hostitelského operačnho systému.
<br/>&euro;ASM generuje spustitelné soubory ve formátech
<strong>ELFX</strong>, <strong>PE</strong>, <strong>MZ</strong>, <strong>COM</strong>,
jejich souborová přípona je <q>.x</q>, <q>.exe</q> nebo <q>.com</q>.
Může rovněž vytvářet dynamicky zaváděnou knihovnu <strong>DLL</strong>,
velmi podobnou formátu PE, ovšem ta může být vykonávána pouze nepřímo, invokací jejích
exportovaných funkcí jiným programem nebo speciálním Windows zaváděčem, jako je <q>RUNDLL32.exe</q>.
<br/>Programové formáty <strong>BIN</strong> a <strong>BOOT</strong> jsou taky považovány za spustitelné.
Nicméně jelikož v nich chybí služební (<i>red tape</i>) informace, binární soubor potřebuje
k zavedení vlastní <i>ad hoc</i> zaváděcí program nebo musí být zaveden na speciální místo v počítači,
jako je firmware anebo bootovací sektor diskového zařízení.</li></ol>

<h3 id="FormatBIN"><a href="#PgmFormats">&uarr; BIN</a></h3>
<p>Volba <code>PROGRAM FORMAT=BIN</code> byla vybrána jako výchozí, pokud není FORMAT= explictině uvedeno.
Další výchozí volby pro formát BIN jsou:</p>
<pre>Name: PROGRAM FORMAT=BIN, OUTFILE=%^PROGRAM.bin, MODEL=TINY, WIDTH=16, \
              ENTRY=0, IMAGEBASE=0, SECTIONALIGN=0, FILEALIGN=0</pre>.
<p>&euro;ASM vytváří výchozí segment [BIN] s univerzálním účelem:</p>
<pre>[BIN] SEGMENT WIDTH=16,ALIGN=16, \
              PURPOSE=CODE+DATA+BSS+STACK+LITERALS</pre>
<blockquote>Následující volby pseudoinstrukce PROGRAM jsou irelevantní:
DLLCHARACTERISTICS, ENTRY, ICONFILE, MAJOROSVERSION, MAJORSUBSYSTEMVERSION,
MAJORIMAGEVERSION, MAJORLINKERVERSION,  MINOROSVERSION,
MINORSUBSYSTEMVERSION, MINORIMAGEVERSION, MINORLINKERVERSION,
WIN32VERSIONVALUE,  SIZEOFHEAPCOMMIT, SIZEOFHEAPRESERVE,
SIZEOFSTACKCOMMIT, SIZEOFSTACKRESERVE, STUBFILE, SUBSYSTEM.</blockquote>
<p>Obsah souboru formátu BIN je jednoduchý: prosté spojení emitovaných obsahů jeho segmentů.
Neinicializované segmenty (BSS) jsou vynechány.</p>
<p>Zarovnání segmentů v image je určeno nejvyšší hodnotou
z <code>PROGRAM FILEALIGN=0</code>, <code>PROGRAM SECTIONALIGN=0</code> a
<code>SEGMENT ALIGN=16</code>.
Mezery mezi segmenty jsou zaplněny buď kódem NOP 0x90 (pokud oba sousední segmenty mají
<code>SEGMENT PURPOSE=CODE</code>), jinak kódem 0x00. </p>
<p>Typickou aplikací binárního formátu jsou čistě datové soubory, konverzní tabulky,
ovladače a jiné speciální záležitosti, viz <a class="EXT" href="../objlib/">BIN projects</a>.</p>

<h3 id="FormatBOOT"><a href="#PgmFormats">&uarr; BOOT</a></h3>
<p>Volba <code>PROGRAM FORMAT=BOOT</code> generuje binární formát přizpůsobený bootování (zavádění operačního systému).
Rozdíly oproti formátu BIN:<ol>
<li>Velikost výstupního souboru je 512 bytes,</li>
<li>je zaváděn na lineární adresu 07C00h,</li>
<li>velikost kódu a dat je zarovnána na 510 a pak jsou zapsány dva bajty s hodnotou 0x55,0xAA (podpis boot-sektoru),</li>
<li>výchozí přípona souboru je <q>.sec</q>.</li>
</ol>
<p>Výchozí volby pro formát BOOT:</p>
<pre>Name: PROGRAM FORMAT=BOOT, OUTFILE=%^PROGRAM.sec, MODEL=TINY, WIDTH=16, \
              ENTRY=, IMAGEBASE=0, SECTIONALIGN=0, FILEALIGN=0</pre>.
<blockquote>Následující volby pseudoinstrukce PROGRAM jsou irelevantní:
DLLCHARACTERISTICS, ENTRY, ICONFILE, MAJOROSVERSION, MAJORSUBSYSTEMVERSION,
MAJORIMAGEVERSION, MAJORLINKERVERSION,  MINOROSVERSION,
MINORSUBSYSTEMVERSION, MINORIMAGEVERSION, MINORLINKERVERSION,
WIN32VERSIONVALUE,  SIZEOFHEAPCOMMIT, SIZEOFHEAPRESERVE,
SIZEOFSTACKCOMMIT, SIZEOFSTACKRESERVE, STUBFILE, SUBSYSTEM.</blockquote>
<p>Viz vzorové projekty <a class="EXT" href="../probin/boottest.htm">boottest.htm</a>
a <a class="EXT" href="../probin/boot16.htm">boot16.htm</a>.</p>

<h3 id="FormatCOM"><a href="#PgmFormats">&uarr; COM</a></h3>
<p>Soubory ve formátu COM jsou dědictvím po operačním systému CP/M, jsou přímo spustitelné
v DOS a ve 32bitových Windows. V jiných systémech pouze v emulátoru DOSu.</p>
<p>Výchozí volby pro formát COM:</p>
<pre>Name: PROGRAM FORMAT=COM,OUTFILE=%^PROGRAM.com,MODEL=TINY,WIDTH=16,IMAGEBASE=0, \
              ENTRY=256,SECTIONALIGN=0,FILEALIGN=0</pre>.
<p>Volby <code>ENTRY=0x100</code> a <code>IMAGEBASE=0</code> jsou v tomto formátu pevné
a nelze je měnit (mohou být vynechány z instrukce PROGRAM).</p>
<p>&euro;ASM vytvoří implicitní segment [COM] s univerzálním účelem:</p>
<pre>[COM] SEGMENT WIDTH=16,ALIGN=16,PURPOSE=CODE+DATA+BSS+STACK+LITERALS</pre>
<blockquote>Následující volby pseudoinstrukce PROGRAM jsou irelevantní:
DLLCHARACTERISTICS, ICONFILE, MAJOROSVERSION, MAJORSUBSYSTEMVERSION,
MAJORIMAGEVERSION, MAJORLINKERVERSION,  MINOROSVERSION,
MINORSUBSYSTEMVERSION, MINORIMAGEVERSION, MINORLINKERVERSION,
WIN32VERSIONVALUE,  SIZEOFHEAPCOMMIT, SIZEOFHEAPRESERVE,
SIZEOFSTACKCOMMIT, SIZEOFSTACKRESERVE, STUBFILE, SUBSYSTEM.</blockquote>
<p>Struktura souboru COM se podobá formátu BIN, žádné metainformace nejsou
v souboru uloženy s výjimkou jeho přípony <q>.com</q>, která říká operačnímu systému,
aby jej považoval za spustitelný.
<br/>Zaváděč OS alokuje 64 KB paměti, naplní segmentové registry
CS,DS,ES,SS paragrafovou adresou tohoto bloku, inicializuje 256 bajtů dlouhou strukturu
<a class="EXTL" href="links.htm#PSP">[PSP]</a> na ofsetu 0, načte obsah souboru
na ofset 256 (0x0100), nastaví ukazatel zásobníku na vrchol alokovaného bloku
(obvykle SP=0xFFFE) a nakonec nastaví IP=0x0100.</p>
<p>Velikost kódu, dat a zásobníku by dohromady neměla přesáhnout 64 KB.
Program ve formátu COM může používat 32bitové registry, pokud je CPU=386 nebo vyšší.
Rovněž může za běhu požadovat další paměťové bloky od operačního systému.</p>
<p>Typickou aplikací tohoto zastaralého formátu jsou krátké a rychlé utility
a programy <dfn id="TSR" title="TSR programs">Terminate-and-Stay-Resident</dfn> (TSR) poskytující služby v DOS.
Viz ukázkové <a class="EXT" href="../objlib/">projekty pro DOS</a>.</p>
<p id="ShortestCOM">Následující příklad programu ve formátu COM je pouze 1 bajt dlouhý,
ale i tak je to formálně platný počítačový program, i když nic nedělá:</p>
<pre>         EUROASM
Shortest PROGRAM FORMAT=COM
           RET
         ENDPROGRAM Shortest
</pre>
<p>Program ve formátu COM také může linkovat jiné moduly a knihovny, viz
<a class="EXT" href="../eatests/#LinkerCombinations">kombinace linkeru</a>.</p>

<h3 id="FormatMZ"><a href="#PgmFormats">&uarr; MZ</a></h3>
<p>Specifikací programového formátu MZ vytvoříme 16bitový, případně 32bitový spustitelný program pro reálný mód,
který může být přímo spuštěn v DOS a ve 32bitových Windows.
Jeho struktura je popsána v dokumentaci <a class="EXTL" href="../eadoc/links.htm#MZ">[MZ]</a>
a <a class="EXTL" href="../eadoc/links.htm#MZEXE">[MZEXE]</a>.
Dosový spustitelný program začíná <dfn id="MZ" title="MZ format signature">podpisem MZ</dfn> <code>'M','Z'</code>.</p>
<p>Výchozí volby pro <code>PROGRAM FORMAT=MZ</code> jsou:</p>
<pre>PROGRAM FORMAT=MZ, ENTRY=, OUTFILE=%^PROGRAM.exe, MODEL=SMALL, WIDTH=16, IMAGEBASE=0, \
        SECTIONALIGN=0, FILEALIGN=0, SIZEOFSTACKCOMMIT=8K, SIZEOFHEAPCOMMIT=1M</pre>
<p id="MZdefaultSegments">&euro;ASM vytvoří výchozí implicitní segmenty [CODE], [RODATA], [DATA], [BSS], [STACK]
ve formátech MZ, OMF, LIBOMF.</p>
<p>Parametr <code>PROGRAM SizeOfStackCommit=</code> vytváří defaultní velikost segmentu [STACK],
takže nemusíme explicitně definovat strojový zásobník, pokud byla volba <code>AUTOSEGMENT=</code> povolena.</p>
<p>Parametr <code>PROGRAM SizeOfHeapCommit=</code> může být použit k omezení velikosti heap
prealokované zaváděčem (člen <a class="EXT" href="../easource/pfmz.htm#PFMZ_DOS_HEADER">.e_maxalloc</a> Dosové hlavičky).</p>
<p>Pokud je paměťový model HUGE nebo FLAT a šířka programu není explicitně určena, použije se
<code>PROGRAM WIDTH=32</code>, jinak je to 16.</p>
<p><code>ImageBase=0</code> v tomto formátu a nemůže být měněna.
<br/>Explictní stanovení <code>PROGRAM Entry=</code> je v MZ formátu povinné.</p>
<blockquote>Následující volby pseudoinstrukce PROGRAM jsou irelevantní:
DLLCHARACTERISTICS, ENTRY, ICONFILE, MAJOROSVERSION, MAJORSUBSYSTEMVERSION,
MAJORIMAGEVERSION, MAJORLINKERVERSION,  MINOROSVERSION,
MINORSUBSYSTEMVERSION, MINORIMAGEVERSION, MINORLINKERVERSION,
WIN32VERSIONVALUE, SIZEOFHEAPRESERVE, SIZEOFSTACKRESERVE, STUBFILE, SUBSYSTEM.</blockquote>
<p>Jako příklad spustitelného programu MZ pro DOS viz test <a class="EXT" href="../eatests/t8300.htm">t8300</a>.</p>

<h3 id="FormatOMF"><a href="#PgmFormats">&uarr; OMF</a></h3>
<p><dfn>Object Module Format</dfn> popsaný v dokumentaci <a class="EXTL" href="../eadoc/links.htm#OMF">[OMF]</a>
je určen k linkování do 16bitových a 32bitových programů pro reálný mód.
Importy v tomto formátu jsou linkovatelné také do programů v chráněném módu (MS-Windows).</p>
<p>Výchozí segmenty jsou stejné jako u <a href="#MZdefaultSegments">formátu MZ</a>.</p>
<p>Soubor je rozpoznán pro linkování, pokud sestává z platných <em>záznamů OMF</em>
a první záznam je THEADR nebo LHEADR.</p>
<p>Výchozí volby pro tento formát jsou:</p>
<pre>Name: PROGRAM FORMAT=OMF,OUTFILE=%^PROGRAM.obj,MODEL=SMALL,WIDTH=16</pre>
<blockquote>Následující volby pseudoinstrukce PROGRAM jsou irelevantní:
DLLCHARACTERISTICS, ENTRY, FILEALIGN, ICONFILE, IMAGEBASE, MAJOROSVERSION, MAJORSUBSYSTEMVERSION,
MAJORIMAGEVERSION, MAJORLINKERVERSION,  MINOROSVERSION,
MINORSUBSYSTEMVERSION, MINORIMAGEVERSION, MINORLINKERVERSION,
WIN32VERSIONVALUE, SECTIONALIGN, SIZEOFHEAPCOMMIT, SIZEOFHEAPRESERVE,
SIZEOFSTACKCOMMIT, SIZEOFSTACKRESERVE, STUBFILE, SUBSYSTEM.</blockquote>
<p>Jako příklad modulu OMF viz test <a class="EXT" href="../eatests/t8400.htm">t8400</a>.</p>

<h3 id="FormatLIBOMF"><a href="#PgmFormats">&uarr; LIBOMF</a></h3>
<p>Formát knihovny OMF je popsán v Apendix2 stejného dokumentu jako <a class="EXTL" href="links.htm#OMF">[OMF]</a>.
Hashovaný slovník vyžadovaný formátem na konci knihovny je EuroAssemblerem vytvářen,
avšak při linkování je ignorován. Je-li knihovna LIBOMF linkována EuroAssemblerem do jiného programu,
její PUBLIC symboly budou hledány sekvenčně.
<br/>Velikost stránky knihoven LIBOMF vytvářených EuroAssemblerem je napevno 16.</p>
<p>Výchozí segmenty jsou stejné jako ve <a href="#MZdefaultSegments">formátu MZ</a>.</p>
<p>Souborový formát LIBOMF je rozpoznáván pro LINK pokud začíná záznamem LIBHDR
s <em>délkou strany</em> 16, 32, 64,..32K, a pokud je tento záznam následován platnými <a href="#FormatOMF">moduly OMF</a>,
které začínají záznamem THEADR nebo LHEADR a které končí záznamem MODEND nebo MODEND32.
Slovník hashů na konci knihovny není používán.</p>
<p>Výchozí volby formátu <code>PROGRAM FORMAT=LIBOMF</code> jsou:</p>
<pre>Name: PROGRAM FORMAT=LIBOMF,OUTFILE=%^PROGRAM.lib</pre>
<p>Ostatní vlastnosti jsou zděděny z linkovaných modulů.</p>
<blockquote>Následující volby pseudoinstrukce PROGRAM jsou irelevantní:
DLLCHARACTERISTICS, ENTRY, FILEALIGN, ICONFILE, IMAGEBASE, MAJOROSVERSION, MAJORSUBSYSTEMVERSION,
MAJORIMAGEVERSION, MAJORLINKERVERSION, MODEL, MINOROSVERSION,
MINORSUBSYSTEMVERSION, MINORIMAGEVERSION, MINORLINKERVERSION,
WIN32VERSIONVALUE, SECTIONALIGN, SIZEOFHEAPCOMMIT, SIZEOFHEAPRESERVE,
SIZEOFSTACKCOMMIT, SIZEOFSTACKRESERVE, STUBFILE, SUBSYSTEM, WIDTH.</blockquote>
<p>Moduly, které mají být vloženy do knihovny, by měly být předem přeloženy do souborů ve formátu OMF.
Pokud program představující knihovnu také obsahuje nějaký kód,
bude přeložen a uložen jako první modul knihovny.
Moduly z jiných linkovaných knihoven, které neobsahují žádný globální symbol,
nebudou do cílové knihovny vůbec zařazeny.
<br/>Příklad statické knihovny linkované ze tří samostatných modulů:</p>
<pre>MyLib: PROGRAM FORMAT=LIBOMF
        LINK "Module1.obj", "Module2.obj", "Module3.obj"
       ENDPROGRAM MyLib</pre>
<p>Třebaže byl formát OMF vyvinut pro programy v reálném módu,
může být doplněn OMF záznamy COMENT/IMPDEF
a taková knihovna importních záznamů použita v programu pro Windows.</p>
<p>Některé knihovní programy, jako <a class="EXTL" href="links.htm#ALIB">[ALIB]</a>,
vytvářejí delší variantu importních záznamů, která přidává záznamy LEDATA+FIXUPP
včetně relokabilního strojového kódu proxy-skoků na importovanou funkci.
<br/>&euro;ASM nevytváří delší verzi importních záznamů,
ale jak dlouhá, tak krátká verze jsou akceptovány linkerem.
Příklad programu vytvářejícího čistě importní knihovnu v krátkém formátu OMF:</p><pre>
ImpLib PROGRAM FORMAT=LIBOMF
  IMPORT LIB="kernel32.dll",TerminateProcess,TerminateThread
  IMPORT LIB="user32.dll",CreateCursor,CreateIcon,CreateMenu
 ENDPROGRAM ImpLib
</pre>
<p>Jako příklad knihovny LIBOMF viz test <a class="EXT" href="../eatests/t8600.htm">t8600</a>.</p>


<h3 id="FormatCOFF"><a href="#PgmFormats">&uarr; COFF</a></h3>
<p>EuroAssembler implementuje objektový formát COFF v modifikaci od Microsoftu popsané v
<a class="EXTL" href="links.htm#MS_PECOFF">[MS_PECOFF]</a>. Tento popis také platí
pro &euro;ASM formáty LIBCOF, PE, DLL (<dfn>formáty založené na COFF</dfn>).</p>
<p id="COFFdefaultSegments" title="COFF based">&euro;ASM zde vytváří výchozí segmenty
(&quot;sekce&quot; v terminologii Microsoftu):
<br/><code>[.text], [.rodata], [.data], [.bss]</code>.
Strojový zásobník pro spustitelný soubor bude vytvořen zaváděčem při spouštění programu
a nemusíme se o něj starat.</p>
<p>Výchozí volby pro <code>PROGRAM FORMAT=COFF</code> jsou:</p>
<pre>PROGRAM FORMAT=COFF,OUTFILE=%^PROGRAM.obj,MODEL=FLAT,WIDTH=32</pre>
<blockquote>Následující volby pseudoinstrukce PROGRAM jsou irelevantní:
DLLCHARACTERISTICS, ENTRY, FILEALIGN, ICONFILE, IMAGEBASE, MAJOROSVERSION, MAJORSUBSYSTEMVERSION,
MAJORIMAGEVERSION, MAJORLINKERVERSION, MINOROSVERSION,
MINORSUBSYSTEMVERSION, MINORIMAGEVERSION, MINORLINKERVERSION,
WIN32VERSIONVALUE, SECTIONALIGN, SIZEOFHEAPCOMMIT, SIZEOFHEAPRESERVE,
SIZEOFSTACKCOMMIT, SIZEOFSTACKRESERVE, STUBFILE, SUBSYSTEM.</blockquote>
<p>Hodnota generovaná do členu <a class="EXT" href="../easource/pfcoff.htm#PFCOFF_FILE_HEADER">PFCOFF_FILE_HEADER.Machine</a>
je pro zděděný mód COFF vždy <code>0x014C</code> (Intel 386) bez ohledu na hodnotu <code>EUROASM CPU=</code>.
Pro 64bitový mód PECOFF je vždy <code>0x8664</code> (architektura AMD64).
Architektura Itanium (0x0200) není podporována</p>
<p>Obsah členu <a class="EXT" href="../easource/pfcoff.htm#PFCOFF_FILE_HEADER">PFCOFF_FILE_HEADER.TimeDateStamp</a>
odpovídá aktuálnímu systémovému času, ledaže by byl zfalšován volbou <code>EUROASM TIMESTAMP=</code>.</p>
<p>Linkovaný modul COFF je rozeznáván obsahem členu
<a class="EXT" href="../easource/pfcoff.htm#PFCOFF_FILE_HEADER">PFCOFF_FILE_HEADER.Machine</a>,
který může mít jednu z hodnot <code>0x0000, 0x014C, 0x014D, 0x014E, 0x0200, 0x8664</code>.</p>
<p>Jako příklad modulu COFF viz test <a class="EXT" href="../eatests/t8850.htm">t8850</a> (pro Windows)
nebo <a class="EXT" href="../eatests/t9000.htm">t9000</a> (pro Linux).

<h3 id="FormatLIBCOF"><a href="#PgmFormats">&uarr; LIBCOF</a></h3>
<p>Formát knihovny COFF je popsán v <a class="EXTL" href="links.htm#COFFlib">[COFFlib]</a>.</p>
<p>Výchozí volby pro <code>PROGRAM FORMAT=LIBCOF</code> jsou:</p>
<pre>PROGRAM FORMAT=LIBCOF,OUTFILE=%^PROGRAM.lib,MODEL=FLAT,WIDTH=32</pre>
<p>Výchozí segmenty jsou stejné jako u <a href="#COFFdefaultSegments">formátu COFF</a>.</p>
<blockquote>Následující volby pseudoinstrukce PROGRAM jsou irelevantní:
DLLCHARACTERISTICS, ENTRY, FILEALIGN, ICONFILE, IMAGEBASE, MAJOROSVERSION, MAJORSUBSYSTEMVERSION,
MAJORIMAGEVERSION, MAJORLINKERVERSION, MINOROSVERSION,
MINORSUBSYSTEMVERSION, MINORIMAGEVERSION, MINORLINKERVERSION,
WIN32VERSIONVALUE, SECTIONALIGN, SIZEOFHEAPCOMMIT, SIZEOFHEAPRESERVE,
SIZEOFSTACKCOMMIT, SIZEOFSTACKRESERVE, STUBFILE, SUBSYSTEM.</blockquote>
<p>Knihovna COFF je identifikována podpisem <code>!&lt;arch&gt;</code> následovaným bajtem <code>0x0A</code>.</p>
<p>Knihovnu LIBCOF můžeme vytvořit linkováním z jiných objektových souborů.
Moduly by měly být nejprve přeloženy do souborů ve formátu COFF (ale lze i OMF nebo ELF).
Pokud program představující knihovnu také obsahuje nějaký kód
(mimo instrukce LINK), bude přeložen a uložen jako první člen knihovny.
Moduly nedeklarující žádný globální symbol nebudou do knihovny vůbec zařazeny.
Příklad knihovny LIBCOF obsahující tři moduly:</p>
<pre>MyLib: PROGRAM FORMAT=LIBCOF
         LINK "Module1.obj", "Module2.obj", "Module3.obj"
       ENDPROGRAM MyLib</pre>
<p>&euro;ASM nevytváří delší verzi importních knihovních záznamů,
ale jeho linker akceptuje dlouhou i krátkou verzi.
Příklad programu vytvářejícího importní knihovnu v krátkém formátu:</p>
<pre>ImpLib: PROGRAM FORMAT=LIBCOF
         IMPORT LIB="kernel32.dll",TerminateProcess,TerminateThread
         IMPORT LIB="user32.dll",CreateCursor,CreateIcon,CreateMenu
        ENDPROGRAM ImpLib:</pre>
<p>Jako příklad knihovny LIBCOF viz test <a class="EXT" href="../eatests/t9150.htm">t9150</a>.</p>

<h3 id="FormatELF"><a href="#PgmFormats">&uarr; ELF</a></h3>
<p>ELF neboli <dfn>Executable and Linkable Format</dfn> je používán v Linuxu.
Existují tři druhy souborů ELF:</p><ul>
<li>Linkovatelný objektový soubor ELF, v &euro;ASM vytvářený pomocí PROGRAM FORMAT=ELF</li>
<li>Spustitelný soubor, vytvářený pomocí PROGRAM FORMAT=ELFX </li>
<li>Dynamicky Sdílený Objekt (DSO), vytvářený pomocí PROGRAM FORMAT=ELFSO</li>
</ul>
<p>Výchozí volby pro <code>PROGRAM FORMAT=ELF</code> jsou</p>
<pre>Name: PROGRAM FORMAT=ELF, OUTFILE=%^PROGRAM.o, MODEL=FLAT, WIDTH=32, \
      FILEALIGN=16</pre>
<p>ELF je objektový (linkovatelný) soubor s přípomou <q>.o</q>.
Jeho defaultní segmenty jsou <code>[.text], [.rodata], [.data], [.bss]</code>.
Segmentům se říká <dfn>sekce</dfn> v dokumentaci <a class="EXTL" href="links.htm#ELF64">[ELF]</a>.
Vedle těchto &quot;sekcí&quot; vytváří &euro;ASM také služební sekce <code>[.symtab], [.strtab], [.shstrtab], [.rela.text], [.rela.data] aj.</code>.
Viz test <a class="EXT" href="../eatests/t9750.htm">t9750</a> jako příklad objektu ELF.</p>
<blockquote>Následující volby pseudoinstrukce PROGRAM jsou irelevantní:
DLLCHARACTERISTICS, ENTRY, ICONFILE, IMAGEBASE, MAJOROSVERSION, MAJORSUBSYSTEMVERSION,
MAJORIMAGEVERSION, MAJORLINKERVERSION, MINOROSVERSION,
MINORSUBSYSTEMVERSION, MINORIMAGEVERSION, MINORLINKERVERSION,
WIN32VERSIONVALUE, SECTIONALIGN, SIZEOFHEAPCOMMIT, SIZEOFHEAPRESERVE,
SIZEOFSTACKCOMMIT, SIZEOFSTACKRESERVE, STUBFILE, SUBSYSTEM.</blockquote>

<h3 id="FormatELFX"><a href="#PgmFormats">&uarr; ELFX</a></h3>
<p>Spustitelnému programu pro Linux přiděluje &euro;ASM souborovou příponu <q>.x</q>,
pokud není předepsáno jinak volbou PROGRAM OUTFILE=. </p>
<p>Formát ELFX vytváří segmentové skupiny <code>[LOAD.HDR], [LOAD.CODE], [LOAD.RODATA], [LOAD.DATA]</code>,
viz například test <a class="EXT" href="../eatests/t9850.htm">t9850</a>.
Těmto skupinám se v <a class="EXTL" href="links.htm#ELF64">[ELF]</a> dokumentaci říká <em>program headers</em>.</p>
<pre>Name: PROGRAM FORMAT=ELFX, OUTFILE=%^PROGRAM.x, MODEL=FLAT, WIDTH=32, \
    ENTRY=, IMAGEBASE=4M, FILEALIGN=16, SECTIONALIGN=4K</pre>
<p>Výchozí přípona souboru je <q>.x</q>. Parametr ENTRY= je povinný, určuje vstupní bod programu.</p>
<blockquote>Následující volby pseudoinstrukce PROGRAM jsou irelevantní:
DLLCHARACTERISTICS, ICONFILE, MAJOROSVERSION, MAJORSUBSYSTEMVERSION,
MAJORIMAGEVERSION, MAJORLINKERVERSION, MINOROSVERSION,
MINORSUBSYSTEMVERSION, MINORIMAGEVERSION, MINORLINKERVERSION,
WIN32VERSIONVALUE, SIZEOFHEAPCOMMIT, SIZEOFHEAPRESERVE,
SIZEOFSTACKCOMMIT, SIZEOFSTACKRESERVE, STUBFILE, SUBSYSTEM.</blockquote>

<h3 id="FormatELFSO"><a href="#PgmFormats">&uarr; ELFSO</a></h3>
<p>Volba PROGRAM FORMAT=ELFSO vytváří DSO - Dynamic Shared Object pro Linux.
EuroAssembler vytváří DSO s příponou souboru <q>.so</q>, avšak neumí jej dynamicky linkovat,
nenahrazuje zde funkcionalitu komplexního Linuxového dynamického linkeru <code>GNU ld</code>.
Soubor DSO může být linkován do programu ELFX pouze staticky.</p>

<pre>Name: PROGRAM FORMAT=ELFSO, OUTFILE=%^PROGRAM.so, MODEL=FLAT, WIDTH=32, \
    IMAGEBASE=4M, FILEALIGN=4K, SECTIONALIGN=4K</pre>
<blockquote>Následující volby pseudoinstrukce PROGRAM jsou irelevantní:
DLLCHARACTERISTICS, ENTRY, ICONFILE, MAJOROSVERSION, MAJORSUBSYSTEMVERSION,
MAJORIMAGEVERSION, MAJORLINKERVERSION, MINOROSVERSION,
MINORSUBSYSTEMVERSION, MINORIMAGEVERSION, MINORLINKERVERSION,
WIN32VERSIONVALUE, SECTIONALIGN, SIZEOFHEAPCOMMIT, SIZEOFHEAPRESERVE,
SIZEOFSTACKCOMMIT, SIZEOFSTACKRESERVE, STUBFILE, SUBSYSTEM.</blockquote>

<h3 id="FormatPE"><a href="#PgmFormats">&uarr; PE</a></h3>
<p>Portable Executable formát PE pro Windows je popsán v dokumentu <a class="EXTL" href="links.htm#MS_PECOFF">[MS_PECOFF]</a>.
Výchozí volby pro <code>PROGRAM FORMAT=PE</code> jsou</p>
<pre>Name: PROGRAM FORMAT=PE,OUTFILE=%^PROGRAM.exe,MODEL=FLAT,WIDTH=32,IMAGEBASE=4M,FILEALIGN=512,SECTIONALIGN=4K, \
              SUBSYSTEM=CON,ICONFILE="euroasm.ico",MAJORLINKERVERSION=1,MINORLINKERVERSION=0,ENTRY=,          \
              MAJOROSVERSION=4,MINOROSVERSION=0,MAJORIMAGEVERSION=1,MINORIMAGEVERSION=0,                      \
              MAJORSUBSYSTEMVERSION=4,MINORSUBSYSTEMVERSION=0,WIN32VERSIONVALUE=0,DLLCHARACTERISTIC=0x000F,   \
              SIZEOFSTACKRESERVE=1M,SIZEOFSTACKCOMMIT=8K,SIZEOFHEAPRESERVE=4M,SIZOHEAPCOMMIT=1M</pre>
<p>Výchozí segmenty jsou stejné jako ve <a href="#COFFdefaultSegments">formátu COFF</a>.</p>
<p>Soubor PE začíná Dosovým programem (stub) ve formátu MZ, který se spouští pokud PE program není spuštěn ve Windows.
Na pozici členu <a class="EXT" href="../easource/pfmz.htm#PFMZ_DOS_HEADER">PFMZ_DOS_HEADER.e_lfanew</a>
očekává <dfn id="PE" title="PE file signature">signaturu PE</dfn> s bajty <code>'P','E',0,0</code>.</p>
<blockquote>Starší souborový formát se <dfn id="NE" title="NE format signature">signaturou NE (New Executable)</dfn>,
používaný v 16bitových Windows a OS/2, není EuroAssemblerem podporován.</blockquote>
<p>Po souborové hlavičce COFF následuje <a class="EXT"
href="../easource/pfpe.htm#PFPE_OPTIONAL_HEADER32">PFPE_OPTIONAL_HEADER</a>. Téměř všechna její pole lze  konfigurovat
pomocí voleb pseudoinstrukce PROGRAM.
<br/>Položka <code>PROGRAM ENTRY=</code> je v PE formátu povinná.
<br/>Volba <code>PROGRAM STUBFILE=</code> specifikuje jméno MZ programu použitého, když
byl náš program spuštěn v DOS.
Pokud je ponecháno prázdné, &euro;ASM použije vlastní vestavěný stub, který oznámí
<em>This program was launched in DOS but it requires Windows.</em> a skončí.
<br/>Výchozí volba <code>PROGRAM ICONFILE="euroasm.ico"</code> určuje jméno souboru s ikonou
<img src="../objlib/euroasm.ico" width="16" height="16"/>,
která bude vestavěna do segmentu <em>resources</em> spustitelného souboru.
Vizuálně reprezentuje náš program na Ploše nebo v Průzkumníku Windows.</p>
<blockquote>Tento parametr je ignorován, pokud byl explicitně přilinkován libovolný soubor <em>resources</em>;
pak se použije první ikona z tohoto souboru.
Je-li volba ICONFILE= prázdná, a pokud není přilinkován žádný soubor <em>resources</em>,
příslušná sekce [.rsrc] bude z PE souboru zcela vynechána.</blockquote>
<p>Po &quot;volitelné&quot; hlavičce následuje 16 <dfn id="PECOFFdir" title="PECOFF directories">
záznamů speciálních adresářů</dfn>, které identifikují sekce s účely
jinými než běžné účely CODE, DATA, BSS. Viz posledních 16 řádků lines v tabulce
<a href="#SegmentPURPOSEeq">účelu segmentů</a>, počínaje EXPORT.</p>
<p>EuroAssembler nativně podporuje jen několik speciálních adresářů:
<dl><dt>EXPORT</dt><dd>automaticky vytváří sekci [.edata] s tabulkou exportovaných symbolů.</dd>
<dt>IMPORT</dt><dd>automaticky vytváří sekci [.idata] s tabulkou jmen a čísel importovaných symbolů.</dd>
<dt>RESOURCE</dt><dd>se vytváří, když je soubor se zdroji přilinkován nebo pokud volba ICONFILE= specifikuje existující ikonu.</dd>
<dt>BASERELOC</dt><dd>obsahuje tabulku relokací, která musí být aplikována zaváděčem programu,
pokud PE nemohl být zaveden na adresu preferovanou ve volbě IMAGEBASE=.</dd>
<dt>IAT</dt><dd>importní adresní tabulka se vytváří v sekci [.idata], stejné jako speciální adresář IMPORT.
Spojení tabulek IAT, IMPORT a thunk proxy skoků do jedné společné sekce [.idata] šetří velikost image.</dd></dl>
<p>Ostatní speciální adresáře nejsou v této verzi &euro;ASM podporovány.
Nicméně jejich segmenty mohou být definovány explicitně a jejich obsah vytvořen ručně
nebo nějakou utilitou třetí strany, a pak emitován do segmentu pomocí
<a href="#INCLUDEBIN">INCLUDEBIN</a> nebo <a href="#D">definicemi dat</a>.
Pokud parametr segmentu PURPOSE= přesně (až na velikost písmen) souhlasí s názvem v <a href="#SegmentPURPOSEeq">tabulce účelů</a>,
bude vytvořen odpovídající vstup ve &quot;volitelné&quot; hlavičce PE,
který pokryje celý obsah segmentu.
Příklad:
<pre>[.cormeta] SEGMENT PURPOSE=CLR
 D '&lt;compatibility xmlns=&quot;urn:schemas-microsoft-com:compatibility.v1&quot;&gt;'
 D '  &lt;application&gt;'
 D '     &lt;!-- A list of all Windows versions that this application is designed to work with.&gt;'
 D '   &lt;/application&gt;'
 D ' &lt;/compatibility&gt;'
</pre>
<p>Pokud je povolena volba <code>EUROASM DEBUG=ENABLED</code>,
tabulka symbolů bude připojena k image souboru PE.</p>
<blockquote>Debugery by měly být schopny načítat symbolická jména z laděného spustitelného souboru,
a spojit je s disasemblovanými zdrojovými řádky.
Bohužel ale žádný z mně známých debugerů nebyl schopen využít tabulku symbolů z PE
(místo toho bylo třeba nejprve přeložit do formátu COFF).</blockquote>


<h3 id="FormatDLL"><a href="#PgmFormats">&uarr; DLL</a></h3>
<p>Souborový formát DLL je téměř identický s formátem PE, s několika drobnými rozdíly:
<br/>Člen souborové hlavičky <a class="EXT" href="../easource/pfcoff.htm#PFCOFF_FILE_HEADER">
PFCOFF_FILE_HEADER.Characteristic</a> je označen jako <code>pfcoffFILE_DLL = 0x2000</code>,
<br/>výchozí přípona souboru je <q>.dll</q>, ImageBase je 256 MB.</p>
<pre>Name: PROGRAM FORMAT=DLL,OUTFILE=%^PROGRAM.dll,IMAGEBASE=256M</pre>
<p>Volba <code>ENTRY=</code> je u DLL nepovinná.</p>
<p>Výchozí segmenty jsou stejné jako ve <a href="#COFFdefaultSegments">formátu COFF</a>.</p>
<p>Dynamicky linkovatelné symboly musí být deklarovány s viditelností EXPORT.
<br/>Pseudoinstruckce <a href="#EXPORT">EXPORT</a> podporuje
<dfn id="DllForward" title="DLL forwarding">DLL forwarding</dfn>
exportovaných funkcí do jiné funkce v jiné knihovně DLL, používajíc klíčové operandy EXPORT
se jmény FWD= and LIB=. Viz test <a class="EXT" href="../eatests/t9475.htm">t9475</a> jako příklad forwardingu.</p>
<p>Formát DLL může být používán pro <dfn id="ResourceDLL" title="Resource DLL">knihovnu resource</dfn>,
která obsahuje pouze sekci [.rsrc], typicky se jedná o sbírku ikon.
Toho je dosaženo linkováním souboru <em>resources</em>, který byl vytvořen
pomocí <em>resource kompileru</em> třetí strany.
Příklad resource-only DLL obsahující 3 ikony můžeme vidět v testech
<a class="EXT" href="../eatests/t9485.htm">t9485</a>
a <a class="EXT" href="../eatests/t9536.htm">t9536</a>.</p>


<h3 id="FormatRSRC"><a href="#PgmFormats">&uarr; RSRC</a></h3>
<p><dfn>Microsoft resources</dfn> je obecné jméno pro multimediální data, jako bitmapové obrázky,
ikony, tvary kurzorů, fonty apod.
Tyto zdroje (resources) používané v grafických programech jsou popsány ve <dfn>skriptu resources</dfn>
jako strom odkazující na jednotlivé prvky grafických souborů.
Typický skript je prostý textový soubor s příponou <q>.rc</q>
a měl by být zkonvertován pomocí <dfn>resource compiler</dfn>
na binární soubor <em>resources</em> s příponou <q>.res</q>, kterou umí &euro;ASM linkovat.
Jeho formát je popsán v dokumentaci <a class="EXTL" href="links.htm#RSRC">[RSRC]</a>.</p>
<p><del><code>MyCompiledResource PROGRAM FORMAT=RSRC</code></del> nefunguje,
EuroAssembler neumí kompilovat skripty resources. Použijte nástroj třetí strany, jako
<a class="EXTL" href="links.htm#MS_RC">[MS_RC]</a>, <a class="EXTL" href="links.htm#GoRC">[GoRC]</a>,
nebo <a class="EXTL" href="links.htm#ResourceHacker">[ResourceHacker]</a>.</p>
<p>Je-li soubor <em>resources</em> linkován do PE nebo DLL image vytvořené EuroAssemblerem,
volba <code>PROGRAM ICONFILE=</code> se ignoruje. Soubor je přeložen na interní strukturu
binárního stromu v sekci [.rsrc], na niž odkazuje speciální adresář <a href="#SegmentPURPOSEeq">RESOURCE</a>.</p>

<h3 id="FormatWidth"><a href="#PgmFormats">&uarr; Šířka formátů</a></h3>
<p>Šířka výstupních souborů linkovaných EuroAssemblerem je určována volbou
<code>PROGRAM WIDTH=</code>, jejíž výchozí hodnota pro formáty založené na COFF je 32 bitů.
K vytvoření 64bitových programů ELF, ELFX, ELFSO, PE, DLL, COFF nebo LIBCOF musí být
explicitně stanovena PROGRAM WIDTH=64. Rovněž by pak měla být povolena volba
<code>EUROASM CPU=X64</code>.
<table><caption>Rozdíly mezi formáty PE-COFF generovanými EuroAssemblerem</caption>
<tr><th>Člen</th><th>PROGRAM WIDTH=16</th><th>PROGRAM WIDTH=32</th><th>PROGRAM WIDTH=64</th></tr>
<tr><td><a class="EXT" href="../easource/pfcoff.htm#PFCOFF_FILE_HEADER">PFCOFF_FILE_HEADER.Machine</a></td>
<td>0x014C (Intel 386)</td><td>0x014C (Intel 386)</td><td>0x8664 (AMD64)</tr>
<tr><td><a class="EXT" href="../easource/pfcoff.htm#PFCOFF_FILE_HEADER">PFCOFF_FILE_HEADER.Characteristics:32BIT_MACHINE</a></td>
<td>0 (nepravda)</td><td>0x0100 (pravda)</td><td>0 (nepravda)</td></tr>
<tr><td><a class="EXT" href="../easource/pfcoff.htm#PFCOFF_FILE_HEADER">PFCOFF_FILE_HEADER.Characteristics:LARGE_ADDRESS_AWARE</a></td>
<td>0 (nepravda)</td><td>0 (nepravda)</td><td>0x0020 (pravda)</td></tr>
<tr><td><a class="EXT" href="../easource/pfpe.htm#PFPE_OPTIONAL_HEADER32">PFPE_OPTIONAL_HEADER32.Magic</a></td>
<td>0x010B (PE32)</td><td>0x010B (PE32)</td><td>0x020B (PE32+)</td></tr>
<tr><td>SIZE# <a class="EXT" href="../easource/pfpe.htm#PFPE_OPTIONAL_HEADER32">PFPE_OPTIONAL_HEADER32</a></td>
<td>224</td><td>224</td><td>240</td></tr></table>

<hr/>

<h2 id="EaFn"><a href="#top">&uarr; Funkce EuroAssembleru</a></h2>
<h3><a href="#EaFnPreprocessing">Preprocesing &darr;</a></h3>
<h3><a href="#EaFnRefactoring">Refaktorizace &darr;</a></h3>
<h3><a href="#EaFnAsm">Asembler &darr;</a></h3>
<h3><a href="#EaFnAsmDbg">Hledání chyb v asembleru &darr;</a></h3>
<h3><a href="#EaFnLink">Linker &darr;</a></h3>
<h3><a href="#EaFnLib">Knihovník &darr;</a></h3>
<h3><a href="#EaFnConvert">Objektový konvertor &darr;</a></h3>
<h3><a href="#EaFnMake">Makefile manažer &darr;</a></h3>
<h3><a href="#EaFnOptimize">Optimalizace &darr;</a></h3>
<h3><a href="#EaFnBegin">Kde začít &darr;</a></h3>
<p>Tato kapitola popisuje možnosti EuroAssembleru</p>

<h3 id="EaFnPreprocessing" title="Preprocessing"><a href="#EaFn">&uarr; Preprocesing</a></h3>
<p>Mnoho asemblerů poskytuje nástroje pomáhající programátorovi s opakující se namáhavou prací,
říká se jim <dfn>makroasemblery</dfn>.
Preprocesní (makro) aparát je v EuroAssembleru rozpoznatelný podle znaménka procenta <kbd>%</kbd>
přidaného před pseudoinstrukce řídicí opakované generování bloků kódu
(<a href="#pcREPEAT">%REPEAT</a>, <a href="#pcWHILE">%WHILE</a>, <a href="#pcFOR">%FOR</a>, <a href="#pcMACRO">%MACRO</a>),
podmíněný překlad (<a href="#pcIF">%IF</a>, <a href="#pcCOMMENT">%COMMENT</a>),
laděni v asm-time (<a href="#pcDISPLAY">%DISPLAY</a>)
a přiřazování a expanzi preprocesních %proměnných (rodina pseudoinstrukcí <a href="#pcSET">%SET*</a>).</p>
<p>Tato sbírka nástrojů manipuluje se zdrojovým textem dříve, než je předložen ke konečnému zpracování
asemblerem (předložen <dfn>prostému asembleru</dfn>, který o preprocesním aparátu nic neví).</p>
<p>Některé kompilery provedou preprocesing ve speciálním nultém průchodu,
který načítá vstupní zdrojový kód a jehož výstupem je kód prostého asembleru.
Předzpracovaný mezikód pak může být manuálně prohlédnut.</p>
<p>EuroAssembler používá odlišný přístup: namísto <strong>předzpracování celého zdrojového souboru</strong> najednou
jej předzpracovává <strong>instrukci po instrukci</strong> v každém průchodu.
To dovoluje manipulovat i s údaji, jenž se dynamicky mění a které nejsou pevné
dříve než &euro;ASM dostal příležitost projít celým programem aspoň jednou;
týká se to například vzdálenosti mezi návěstími, velikosti dosud nedefinovaných struktur apod.</p>

<blockquote>Když &euro;ASM čte řádek zdrojového textu, nejprve ho prohledá, zda obsahuje procento <kbd>%</kbd>.
Pokud ano, dívá se na následující znak a připraví kopii zdrojového řádku pro <i>prostý asembler</i>,
expandovanou dle následujících pravidel:
<table>
<tr><th>Znak následující <kbd>%</kbd></th><th>Příklad</th><th>Co jej nahradí</th></tr>
<tr><th><kbd>%</kbd></th><td>%%</td><td>Jednoduchý znak procenta <code>%</code></td></tr>
<tr><th><kbd>&amp;</kbd></th><td>%&amp;</td><td><a href="#pcam">Velikost nebo délka suboperace</a></td></tr>
<tr><th><kbd>.</kbd></th><td>%.</td><td><a href="#pcpt">Počitadlo expanzí</a></td></tr>
<tr><th><kbd>:</kbd></th><td>%:</td><td><a href="#pcco">Návěstí makra</a></td></tr>
<tr><th><kbd>!</kbd></th><td>%!formal</td><td><a href="#InvertedCondition">Invertovaná podmínka</a>, např. <code>NC</code></td></tr>
<tr><th><kbd>*</kbd></th><td>%*</td><td><a href="#pcas">Seznam pořadových operandů makra</a></td></tr>
<tr><th><kbd>#</kbd></th><td>%#</td><td><a href="#pcha">Počet pořadových operandů makra</a></td></tr>
<tr><th><kbd>=*</kbd></th><td>%=*</td><td><a href="#pceqas">Seznam klíčových operandů makra</a></td></tr>
<tr><th><kbd>=#</kbd></th><td>%=#</td><td><a href="#pceqha">Počet klíčových operandů makra</a></td></tr>
<tr><th><kbd>^identifier</kbd></th><td>%^Width</td><td><a href="#SystemVariables">Systémová %^proměnná</a> (čísla 16, 32 nebo 64}</td></tr>
<tr><th>decimal digit(s)</th><td>%12</td><td><a href="#pc1">Pořadový operand makra</a>, např. dvanáctý</td></tr>
<tr><th rowspan="3">letter(s)</th>
<td>%If</td><td>Jméno <a href="#PseudoInstructions">pseudoinstrukce</a> je ponecháno neexpandované (<code>%If</code>)</td></tr>
<tr><td>%Size</td><td>Pokud je to <a href="#FormalVariables">formální operand</a>, bude expandován na svou hodnotu,</td></tr>
<tr><td>%OtherId</td><td>jinak je expandován jako
<a href="#UserVariables">uživatelem definovaná</a> preprocesní %proměnná</td></tr>
</table>

Pro více detailů ohledně viditelnosti %proměnných viz zdrojový text
<a class="EXT" href="../easource/var.htm#VarExpand">VarExpand</a>.</blockquote>
<p>Vztah mezi preprocesingem a prostým asemblerem se podobá vztahu mezi
Javascriptem a prostým textem HTML v internetových browserech.</p>
<p>Správnou funkci &euro;ASM preprocesingu můžeme zkontrolovat v listingu
povolením voleb <code>EUROASM LISTVAR=ENABLE, LISTREPEAT=ENABLE, LISTMACRO=ENABLE</code>.</p>


<h3 id="EaFnRefactoring" title="Refactoring"><a href="#EaFn">&uarr; Refaktorizace</a></h3>
<h4><a href="#EaFnRfInlineCode">Inline kód&darr;</a></h4>
<h4><a href="#EaFnRfBypassedProc">Přeskočená PROC &darr;</a></h4>
<h4><a href="#EaFnRfProcOwnSection">PROC ve vlastní sekci &darr;</a></h4>
<h4><a href="#EaFnRfProc1">PROC1 &darr;</a></h4>
<h4><a href="#EaFnRfProcIncluded">PROC v INCLUDE &darr;</a></h4>
<h4><a href="#EaFnRfProcStaticLink">Staticky linkovaná PROC &darr;</a></h4>
<h4><a href="#EaFnRfProcDynamicLink">Dynamicky linkovaná PROC &darr;</a></h4>
<h4><a href="#EaFnRfInlineMacro">Inline makro &darr;</a></h4>
<h4><a href="#EaFnRfProcMacro">Makro volající PROC &darr;</a></h4>
<h4><a href="#EaFnRfSemiinlineMacro">Napůl-inline makro &darr;</a></h4>

<p>V této kapitole se podíváme, jako se dá v &euro;ASM rozdělit funkčnost programu na menší subprogramy.</p>
<p>Dejme tomu, že budeme potřebovat funkci, která kalkuluje třetí mocninu
kladného čísla. Výsledek by se měl vejít do 32 bitů, jinak program ohlásí přetečení a skončí.</p>
<p>Předpokládejme 32bitový mód a vstupní číslo načtené do registru EAX.
Použijeme instrukci <a class="EXT" href="../easource/iig.htm#IigMUL">MUL</a>
(unsigned multiplication) dvakrát:</p>

<h4 id="EaFnRfInlineCode"><a href="#EaFnRefactoring">&uarr; Inline kód</a></h4>
<p>Přímé řešení <strong>vkládá kód přímo</strong> do hlavního toku programu.</p>
<pre>    ; EAX obsahuje vstupní číslo N.
    MOV ECX,EAX ; Zkopíruj vstupní číslo N do registru ECX.
    MUL ECX     ; Nechť EDX:EAX = N*N
    JC Abort:   ; CF=OF=1 pokud je EDX nenulové (32bitové přetečení).
    MUL ECX     ; Nechť EDX:EAX = N*N*N
    JC Abort:   ; Abort při přetečení.
    ; EAX nyní obsahuje N<sup>3</sup>, pokračuj v hlavním toku programu.
</pre>

<h4 id="EaFnRfBypassedProc"><a href="#EaFnRefactoring">&uarr; Přeskočená PROC</a></h4>
<p>Pokud je výše zmíněná kalkulace potřebná častěji než jednou, měli bychom uvážit
<dfn>refactorizaci</dfn> přímého kódu na subproceduru, která bude volána opakovaně.
Vložíme proceduru nazvanou <code>Cube</code> do hlavního toku programu,
když bude její funkce poprvé potřeba. Vložení volatelné procedury vyžaduje její přeskočení.</p>
<pre>       ; EAX obsahuje vstupní číslo N.
       CALL Cube:  ; Vyvolej funkci, která kalkuluje N<sup>3</sup>.
       JC Abort:   ; Abort při overflow.
       JMP Bypass: ; Přeskoč kód funkce.
Cube PROC  ; Procedura kalkuluje třetí mocninu N.
; Input:   EAX=celé číslo N.
; Output:  CF=OF=0, EAX=N<sup>3</sup>, ECX=N, EDX=0.
; Overflow:CF=OF=1, EAX,ECX,EDX nedefinováno.
       MOV ECX,EAX ; Zkopíruj vstupní číslo N do registru ECX.
       MUL ECX     ; Nechť EDX:EAX = N*N
       JC .Abort   ; CF=OF=1 pokud je EDX nenulové (32bitové přetečení).
       MUL ECX     ; Nechť EDX:EAX = N*N*N
.Abort:RET         ; CF=OF=1 pokud je EDX nenulové (32bitové přetečení).
     ENDPROC Cube
Bypass:  ; EAX nyní obsahuje N<sup>3</sup>, pokračuj v hlavním toku programu.
</pre>

<h4 id="EaFnRfProcOwnSection"><a href="#EaFnRefactoring">&uarr; PROC ve vlastní sekci</a></h4>
<p>Instrukci <code>JMP Bypass:</code> bychom mohli uspořit, pokud by
procedura byla definována někde jinde, mimo programový tok.
Toho lze dosáhnout přemístěním procedury do jiné sekce, například do <code>[Subproc]</code>.</p>
<pre>       ; EAX obsahuje vstupní číslo N.
       CALL Cube:  ; Vyvolej funkci, která kalkuluje N<sup>3</sup>.
       JC Abort:   ; Abort při overflow.
%CurrentSect %SET %^Section ; Zálohuj jméno současné sekce do %proměnné.
[Subproc]  ; Přepni emitování do jiné kódové sekce.
Cube PROC  ; Procedura kalkuluje třetí mocninu N.
; Input:   EAX=celé číslo N.
; Output:  CF=OF=0, EAX=N<sup>3</sup>, ECX=N, EDX=0.
; Overflow:CF=OF=1, EAX,ECX,EDX nedefinováno.
       MOV ECX,EAX ; Zkopíruj vstupní číslo N do registru ECX.
       MUL ECX     ; Nechť EDX:EAX = N*N
       JC .Abort   ; CF=OF=1 pokud je EDX nenulové (32bitové přetečení).
       MUL ECX     ; Nechť EDX:EAX = N*N*N
.Abort:RET         ; CF=OF=1 pokud je EDX nenulové (32bitové přetečení).
     ENDPROC Cube
[%CurrentSect]     ; Návrat k původní sekci.
        ; EAX nyní obsahuje N<sup>3</sup>, pokračuj v hlavním toku programu.
</pre>

<h4 id="EaFnRfProc1"><a href="#EaFnRefactoring">&uarr; PROC1</a></h4>
<p>Namísto ručního přepnutí do odlišné sekce bychom mohli využít
blok <code>PROC1..ENDPROC1</code>, který přepíná do jiné sekce
[@RT1] a vrací se zpět zcela automaticky.</p>
<pre>       ; EAX obsahuje vstupní číslo N.
       CALL Cube:  ; Vyvolej funkci, která kalkuluje N<sup>3</sup>.
       JC Abort:   ; Abort při overflow.
Cube PROC1 ; Procedura kalkuluje třetí mocninu N. Je umístěna v sekci [@RT1].
; Input:   EAX=celé číslo N.
; Output:  CF=OF=0, EAX=N<sup>3</sup>, ECX=N, EDX=0.
; Overflow:CF=OF=1, EAX,ECX,EDX nedefinováno.
       MOV ECX,EAX ; Zkopíruj vstupní číslo N do registru ECX.
       MUL ECX     ; Nechť EDX:EAX = N*N
       JC .Abort   ; CF=OF=1 pokud je EDX nenulové (32bitové přetečení).
       MUL ECX     ; Nechť EDX:EAX = N*N*N
.Abort:RET         ; CF=OF=1 pokud je EDX nenulové (32bitové přetečení).
     ENDPROC1 Cube ; Konec procedury v sekci [@RT1]. Návrat do [.text].
      ; EAX nyní obsahuje N<sup>3</sup>, pokračuj v hlavním toku programu.
</pre>

<h4 id="EaFnRfProcIncluded"><a href="#EaFnRefactoring">&uarr; PROC v INCLUDE</a></h4>
<p>Definice funkce Cube v místě, kde je použita, je vhodná pro porozumění.
Na druhé straně, pokud je takových funkcí více, zahlcuje to hlavní linku programu.
Organizace by byla jasnější, pokud by pomocné podprogramy byly odloženy do jiného souboru,
např. <q>functions.inc</q>. Tento soubor pak bude
<strong>inkludována</strong> do hlavního zdrojového kódu v asm-time.</p><pre>
       INCLUDE "functions.inc" ; Soubor obsahující proceduru <code>Cube: PROC</code>.
       ; EAX obsahuje vstupní číslo N.
       CALL Cube:  ; Vyvolej funkci, která kalkuluje N<sup>3</sup>.
       JC Abort:   ; Abort při overflow.
       ; EAX nyní obsahuje N<sup>3</sup>, pokračuj v hlavním toku programu.
</pre>

<h4 id="EaFnRfProcStaticLink"><a href="#EaFnRefactoring">&uarr; Staticky linkovaná PROC</a></h4>
<p>Funkce definované v inkludovaném souboru <q>functions.inc</q> mohou být
zabaleny do bloku <code>functions PROGRAM</code>..<code>ENDPROGRAM</code>
a přeloženy zvlášť do objektového formátu OMF, ELF nebo COFF <q>functions.obj</q>,
případně do knihovny objektů. Jméno funkce (<code>Cube</code>) musí být deklarováno jako
GLOBAL nebo PUBLIC v objektovém kódu, a jako GLOBAL nebo EXTERN v hlavním souboru.
Namísto explicitní deklarace pomocí GLOBAL lze globálnost funkcí označovat dvojitou dvojtečkou
(<code>Cube::</code>). Přeložený objekt pak bude <strong>staticky linkován</strong> do  hlavního programu v link-time.</p><pre>
       LINK "functions.obj" ; Objektový soubor s procedurou Cube.
       ; EAX obsahuje vstupní číslo N.
       CALL Cube:: ; Vyvolej funkci, která kalkuluje N<sup>3</sup>.
       JC Abort:   ; Abort při overflow.
       ; EAX nyní obsahuje N<sup>3</sup>, pokračuj v hlavním toku programu.
</pre>

<h4 id="EaFnRfProcDynamicLink"><a href="#EaFnRefactoring">&uarr; Dynamicky linkovaná PROC</a></h4>
<p>Funkce definované v inkludovaném souboru <q>functions.inc</q> také mohly být zabaleny
do bloku <code>functions PROGRAM</code>..<code>ENDPROGRAM</code>
a přeloženy zvlášť do dynamicky linkované knihovny <q>functions.dll</q>.
Jméno funkce (<code>Cube</code>) musí být deklarováno jako EXPORT v této knihovně,
a jako IMPORT v hlavním spustitelném souboru.
Přeložená funkce z programu DLL pak bude <strong>dynamicky svázána</strong> s hlavním programem v bind-time.</p><pre>
       IMPORT Cube, LIB="functions.dll"
       ; EAX obsahuje vstupní číslo N.
       CALL Cube:: ; Vyvolej funkci, která kalkuluje N<sup>3</sup>.
       JC Abort:   ; Abort při overflow.
       ; EAX nyní obsahuje N<sup>3</sup>, pokračuj v hlavním toku programu.
</pre>

<h4 id="EaFnRfInlineMacro"><a href="#EaFnRefactoring">&uarr; Inline macro</a></h4>
<p>Alternativní přístup k opakování <a href="#EaFnRfInlineCode">inline kódu</a>
je využití makra, které expanduje kdykoli je požadována jeho funkčnost.</p>
<p>Instrukce, které definují makro, nemusí být přeskakovány, neboť neemitují žádný kód,
avšak makrodefinice se musí objevit dříve, než bude makro použito.
Tato definice také mohla být odložena do inkludovaného souboru, podobně jako v metodě
<a href="#EaFnRfProcIncluded">PROC v INCLUDE</a>.</p>
<pre>
Cube %MACRO
       MOV ECX,EAX ; Zkopíruj vstupní číslo N do registru ECX.
       MUL ECX     ; Nechť EDX:EAX = N*N
       JC Abort%.: ; CF=OF=1 pokud je EDX nenulové (32bitové přetečení).
       MUL ECX     ; Nechť EDX:EAX = N*N*N
Abort%.:           ; Jméno návěstí je modifikováno %proměnnou <code>%.</code>, jež se inkrementuje při každé expanzi.
     %ENDMACRO Cube
     ; EAX obsahuje vstupní číslo N.
     Cube          ; Expanze makra.
     JC Abort:     ; Abort při overflow.
     ; EAX nyní obsahuje N<sup>3</sup>, pokračuj v hlavním toku programu.
</pre>

<h4 id="EaFnRfProcMacro"><a href="#EaFnRefactoring">&uarr; Makro volající PROC</a></h4>
<p>Inline makra jsou rychlá, ale každá invokace opakuje celý kód procedury.
Velikost programu bychom mohli omezit, pokud by makro volalo proceduru s funkčním kódem,
která mohla být rovněž odložena do inkludovaného <q>functions.inc</q>.
Funkce makra pak bude omezena na předání eventuálních parametrů a skrytí volací konvence
(v našem prostém příkladu ale žádné parametry předávány nejsou).</p>
<pre>
     INCLUDE "functions.inc" ; Soubor s definicí procedury Cube.
Cube %MACRO       ; Definuj makro Cube.
       CALL Cube: ; Volání procedury Cube:
     %ENDMACRO Cube
     ; EAX obsahuje vstupní číslo N.
     Cube         ; Vyvolej makro volající inkludovanou proceduru.
     JC Abort     ; Abort při overflow.
     ; EAX nyní obsahuje N<sup>3</sup>, pokračuj v hlavním toku programu.
</pre>

<h4 id="EaFnRfSemiinlineMacro"><a href="#EaFnRefactoring">&uarr; Napůl-inline makro</a></h4>
<p>Nevýhodou předchozí metody je, že musíme udržovat dva bloky kódu:
definici makra a definici procedury. &euro;ASM poskytuje blok procedury PROC1,
který se překládán pouze jednou, i když je makro tento blok obsahující voláno opakovaně.
Díky tomu je kód procedury emitován pouze jednou, když je makro voláno poprvé,
a pokud by nebylo vůbec voláno, kód procedury se vůbec neemituje.
Makroknihovna s takovými <strong>napůl-inline makry</strong> může být začleněna do zdrojového kódu
a nezvyšuje přitom velikost výsledného kódu, pokud makro nebylo v programu použito (expandováno).</p>
<p>Tato metoda je preferována ve většině makroknihoven
<a class="EXT" href="../maclib/">dodaných</a> s EuroAssemblerem.</p>
<pre>
Cube %MACRO          ; Definice napůl-inline maker Cube.
       CALL Cube:    ; Volání procedury Cube:
 Cube: PROC1         ; PROC1 blok je emitován pouze jednou při první expanzi makra.
         MOV ECX,EAX ; Kopíruj vstupní číslo N do registru ECX.
         MUL ECX     ; Nechť EDX:EAX = N*N
         JC .Abort:  ; CF=OF=1 pokud je EDX nenulové (32bitové přetečení).
         MUL ECX     ; Nechť EDX:EAX = N*N*N
  .Abort:RET         ; CF=OF=1 pokud je EDX nenulové (32bitové přetečení).
       ENDPROC1 Cube:
     %ENDMACRO Cube
     ; EAX obsahuje vstupní číslo N.
     Cube            ; Vyvolej makro, které volá PROC1.
     JC Abort        ; Abort při overflow.
     ; EAX nyní obsahuje N<sup>3</sup>, pokračuj v hlavním toku programu.
</pre>

<h3 id="EaFnAsm" title="Assembler"><a href="#EaFn">&uarr; Asembler</a></h3>
<h4><a href="#EaFnSrc">Obálka zdrojového programu &darr;</a></h4>
<h4><a href="#EaFnChain">Řetězené programy &darr;</a></h4>
<h4><a href="#EaFnNest">Vnořené programy &darr;</a></h4>
<p>Tato kapitola se blíže zabývá, jak jsou bloky programu zpracovány EuroAssemblerem.</p>
<h4 id="EaFnSrc" title="Envelope"><a href="#EaFnAsm">&uarr; Obálka zdrojového programu</a></h4>
<p>Uvažme prostý textový soubor <q>src.asm</q> předložený asembleru:</p>
<pre>
 DB 'This source "src.asm" has'
 DB ' no PROGRAM statement.',13,10
 DB 'EuroAssembler will use '
 DB 'a fictive envelope instead.'
</pre>
<p>Jelikož v souboru není definován žádný blok <code>PROGRAM..ENDPROGRAM</code>,
výstupní formát cílového souboru je určen pouze sekcí [PROGRAM] konfiguračního souboru <q>euroasm.ini</q>,
nebo vestavěným továrním defaultem, kterým je <code>PROGRAM FORMAT=BIN,MODEL=TINY,WIDTH=16</code>.</p>
<p>EuroAssembler formálně balí každý zdrojový soubor do dvou fiktivních
<dfn>obálkových</dfn> pseudoinstrukcí PROGRAM a ENDPROGRAM.
Přidaná obálková instrukce PROGRAM odvozuje své návěstí (název modulu)
ze jména zdrojového souboru po odříznutí přípony.
Ze zdrojového souboru <q>src.asm</q> tedy vytvoří binární soubor <q>src.bin</q>.
To je chování kompatibilní s mnoha dalšími asemblery.</p>
<blockquote><p>Pokud by jméno zdrojového souboru začínalo číslicí, např. <q>123.asm</q>,
takový název programu není přijatelný pro &euro;ASM, který proto před jméno modulu přidá znak grave <kbd>`</kbd>
a zdroj <q>123.asm</q> bude přeložen na <q>`123.bin</q>.</p>
<p>Podobně, pokud by návěstí pseudoinstrukce PROGRAM obsahovalo otazník <kbd>?</kbd>
nebo jiný znak nepřijatelný pro souborový systém, takový znak pak bude v názvu souboru nahrazen podtržítkem <kbd>_</kbd>.
Instrukce <code>IsNumlockOn? PROGRAM FORMAT=COM</code> vyrobí program se jménem <q>IsNumlockOn_.com</q>.</p>
<p>&euro;ASM používá ANSI verze Windows API pro zacházení se jmény souborů,
takže je lepší se vyvarovat národních znaků mimo aktuální codepage ve jménech souborů.</p></blockquote>
<p>Jakmile je zdrojový soubor načten v paměti, &euro;ASM začíná číst zdroj počínaje fiktivní
obálkovou instrukcí <code>PROGRAM</code>. Až bude načtena odpovídající pseudoinstrukce
<code>ENDPROGRAM</code>, skončil jeden <dfn>průchod asembleru</dfn>.
&euro;ASM se podívá na všechny symboly nadefinované v programu
a kontroluje, zda jejich ofsety jsou označeny jako <dfn>fixed</dfn>, tj. nezměnily se mezi průchody.
Jestliže aspoň jeden symbol dosud nemá svůj ofset zafixován,
je potřeba další průchod a &euro;ASM se vrací k pseudoinstrukci <code>PROGRAM</code>.
Až budou mít všechny symboly ofset stabilní, &euro;ASM zahájí <dfn>finální průchod</dfn>,
v němž se generuje kód a data do cílového souboru a také se generuje listing.
K přeložení každého programu jsou zapotřebí nejméně dva průchody.</p>
<pre>                                                     <abbr>assembly progress &#x2500;&gt;</abbr>
&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;<abbr>     &#x2588;</abbr>
&#x2502;envelope &#x2502;src: PROGRAM                      &#x2502;<abbr>      &#x2588;       &#x250C;&#x2588;</abbr>
&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x253C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;<abbr>       &#x2588;      &#x2502; &#x2588;</abbr>
&#x2502;      {1}&#x2502; DB 'This source "src.asm" has'   &#x2502;<abbr>        &#x2588;     &#x2502;  &#x2588;</abbr>
&#x2502;"src.asm"&#x2502; DB ' no PROGRAM statement.',13,10&#x2502;<abbr>         &#x2588;    &#x2502;   &#x2588;</abbr>
&#x2502;      {3}&#x2502; DB 'EuroAssembler will use '     &#x2502;<abbr>          &#x2588;   &#x2502;    &#x2588;</abbr>
&#x2502;      {4}&#x2502; DB 'a fictive envelope instead.' &#x2502;<abbr>           &#x2588;  &#x2502;     &#x2588;</abbr>
&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x253C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;<abbr>            &#x2588; &#x2502;      &#x2588;</abbr>
&#x2502;envelope &#x2502; ENDPROGRAM src:                  &#x2502;<abbr>             &#x2588;&#x2518;       &#x2588;&#x2500;&#x2510;</abbr>
&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;<abbr>                        &#x2588;</abbr>
                                                   &#x2502;&#x2502;        &#x2502;      &#x2502; &#x2502;
I0010 EuroAssembler started.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;        &#x2502;      &#x2502; &#x2502;
I0180 Assembling source file "src.asm".&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;        &#x2502;      &#x2502; &#x2502;
I0270 Assembling source "src".&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&#x2502;        &#x2502;      &#x2502; &#x2502;
I0310 Assembling source pass 1.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;        &#x2502;      &#x2502; &#x2502;
I0330 Assembling source pass 2 - final.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;      &#x2502; &#x2502;
I0760 16bit TINY BIN file "src.bin" created from source, size=99.&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;
I0750 Source "src" (4 lines) assembled in 2 passes with errorlevel 0.&#x2500;&#x2524;
I0860 Listing file "src.asm.lst" created, size=717.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;
I0990 EuroAssembler terminated with errorlevel 0.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</pre>
<p>Dvě obálkové pseudoinstrukce jsou použity nezávisle na tom, zda byl explicitní blok PROGRAM..ENDPROGRAM
ve zdrojovém textu definován či ne.
Zdrojové řádky mezi začátkem souboru a explicitní pseudoinstrukcí PROGRAM,
stejně jako řádky mezi explicitní pseudoinstrukcí ENDPROGRAM a koncem souboru
be neměly emitovat žádný kód ani data. V tom případě je obálkový zdroj prázdný
a nevytváří se z něj žádný cílový soubor.</p>
<p>Uvažme následující zdrojový soubor <q>src.asm</q>.
Obsahuje explicitní blok <code>Src:PROGRAM..ENDPROGRAM Src:</code> (řádky 5..8)
uvnitř neviditelných obálkových pseudoinstrukcí <code>src: PROGRAM</code> a <code>ENDPROGRAM src:</code>.
Když byl interní blok <code>Src:PROGRAM..ENDPROGRAM Src:</code> spatřen během překladu,
celý tento blok je přeskočen až dokud nedojde k poslednímu průchodu vnějším blokem
<code>src: PROGRAM..ENDPROGRAM src:</code>.
Pak &euro;ASM odloží momentálně překládaný poslední průchod stranou,
a začne překládat vnitřní blok v potřebném počtu průchodů, dokud nevytvoří
a neuzavře cílový soubor. Pak se &euro;ASM vrátí k dokončení posledního průchodu předtím přerušeného průchodu
vnějším (obálkovým) programem.</p>
<pre>
    EUROASM ; Common options.
    ; Source file "src.asm"
    ; with PROGRAM defined
explicitly.
Src:PROGRAM FORMAT=BIN
     DB 'Data emitted '
     DB 'by program Src.'
     ENDPROGRAM Src:
</pre>
<p>Všimněte si chyby: zalomení komentářového řádku {3} způsobilo vznik ne-komentářového řádku {4}.
Výraz <code>explicitly.</code> bude považován za platné návěstí (definice adresního symbolu).
To způsobí, že obálkový program již není považován za prázdný a bude z něj vytvořen
cílový binární soubor <q>src.bin</q>, i když s nulovou délkou (obsahuje pouze jeden symbol s nulovou délkou).
<br/>Vnitřní program z řádků {5..8} vytváří cílový soubor <q>Src.bin</q>
dlouhý 28 bajtů, avšak ten bude hned přepsán obálkovým cílovým souborem <q>src.bin</q>
s nulovou délkou, který má náhodou téměř identické jméno
(souborový systém v Dos a Windows je nezávislý na velikosti znaků).
<pre>

&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;<abbr>  &#x2588;              assembly progress &#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&gt;</abbr>
&#x2502;envelope &#x2502;src: PROGRAM                      &#x2502;<abbr>   &#x2588;         &#x250C;&#x2588;         &#x250C;&#x2588;</abbr>
&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x253C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;<abbr>    &#x2588;        &#x2502; &#x2588;        &#x2502; &#x2588;</abbr>
&#x2502;      {1}&#x2502; EUROASM ; Common options.        &#x2502;<abbr>     &#x2588;       &#x2502;  &#x2588;       &#x2502;  &#x2588;</abbr>
&#x2502;      {2}&#x2502;    ; Source file "src.asm"       &#x2502;<abbr>      &#x2588;      &#x2502;   &#x2588;      &#x2502;   &#x2588;</abbr>
&#x2502;      {3}&#x2502;    ; with PROGRAM defined        &#x2502;<abbr>       &#x2588;     &#x2502;    &#x2588;     &#x2502;    &#x2588;</abbr>
&#x2502;      {4}&#x2502;explicitly.                       &#x2502;<abbr>        &#x2588;&#x2510;   &#x2502;     &#x2588;&#x2510;   &#x2502;     &#x2588;</abbr>
&#x2502;"src.asm"&#x2502;Src:PROGRAM FORMAT=BIN            &#x2502;<abbr>         &#x2502;   &#x2502;      &#x2502;   &#x2502;      &#x2588;&#x2500;&#x2588;   &#x250C;&#x2588;</abbr>
&#x2502;      {6}&#x2502;     DB 'Data emitted '           &#x2502;<abbr>         &#x2502;   &#x2502;      &#x2502;   &#x2502;         &#x2588;  &#x2502; &#x2588;</abbr>
&#x2502;      {7}&#x2502;     DB 'by program Src.'         &#x2502;<abbr>         &#x2502;   &#x2502;      &#x2502;   &#x2502;          &#x2588; &#x2502;  &#x2588;</abbr>
&#x2502;      {8}&#x2502;     ENDPROGRAM Src:              &#x2502;<abbr>         &#x2514;&#x2588;  &#x2502;      &#x2514;&#x2588;  &#x2502;           &#x2588;&#x2518;   &#x2588;&#x2510;</abbr>
&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x253C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;<abbr>           &#x2588; &#x2502;        &#x2588; &#x2502;                 &#x2514;&#x2588;</abbr>
&#x2502;envelope &#x2502; ENDPROGRAM src:                  &#x2502;<abbr>            &#x2588;&#x2518;         &#x2588;&#x2518;                   &#x2588;&#x2510;</abbr>
&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;<abbr>                                             &#x2588;</abbr>
                                                &#x2502;&#x2502;          &#x2502;          &#x2502;    &#x2502; &#x2502;&#x2502;    &#x2502;  &#x2502;  &#x2502;&#x2502;
I0010 EuroAssembler started.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;          &#x2502;          &#x2502;    &#x2502; &#x2502;&#x2502;    &#x2502;  &#x2502;  &#x2502;&#x2502;
I0180 Assembling source file "src.asm".&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;          &#x2502;          &#x2502;    &#x2502; &#x2502;&#x2502;    &#x2502;  &#x2502;  &#x2502;&#x2502;
I0270 Assembling source "src".&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&#x2502;          &#x2502;          &#x2502;    &#x2502; &#x2502;&#x2502;    &#x2502;  &#x2502;  &#x2502;&#x2502;
I0310 Assembling source pass 1.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;          &#x2502;          &#x2502;    &#x2502; &#x2502;&#x2502;    &#x2502;  &#x2502;  &#x2502;&#x2502;
I0310 Assembling source pass 2.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;          &#x2502;    &#x2502; &#x2502;&#x2502;    &#x2502;  &#x2502;  &#x2502;&#x2502;
I0330 Assembling source pass 3 - final.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2502; &#x2502;&#x2502;    &#x2502;  &#x2502;  &#x2502;&#x2502;
W2101 Symbol "explicitly." was defined but never used. "src.asm"{4}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;&#x2502;    &#x2502;  &#x2502;  &#x2502;&#x2502;
I0470 Assembling program "Src". "src.asm"{5}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&#x2502;    &#x2502;  &#x2502;  &#x2502;&#x2502;
I0510 Assembling program pass 1. "src.asm"{5}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2502;  &#x2502;  &#x2502;&#x2502;
I0530 Assembling program pass 2 - final. "src.asm"{5}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;  &#x2502;  &#x2502;&#x2502;
I0660 16bit TINY BIN file "Src.bin" created, size=28. "src.asm"{8}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;  &#x2502;&#x2502;
I0650 Program "Src" assembled in 2 passes with errorlevel 0. "src.asm"{8}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;  &#x2502;&#x2502;
W3990 Overwriting previously generated output file "Src.bin".&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;
I0760 16bit TINY BIN file "src.bin" created from source, size=0.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;
I0750 Source "src" (8 lines) assembled in 3 passes with errorlevel 3.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;
I0860 Listing file "src.asm.lst" created, size=1372.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&#x2502;
I0990 EuroAssembler terminated with errorlevel 3.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</pre>

<h4 id="EaFnChain"><a href="#EaFnAsm">&uarr; Řetězené programy</a></h4>
<p>EuroAssembler dovoluje definovat v jednom zdrojovém souboru více programových bloků
a pak je překládat jedním příkazem.
Pamatujte, že symboly použité v různých blocích PROGRAM..ENDPROGRAM mají privátní viditelnost,
takže se navzájem nevidí, i když byly definovány ve stejném zdrojovém souboru.
Chceme-li volat proceduru definovanou v Pgm1 z programu Pgm2,
volaný symbol musí být globální a oba přeložené moduly musejí být slinkovány dohromady.</p><pre>
&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;<abbr> &#x2588;            assembly progress &#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&gt;</abbr>
&#x2502;envelope &#x2502;src: PROGRAM                      &#x2502;<abbr>  &#x2588;       &#x250C;&#x2588;</abbr>
&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x253C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;<abbr>   &#x2588;      &#x2502; &#x2588;</abbr>
&#x2502;      {1}&#x2502;     EUROASM ; Common options.    &#x2502;<abbr>    &#x2588;     &#x2502;  &#x2588;</abbr>
&#x2502;      {2}&#x2502;Pgm1:PROGRAM FORMAT=PE,ENTRY=Run1:&#x2502;<abbr>     &#x2588;&#x2510;   &#x2502;   &#x2588;&#x2500;&#x2588;   &#x250C;&#x2588;   &#x250C;&#x2588;</abbr>
&#x2502;      {3}&#x2502;      ; Pgm1 data.                &#x2502;<abbr>      &#x2502;   &#x2502;      &#x2588;  &#x2502; &#x2588;  &#x2502; &#x2588;</abbr>
&#x2502;      {4}&#x2502;Run1: ; Pgm1 code.                &#x2502;<abbr>      &#x2502;   &#x2502;       &#x2588; &#x2502;  &#x2588; &#x2502;  &#x2588;</abbr>
&#x2502;"src.asm"&#x2502;     ENDPROGRAM Pgm1:             &#x2502;<abbr>      &#x2502;   &#x2502;        &#x2588;&#x2518;   &#x2588;&#x2518;   &#x2588;&#x2510;</abbr>
&#x2502;      {6}&#x2502;     ; Pgm2 description.          &#x2502;<abbr>      &#x2502;   &#x2502;                   &#x2588;</abbr>
&#x2502;      {7}&#x2502;Pgm2:PROGRAM FORMAT=PE,ENTRY=Run2:&#x2502;<abbr>      &#x2502;   &#x2502;                   &#x2514;&#x2588;   &#x250C;&#x2588;   &#x250C;&#x2588;</abbr>
&#x2502;      {8}&#x2502;      ; Pgm2 data.                &#x2502;<abbr>      &#x2502;   &#x2502;                     &#x2588;  &#x2502; &#x2588;  &#x2502; &#x2588;</abbr>
&#x2502;      {9}&#x2502;Run2: ; Pgm2 code.                &#x2502;<abbr>      &#x2502;   &#x2502;                      &#x2588; &#x2502;  &#x2588; &#x2502;  &#x2588;</abbr>
&#x2502;     {10}&#x2502;      ENDPROGRAM Pgm2:            &#x2502;<abbr>      &#x2514;&#x2588;  &#x2502;                       &#x2588;&#x2518;   &#x2588;&#x2518;   &#x2588;&#x2510;</abbr>
&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x253C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;<abbr>        &#x2588; &#x2502;                                  &#x2514;&#x2588;</abbr>
&#x2502;envelope &#x2502; ENDPROGRAM src:                  &#x2502;<abbr>         &#x2588;&#x2518;                                    &#x2588;&#x2510;</abbr>
&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;<abbr>                                                &#x2588;</abbr>
                                               &#x2502;&#x2502;        &#x2502;    &#x2502;    &#x2502;    &#x2502;  &#x2502; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0010 EuroAssembler started.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;        &#x2502;    &#x2502;    &#x2502;    &#x2502;  &#x2502; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0180 Assembling source file "src.asm".&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;        &#x2502;    &#x2502;    &#x2502;    &#x2502;  &#x2502; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0270 Assembling source "src".&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&#x2502;        &#x2502;    &#x2502;    &#x2502;    &#x2502;  &#x2502; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0310 Assembling source pass 1.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;        &#x2502;    &#x2502;    &#x2502;    &#x2502;  &#x2502; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0330 Assembling source pass 2 - final.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2502;    &#x2502;    &#x2502;  &#x2502; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0470 Assembling program "Pgm1". "src.asm"{2}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;    &#x2502;    &#x2502;  &#x2502; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0510 Assembling program pass 1. "src.asm"{2}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2502;    &#x2502;  &#x2502; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0510 Assembling program pass 2. "src.asm"{2}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2502;  &#x2502; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0530 Assembling program pass 3 - final. "src.asm"{2}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;  &#x2502; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0660 32bit FLAT PE file "Pgm1.exe" created, size=14320. "src.asm"{5}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0650 Program "Pgm1" assembled in 3 passes with errorlevel 0. "src.asm"{5}&#x2500;&#x2518; &#x2502;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0470 Assembling program "Pgm2". "src.asm"{7}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0510 Assembling program pass 1. "src.asm"{7}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2502;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0510 Assembling program pass 2. "src.asm"{7}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2502;   &#x2502; &#x2502;&#x2502;
I0530 Assembling program pass 3 - final. "src.asm"{7}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;   &#x2502; &#x2502;&#x2502;
I0660 32bit FLAT PE file "Pgm2.exe" created, size=14320. "src.asm"{10}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;&#x2502;
I0650 Program "Pgm2" assembled in 3 passes with errorlevel 0. "src.asm"{10}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;&#x2502;
I0750 Source "src" (10 lines) assembled in 2 passes with errorlevel 0.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;
I0860 Listing file "src.asm.lst" created, size=1736.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&#x2502;
I0990 EuroAssembler terminated with errorlevel 0.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</pre>
<blockquote><p>Proč bychom měli balit moduly spolu s jejich dokumentací do jednoho velkého zdrojového souboru,
místo abychom je roztrousili do balíku menších souborů?
Je to otázka individuálních preferencí.</p>
<p>Jedním z důvodů může být přenos informací mezi moduly preprocesními %proměnnými.
Na rozdíl od běžných symbolů není viditelnost %proměnných omezována hranicemi bloků PROGRAM..ENDPROGRAM.
Předpokládejme, že v programu Pgm2 potřebujeme znát velikost datového segmentu programu Pgm1.
Jeho velikost můžeme načíst do %proměnné povelem <code>%Pgm1DataSize %SETA SIZE# [DATA]</code>
umístěným v Pgm1 hned nad jeho <code> ENDPROGRAM Pgm1</code>.
V posledním průchodu Pgm1 již je velikost segmentu spolehlivě určena a %proměnná <code>%Pgm1DataSize</code>
bude viditelná v celém zdroji pod svou definicí, takže s ní Pgm2 může počítat.</p>
<p>Dalším příkladem užitečnosti seskupování programů je, pokud jsou si navzájem podobné
nebo sdílejí společná data deklarovaná preprocesními %proměnnými.
Následující příklad generuje ve smyčce tři podobné krátké programy
<q>RstLPT1.com</q>, <q>RstLPT2.com</q>, <q>RstLPT3.com</q>:</p>
<pre>
Nr %FOR 1,2,3     ; Zopakuj blok %FOR..%ENDFOR třikrát.
 RstLPT%Nr PROGRAM FORMAT=COM ; Program k resetu portu tiskárny.
   MOV DX,%Nr     ; Pořadové číslo LPT portu (1,2,3).
   MOV AH,1       ; Funkce BIOSu INITIALIZE LPT PORT.
   INT 17h        ; Použij funkci BIOSu k resetu tiskárny.
   MOV DX,Message ; Vlož adresu řetězce do DS:DX.
   MOV AH,9       ; Funkce DOSu WRITE STRING TO STDOUT.
   INT 21h        ; Použij funkci DOSu k ohlášení výsledku.
   RET            ; Ukonči program
   Message:DB "LPT%Nr was reset.$"
 ENDPROGRAM RstLPT%Nr
%ENDFOR Nr        ; Generuj 3 klony programu.
</pre>
</blockquote>

<h4 id="EaFnNest"><a href="#EaFnAsm">&uarr; Vnořené programy</a></h4>
<p>Programové moduly mohou být vnořeny jeden do druhého. Například při překladu
obojživelného programu spustitelného v DOSu i ve Windows můžeme chtít zohlednit fakt,
že DOSovský spustitelný soubor MZ je vestavěn jako <em>stub</em>
do spustitelného PE programu pro Windows a poskytuje stejnou funkčnost.
<br/>Viz vzorový projekt <a class="EXT" href="../prowin32/locktest.htm">LockTest</a>
jako příklad duálního DOS&amp;Windows programu.</p>
<p>Opět, pokud vnější program vidí vnitřní programový blok v neposledním průchodu,
bude přeskočen. Až v posledním průchodu vnějšího bloku bude tento dočasně suspendován,
vnitřní program kompletně přeložen a uložen, a pak se teprve vnější program vrátí
k dokončení posledního průchodu.</p>
<pre>
&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;<abbr> &#x2588;                   assembly progress &#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&gt;</abbr>
&#x2502;envelope &#x2502;src: PROGRAM                      &#x2502;<abbr>  &#x2588;       &#x250C;&#x2588;</abbr>
&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x253C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;<abbr>   &#x2588;      &#x2502; &#x2588;</abbr>
&#x2502;      {1}&#x2502;      EUROASM ; Common options.   &#x2502;<abbr>    &#x2588;     &#x2502;  &#x2588;</abbr>
&#x2502;      {2}&#x2502;Pgm1: PROGRAM FORMAT=PE,ENTRY=Run:&#x2502;<abbr>     &#x2588;&#x2510;   &#x2502;   &#x2588;&#x2500;&#x2588;       &#x250C;&#x2588;       &#x250C;&#x2588;</abbr>
&#x2502;      {3}&#x2502;Run:   ; Pgm1 data + code.        &#x2502;<abbr>      &#x2502;   &#x2502;      &#x2588;      &#x2502; &#x2588;      &#x2502; &#x2588;</abbr>
&#x2502;      {4}&#x2502; Pgm2: PROGRAM FORMAT=COFF        &#x2502;<abbr>      &#x2502;   &#x2502;       &#x2588;&#x2510;    &#x2502;  &#x2588;&#x2510;    &#x2502;  &#x2588;&#x2500;&#x2588;  &#x250C;&#x2588;</abbr>
&#x2502;"src.asm"&#x2502;        ; Pgm2 data + code.       &#x2502;<abbr>      &#x2502;   &#x2502;        &#x2502;    &#x2502;   &#x2502;    &#x2502;     &#x2588; &#x2502; &#x2588;</abbr>
&#x2502;      {6}&#x2502;       ENDPROGRAM Pgm2:           &#x2502;<abbr>      &#x2502;   &#x2502;        &#x2514;&#x2588;   &#x2502;   &#x2514;&#x2588;   &#x2502;      &#x2588;&#x2518;  &#x2588;&#x2500;&#x2588;</abbr>
&#x2502;      {7}&#x2502;       ; Pgm1 more code.          &#x2502;<abbr>      &#x2502;   &#x2502;          &#x2588;  &#x2502;     &#x2588;  &#x2502;             &#x2588;</abbr>
&#x2502;      {8}&#x2502;       LINK "Pgm2.obj"            &#x2502;<abbr>      &#x2502;   &#x2502;           &#x2588; &#x2502;      &#x2588; &#x2502;              &#x2588;</abbr>
&#x2502;      {9}&#x2502;      ENDPROGRAM Pgm1:            &#x2502;<abbr>      &#x2514;&#x2588;  &#x2502;            &#x2588;&#x2518;       &#x2588;&#x2518;               &#x2588;&#x2500;&#x2588;</abbr>
&#x251C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x253C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;<abbr>        &#x2588; &#x2502;                                         &#x2588;</abbr>
&#x2502;envelope &#x2502; ENDPROGRAM src:                  &#x2502;<abbr>         &#x2588;&#x2518;                                          &#x2588;&#x2500;&#x2510;</abbr>
&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;<abbr>                                                       &#x2588;</abbr>
                                               &#x2502;&#x2502;        &#x2502;    &#x2502;        &#x2502;        &#x2502;   &#x2502;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0010 EuroAssembler started. &#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;        &#x2502;    &#x2502;        &#x2502;        &#x2502;   &#x2502;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0180 Assembling source file "src.asm".&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;&#x2502;        &#x2502;    &#x2502;        &#x2502;        &#x2502;   &#x2502;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0270 Assembling source "src".&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;&#x2502;        &#x2502;    &#x2502;        &#x2502;        &#x2502;   &#x2502;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0310 Assembling source pass 1.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;        &#x2502;    &#x2502;        &#x2502;        &#x2502;   &#x2502;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0330 Assembling source pass 2 - final.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2502;        &#x2502;        &#x2502;   &#x2502;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0470 Assembling program "Pgm1". "src.asm"{2}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;        &#x2502;        &#x2502;   &#x2502;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0510 Assembling program pass 1. "src.asm"{2}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;        &#x2502;        &#x2502;   &#x2502;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0510 Assembling program pass 2. "src.asm"{2}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;        &#x2502;   &#x2502;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0530 Assembling program pass 3 - final. "src.asm"{2}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;   &#x2502;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0470 Assembling program "Pgm2". "src.asm"{4}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0510 Assembling program pass 1. "src.asm"{4}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;   &#x2502; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0530 Assembling program pass 2 - final. "src.asm"{4}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;    &#x2502;   &#x2502; &#x2502;
I0660 32bit FLAT COFF file "Pgm2.obj" created, size=78. "src.asm"{6}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;    &#x2502;   &#x2502; &#x2502;
I0650 Program "Pgm2" assembled in 2 passes with errorlevel 0. "src.asm"{6}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;    &#x2502;   &#x2502; &#x2502;
I0560 Linking COFF module ".\Pgm2.obj". "src.asm"{9}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;   &#x2502; &#x2502;
I0660 32bit FLAT PE file "Pgm1.exe" created, size=14320. "src.asm"{9}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524;   &#x2502; &#x2502;
I0650 Program "Pgm1" assembled in 3 passes with errorlevel 0. "src.asm"{9}&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;   &#x2502; &#x2502;
I0750 Source "src" (9 lines) assembled in 2 passes with errorlevel 0.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2524; &#x2502;
I0860 Listing file "src.asm.lst" created, size=1237.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2502;
I0990 EuroAssembler terminated with errorlevel 0.&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
</pre>

<h3 id="EaFnAsmDbg"><a href="#EaFn">&uarr; Hledání chyb v asembleru</a></h3>
<p>Několik užitečných vlastností EuroAssembleru pomůže programátorovi s kontrolou,
zda se jeho zdrojový kód přeložil tak, jak bylo zamýšleno.</p>
<p>Toto <strong>hledání chyb v asm-time</strong> pomáhá nalézt nedorozumění a chyby v EuroAssembleru samotném,
nikoli v překládaném programu.</p>
<p>Nejvíce pomůže <a href="#ListingFile">sloupec pro dump</a> přeloženého kódu <strong>v listingu</strong>.
Opakované úseky považované za bezchybné jsou ze zobrazování vynechány, ale mohou být vyžádány
direktivami <a href="#ListParameters"><code>EUROASM LISTINCLUDE=ON, LISTVAR=ON, LISTMACRO=ON, LISTREPEAT=ON</code></a>.</p>
<p><strong>Rozpoznávání polí</strong> v instrukcích lze objednat pomocí volby <code>EUROASM DISPLAYSTM=ON</code>,
která přidává komentářové řádky identifikující každé pole.
Jelikož to významně nafukuje listing, je lepší omezit DISPLAYSTM pouze na podezřelé řádky
a pak volby zase vypnout anebo obnovit předchozí stav:<pre>
   EUROASM PUSH, DISPLAYSTM=ON ; <abbr>Nejprve ulož všechny volby EUROASM pomocí PUSH.</abbr>
   MyMacro Operand1, Operand2  ; <abbr>&quot;MyMacro&quot; zatím nebylo deklarováno jako makro, takže se považuje za návěstí (label).</abbr>
<span class="inner">D1010 **** DISPLAYSTM "MyMacro Operand1, Operand2"
D1020 label="MyMacro"
D1040 unknown operation="Operand1"
D1050 ordinal operand number=1,value="Operand2"
</span>   EUROASM POP                 ; <abbr>Obnov volby EUROASM.</abbr>
<span class="inner">D1010 **** DISPLAYSTM "EUROASM POP"
D1040 pseudo operation="EUROASM"
D1050 ordinal operand number=1,value="POP"
</span>                              ; <abbr>Pole instrukcí nejsou nadále zobrazovány.</abbr></pre>

<p>Podrobnosti <strong>zakódování strojových instrukcí</strong> si lze vyžádat volbou
<code>EUROASM DISPLAYENC=ON</code>, která pod strojové instrukce vkládá komentářový řádek
se seznamem použitých <a href="#InstructionModifiers">modifikátorů</a>.</p><pre>
   EUROASM PUSH, DISPLAYENC=ON ; <abbr>Nejprve ulož všechny volby EUROASM pomocí PUSH.</abbr>
   SHRD [RDI+64],RDX,2
<span class="inner">D1080 Emitted size=6,DATA=QWORD,DISP=BYTE,SCALE=SMART,ADDR=ABS,IMM=BYTE.
</span>   VMOVNTDQA XMM17,[RBP+40h]
<span class="inner">D1080 Emitted size=7,PREFIX=EVEX,DATA=OWORD,OPER=0,DISP=BYTE,SCALE=SMART,ADDR=ABS.
</span>   EUROASM POP         ; <abbr>Obnov volby EUROASM. Detaily nadále nebudou zobrazovány.</abbr></pre>
<p>Všechny <strong>konfigurační volby</strong> nastavitelné v pseudoinstrukcích <a href="#EUROASM">EUROASM</a>
a <a href="#PROGRAM">PROGRAM</a> lze získat a testovat pomocí
<a href="#SystemVariables">systémových %^proměnných</a>:</p>
<pre>
   %IF %^NOWARN[2101]
     %ERROR Neměli byste potlačovat varování W2101. Raději přesuňte nepoužité symboly do inkludovaných souborů.
   %ENDIF</pre>
<p>Nejmocnějším nástrojem pro asm-time ladění je pseudoinstrukce
<a href="#pcDISPLAY">%DISPLAY</a>, která <strong>zobrazuje interní &euro;ASM objekty v čase překladu</strong>
a pomáhá tak zjistit, proč &euro;ASM nefunguje podle očekávání.</p>
<p>Viz testy <a class="EXT" href="../eatests/t2907.htm">t2901..t2917</a>
jako příklady.</p>

<h3 id="EaFnLink" title="Linker"><a href="#EaFn">&uarr; Linker</a></h3>
<h4><a href="#EaFnLinkStatic">Statické linkování &darr;</a></h4>
<h4><a href="#EaFnLinkDynamic">Dynamické linování &darr;</a></h4>
<p><dfn>Linkování</dfn> je v terminologii výpočetní techniky proces, kdy separátně přeložené
moduly jsou spojovány, interakce mezi globálními symboly vyřešeny, kód a data zkombinovány
a přeformátovány do cílového souboru.
Viz dokumentaci <a class="EXTL" href="links.htm#Linkers">[Linkers]</a> pro podrobnější informace.</p>
<p>Na rozdíl od jných linkerů nevytváří EuroAssembler pouze spustitelné soubory,
ale také relinkovatelné soubory ve formátech ELF, COFF a OMF, případně jejich knihovny LIBCOF a LIBOMF
(viz <a href="#EaFnConvert">Objektové konvertory</a> a tabulky podporovaných
<a class="EXT" href="../eatests/index.htm#LinkerCombinations">kombinací</a>).</p>
<h6>Linkování přichází v EuroAssembleru ke slovu, když je pseudoinstrukce
ENDPROGRAM zpracovávána v posledním průchodu.</h6>
<p>Linkování je řízeno pseudoinstrukcí <a href="#LINK">LINK</a>
následovanou jmény vstupních modulů.
Přijatelné formáty vstupních souborů jsou dvojího druhu:
<ol><li><strong>linkovatelné</strong> formáty pro statické linkování jsou
<strong>ELF, COFF, OMF, LIBCOF, LIBOMF, RSRC</strong>.</li>
<li><strong>importovatelné</strong> formáty pro dynamické linkování jsou
<strong>DLL, LIBCOF, LIBOMF</strong>.</li>
</ol>
<table class="SMALLER"><caption>Formáty souborů akceptované příkazem LINK</caption>
<tr><th>CPU<br/>mód</th><th>Šířka<br/>programu</th><th>Výstupní<br/>spustitelný</th>
<th>Výstupní<br/>linkovatelný</th>
<th>Vstupní<br/>linkovatelný</th><th>Vstupní<br/>importovatelný</th></tr>
<tr><th>Real</th><th>16</th><th>BIN, BOOT, COM, MZ</th><th>OMF, LIBOMF, COFF, LIBCOF</th><td>OMF, LIBOMF, COFF, LIBCOF</td><td>-</td></tr>
<tr><th>Real</th><th>32</th><th>BIN, BOOT, COM, MZ</th><th>OMF, LIBOMF, COFF, LIBCOF</th><td>OMF, LIBOMF, COFF, LIBCOF</td><td>-</td></tr>
<tr><th>Prot</th><th>32</th><th>ELFX, PE, DLL</th><th>ELF, COFF, LIBCOF, OMF, LIBOMF</th><td>ELF, COFF, LIBCOF, RSRC, OMF, LIBOMF</td><td>ELF, COFF, LIBCOF, DLL, OMF, LIBOMF</td></tr>
<tr><th>Prot</th><th>64</th><th>ELFX, PE, DLL</th><th>ELF, COFF, LIBCOF</th><td>ELF, COFF, LIBCOF, RSRC</td><td>ELF, COFF, LIBCOF, DLL, OMF, LIBOMF</td></tr>
</table>
<p>Viz také tabulky přípustných <a class="EXT" href="../eatests/#LinkerCombinations">kombinací</a>.
<br/>Všimněte si, že se formát OMF nemůže linkovat do 64bitových programů.</p>
<p>Formát linkovaného souboru se rozpoznává podle svého obsahu, nikoli podle souborové přípony.
Každý linkovaný modul se nejprve načte a převede do interního formátu
(<a class="EXT" href="../easource/pgm.htm#PGM">PGM</a>) před vlastním linkováním.</p>
<p>Není důležité, kde v bloku PROGRAM..ENDPROGRAM jsou pseudoinstrukce LINK umístěny;
ony pouze sbírají jména linkovaných modulů a jejich linkování je odloženo na konec programu.</p>

<h4 id="EaFnLinkStatic"><a href="#EaFnLink">&uarr; Statické linkování</a></h4>
<p>Kód a data linkovaných objektových souborů ve formátech ELF, COFF nebo OMF
budou zkombinovány a přidány ke kódu a datům hlavního programu
(tj. do toho, ke kterému je linkováno). Hlavní program může být také prázdný.
Linker zároveň vyřeší vzájemné odkazy mezi PUBLIC a EXTERN symboly
všech linkovaných modulů.</p>

<p>Na rozdíl od jiných linkerů neočekává EuroAssembler jména linkovaných modulů
jako argumenty příkazového řádku.
I když chceme využít EuroAssembler jen jako pouhý linker, musíme vytvořit
linkovací skript, což je v podstatě &euro;ASM zdrojový program.
Požadovaný výstupní formát a šířka bude specifikován jako argument pseudoinstrukce PROGRAM:</p>
<pre>MyExeFile PROGRAM FORMAT=PE, WIDTH=32, ListMap=Yes, ListGlobals=Yes
              LINK MyCoff.obj, PascalOmf.obj, Win32.lib
          ENDPROGRAM MyExeFile</pre>
<p>Uložení tohoto skriptu jako <q>MyScript.asm</q> a vykonání
<code>euroasm MyScript.asm</code> vyprodukuje program pro Windows <q>MyExeFile.exe</q>
a listing <q>MyScript.asm.lst</q> s mapou linkovaných sekcí a globálních symbolů.</p>

<p>Vedle samostatných objektových modulů (ELF, OMF, COFF) mohou být kód a data linkovány
také z objektových knihoven ve formátech LIBCOF a LIBOMF.</p>
<p>Je-li hlavní výstupní program <strong>spustitelný</strong>, &euro;ASM linkuje pouze ty moduly z knihovny,
které jsou aspoň jednou zmíněny jinými moduly (tzv.  <dfn>chytré linkování</dfn>).
Pomáhá to udržovat malou velikost linkovaného souboru vyloučením mrtvého kódu.</p>
<blockquote>Pokud bychom přesto potřebovali zkombinovat neodkazované knihovní procedury
do našeho spustitelného programu, museli bychom explicitně deklarovat
jejich nereferencovaná jména v hlavním programu jako GLOBAL.</blockquote>
<p>Chytré linkování se neuplatňuje při vytváření <strong>linkovatelného</strong> výstupního formátu,
například pokud tvoříme knihovnu LIBCOF z jiných knihoven a samostatných objektových modulů.
V tom případě všechny (referencované i nereferencované) moduly budou do výstupního souboru přilinkovány.</p>
<blockquote><p>Dobrým důvodem, proč rozdělovat velký projekt na menší, separátně překládané moduly,
je <b>rychlejší sestavení</b>.</p>
<p>Jakmile projekt roste a velikost jeho zdrojového kódu se zdvojnásobí,
počet symbolů v něm se pravděpodobně také zdvojnásobí.
Každý symbol musí být porovnán s polem jiných již definovaných symbolů kvůli vyloučení duplicit,
počet porovnávání se tedy zečtyřnásobí. Počet kontrol, a tedy spotřebovaný čas
roste téměř kvadraticky s velikostí zdroje.</p>
<p>Během vývoje jsme zpravidla soustředěni na jednu část (modul) projektu,
takže ostatní nezměněné moduly se nemusejí rekompilovat během každého vývojového cyklu.
Viz také <a href="#EaFnMake">Makefile manažer</a>).</p></blockquote>
<p><strong>Rekapitulace:</strong> Chcete-li staticky linkovat vlastní funkci (proceduru),
deklarujte ji jako <code>PUBLIC function</code>
(nebo zakončete její jméno při definici dvěma dvojtečkami <code>function:: PROC</code>)
a přeložte funkci do objektového nebo knihovního formátu.
<br/>Pak přeložte hlavní program, kde byla linkovaná funkce deklarována jako <code>EXTERN function</code>
(anebo její jméno zakončeno dvěma dvojtečkami)
a přidejte do programu pseudoinstrukci <code>LINK module.obj</code>.
V hlavním programu pak lze <code>CALL function::</code>
jako by byla přeložena v jeho vlastním těle.
<br/>Totéž lze aplikovat na funkce z knihoven třetí strany.
Je ovšem třeba respektovat její zveřejněné jméno, volací konvenci, počet, pořadí a typy argumentů.</p>

<h4 id="EaFnLinkDynamic"><a href="#EaFnLink">&uarr; Dynamické linkování</a></h4>
<p>Tato verze EuroAssembleru nepodporuje dynamické linkování Linuxových dynamických knihoven (DSO).
Povel <code>LINK DSO.so</code> se pokusí přilinkovat soubor pouze staticky.
Tato kapitola se zabývá pouze dynamickými knihovnami MS-Windows.</p>
<p>Kód a data dynamicky linkovaných funkcí není kopírován do cílového spustitelného souboru (image),
zůstávají v dynamické knihovněě (DLL), která musí být dostupná na počítači, kde program běží.
Jakmile náš program zavolá funkci z DLL, ve skutečnosti vykonává zástupný kód
(<dfn>thunk</dfn>) reprezentovaný voláním instrukce proxy-skoku (<dfn>stub</dfn>).
<br/>&euro;ASM generuje <em>stuby</em> ve speciální importové sekci [.idata]
ve formě nepřímého absolutního blízkého skoku (JMPN).
Každý takový skok je 7&nbsp;bajtů dlouhý (<code>0xFF2425[00000000]</code>)
a používá ukazatel do Import Address Table (<dfn>IAT</dfn>) jako svůj nepřímý 32bitový cíl.
Virtuální adresa ukazatele <code>[00000000]</code> je vyřešena linkerem,
ale vlastní 32 nebo 64bitová virtuální adresa knihovní funkce (ukazované vyřešeným dvojslovem)
bude upravena později, zaváděčem v čase bind-time, kdy naše aplikace startuje.</p>
<p>Zaváděč implementovaný v jádře Windows, potřebuje dvě informace
ke spojení knihovní funkce a k úpravě její adresy v IAT:</p>
<p><b>1)</b> Jméno dynamicky linkovaného <strong>symbolu</strong> (jméno funkce)
nebo její pořadové číslo v tabulce exportovaných symbolů</p>
<blockquote>Volání podle těchto čísel (ordinal numbers) není v &euro;ASM podporováno.</blockquote>
<p><b>2)</b> Název <strong>knihovny</strong> exportující daný symbol (bez cesty).</p>
<blockquote>Cesta k souboru knihovny bude stanovena zaváděčem.
Pořadí, v jakém Windows prohledává cesty ke knihovně, je vysvětleno ve
<a class="EXTL" href="links.htm#WinDllSearchOrder">[WinDllSearchOrder]</a>.</blockquote>
<p>Program, který chce volat symbol (importovanou funkci) z DLL, by měl deklarovat symbol pomocí IMPORT.
Může být deklarován také jako GLOBAL, buď explicitně nebo implicitně
(<code> CALL ImportedSymbol::</code>), avšak &euro;ASM považuje takový globální symbol za EXTERN (staticky linkovaný)
a nikoli IMPORT (dynamicky linkovaný) a postěžuje si, že nebyl nalezen odpovídající PUBLIC symbol.
<br/>Je několik metod, jako říci EuroAssembleru, že symbol má být linkován dynamicky:</p>
<ul><li><p>Použijte explicitní <strong>importní deklaraci</strong>, například
<code> IMPORT ImportedSymbol1, ImportedSymbol2, LIB="dynamic.dll"</code>.
Dynamická knihovna by měla být specifikována bez cesty a může být vynechána,
pokud je to základní knihovna jádra Windows <q>kernel32.dll</q>.</p>
<blockquote>Přítomnost <q>dynamic.dll</q> není zjišťována během linkování,
program se sestaví bez chyb dokonce i když takový soubor na našem počítači vůbec neexistuje.
Avšak Windows si začne stěžovat, že spouštěný program nemůže nalézt
knihovnu <q>dynamic.dll</q> anebo že ImportedSymbol nebyl exportován knihovnou <q>dynamic.dll</q>.</blockquote>
</li><li><p>Přilinkujte k programu <strong>importní knihovnu</strong>, pomocí <code>LINK "winapi.lib"</code>.
Takový soubor může být ve formátu LIBOMF nebo LIBCOF
a obvykle obsahuje pouze deklarace jmen exportovaných symbolů a jejich knihovních souborů
(<dfn id="PureImportLib" title="Import library">čistě importní knihovna</dfn>).
&euro;ASM ztotožní nedefinované globální symboly s názvy z importní knihovny a redeklaruje je jako IMPORT.</p>
<blockquote>Některé starší knihovní programy, jako <a class="EXTL" href="../eadoc/links.htm#ALIB">[ALIB]</a>,
produkují importní knihovny ve <em>dlouhém formátu</em>, který obsahuje přídavný kód skoků na <em>thunk</em>.
&euro;ASM dlouhý formát akceptuje, avšak ignoruje tento nadbytečný obsah.
<br/>Některé kompilátory zatemňují (mangle) exportovaná jména dekorací pomocí podtržítek
a dalším obsahem prozrazujícím volací konvenci a počet operandů.
&euro;ASM to nepodporuje, importované funkce musejí být volány identickým jménem,
které je exportováno.</blockquote>
<p>Vzorový projekt <a class="EXT" href="../prowin32/dll2lib.htm">dll2lib.htm</a> ukazuje, jak vytvořit
exportní knihovnu z dynamických knihoven DLL systému MS-Windows.</p>
</li>
<li>Přilinkujte <strong>dynamickou knihovnu</strong> abyste zjistili, co exportuje.
Knihovna by měla být určena s kompletní cestou a musí existovat v link-time, např.
<pre> %SystemRoot %SETE SystemRoot
 LINK "%SystemRoot\system32\USER32.DLL"</pre>
<p>Linkování dynamické knihovny nekopíruje její kód a data do našeho programu,
pouze detekuje jména exportovaných funkcí.
Instrukce je ekvivalentní deklaraci <code> IMPORT *, LIB="USER32.DLL"</code>
nebo přilinkování importní knihovny <code>LINK "USER32.lib"</code>.</p>
<li>Toto <strong>načtení knihovny</strong> může být odloženo z load-time na run-time,
použitím funkce Windows API <code>LoadLibrary("library.dll"); GetProcAddress(SymbolName);</code>
předtím, než bude použito SymbolName.</li></ul>

<p><strong>Rekapitulace:</strong> Chcete-li dynamicky linkovat svou vlastní funkci
(proceduru) do jiného programu, deklarujte ji jako <code>EXPORT function</code> a přeložte funkci
do formátu DLL (<code>mylib PROGRAM FORMAT=DLL</code>). Nezapomeňte distrubuovat <q>mylib.dll</q>
spolu s vašimi programy.
<br/>Pak přeložte hlavní spustitelný program a v něm deklarujte linkovanou funkci pomocí
<code>IMPORT function, LIB=mylib.dll</code>.
Hlavní program ji pak může volat pomocí  <code>CALL function</code>.
<br/>Častěji asi budete potřebovat volat funkce z dynamické knihovny třetí strany,
což je případ <a class="EXTL" href="../eadoc/links.htm#WindowsAPI">
MS-Windows API</a>. Mohli byste explicitně vyjmenovat každou funkci WinAPI
pseudoinstrukcemi jako <code>IMPORT function1,function2,LIB=user32.dll</code>,
ale pohodlnější řešení je použít importovou knihovnu, která deklaruje všechna jména funkcí
touto dynamickou knihovnou exportovaných. Pak nebude potřeba přidávat novou importní deklaraci pokaždé,
jakmile bude během vývoje vašeho programu přidána nová funkce z WinAPI.
Prostě volejte novou funkci s dvojitou dvojtečkou (<code>CALL NováFunkce::</code>)
a pokud se jmého NováFunkce objeví v importní knihovně, funkce bude importována.
Můžete rovněž chtít používat makra
<a class="EXT" href="../maclib/winapi.htm#WinAPI">WinAPI (32bit)</a> nebo
<a class="EXT" href="../maclib/winabi.htm#WinABI">WinABI (64bit)</a>
která se postarají o deklarace IMPORT a o automatický výběr mezi variantami  ANSI a WIDE.</p>

<h3 id="EaFnLib" title="Librarian"><a href="#EaFn">&uarr; Knihovník</a></h3>
<p>EuroAssembler umí vytvářet knihovny z předem přeložených objektových modulů
(souborů ve formátu ELF, OMF nebo COFF). A pokud knihovní program také obsahuje nějaký kód,
bude přilinkován do knihovny jako její první člen.
<pre>
Library PROGRAM FORMAT=LIBOMF  ; nebo FORMAT=LIBCOF
ObjModule1:: PROC ; Jeden z objektových modulů může být také definován zde.
                  ; Zdojový kód modulu ObjModule1.
             ENDP ObjModule1::
             LINK "ObjModule2.obj", "ObjModule3.obj" ; Další moduly ELF, OMF nebo COFF.
        ENDPROGRAM Library
</pre>
<p>Pokud linkované moduly obsahují importní informace, budou také zkopírovány do výstupní knihovny.
Čistě importní knihovny obsahují pouze importní deklarace. Tyto mohou být explicitně specifikovány
jako IMPORT, nebo načteny z existující dynamické knihovny DLL, nebo linkovány z jiných importních knihoven.
Následující příklad využívá postupně všechny tři metody:</p><pre>
ImpLibrary PROGRAM FORMAT=LIBOMF ; nebo FORMAT=LIBCOF
             IMPORT Symbol1, Symbol2, LIB="DynamicLibrary1.dll" ; <b>Explicitní deklarace</b>.
             LINK "C:\MyDLLs\DynamicLibrary2.dll"               ; <b>Automatická detekce exportů</b> z DLL.
             LINK "OtherImportLibrary.lib"                      ; <b>Reimport z jiné knihovny</b>.
           ENDPROGRAM ImpLibrary
</pre>
<p>Příklady knihoven vytvořených ze tří separátně přeložených modulů jsou v &euro;ASM testech:
<br/><a class="EXT" href="../eatests/t8552.htm">t8552</a> (objektová knihovna LIBOMF pro 16bitový Dos),
<br/><a class="EXT" href="../eatests/t9113.htm">t9113</a> (objektová knihovna LIBCOF pro 32bitová Windows),
<br/><a class="EXT" href="../eatests/t9164.htm">t9164</a> (objektová knihovna LIBCOF pro 64bitová Windows),
<br/><a class="EXT" href="../eatests/t8675.htm">t8675</a> (importní knihovna LIBOMF pro Windows),
<br/><a class="EXT" href="../eatests/t9225.htm">t9225</a> (importní knihovna LIBCOF pro Windows),
</p>

<h3 id="EaFnConvert" title="Object convertor"><a href="#EaFn">&uarr; Objektový konvertor</a></h3>
<p>Poptávka po objektovém konvertoru bude asi slabá, neboť EuroAssembler může přímo linkovat všechny hlavní
objektové formáty OMF, ELF a COFF.
Příklady:</p><pre>
OMFobject PROGRAM FORMAT=OMF ; Konvertuj objekt COFF na objekt OMF.
            LINK "COFFobject.obj"
          ENDPROGRAM OMFobject
</pre><pre>
COFFobject PROGRAM FORMAT=COFF; Konvertuj objekt OMF na objekt COFF.
             LINK "OMFobject.obj"
           ENDPROGRAM COFFobject
</pre><pre>
ELFobject PROGRAM FORMAT=ELF; Konvertuj objekt COFF na objekt ELF.
             LINK "COFFobject.obj"
           ENDPROGRAM ELFobject
</pre><pre>
COFFobject PROGRAM FORMAT=COFF; Konvertuj objekt ELF na objekt COFF.
             LINK "ELFobject.o"
           ENDPROGRAM COFFobject
</pre><pre>
OMFlibrary PROGRAM FORMAT=LIBOMF ; Konvertuj knihovnu LIBCOF na knihovnu LIBOMF.
             LINK "COFFlibrary.lib"
           ENDPROGRAM OMFlibrary
</pre><pre>
COFFlibrary PROGRAM FORMAT=LIBCOF ; Konvertuj knihovnu LIBOMF na knihovnu LIBCOF.
              LINK "OMFlibrary.lib"
            ENDPROGRAM COFFlibrary
</pre>

<h3 id="EaFnMake" title="Makefile"><a href="#EaFn">&uarr; Makefile manažer</a></h3>
<p>Atributový operátor <a href="#FILETIMEha">FILETIME#</a> načítá čas poslední modifikace souboru,
což se dá využít k detekci, zda cílový soubor potřebuje přeložit nebo ne.
Stačí porovnat čas cílového souboru s časem všech zdrojových souborů, na kterých cíl záleží.
Pokud cílový soubor dosud neexistoval, jeho FILETIME# vrací 0, což je totéž, jako by byl velmi starý,
takže jeho vytvoření bude i tak vyžadováno.</p>
<pre>       ; Rekompiluj "source.asm" pouze pokud "target.exe" neexistuje nebo je starší než jeho zdrojové soubory.
    %IF FILETIME# "target.exe" &gt; FILETIME# "source.asm" &amp;&amp; FILETIME# "target.exe" &gt; FILETIME# "included2source.inc"
       %ERROR "target.exe" je čerstvý, není třeba ho znovu překládat.
    %ELSE
       target PROGRAM FORMAT=PE
               INCLUDE "source.asm"
              ENDPROGRAM target
    %ENDIF
</pre>
<hr/>

<h3 id="EaFnOptimize"><a href="#EaFn">&uarr; Optimalizace</a></h3>
<p>Počítačové programy často píšeme v asembleru proto, aby byly
<strong>rychlé</strong> a <strong>malé</strong>. To ale nejsou jediná kritéria,
jak se dá program optimalizovat:</p>
<h4><a href="#OptBySize">Optimalizace na velikost programu &darr;</a></h4>
<h4><a href="#OptBySpeed">Optimalizace na rychlost programu &darr;</a></h4>
<h4><a href="#OptByAssemblySpeed">Optimalizace na rychlost překladu &darr;</a></h4>
<h4><a href="#OptByWriteability">Optimalizace na zapisovatelnost programu &darr;</a></h4>
<h4><a href="#OptByReadability">Optimalizace na čitelnost programu &darr;</a></h4>
<p>Viz také optimalizační <a class="EXTL" href="links.htm#Tutorials">tutoriály</a>.</p>
<p>Podívejme se, jak může EuroAssembler pomoci s optimalizací.</p>

<h4 id="OptBySize"><a href="#EaFnOptimize">&uarr; Optimalizace na velikost programu</a></h4>
<p>Ve výchozím stavu vybírá &euro;ASM nejkratší možné zakódování strojových instrukcí.
Na druhé straně ale respektuje mnemoniku zvolenou programátorem, což nemusí být vždy
ta nejkratší varianta. Za zapamatování stojí několik pravidel:</p>
<samp>
|0000:B80000     | MOV AX,0
|0003:29C0       | SUB AX,AX ; <abbr>Použití SUB nebo XOR pro nulování registru je kratší. Vedlejší efekt: změní to flagy.</abbr>
|0005:           |
|0005:89D8       | MOV AX,BX
|0007:93         | XCHG AX,BX ; <abbr>XCHG je kratší než MOV. Vedlejší efekt: druhý registr je také změněn.</abbr>
|0008:           |
|0008:           |Label:
|0008:8D06[0800] | LEA AX,[Label]
|000C:B8[0800]   | MOV AX,Label  ; <abbr>Zavedení ofsetu do registru (MOV) je kratší nez zavedení jeho adresy (LEA).</abbr>
|000F:           |
|000F:5053       | PUSH AX,BX
|0011:60         | PUSHAW    ; <abbr>PUSH/POP všech 8 registrů najednou je kratší než individuální PUSH/POP.</abbr>
|0012:           |
|0012:050100     | ADD AX,1
|0015:40         | INC AX   ; <abbr>Increment/decrement je kratší než add/subtract 1.</abbr>
|0016:           |
|0016:           |LoopStart:
|0016:49         | DEC CX
|0017:75FD       | JNZ LoopStart:
|0019:E2FB       | LOOP LoopStart: ; LOOP, JCXZ jsou kratší nez separátní test a skok.</samp>

<p>Programy aspirující do kategorie těch nejkratších by měly mít <code>PROGRAM FORMAT=COM</code> a <code>EUROASM AUTOALIGN=OFF</code>.
Mohou končit prostým <code>RET</code> namísto volání DOS funkce TERMINATE PROCESS,
protože návratová adresa na zásobníku programů COM je inicializována na 0
a tam na začátku bloku PSP leží přerušení ukončující proces.</p>
<pre>Hello PROGRAM FORMAT=COM
       MOV DX,=B "Hello world!$"
       MOV AH,9
       INT 21h
       RET
      ENDPROGRAM Hello
</pre>
<p>Pro další inspiraci se podívejte na
<a class="EXTL" href="../eadoc/links.htm#Golfing_tips">[Golfing_tips]</a>,
<br/><a class="EXTW" href="http://www.hugi.scene.org/compo/compoold.htm">
Hugi Size Coding Competition Series</a>,
<br><a class="EXTW" href="http://sebastianmihai.com/asmtris.html">
Graphical Tetris</a> in 1986 bytes by Sebastian Mihai,
<br><a class="EXTW" href="http://mashable.com/2015/01/30/play-it-better-tiny-chess-game/">
BootChess</a> play in 487 bytes by Oliver Poudade.
</p>
<p>Programy pro Windows vytvořené v &euro;ASM budou kratší,
pokud bude volba <code>PROGRAM ICONFILE=</code> explicitně prázdná
a nebude přilinkován žádný soubor <em>resources</em>.
V tom případě nebude sekce [.rsrc] v PE souboru vůbec přítomna.
Můžete také experimentovat s použitím programových voleb jako
<code>PROGRAM FILEALIGN=</code>.</p>

<h4 id="OptBySpeed"><a href="#EaFnOptimize">&uarr; Optimalizace na rychlost programu</a></h4>
<p>Psaní rychlých programů je plně v rukou programátora, EuroAssembler zde příliš nepomůže,
neprovádí žádnou optimalizaci za vašimi zády, jako to dělají kompilátory vyšších jazyků.
Možná budete chtít nastavit <code>EUROASM AUTOALIGN=ON</code>, aby se všechna data zarovnala kvůli rychlému přístupu.
Naprostá <a href="#InstructionModifiers">kontrola zakódování instrukce</a> pomocí modifikátorů
dovoluje v &euro;ASM vybrat variantu s přesnou velikostí kódu, což může být rychlejší
než verze s minimální velikostí doplněnou pomocí NOP. &euro;ASM podporuje
<a href="#InsEnhNOP">optimalizované instrukce NOP</a> pro snadné ruční zarovnávání.</p>
<p>Existuje více triků, jak urychlit program: rozbalení smyček, paralelizace, vyvarování se zbytečných přístupů do paměti
a v neposlední řadě výběr nejrychlejšího algoritmu.
Výkonnost taky závisí na modelu CPU a jeho generaci.
Dobrým průvodcem je manuál <a class="EXTL" href="links.htm#SoftwareOptimisation">[SoftwareOptimisation]</a>
od Agnera Foga.</p>
<p>Výkonnost programu se obvykle směňuje s jeho velikostí, například mnoho triků
zmenšující velikost programu uvedených <a href="#OptBySize">nahoře</a> vede k jeho pomalejšímu vykonávání.
K optimalizaci na rychlost se hodí hlavně kritické části programu, které budou vykonávány mnohokrát.</p>

<h4 id="OptByAssemblySpeed"><a href="#EaFnOptimize">&uarr; Optimalizace na rychlost překladu</a></h4>
<p>EuroAssembler není optimalizován na rychlost překladu, nicméně jeho trvání obvykle není problém.
Nejvíce záleží na počtu průchodů, který je řízen EuroAssemblerem samotným a programátor
jej nemůže přímo ovlivňovat.
Nejméně dva průchody jsou požadovány pokaždé. Jejich počet se zvyšuje, pokud program obsahuje dopředné reference,
smyčky v asm-time, makroinstrukce.</p>
<p>Když &euro;ASM překládá dopředný skok, nejprve předpokládá krátkou vzdálenost (DIST=SHORT)
k dosud nedefinovanému cíli, a rezervuje prostor pro dvoubajtový operační kód.
Pokud víme při psaní programu, že cíl bude dále než 127 bajtů, mohli bychom explicitně určit
<code>DIST=NEAR</code>, což by mohlo ušetřit jeden průchod. Ten by ale byl uspořen jen pokud by
byly specifikovány vzdálenosti <b>všech</b> podobných skoků, což obvykle nestojí za námahu.</p>
<p>Chcete-li vědět, proč &euro;ASM potřebuje tolik průchodů, vložte direktivu
<code>%DISPLAY UnfixedSymbols</code> před <code>ENDPROGRAM</code>, abyste zjistili
ofsety kterých symbolů oscilují mezi průchody asembleru.</p>
<p>Čas sestavení velkých projektů může být významně snížen rozdělením kódu na menší, samostatně překládané moduly,
které pak budou ve finále spojeny (<a href="#EaFnLinkStatic">slinkovány</a>) dohromady.
Viz například zdrojový kód <a class="EXT" href="../easource/euroasm.htm">euroasm.htm</a>.</p>

<h4 id="OptByWriteability"><a href="#EaFnOptimize">&uarr; Optimalizace na zapisovatelnost programu</a></h4>
<p>EuroAssembler zavádí nové pohodlné rysy ne příliš obvyklé mezi jinými asemblery:
<ul><li>Jména souborů určených k překladu, k inkludování a k linkování mohou být specifikována
jen částečně, s použitím žolíkových znaků <kbd>* ?</kbd>, například <code> INCLUDE "Win*.inc"</code>.</li>
<li>Nejste-li si jisti, zda určitý soubor nebyl již jednou inkludován,
použijte <code>INCLUDE1 file</code> místo <code>INCLUDE file</code> a &euro;ASM se o to postará.</li>
<li>Můžete používat symboly a struktury dříve než byly definovány pomocí <code>EQU</code> nebo <code>STRUC</code>.</li>
<li>Můžete definovat a referovat datové položky v jedné instrukci s použitím literálů, jako třeba <code>FLD ST0,[=Q 1.234]</code>.</li>
<li>Vzdálenost cíle instrukcí předání zpracování JrCXZ, LOOPcc, Jcc není omezena na 127 bajtů.
&euro;ASM v případě potřeby kóduje <a href="#InsEnhLOOPNear">NEAR nebo FAR proxy-skoky</a>.
Není to sice doporučeníhodná technika pokud jde o rychlost programu,
ale nemuset se starat o vzdálenost cíle umožňuje sestavovat programové prototypy rychleji.</li>
<li>Interakce s operačním systémem, zejména v 64bitovém módu, je v asembleru pracná.
Programátor musí předávat parametry zásobníkem nebo v registrech s respektováním
volacích konvencí. Některé asemblery vyvinuly speciální direktivy (INVOKE, PROTO atd.),
které obalují volání OS. EuroAssembler odkládá podobné detaily do
<a class="EXT" href="../maclib/#ApiMaclibs">maker</a>. Volací konvence nejsou do <q>euroasm.exe</q> pevně vestavěny
a mohou tak být operativně přizpůsobeny modifikací maker API.</li>
</ul>

<h4 id="OptByReadability"><a href="#EaFnOptimize">&uarr; Optimalizace na čitelnost</a></h4>
<p>Dobře okomentovaný program je snadné číst a udržovat.
EuroAssembler dovoluje formátování HTML poznámek, takže zdrojový kód v něm psaných programů může být přímo publikován
na webových stránkách a každá jeho část může být hned dokumentována
bohatě formátovanými poznámkami, tabulkami, obrázky, hypertextovými odkazy.</p>
<p>Velikost a jazyk identifikátorů není omezován, takže mohou být samopopisné.
Pokud není angličtina váš rodný jazyk, je dobrým nápadem preferovat symboly
s neanglickými názvy, jako <code>Drucken</code> místo <code>Print</code>,
<code>файл</code> místo <code>file</code> apod.
Pomůže to čtenáři vašeho programu rozeznat vestavěná rezervovaná slova od identifikátorů
vytvořených autorem programu.</p>
<p>Některé prvky jazyka EuroAssembler používají dekorátory pomáhajícími lidskému čtenáři
rozlišit kategorii dekorovaných identifikátorů:</p><ul>
<li>jména segmentů jsou vždy v hranatých závorkách <kbd>[]</kbd>,</li>
<li>návěstí a další symboly lze rozpoznat podle zakončující dvojtečky <kbd>:</kbd>,</li>
<li><a href="#FpSpecValues">speciálním floating-point konstantám</a> je předřazen znak <kbd>#</kbd>.</li>
<li><a href="#Attributes">za operátory atributů</a> je připojen znak <kbd>#</kbd>.</li>
<li>preprocesním %proměnným a pseudoinstrukcím předchází znak procenta <kbd>%</kbd>.</li>
</ul>

<h3 id="EaFnBegin"><a href="#EaFn">&uarr; Kde začít</a></h3>
<blockquote>Pokud jste dočetli tento manuál až sem a chcete vyzkoušet EuroAssembler,
<a class="EXTW" href="https://euroassembler.eu/download/">
stáhněte</a> jeho poslední verzi, vytiskněte si
<a class="EXT" href="../eadoc/euroasm.png">papírový tahák</a>,
projděte si <a class="EXT" href="../eadoc/tut_cze.htm">tutoriál</a>
a prohlédněte si <a class="EXT" href="../objlib/">vzorové projekty</a>.
Mnoho štěstí!</blockquote>

<!--TAILMENU-->
<!--Contents below the marker {!==TAILMENU==} was generated by "generate.php".-->
<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Zpět na začátek&#x25B2;</a>
</body></html>
