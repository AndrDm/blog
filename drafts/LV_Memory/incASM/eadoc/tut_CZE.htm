<!doctype html><html lang='cs'><head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes'>
<meta name='robots' content='ALL,FOLLOW'/>
<meta name='description' content='&euro;ASM file tut_cze.htm'/>
<meta name='version' content='20250318'/>
<meta name='author' content='Pavel vitsoft Šrubař'/>
<link rel='stylesheet' href='../euroasm.css' type='text/css'/>
<link rel='shortcut icon' href='../favicon.ico'/>
<title>tut_cze.htm manual</title>
</head>
<body class='EADOC' id='top'><div class='HEADMENU'><table>
<tr><td rowspan='2' title='&euro;ASM - assembler and linker'><img src='../favicon.ico' alt='EuroAssembler' />
<td><a href='../index.htm' title='Alphabetical index of all &euro;ASM elements, directives and instructions'>Index</a></td>
<td><a href='../eadoc/' class='EADOC' title='Documentation of EuroAssembler'>Manual</a></td>
<td><a href='https://euroassembler.eu/download/' title='History &amp; download of the latest and previous versions'>Download</a></td>
<td><a href='../easource/' class='EASOURCE' title='Source files of EuroAssembler itself'>Source</a></td>
<td><a href='../maclib/' class='MACLIB' title='Macro libraries shipped with &euro;ASM'>Macros</a></td>
<td rowspan='2' title='Find the searched token in any text file on this site'>
<form method='post' action='../search.php' enctype='multipart/form-data' accept-charset='utf-8'>
<input type='text' id='q' placeholder='Searched word(s)' name='q' value=''/>
<br/><label title='Check the box to find the expression even if it is surrounded by other letters | digits.'>
<input type='checkbox' name='EW'/><small>Embedded word</small></label>
<br/><label title='Check the box for case-insensitive search.'>
<input type='checkbox' name='CI'/><small>Case ins.</small></label>
<input type='submit' title='Search for the specified word|expression in all site files.' name='find' value='Search'/>
</form></td></tr><tr>
<td><a href='../sitemap.htm' title='List of directories and files on this site'>Sitemap</a></td>
<td><a href='../eadoc/links.htm' class='EADOC' title='References and external links to resources used in EuroAssembler developement'>Links</a></td>
<td><a href='https://euroassembler.eu/forum/' title='Discussion forum concerning EuroAssembler'>Forum</a></td>
<td><a href='../eatests/' class='EATESTS' title='Program snippets for testing the function of &euro;ASM'>Tests</a></td>
<td><a href='../objlib/' class='OBJLIB' title='Skeletons and sample objects and projects shipped with &euro;ASM'>Projects</a></td>
</tr></table></div>
<!--Contents above the marker {!==/HEADMENU==} was generated by "generate.php".-->
<!--/HEADMENU-->
<h1>EuroAssembler tutoriál</h1><br class="CLEAR"/>
<h3><a href="#Introduction">Úvod</a></h3>
<h3><a class="EXT" href="tut_eng.htm">English version of this tutorial</a></h3>
<h3><a href="#BasicKnowledge">Předpokládané znalosti &darr;</a></h3>
<h3><a href="#HowComputerWorks">Jak počítač pracuje &darr;</a></h3>
<h4><a href="#Modes">Procesorové módy a režimy &darr;</a></h4>
<h4><a href="#DataTypes">Datové typy &darr;</a></h4>
<h3><a href="#MachineInstructions">Strojové instrukce &darr;</a></h3>
<h4><a href="#CopyInstructions">Instrukce pro kopii dat &darr;</a></h4>
<h4><a href="#ArithmeticInstructions">Aritmetické a logické instrukce &darr;</a></h4>
<h4><a href="#StackInstructions">Instrukce pracující se zásobníkem &darr;</a></h4>
<h4><a href="#TransferInstructions">Skokové instrukce &darr;</a></h4>
<h4><a href="#ShiftInstructions">Posuvy a rotace &darr;</a></h4>
<h4><a href="#StringInstructions">Řetězcové instrukce &darr;</a></h4>
<h3><a href="#FirstProgram">První program &darr;</a></h3>
<h4><a href="#HelloBios">BIOS 16 bitů &darr;</a></h4>
<h4><a href="#HelloDos">DOS 16 bitů &darr;</a></h4>
<h4><a href="#HelloL32">Linux 32 bitů &darr;</a></h4>
<h4><a href="#HelloL64">Linux 64 bitů &darr;</a></h4>
<h4><a href="#HelloW32">Windows 32 bitů &darr;</a></h4>
<h4><a href="#HelloW64">Windows 64 bitů &darr;</a></h4>
<h3><a href="#Macros">Zkusíme to s makry &darr;</a></h3>
<h4><a href="#MacroDefinitions">Definice a expanze maker &darr;</a></h4>
<h3><a href="#Literals">Literál namísto symbolu &darr;</a></h3>
<h3><a href="#Input">Načtení informace od uživatele &darr;</a></h3>
<h4><a href="#GetArg">Z příkazového řádku &darr;</a></h4>
<h4><a href="#StdInput">Ze standardního vstupu &darr;</a></h4>
<h3><a href="#Debugging">Hledání chyb &darr;</a></h3>
<h4><a href="#DebugCheck">Hledání chyb kontrolními výpisy &darr;</a></h4>
<h4><a href="#DebugDebug">Hledání chyb makrem Debug &darr;</a></h4>
<h4><a href="#DebugAppl">Hledání chyb ladicí aplikací &darr;</a></h4>
<hr/>
<p id="Introduction">Možná máte zájem naučit se programovat v asembleru, ale nevíte, kde začít.
Slyšeli jste, že se v tomto jazyce píší bootsektory, ovladače zařízení, kompilátory, operační systémy,
a tak zkoušíte něco takového napsat a pak zahlcujete odborná fóra dotazy,
kde přiznáváte, že jste v asembleru začátečník a něco vám nefunguje.
Než se pustíte do podobných specializovaných úkolů, je třeba získat základní orientaci a praxi
v používání nástrojů jako je asembler, disasembler, prohlížeč či analyzátor souborů apod.
To se nejlépe provede jejich častým používáním, nejprve na jednoduchých příkladech typu "Hello world",
kalkulačka, kreslení ASCII grafikou, později i na méně triviálních aplikacích.
Nemusíte se bát, že je psaní v asembleru oproti jiným jazykům pomalejší; samotným psaním na klávesnici
strávíme mnohonásobně méně času, než přemýšlením nad logikou programu, a to platí ve všech jazycích.</p>
<p>Předpokládejme, že jste někde zahlédli pár asemblerových instrukcí,
které byste chtěli vyzkoušet, ale teď nastává hlavní problém práce s novým programovacím jazykem:
kam tyto instrukce napsat a jak zařídit, aby je váš počítač provedl.
Zde se dozvíte jak.</p>

<h3 id="BasicKnowledge"><a href="#top">Předpokládané znalosti</a></h3>
<p>Tento tutoriál je určen zájemcům o programování v asembleru pro osobní počítače architektury
<strong>x64_32</strong> (Intel, AMD) a budeme psát programy pro operační systémy
<strong>MS Windows, Linux, DOS</strong>.</p>
<p>Předpokládejme, že máte aspoň základní znalosti angličtiny, umíte ovládat počítač,
instalovat a spouštět programy z příkazového řádku, umíte editovat soubory prostým textovým
editorem (nano, joe, Notepad apod.), znáte hexadecimální zápis čísel a umíte základní operace
s hexadecimálními čísly, například umíte spočítat příklady typu</p>
<div class="PRE">   1234h          89ABCDh           4567h
  +5678h         -234567h          -89ABh
---------       ---------        --------
   68ACh          666666h         ~FBBBCh</div>
<p>zpaměti, na papíře nebo aspoň s pomocí programátorské kalkulačky.</p>

<h3 id="HowComputerWorks"><a href="#top">Jak počítač pracuje</a></h3>
<p>Z pohledu programátora aplikací se počítač skládá z <ol>
<li>centrální procesorové jednotky (CPU) obsahující paměťové registry</li>
<li>operační paměti (memory)</li>
<li>zařízení (devices).</li></ol>
<div class="PRE">
&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;   data     &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;   data     &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
&#x2502;          &#x2502;<&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;>&#x2502;   CPU     &#x2502;<&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;>&#x2502;        &#x2502;
&#x2502; devices  &#x2502;   port     &#x2502;           &#x2502;  address   &#x2502; memory &#x2502;
&#x2502;          &#x2502;<&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;>&#x2502; registers &#x2502;<&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;>&#x2502;        &#x2502;
&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;            &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;            &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;</div>

<p>Nejmenší jednotkou informace je jeden bit, jehož fyzickou realizaci v CPU si můžeme představit
jako klopný obvod se dvěma stabilními stavy, který může být překlopen tak, aby na výstupu poskytoval napětí,
kterému jsme přiřadili hodnotu buď logická 1 nebo logická 0 (a nic mezi tím).
Klopný obvod si pamatuje svůj stav a může ho na požádání změnit (zapsat nebo přečíst).
<br>Spojení více klopných obvodů tak, aby se jejich bity daly zapisovat/číst najednou, se říká <dfn>registr</dfn>.
Ten může být v osobních počítačích osmibitový, šestnáctibitový, třiadvacetibitový atd. až 512bitový.
Zápis obsahu registru pomocí nul a jedniček by byl nepřehledný, místo toho se obvykle obsah registru
zapisuje pomocí dvou hexadecimálních cifer na každý jeho bajt, tedy na 8 bitů. </p>
<p>Registry jsou umístěny na čipu CPU. Na rozdíl od pamětí jsou registry velmi rychlé,
ale jejich počet a velikost jsou omezeny. Budeme pracovat hlavně s obecnými registry
(General Purpose Registers, GPR). K registrům programátor přistupuje pomocí jejich jména
(nikoli adresy), přičemž u většiny GPR lze kromě celého registru jmenovat také jejich podmnožiny.
Dolní polovina 64bitového registru RAX se nazývá EAX, dolní čtvrtina AX, dolní osmina AL.
Kompletní přehled registrů je v <a class="EXT" href="man_cze.htm#Registers">manuálu</a>.
Někde používáme označení rAX, rBX atd. Malé písmeno <kbd>r</kbd> zde vyjadřuje, že rAX může reprezentovat
registry RAX, EAX nebo AX, v závislosti na aktuálním módu procesoru.</p>
<div class="PRE">                   RAX
&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
&#x2502;                   &#x2502;        EAX        &#x2502;
&#x2502;         &#x2502;         &#x2502;         &#x2502;   AX    &#x2502;
&#x2502;    &#x2502;    &#x2502;    &#x2502;    &#x2502;    &#x2502;    &#x2502; AH &#x2502; AL &#x2502;
&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;</div>

<p>Obdobně jako RAX lze rozdělit i ostatní obecné registry RBX, RCX, RDX, RBP, RSI, RDI, RSP, R8..R15.</p>
<p>Obecné registry jsou v některých instrukcích specializovány nebo pevně přiřazeny,
čemuž částečně odpovídá i mnemotechnika jejich názvu.</p>
<ul><li>rAX - akumulátor, registr první volby, vhodný k aritmetickým operacím. Některé instrukce
jsou při jeho použití kratší.</li>
<li>rBX - bázový registr, adresace dat, univerzální použití.</li>
<li>rCX - čítač (counter), vhodný pro ukládání délky pole nebo počtu bajtů.
U instrukcí rotací a posuvu určuje velikost posuvu, u řetězcových instrukcí počet opakování.</li>
<li>rDX - druhý datový registr po akumulátoru, občas se s ním spojuje do dvojice DX:AX nebo EDX:EAX.
V instrukcích vstupu/výstupu může DX uchovávat číslo portu.</li>
<li>rBP - ukazatel základního rámce zásobníku (base pointer), používá se alternativně k rSP
k adresaci lokálních paměťových proměnných na zásobníku.</li>
<li>rSP - ukazatel zásobníku (stack pointer) je automaticky aktualizovaný registr
při instrukcích PUSH, POP, CALL, RET.</li>
<li>rSI - vstupní (source) index zejména u řetězcových instrukcí.</li>
<li>rDI - výstupní (destination) index u řetězcových instrukcí.</li>
<li>CS - code segment pro adresaci kódové sekce.</li>
<li>DS - data segment pro adresaci datové sekce.</li>
<li>SS - stack segment pro adresaci zásobníku.</li>
<li>ES - extra segment pro univerzální použití.</li>
</ul>
<p>Ostatní registry, jako ST0..ST7 (matematický koprocesor), MM0..MM7 (multimediální),
YMM0..YMM15 (SIMD registry) jsou ortogonální, tzn. nespecializované a vzájemně zaměnitelné.</p>
<p>Kromě registrů existují na čipu CPU klopné obvody zvané <em>příznaky</em> (flags), které se nastavují
automaticky po určitých operacích, zejména aritmetických. Budou nás zajímat hlavně tyto:<ul>
<li>příznak ZF - Zero Flag, který se nastaví na 1 pokud je výsledek předchozí oprerace nulový,</li>
<li>příznak SF - Sign Flag, který se nastaví pokud je výsledek negativní, tj. pokud jeho nejvýznamnější bit je 1,</li>
<li>příznak CF - Carry Flag, který se nastaví, došlo-li k přenosu nebo výpůjčce z nejvýznamnějšího bitu,</li>
<li>příznak OF - Overflow Flag, který se nastaví, došlo-li k přenosu nebo výpůjčce z druhého nejvýznamnějšího bitu,</li>
<li>příznak DF - Direction Flag, který určuje, zda se adresující registry rSI, rDI při řetězových instrukcích
mají po každém kroku zvyšovat nebo snižovat.</li></ul> <p>Ostatní flagy, jako Parity, Auxilliary, Trap, Interrupt
se v běžných aplikacích obvykle neužívají.
Na příznaky můžeme nahlížet jako na samostatné klopné obvody s pamětí jednoho bitu.
Pouze pro účely jejich zápisu na zásobník se sdružují do virtuálního registru, se kterým lze
manipulovat instrukcemi
<a class="EXTW" href="https://www.felixcloutier.com/x86/pushf:pushfd:pushfq">PUSHF</a>,
<a class="EXTW" href="https://www.felixcloutier.com/x86/popf:popfd:popfq">POPF</a>
a obnovovat tak všechny flagy najednou.</p>
<p>K registrům lze započítat také ukazatel instrukcí rIP, který při vykonávání instrukce ukazuje
za ni na adresu následující instrukce. Pouze u skokových instrukcí skoků se adresa v rIP
nahrazuje cílovou adresou, na niž se má skákat.</p>
<p>Carry Flag je vyjímečný tím, že jej můžeme nastavovat na <strong>1</strong> instrukcí
<a class="EXTW" href="https://www.felixcloutier.com/x86/stc">STC</a>, nulovat instrukcí
<a class="EXTW" href="https://www.felixcloutier.com/x86/clc">CLC</a> nebo měnit jeho hodnotu na opačnou pomocí
<a class="EXTW" href="https://www.felixcloutier.com/x86/cmc">CMC</a>.
Podobně se ještě dají nastavovat a nulovat Direction Flag pomocí
<a class="EXTW" href="https://www.felixcloutier.com/x86/std">STD</a> a
<a class="EXTW" href="https://www.felixcloutier.com/x86/cld">CLD</a>,
a Interrupt Flag pomocí
<a class="EXTW" href="https://www.felixcloutier.com/x86/sti">STI</a> a
<a class="EXTW" href="https://www.felixcloutier.com/x86/cli">CLI</a>.
Ostatní příznaky takto explicitně měnit nelze, ale například Zero Flag
můžeme nastavit na <strong>1</strong> vynulováním některého registru pomocí <code>SUB reg, reg</code>.</p>

<p>CPU je spojen s pamětí pomocí datové a adresní <dfn>sběrnice</dfn> (soustava vodičů).
Když CPU potřebuje něco načíst nebo zapsat,
nastaví adresu na adresní sběrnici a zapsaná data přečte nebo zapíše na datovou sběrnici.</p>
<p>Obdobným způsobem funguje čtení a zápis do zařízení. K zařízením patří klávesnice, monitor, myš,
síťová karta a další obdobné periférie. Na rozdíl od paměti se datovým kombinacím sloužícím k jejich výběru
neříká <dfn>adresa</dfn>, ale <dfn>port</dfn>, např. klávesnice má pevně určený port 64h,
tiskárna mívá port 378h apod. Přehled portů osobního počítače nalezneme např.
v <a class="EXTW" href="http://www.techhelpmanual.com/892-i_o_port_map.html">TechHelp</a>.</p>

<p>Obecně se dá o fungování počítače z pohledu programátora v asembleru říci, že</p>
<h6>procesor načte z paměti nebo ze zařízení nějakou informaci do registru,
provede s ní nějakou manipulaci a pak ji někam zapíše.</h6>
<p>Tou manipulací může být aritmetická nebo logická operace, změna bitů, nastavení na nějakou hodnotu apod. Kroky, které má procesor provést, jsou určeny pomocí <dfn>strojových instrukcí</dfn>.
Ty mají proměnnou délku 1 až 15 bajtů a jsou uloženy v operační paměti, jedna za druhou.
CPU je postupně z paměti načítá a provádí.</p>
<p>Každá instrukce má mnemotechnickou zkratku (určenou výrobcem procesoru), za kterou následují
operandy, jež určují odkud a kam se má informace zapsat.
Úlohou programu zvaného <dfn>asembler</dfn> je převést mnemotechnické zkratky a operandy
na hexadecimální kód strojových instrukcí a uložit je do souboru tak, aby byly spustitelné
pomocí operačního systému.</p>
<p>Typická instrukce má dva operandy &ndash; vstupní a výstupní &ndash; a v intelské syntaxi se zapisují v pořadí
<code>instrukce výstup, vstup</code>.
Například instrukce <code>ADD EAX,ECX</code> přikazuje procesoru, aby k obsahu registru EAX (výstupní)
přičetl obsah vstupního registru ECX. Obsah registru ECX zůstává nezměněn.
Obsah obecných registrů se přitom považuje za celé číslo s pevnou desetinnou čárkou.
<div class="PRE">Operační kód                  před provedením instrukce
 ADD EAX,ECX                EAX                ECX
  &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;              &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;     &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;
  &#x2502;01&#x2502;C8&#x2502;              &#x2502;12&#x2502;34&#x2502;56&#x2502;78&#x2502;     &#x2502;56&#x2502;78&#x2502;9A&#x2502;BC&#x2502;
  &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;              &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;     &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;
                              AH AL             CH CL

                               po provedení instrukce
 ADD EAX,ECX                EAX                ECX
  &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;              &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;     &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;
  &#x2502;01&#x2502;C8&#x2502;              &#x2502;68&#x2502;AC&#x2502;F1&#x2502;34&#x2502;     &#x2502;56&#x2502;78&#x2502;9A&#x2502;BC&#x2502;
  &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;              &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;     &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;
                              AH AL             CH CL</div>
<p>Uvedený příklad pracuje s dvaatřicetibitovými registry EAX a ECX, ale stejný postup bychom uplatnili
i pro sčítání registrů s šířkou 8, 16, 32 nebo 64 bitů, například <code>ADD AH,CL</code>,
<code>ADD AH,CH</code>, <code>ADD RAX,RCX</code>. Zlomkové registry, které nemají jméno, jako např.
horní polovina EAX, třetí osmina RCX ap. takto přímo sčítat nelze, ale mohli bychom pomocí
instrukcí rotace dočasně posunout obsah požadovaného zlomkového registru do pojmenované části, provést sčítání
pomocí <code>ADD AL,CL</code> a pak případně opačnou rotací vrátit sečtený registr zpět.</p>

<p>Vedle intelské syntaxe ještě existuje syntaxe vyvinutá ve firmě AT&amp;T, ve které je přehozen vstup a výstup.
Tou se zde ale nebudeme zabývat, neboť téměř všechny asemblery i výrobci procesorů používají syntaxi Intel.</p>
<p>Při sledování výukových materiálů si nelze nevšimnout mnoha nekonzistencí v popisování dat:<ul>
<li>Datový obsah obvykle zapisujeme v hexadecimálním zápisu stejně jako text, tedy zleva doprava, shora dolů.
Občas ale uvidíme, že někteří autoři zobrazují obsah paměti opačně, kdy nižší adresy jsou na monitoru či papíru
dole a rostou směrem nahoru.</li>
<li>Indexy polí a seznamů obvykle začínají jedničkou, ale občas bývá nejnižším indexem nula.</li>
<li>Číslování bitů v registrech někdy začíná od nejvýznamnějšího, ale častěji od nejméně významného
(ve smyslu nejméně ovlivňujícího hodnotu celého čísla v registru; nejméně významný bit je označen jako 0,
jeho soused jako 1 atd.).</li>
<li>Při ukládání slova tvořeného dvěma či více bajty do paměti se nejprve ukládá na nominální adresu
ten nejméně významný, pak se adresa zvětší o jednu a uloží se další bajt.
Této konvenci se říká <em>little endian</em> a je dodržována v celé architektuře x86.</li></ul>
<p>Obsah registru ECX ve výše uvedeném příkladu <code>ADD EAX,ECX</code> je zapsán hexadecimálně
jako <code>56 78 9A BC</code> a začíná tedy jeho nejvíce významným bajtem <code>56</code>.
To je zdánlivě v rozporu s ukládáním 32bitového slova do paměti počínaje nejméně významným bajtem,
avšak slovo v registru si představujeme jinak než slovo v paměti.
Pokud bychom registr ECX uložili do paměti třeba na adresu 0
(což by se provedlo instrukcí <code>MOV [0],ECX</code>) a pak zobrazili obsah paměti debugerem
nebo podobným nástrojem, viděli bychom
<div class="PRE">00000000: BC 9A 78 56</div>
<p>Z toho je patrné, že záleží na tom, zda na obsah paměťového místa nahlížíme jako
na vícebajtové <dfn>slovo</dfn>, nebo jako na sérii bajtů.</p>

<h4 id="Modes"><a href="#top">Procesorové módy a režimy</a></h4>
<p>Osobní počítače běží v dnešní době prakticky výhradně v <em>chráněném módu</em> (protected mode).
Operační systém v tomto módu chrání především sám sebe, aby uživatel nemohl z nepozornosti anebo záměrně
narušit paměť systému nebo jiných uživatelů, kteří by mohli současně na počítači pracovat.
Při pokusu o čtení nebo zápis do paměti, která nebyla uživateli přidělena, se přístup neprovede.
Obdobně je omezen i přístup ke vstupně-výstupním portům. Instrukce pro přímý zápis a čtení portů
<a class="EXTW" href="https://www.felixcloutier.com/x86/in">IN</a> a
<a class="EXTW" href="https://www.felixcloutier.com/x86/out">OUT</a> jsou v chráněném režimu privilegovány
a jejich používání si pro sebe vyhrazuje operační systém.</p>
<p>V počítačovém pravěku ještě osobní počítače (tehdy pouze 16bitové) běžely v <em>reálném módu</em>
operačního systému DOS, kdy měl uživatel pro sebe celou operační paměť i všechny porty.
Na dnešních PC je tento režim dostupný už jen pomocí emulátoru, jako je
<a class="EXTW" href="https://www.dosbox.com/">DOSBox</a>,
tedy oproti nativnímu prostředí Linuxu nebo Windows poněkud nepohodlně. Přesto se kupodivu
šestnáctibitový režim preferuje v asemblerových kursech, snad z (mylného) přesvědčení,
že 16bitový režim je pro začátečníky snazší než 32bitový nebo 64bitový.</p>

<p>Je li počítač přepnut do <dfn>16bitového reálného módu</dfn>, ať už v rámci emulace, nebo nabootováním
počítače do DOSu, budeme mít k dispozici pouze 16bitové registry AX, BX, CX, DX, BP, SP, SI, DI
a při adresaci paměti musíme brát do úvahy segmentové registry CS, DS, SS, ES.
Paměť můžeme oslovovat buď přímým zápisem adresy, např. <code>MOV AX,[1234h]</code>,
nebo adresu nejprve nahrát do registru a ten pak použít k adresaci:</p>
<div class="SRC">MOV BX,1234h
MOV AX,[BX]</div>
<p>V reálném módu můžeme k adresaci použít nanejvýš jeden bázový registr BX nebo BP
a nanejvýš jeden indexový registr SI nebo DI, např. <code>MOV AX,[BX+SI+1234h]</code>.
Při použití BP bude jako implicitní segmentový registr použit SS (není-li výslovně předepsáno jinak),
jinak se použije defaultní datový registr DS.</p>
<p>K adrese vypočtené jako součet obsahu registrů BX, SI a přímé hodnoty 1234h
se ještě přičítá obsah 16bitového segmentového registru vynásobený 16, než se tato <em>lineární adresa</em>
použije k přístupu do paměti.</p>

<p>V chráněném <dfn>32bitovém módu</dfn> je adresace paměti podstatně jednodušší.
K dispozici máme 32bitové registry EAX, EBX, ECX, EDX, EBP, ESP, ESI, EDI
a k adresaci paměti můžeme použít libovolnou kombinaci až dvou těchto registrů,
například <code>MOV EAX,[ECX+EDX+12346789h]</code>. Je-li v adresaci použit ESP nebo EBP,
segmentovým registrem se stává namísto defaultního DS registr SS. To je ale obvykle jedno,
protože DS, SS i ES obsahují v chráněném módu tutéž adresu a segmentovými registry se
nemusíme vůbec zabývat. Je tedy vidět, že 32bitový režim je pro programátora mnohem snazší
než 16bitový.</p>
<p>Obdobná pravidla adresace platí i v <dfn>64bitovém módu</dfn>, navíc zde můžeme
kromě RAX, RBX, RCX, RDX, RBP, RSP, RSI, RDI využívat i další obecné registry R8..R15.
Segmentové registry CS, DS, SS, ES se zde vůbec nepoužívají.</p>

<h4 id="DataTypes"><a href="#top">Datové typy</a></h4>
<p><dfn>Datový typ</dfn> určuje, jak máme na datovou položkou nahlížet - zda ji brát jako
celočíselnou hodnotu, číslo s plovoucí desetinnou tečkou, textový řetězec,
bitovou mapu či jinou strukturu. Jejich přehled je v <a class="EXT" href="man_cze.htm#DataTypes">manuálu</a>.
Na rozdíl od vyšších programovacích jazyků nejsou datové typy asemblerem nijak hlídány.
Základní datový typ je určen šířkou datové položky (např. 8, 16, 32, 64 bitů),
ale nic nám nebrání třeba 64bitové číslo s plovoucí desetinnou tečkou
interpretovat jako binární číslo nebo jako řetězec znaků (a dobrat se samozřejmě chybného výsledku).
Obsah položky (paměťového místa) můžeme zobrazovat jako text, převést
na číslo ve formátu člověkem očekávaného, můžeme je přehrávat jako zvuk, zobrazovat
jako fotografii, cokoli.</p>
<h6>Datový typ je v asembleru definován operacemi, které budeme s položkou provádět.</h6>

<h3 id="MachineInstructions"><a href="#top">Strojové instrukce</a></h3>
<p>Co můžeme ve formátu zápisu strojových instrukcí
<span class="SRC">mnemotechická_zkratka výstup, vstup</span>  používat jako
<span class="SRC">výstup, vstup</span>? Jsou čtyři možnosti.</p><ol>
<li>Jméno registru, do nebo ze kterého se má výsledek načíst, např. EBX</li>
<li>Adresa paměti, odkud se má operand načíst nebo kam se má výstup uložit.
Adresa bývá zapsaná v hranatých závorkách, např.  [1234h], často ale místo číselného zápisu
používáme jeho symbolické vyjádření. Paměťový operand může být v instrukci pouze jeden
(buď vstup, nebo výstup, případně žádný).</li>
<li>Přímá číselná hodnota, např. 1234h. Ta se dá použít pouze jako vstupní, nemůžeme do ní zapisovat.</li>
<li>Některé instrukce mají svou vstupní hodnotu určenu už svým názvem (např. FLDPI, XLAT)
nebo používají implicitní pevně určené registry (např. PUSHA, STOSB, CQO),
takže svůj vstup ani výstup nespecifikují.</li></ol>

<p>Instrukcím se říká <em>strojové</em>, protože jsou zabudovány do stroje (procesoru).
V asembleru ještě můžeme vidět <em>pseudoinstrukce</em>, které vypadají podobně, ale
jsou to direktivy pro asembler, nikoli pro procesor.</p>
<p>Nejnovější procesory architektury x86-64 mohou mít přes dva tisíce různých strojových instrukcí.
Dobrá zpráva je, že k běžnému programování vystačíme jen s pár desítkami, které si teď popíšeme.</p>
<p>Autoritativní popis každé instrukce je nejlépe hledat na webu výrobce CPU, např.
<a class="EXTW" href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel</a>.
Jedná se ale většinou o rozsáhlé materiály ve formátu PDF, se kterými se špatně pracuje a odkazuje,
takže se asi budete raději dívat na jejich podobu převedenou do
<a class="EXTW" href="https://www.felixcloutier.com/x86/">webového formátu HTML</a>.</p>

<h4 id="CopyInstructions"><a href="#top">Instrukce pro kopii dat</a></h4>
<p>Asi nejuniverzálnější instrukcí je <a class="EXTW" href="https://www.felixcloutier.com/x86/mov">MOV</a>,
zkratka od <em>MOVE</em>, tedy <em>přesuň, přestěhuj</em>. Což je poněkud nešťastně zvolený název,
lepší by bylo <em>COPY</em>, neboť se jedná o kopírování dat z jednoho místa na druhé, a ne o jejich
přesouvání. Informace ve vstupním registru nebo paměťovém místu zůstává zachována.
Ostatně v počítači ani není možnost informaci z registru nebo z paměti <em>odstranit</em>,
vždy tam nějaká zůstane, přinejmenším samé nuly.</p>
<p>Kromě kopírování mezi 8,16,32,64bitovými registry a paměťovými místy je stejná mnemonika (MOV) využita
i k přesouvání mezi obecnými (GPR) a dalšími registry, jako jsou segmentové, kontrolní, ladicí,
MMX nebo SIMD.</p>
<p>Pomocí MOV z paměti do registru načítáme obsah paměťového místa (bajtu, slova, dvojslova) do registru,
což se vyjadřuje uzavřením paměťového místa do hranatých závorek: <code class="SRC">MOV ECX,[1234h]</code>,
<code class="SRC">MOV ECX,[EBX]</code> apod.
Při vynechání závorek bychom namísto obsahu uloženého v paměti načítali adresu paměťového místa.
<code class="SRC">MOV ECX,1234h</code> by tedy naplnilo registr ECX číslem 1234h.
<code class="SRC">MOV ECX,EBX</code> by pouze zkopírovalo obsah registru EBX do registru ECX.
Neuvědomění si rozdílu mezi adresou (offsetem) paměťového místa a jeho obsahem je častým zdrojem chyb.</p>

<p>Další velmi často používanou instrukcí je <a class="EXT" href="https://www.felixcloutier.com/x86/lea">LEA</a>.
Zatímco <code class="SRC">MOV registr, [memory]</code>  načítal obsah paměti a
<code class="SRC">MOV registr, memory</code> načítal adresu paměti,
<code class="SRC">LEA registr, [memory]</code> načítá adresu, přestože je druhý operand vždy v hranatých závorkách.
Instrukce LEA je navíc o jeden bajt delší než MOV, proč ji tedy používat?
Například tam. kde nás zajímá výpočet adresy a nechceme znát její obsah (který ani nemusí v paměti existovat).
Ve 32bitovém a 64bitovém módu můžeme využít adresaci paměti se dvěma obecnými registry
(jeden je bázový a druhý indexový), přičemž indexový registr může být navíc škálován,
tedy interně vynásoben dvěma, čtyřmi nebo osmi.
To dovoluje používat k jednodušším výpočtům adresní aritmetiku:
<br><code class="SRC">LEA EDX,[ESI+ECX]</code> naplní EDX součtem obsahu registrů ESI a ECX.
<br><code class="SRC">LEA EAX,[8*EAX]</code> naplní EAX osminásobkem původního obsahu EAX.
<br><code class="SRC">LEA EBX,[EDX+4*EDX]</code> naplní EBX pětinásobkem obsahu EDX.</p>
<p>Další oblastí využití LEA je získávání adresy v 64bitovém režimu, kde na rozdíl od MOV
používá relativní adresaci místo absolutní a umožňuje tak oslovovat paměť v rozsahu plusminus 2 GB od instrukce LEA.</p>

<p>K instrukcím kopírování dat ještě patří <a class="EXT" href="https://www.felixcloutier.com/x86/xchg">XCHG</a>,
tedy vzájemná výměna informací mezi dvěma registry nebo mezi registrem a paměťovým místem.</p>
<p>Je dobré si pamatovat, že MOV, LEA, XCHG nechávají příznaky (flags) beze změny.</p>

<p>Jedinou instrukcí MOV můžeme načíst z paměti do registru 1 až 8 bajtů, případně až 64 bajtů pomocí VMOV*.
Procesor přístupy do paměti sdružuje, takže když načítáme nebo zapisujeme jen jeden bajt, např. pomocí
<code class="SRC">MOV AL,[RBX]</code>, <code class="SRC">MOV [RBX],AL</code>, ve skutečnosti
CPU načte najednou třeba 16 sousedních bajtů, z nichž pak vybere ten jeden požadovaný
a ostatní bajty nechá v původním stavu.
Nejmenší granularita přístupu do paměti je jeden bajt, programátor se ale sdružováním v procesoru nemusí zabývat.</p>
<p>Co kdybychom potřebovali změnit jen část bajtu, třeba jen jeden bit?
O to už se musí postarat programátor sám: načíst celý bajt, změnit v něm pouze požadovaný bit
(a ostatní ponechat tak jak jsou) a pak ten bajt zapsat zpět do paměti.
K manipulaci s jednotlivými bity můžeme použít specializované instrukce
<a class="EXT" href="https://www.felixcloutier.com/x86/bts">BTS</a> (nastavení bitu na 1),
<a class="EXT" href="https://www.felixcloutier.com/x86/btr">BTR</a> (nulování) nebo
<a class="EXT" href="https://www.felixcloutier.com/x86/btc">BTC</a> (změna na opačný).
Anebo můžeme použít bitově-logické (bitwise) operace
<a class="EXT" href="https://www.felixcloutier.com/x86/or">OR</a> k nastavování bitů,
<a class="EXT" href="https://www.felixcloutier.com/x86/and">AND</a> k nulování bitů nebo
<a class="EXT" href="https://www.felixcloutier.com/x86/xor">XOR</a> k překlopení bitů do opačného stavu.</p>

<h4 id="ArithmeticInstructions"><a href="#top">Aritmetické a logické instrukce</a></h4>
<p>Aritmetické instrukce počítají s celými čísly v binárním vyjádření. Obsah osmibitového registru
může být v rozmezí 00h až FFh, tedy dekadicky 0 až 255. Takové interpretaci říkáme
<em>čísla bez znaménka</em> (unsigned).
Kromě 8bitového registru můžeme celá čísla uložit také do 16, 32 nebo 64bitového registru.
Pokud k osmibitovému registru obsahujícímu např. číslo 78h=120 přičteme jiný registr s obsahem 9Ah=154,
třeba instrukcí <code class="SRC">ADD AL,BL</code>, součet činí 112h=274.
To je o 12h víc než je kapacita osmibitového registru (FFh), do registru AL se proto uloží hodnota jen 12h
a procesor nastaví Carry Flag na 1 jako signalizaci přetečení. Tato jednička přetečená z AL tedy nepřechází
do vyššího registru AH, jako by tomu bylo při 16bitovém sčítání <code class="SRC">ADD AX,BX</code>.
Můžeme ji ale započíst k dalšímu součtu, pokud bychom jej namísto
<a class="EXT" href="https://www.felixcloutier.com/x86/add">ADD</a> provedli instrukcí
<a class="EXT" href="https://www.felixcloutier.com/x86/adc">ADC</a>, (Add with Carry).
U ní se k součtu ještě navíc přičte jednotka, pokud byl Carry Flag nastaven: <code class="SRC">ADC AH,0</code>.
V praxi se to využívá pro sčítání a odčítání delších čísel, než odpovídá kapacitě GPR.</p>
<p>Následující příklad ilustruje sčítání dvou velkých čísel v 16bitových registrech,
když 32bitové registry nebyly k dispozici, jako tomu bylo v DOSu.
Mějme například sečíst v 16bitovém režimu dvě 32bitová čísla 89ABCDEFh a 55556666h.
Čísla rozdělíme do dvojic registrů DX:AX a BX:CX. Dvojtečka mezi názvy registrů zde představuje
spojení dvou 16bitových registrů do jednoho virtuálního 32bitového.</p>
<div class="PRE">MOV DX,89ABhh
MOV AX,0CDEFh
MOV BX,5555h
MOV CX,6666h
                 CF     DX      AX     BX      CX
                &#x250C;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510; &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510; &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510; &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;
                &#x2502;?&#x2502;  &#x2502;89&#x2502;AB&#x2502; &#x2502;CD&#x2502;EF&#x2502; &#x2502;55&#x2502;55&#x2502; &#x2502;66&#x2502;66&#x2502;
                &#x2514;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518; &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518; &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518; &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;
ADD AX,CX
                 CF     DX      AX     BX      CX
                &#x250C;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510; &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510; &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510; &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;
                &#x2502;1&#x2502;  &#x2502;89&#x2502;AB&#x2502; &#x2502;34&#x2502;55&#x2502; &#x2502;55&#x2502;55&#x2502; &#x2502;66&#x2502;66&#x2502;
                &#x2514;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518; &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518; &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518; &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;
ADC DX,BX
                 CF     DX      AX     BX      CX
                &#x250C;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510; &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510; &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510; &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;
                &#x2502;0&#x2502;  &#x2502;DF&#x2502;01&#x2502; &#x2502;34&#x2502;55&#x2502; &#x2502;55&#x2502;55&#x2502; &#x2502;66&#x2502;66&#x2502;
                &#x2514;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518; &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518; &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518; &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;</div>
<p>Výsledek ve dvojici registrů DX:AX je tedy DF013455h.</p>
<p>K dalším aritmetickým operacím vedle ADD a ADC patří ještě
<a class="EXT" href="https://www.felixcloutier.com/x86/sub">SUB</a> a
<a class="EXT" href="https://www.felixcloutier.com/x86/sbb">SBB</a> (Subtrack with Borrow).
SBB se liší od prostého odčítání (SUB) tím, že je-li nastaven Carry Flag, odečte navíc ještě jedničku.</p>
<p>Podobnou instrukcí jako SUB je
<a class="EXT" href="https://www.felixcloutier.com/x86/cmp">CMP</a>, která ale nic neodčítá
(obsah registrů se nemění), pouze nastavuje příznaky podle výsledku hypotetického odčítání.</p>
<p>Logické instrukce
<a class="EXT" href="https://www.felixcloutier.com/x86/or">OR</a>,
<a class="EXT" href="https://www.felixcloutier.com/x86/and">AND</a> a
<a class="EXT" href="https://www.felixcloutier.com/x86/xor">XOR</a>
provádějí stejnojmenné logické operace s operandy šířky 8, 16, 32, 64 bitů systémem <em>každý s každým</em>,
tedy nultý bit výstupního operandu s nultým bitem vstupního, první bit s prvním bitem, druhý s druhým atd.</p>

<p>Celá čísla v osmibitovém registru 0..255 jsme považovali za bezznaménková. To ale není jediná možná interpretace;
můžeme vyhradit nejvýznamnější bit pro znaménko a považovat tak číslo za <em>znaménkové</em> (signed).
Pak budou hodnoty 01h..7Fh odpovídat kladným číslům 1..127 a hodnoty FFh..80h záporným -1..-128, Nula zůstává nulou.
Číselný rozsah se tedy u osmibitového registru změnil na -128..+127, u širších registrů bude samozřejmě ještě mnohem větší.
Krása binární aritmetiky spočívá v tom, že znaménková i bezznaménková čísla sčítají a odčítají stejně,
pomocí stejných instrukcí ADD a SUB. Těmto instrukcím nezáleží na tom, zda jsme jim předložili
znaménková či bezznaménková čísla, výsledek aritmetické operace můžeme interpretovat tak i onak.</p>
<p>Pokud operujeme se znaménkovými čísly, přetečení (vybočení z povoleného číselného rozsahu) se namísto Carry Flag
signalizuje pomocí Overflow Flag.</p>
<p>Instrukce <a class="EXT" href="https://www.felixcloutier.com/x86/neg">NEG</a>
převádí pozitivní binární číslo na jeho negativní hodnotu a naopak.
To se provede tak, že změní všechny bity na opačné a k takto změněnému výsledku přičte jedničku.
V osmibitovém registru instrukce <code>NEG AL</code> změní hodnotu AL z 02h na FEh, z 01h na FFh,
z 00h na 00h, z FFh na 01h atd.
Obdobná instrukce je <a class="EXT" href="https://www.felixcloutier.com/x86/not">NOT</a>,
 ta se liší od NEG tím, že k invertovaným bitům žádnou jedničku nepřičítá, hodí se tedy spíše k logickým operacím.</p>

<p>Užitečné aritmetické operace jsou <a class="EXT" href="https://www.felixcloutier.com/x86/inc">INC</a> a
<a class="EXT" href="https://www.felixcloutier.com/x86/dec">DEC</a>, které zvyšují a snižují obsah
registru nebo paměťového místa o jednotku. U těchto dvou instrukcí se musíme zapamatovat, že mění aritmetické příznaky
s výjmkou CF.</p> <h6>Carry Flag zůstává provedením INC nebo DEC nezměněn.</h6>

<p>K aritmetickým instrukcím ještě patří násobení a dělení. U nich ale neplatí, že by s kladnými i zápornými čísly
počítaly stejně. Pokud chceme násobit nebo dělit binární čísla se znaménkem, musíme je buď převést na kladná (pomocí NEG)
a vypočtenou hodnotu pak případně opět převést na zápornou, anebo namísto
<a class="EXT" href="https://www.felixcloutier.com/x86/mul">MUL</a> a
<a class="EXT" href="https://www.felixcloutier.com/x86/div">DIV</a>
použít jejich znaménkové varianty
<a class="EXT" href="https://www.felixcloutier.com/x86/imul">IMUL</a> a
<a class="EXT" href="https://www.felixcloutier.com/x86/idiv">IDIV</a>.
U násobení a dělení neplatí, že bychom mohli použít kterékoli registry.
Výsledek násobení dvou 64bitových čísel může pro uložení výsledku vyžadovat až 128 bitů,
proto se pro uložení součinu používá dvojice registrů rDX:rAX, která je pevně dána.
U 32bitového násobení se výsledek ukládá do dvojice EDX:EAX, u 16bitového do DX:AX,
pouze u osmibitového násobení je výjimka a výsledek násobení AL vstupní osmibitovou hodnotou
jde do registru AX (DX zůstává nezměněn).
K přetečení nemůže už z principu dojít, avšak souběžné nastavení Carry Flag a Overflow Flag na jednotky signalizuje,
že výsledek je velký a přetekl do horní z dvojice výstupních registrů (do DX, EDX nebo RDX).</p>
<p>Při celočíselném dělení se použije opačný postup: dělenec se umístí do dvojice registrů rDX:rAX,
dělitelem může být jiný registr nebo paměťové místo odpovídající šířky.
Zde však k přetečení dojít může, pokud bude dělitel menší než číslo v horní polovině vstupního
registrového páru (DX, EDX,RDX), výsledek by se nevešel do dolní poloviny (AX, EAX, RAX)
a nebyl by tedy definován (tomu se říká <em>dělení nulou</em>).
Architektura x86 neví, jaké číslo by  v takovém případě měla uložit do výstupního registru a vyvolá tedy
<em>programovou výjimku</em> (přerušení), což může způsobit havarijní ukončení našeho programu.
Před dělením je tedy třeba horní polovinu vstupní dvojice registru vynulovat (v případě DIV) nebo
naopak nastavit na samé jedničky při dělení záporných čísel pomocí IDIV.
K tomu nejlépe poslouží u bezznaménkového dělení nulování rDX pomocí <code>SUB rDX,rDX</code>
a při znaménkovém dělení použití krátké instrukce
<a class="EXT" href="https://www.felixcloutier.com/x86/cwd:cdq:cqo">CWD, CDQ nebo CQO</a>.</p>

<h4 id="StackInstructions"><a href="#top">Instrukce pracující se zásobníkem</a></h4>
<p>Zásobník je souvislá oblast rezervovaná z celkového množství operační paměti a prohlášená za zásobník.
Pro adresaci v zásobníku se používá obecný registr rSP (stack pointer).
Zásobník nejčastěji slouží k dočasnému uložení a následné obnově obsahu obecných registrů instrukcemi
<a class="EXTW" href="https://www.felixcloutier.com/x86/push">PUSH</a> a
<a class="EXTW" href="https://www.felixcloutier.com/x86/pop">POP</a>.
Při zavedení programu do paměti se operační systém postará, aby rezervoval dostatečné množství paměti
pro zásobník a nastaví jeho ukazatel ESP nebo RSP na jeho počátek, což ale není nejnižší adresa,
nýbrž naopak nejvyšší. Při ukládání na zásobník pomocí PUSH adresy postupně klesají a naopak při vybírání
ze zásobníku pomocí POP adresy stoupají.</p>
<p>Předmětem PUSH mohou být obecné registry v šířce 16, 32 nebo 64 bitů, nebo paměťové proměnné o stejné šířce,
dále segmentové registry a také přímá číselná hodnota, kterou procesor znaménkově rozšíří na šířku operandu.
Procesor nejprve sníží ukazatel zásobníku rSP o 2, 4 nebo 8 bajtů a do takto vzniklého místa uloží operand.
Registr rSP tedy adresuje právě uloženou položku.</p>
<p>Operace POP funguje obráceně: přesune obsah 2, 4 nebo 8 bajtů adresovaných registrem rSP do operandu
a pak zvýší rSP o 2, 4 nebo 8 bajtů.</p>
<p>Používání registru rSP k adresaci zásobníku je implicitní; v instrukcích PUSH a POP se uvádí pouze
vstupní nebo výstupní operand. Některé asemblery dovolují psát více než jeden operand do jedné instrukce,
což je ale interně implementováno jako řada samostatných instrukcí PUSH nebo POP.
Zápis více operandů slouží hlavně k úspoře řádků zdrojového programu.</p>
<p>Ukládání a obnova ze zásobníku probíhá z principu metodou LIFO, tedy <em>Last In, First Out</em>.
Registr uložený na zásobník jako poslední pomocí PUSH se pak následnou instrukcí POP obnoví jako první;
musíme je tedy obnovovat v opačném pořadí, než jsme je ukládali. Příklad:</p>
<div class="SRC">PUSH EAX,EBX,ECX  ; Ulož tři registry na zásobník.
 ; Tady jsou instrukce měnící EAX, EBX,ECX. Obsah ESP je o 3*4 bajty menší než byl před instrukcí PUSH.
POP ECX,EBX,EAX   ; Obnov registry ze zásobníku do původního stavu. ESP je zpět, paměť pod ním už má nedefinovaný obsah.</div>
<p>V 16 a 32bitovém režimu můžeme namísto ukládání a následné obnově většího počtu registrů použít instrukce
<a class="EXTW" href="https://www.felixcloutier.com/x86/pusha:pushad">PUSHA</a> a
<a class="EXTW" href="https://www.felixcloutier.com/x86/popa:popad">POPA</a>,
které najednou ukládají a obnovují všech 8 GPR v pořadí eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI.
Ukládat všech osm registrů je sice mnohdy zbytečné a pomalejší, ale zase šetříme velikost kódu,
neboť PUSHA i POPA zabírají jen jeden bajt. V 64bitovém režimu PUSHA není k dispozici
a musíme tedy registry ukládat individuálně.</p>

<h4 id="TransferInstructions"><a href="#top">Skokové instrukce</a></h4>
<p>Pokud si z výuky programovacích jazyků pamatujete poučky o zákazu skoků a o škodlivosti příkazu GOTO,
v asembleru na to můžete zapomenout. Všechny programové konstrukty jako IF, ELSE, WHILE, SWITCH, REPEAT UNTIL atd.
se zde provádějí pomocí <em>podmíněných skoků</em>, kdy se nejprve vyhodnotí nějaká podmínka, např. instrukcemi
<a class="EXTW" href="https://www.felixcloutier.com/x86/cmp">CMP</a> nebo
<a class="EXTW" href="https://www.felixcloutier.com/x86/test">TEST</a>,
a pak se provede (nebo neprovede) skok na jiné místo v kódu pomocí instrukce podmíněného skoku
<a class="EXTW" href="https://www.felixcloutier.com/x86/jcc">Jcc</a>.
Tento skok má řadu <a class="EXT" href="../eadoc/#ConditionCodesGeneral">variant</a>
lišících se podmínkou <em>cc</em> v mnemotechnickém názvu instrukce.
Například JA (Jump if Above) nejprve zkoumá, zda platí současně CF=0 a ZF=0 a skočí na cílovou adresu (návěstí)
pouze pokud jsou obě tyto podmínky splněny, jinak instrukci ignoruje a pokračuje tou následující pod ní.</p>
<p>Pojmy <em>Above, Below</em> se používají, pokud jsme porovnávali čísla <em>bez znaménka</em>,
např. dvě adresy pomocí CMP.
Pojmy <em>Greater, Less </em> naopak po porovnávání <em>znaménkových celých čísel</em>.</p>
<p>Rozdílů mezi skoky <em>short</em> a <em>near</em> si nemusíme všímat, je starostí asembleru, aby použil ten správný.</p>
<p>K podmíněným skokům patří ještě instrukce
<a class="EXTW" href="https://www.felixcloutier.com/x86/loop:loopcc">LOOPcc</a>,
která nejprve sníží o 1 obsah registru rCX a pokud je rCX nenulový, provede skok na návěstí
uvedené v operandu instrukce, jinak pokračuje pod instrukcí LOOP.
Pokud by byl rCX nulový už před instrukcí LOOP, nejprve se sníží na hodnotu CX=65535 nebo dokonce ECX=4294967295,
tedy nenulové, a smyčka se pak bude právě tolikrát opakovat. Což jsme asi nechtěli, proto se registr rCX před
instrukcí LOOP testuje pomocí JCXZ nebo JECXZ a smyčka se v případě jeho nulovosti přeskočí:</p>
<div class="SRC">       JECXZ Skip
Label: ; Instrukce prováděné ECX-krát.
       LOOP Label
Skip:</div>
<p>Vedle podmíněných skoků můžeme také skákat na jiné místo programu <em>nepodmíněně</em>,
tedy pokaždé když se v toku instrukcí objeví <a class="EXTW" href="https://www.felixcloutier.com/x86/jmp">JMP</a>.
Tato instrukce nahradí registr rIP (který normálně obsahuje adresu příští instrukce) adresou, na kterou se skáče.</p>
<p>S nepodmíněnými skoky souvisí dvojice instrukcí
<a class="EXTW" href="https://www.felixcloutier.com/x86/call">CALL</a> a
<a class="EXTW" href="https://www.felixcloutier.com/x86/ret">RET</a>.
Podobně jako JMP, také instrukce CALL nahrazuje rIP adresou skoku, ale navíc ještě předtím
uloží obsah rIP na zásobník, podobně jako bychom hypoteticky provedli neexistující operaci <code>PUSH rIP</code>.
Instrukce RET provede hypotetickou operaci <code class="SRC">POP rIP</code>, což je ekvivalentní skoku
na návratovou adresu, která byla uložena na zásobníku instrukcí CALL.</p>
<p>Zásobníkové instrukce umožňují rozdělit tok aplikace na kratší podprogramy (procedury) a program tak
přehledně strukturovat. Každý podprogram či programové makro můžeme považovat za <em>černou skříňku</em>,
zdokumentovat její vstup, výstup a funkci, a pak na detaily její implementace zapomenout.</p>
<div class="SRC">     CALL BlackBox                                         BlackBox: PROC    ; Černá skříňka (na jiném místě programu).
     ; Pokračování v hlavním programu.                                PUSHAD ; Ulož registry
                                                                             ; Instrukce černé skříňky.
                                                                      POPAD  ; Obnov původní obsah registrů.
                                                                      RET    ; Návrat do hlavního programu pod CALL BlackBox.
                                                                     ENDPROC</div>
<p>Strojové instrukci CALL se podobá
<a class="EXTW" href="https://www.felixcloutier.com/x86/intn:into:int3:int1">INT</a> vyvolávající
<em>softwarové přerušení</em> (interrupt). Jako operand se zadává číslo 0..255, které v reálném módu udává
pořadové číslo dvojslova v tabulce přerušení (IDT) udávajícího adresu rutiny zpracovávající dané přerušení.
Například <code class="SRC">INT 21h</code> se podívá na adresu 21h*4 a dvě 16bitová slova z této adresy
zavede do registrů IP a CS. Na této adrese by měl být podprogram provádějící funkci očekávanou od INT 21h;
ten se pak ukončí instrukcí <a class="EXTW" href="https://www.felixcloutier.com/x86/iret:iretd:iretq">IRET</a>.
Rozdíl mezi instrukcemi CALL/RET a INT/IRET je v tom, že INT před uložením návratové adresy na zásobník tam navíc
uloží i příznaky a IRET je pak obnoví zpět.</p>

<h4 id="ShiftInstructions"><a href="#top">Posuvy a rotace</a></h4>
<p>Následujících osm instrukcí
<a class="EXTW" href="https://www.felixcloutier.com/x86/sal:sar:shl:shr">posuvů</a> a
<a class="EXTW" href="https://www.felixcloutier.com/x86/rcl:rcr:rol:ror">rotací</a>
umožňují manipulovat s obsahem 8, 16, 32, 64bitového registru nebo paměťového místa.
Počet posuvů se zadává ve druhém oprandu jako bezprostřední číslo nebo jako obsah pevně určeného registru CL.
O tento počet bitů se obsah posouvá či rotuje buď směrem vlevo, tedy od nejméně významného bitu LSb
k nejvýznamnějšímu MSb, anebo naopak <em>vpravo</em>, tedy od MSb k LSb.
<div class="PRE">            RCL                           RCR
 &#x250C;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;                 &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x2510;
 &#x2502;CF&#x2502;<-&#x2502;MSb <-- LSb&#x2502;<-CF         CF->&#x2502;MSb --> LSb&#x2502;->&#x2502;CF&#x2502;
 &#x2514;&#x2500;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;                 &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2518;

            ROL                           ROR
 &#x250C;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;                 &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x2510;
 &#x2502;CF&#x2502;<-&#x2502;MSb <-- LSb&#x2502;<-MSb       LSb->&#x2502;MSb --> LSb&#x2502;->&#x2502;CF&#x2502;
 &#x2514;&#x2500;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;                 &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2518;

            SAL                           SAR
 &#x250C;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;                 &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x2510;
 &#x2502;CF&#x2502;<-&#x2502;MSb <-- LSb&#x2502;<-0         MSb->&#x2502;MSb --> LSb&#x2502;->&#x2502;CF&#x2502;
 &#x2514;&#x2500;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;                 &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2518;

            SHL                           SHR
 &#x250C;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;                 &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x2510;
 &#x2502;CF&#x2502;<-&#x2502;MSb <-- LSb&#x2502;<-0           0->&#x2502;MSb --> LSb&#x2502;->&#x2502;CF&#x2502;
 &#x2514;&#x2500;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;                 &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2518;</div>

<p>Při instrukcích <em>rotace přes carry</em> (RCL, RCR) se k bitům registru ještě přidává bit Carry Flag
jakožto devátý (17., 33., 65.) bit.</p>
<p>Aritmetické instrukce SAL, SAR slouží k rychlému násobení a dělení znaménkových čísel pomocí mocnin dvou,
např. <code>SAL AX,4</code> je ekvivalentní násobení obsahu AX šestnácti (2<sup>4</sup>),
<code>SAR EBX,3</code> vydělí obsah EBX osmi atd. Proto taky u aritmetického posuvu vpravo (SAR)
nejvyšší znaménkový bit MSb kopíruje při každém kroku svou původní hodnotu.</p>
<p>Logické posuvy (SHL, SHR) se hodí k logickým operacím. Instrukce SHL a SAL se chovají identicky.
Dva příklady:</p>
<div class="PRE">STC
MOV EAX,12345678h
                   CF       EAX
                  &#x250C;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;
                  &#x2502;1&#x2502;  &#x2502;12&#x2502;34&#x2502;56&#x2502;78&#x2502;
                  &#x2514;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;
RCL EAX,4
                   CF       EAX
                  &#x250C;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;
                  &#x2502;1&#x2502;  &#x2502;23&#x2502;45&#x2502;67&#x2502;88&#x2502;
                  &#x2514;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;
MOV ECX,89ABCDEFh
                            ECX        CF
                       &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2510;
                       &#x2502;89&#x2502;AB&#x2502;CD&#x2502;EF&#x2502;  &#x2502;?&#x2502;
                       &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2518;
SHR ECX,2
                            ECX        CF
                       &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2510;
                       &#x2502;22&#x2502;6A&#x2502;F3&#x2502;7B&#x2502;  &#x2502;1&#x2502;
                       &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2518;  &#x2514;&#x2500;&#x2518;</div>

<h4 id="StringInstructions"><a href="#top">Řetězcové instrukce</a></h4>
<p>Jak víme, instrukce mohou přesouvat data mezi registry navzájem a mezi registry a pamětí,
ale nikoli z jednoho místa paměti do druhého. To není tak zcela pravda, existuje instrukce
<a class="EXTW" href="https://www.felixcloutier.com/x86/movs:movsb:movsw:movsd:movsq">MOVS</a>,
která to dělá za cenu obejití standardního způsobu zakódování adresy (ModRM+SIB).
Místo toho očekává, že adresa vstupu bude uložena do registru rSI a adresa výstupu do rDI.
Množství přenesených dat závisí na příponě instrukce, tedy MOVSB, MOVSW, MOVSD, MOVSQ
pro přenesení jednoho bajtu, 16bitového slova (WORD), 32bitového slova (DWORD) nebo 64bitového slova (QWORD).
Počet přenesených slov jednou instrukcí může být i větší, pokud použijeme opakovací <em>prefix</em>
<a class="EXTW" href="https://www.felixcloutier.com/x86/rep:repe:repz:repne:repnz">REP</a>.
Ten specifikuje, že počet opakování přenosu jednoho elementu se má opakovat tolikrát, jaký je obsah rCX,
přičemž po každém přenosu se rCX zmenší o 1 a adresy v registrech rSI a rDI se změní o velikost
přenášeného slova, tedy o 1, 2, 4 nebo 8 bajtů.
To, zda se adresy rSI a rDI budou o velikost slova zvětšovat nebo snižovat, závisí na Direction Flag.</p>
<p>Dva příklady použití MOVS ve 32bitovém módu, kdy jako indexové registry rSI, rDI jsou použity ESI,EDI:</p>
<div class="PRE">CLD
MOV ESI,02h
MOV ECX,3
MOV EDI,07h
            &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            &#x2502;01&#x2502;23&#x2502;<b>45</b>&#x2502;<b>67</b>&#x2502;<b>89</b>&#x2502;AB&#x2502;CD&#x2502;EF&#x2502;01&#x2502;23&#x2502;45&#x2502;67&#x2502;89&#x2502;..
            &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            00 01 02 03 04 05 06 07 08 09 0A 0B 0C  ..
                   ^              ^
            DF=0  ESI=02h        EDI=07h            ECX=3
REP MOVSB
            &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            &#x2502;01&#x2502;23&#x2502;45&#x2502;67&#x2502;89&#x2502;AB&#x2502;CD&#x2502;<b>45</b>&#x2502;<b>67</b>&#x2502;<b>89</b>&#x2502;45&#x2502;67&#x2502;89&#x2502;..
            &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            00 01 02 03 04 05 06 07 08 09 0A 0B 0C  ..
                            ^              ^
            DF=0           ESI=05h         EDI=0Ah  ECX=0
STD
MOV ECX,2
            &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            &#x2502;01&#x2502;23&#x2502;45&#x2502;<b>67</b>&#x2502;<b>89</b>&#x2502;<b>AB</b>&#x2502;<b>CD</b>&#x2502;45&#x2502;67&#x2502;89&#x2502;45&#x2502;67&#x2502;89&#x2502;..
            &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            00 01 02 03 04 05 06 07 08 09 0A 0B 0C  ..
                            ^              ^
            DF=1           ESI=05h        EDI=0Ah  ECX=2
REP MOVSW
            &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            &#x2502;01&#x2502;23&#x2502;45&#x2502;67&#x2502;89&#x2502;AB&#x2502;CD&#x2502;45&#x2502;<b>67</b>&#x2502;<b>89</b>&#x2502;<b>AB</b>&#x2502;<b>CD</b>&#x2502;89&#x2502;..
            &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            00 01 02 03 04 05 06 07 08 09 0A 0B  ...
                ^              ^
               ESI            EDI                  ECX=0</div>
<p>Instrukce <code class="SRC">REP MOVSB</code> v předchozím příkladu nejprve přenesla ECX=3 bajty
z adresy v ESI=02h na adresu EDI=07h.
V pokračování příkladu jsme změnili směr přenosu pomocí <code class="SRC">STD</code> doleva,
změnili šířku elementu z jednoho bajtu (MOVSB) na jedno 16bitové slovo (MOVSW)
a předepsali přenos pouze ECX=2 těchto elementů z adresy ESI=05h na adresu EDI=0Ah.
Ke změně obsahu obou adresovacích registrů rSI, rDI tedy dochází až po přenosu jednoho elementu.
Není-li před  instrukcí MOVS zadán prefix REP, provede se přenos právě jednoho elementu
(a oba registry se zvětší nebo zmenší o velikost elementu), jinak se zkoumá obsah rCX
a dokud je nenulový, přenos elementu včetně změny rSI, rDI se opakuje a rCX se pak sníží o jednotku.
Obsah rCX v <code class="SRC">REP MOVS</code> tedy určuje počet přenášených elementů. Pokud bylo rCX=0,
<code class="SRC">REP MOVS</code> se neprovede ani jednou a obsah registrů rCX, rSI, rDI se nemění.</p>
<p>Zajímavější situace nastává, pokud se přenášená pole částečně překrývají.
V následujícím příkladu se překrývá zdrojový řetězec (adresa ESI=02h, délka ECX=5)
s cílovým (adresa EDI=07h, délka ECX=5). V každém z pěti kopírovacích kroků se nejprve
načte a přenese jeden element (v našem případě bajt), a to i v případě, že tento vstupní element byl
před chvilkou přenesen. Pokud je ESI&lt;EDI a DF=0, anebo pokud je ESI&gt;EDI a DF=1, řetězec se nekopíruje,
ale pouze se jeho část mezi počátečními adresami obou registrů rozmnoží po celé délce výstupního řetězce.
Aby došlo k posunutí zdrojového řetězce dopředu nebo dozadu, muselo by platit ESI&lt;EDI a DF=1,
anebo ESI&gt;EDI a DF=0.</p>
<div class="PRE">CLD
MOV ESI,02h
MOV ECX,5
MOV EDI,05h
            &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            &#x2502;01&#x2502;23&#x2502;<b>45</b>&#x2502;<b>67</b>&#x2502;<b>89</b>&#x2502;<b>AB</b>&#x2502;<b>CD</b>&#x2502;EF&#x2502;01&#x2502;23&#x2502;45&#x2502;67&#x2502;89&#x2502;..
            &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            00 01 02 03 04 05 06 07 08 09 0A 0B 0C  ..
                   ^        ^
            DF=0 ESI=02h  EDI=07h                ECX=3
REP MOVSB
            &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            &#x2502;01&#x2502;23&#x2502;45&#x2502;67&#x2502;89&#x2502;<b>45</b>&#x2502;<b>67</b>&#x2502;<b>89</b>&#x2502;<b>45</b>&#x2502;<b>67</b>&#x2502;45&#x2502;67&#x2502;89&#x2502;..
            &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            00 01 02 03 04 05 06 07 08 09 0A 0B 0C  ..
                                  ^        ^
            DF=0               ESI=07h  EDI=0Ah   ECX=0
STD
MOV ECX,3
            &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            &#x2502;01&#x2502;23&#x2502;45&#x2502;<b>67</b>&#x2502;<b>89</b>&#x2502;<b>45</b>&#x2502;<b>67</b>&#x2502;<b>89</b>&#x2502;<b>45</b>&#x2502;67&#x2502;45&#x2502;67&#x2502;89&#x2502;..
            &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            00 01 02 03 04 05 06 07 08 09 0A 0B 0C  ..
                                  ^        ^
            DF=1               ESI=07h  EDI=0Ah   ECX=3
REP MOVSW
            &#x250C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x252C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            &#x2502;01&#x2502;23&#x2502;45&#x2502;67&#x2502;89&#x2502;45&#x2502;<b>67</b>&#x2502;<b>89</b>&#x2502;<b>45</b>&#x2502;<b>67</b>&#x2502;<b>89</b>&#x2502;<b>45</b>&#x2502;89&#x2502;..
            &#x2514;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2534;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
            00 01 02 03 04 05 06 07 08 09 0A 0B  ...
                ^        ^
             ESI=01h  EDI=04h                      ECX=0</div>
<p>Další užitečnou řetězcovou instrukcí je
<a class="EXTW" href="https://www.felixcloutier.com/x86/stos:stosb:stosw:stosd:stosq">STOS</a>, která ukládá obsah
registru AL, AX, EAX nebo RAX do paměti na adresu uloženou v registru rDI, a po uložení obsah rDI o velikost elementu
zvětší nebo zmenší, což záleží na Direction Flag. Také před touto instrukcí se často používá prefix REP
a umožňuje tak vynulovat velké úseky operační paměti.
<div class="SRC">CLD
MOV EDI,MemBlock ; Adresa počátečního bajtu nulovaného bloku paměti o velikosti 64 KB.
MOV ECX,64K / 4  ; Počet opakování = velikost bloku děleno velikostí DWORD.
SUB EAX,EAX      ; Vynuluj registr EAX (DWORD), který se bude ukládat do bloku.
REP MOVSD        ; Vynuluj celý MemBlock.</div>

<p>Opačným způsobem než STOS funguje
<a class="EXTW" href="https://www.felixcloutier.com/x86/lods:lodsb:lodsw:lodsd:lodsq">LODS</a>, která
načítá paměť z adresy dané registrem ESI do AL, AX, EAX nebo RAX, a po načtení zvětší nebo zmenší rSI.
U této instrukce nemá smysl používat prefix REP, neboť načítané hodnoty by přepisovaly obsah rAX
ještě dříve, než bychom jej stačili nějak zpracovat. LODSB se používá se spolupráci se STOSB,
pokud chceme kopírovat řetězec bajt po bajtu a zároveň reagovat na kopírované znaky.
Příklad jednoduché konverze nulou zakončeného řetězce z malých písmen a..z na velká A..Z:</p>
<div class="SRC">      CLD
      MOV ESI,MixedCase ; Načti adresy obou řetězců.
      MOV EDI,UpperCase ; Délka je neznámá, ale je zakončen nulovým znakem.
Next: LODSB             ; Načti jeden znak vstupního řetězce z [ESI] do AL a zvětši ESI o 1.
      CMP AL,0          ; Testuj, zda už jsme na konci vstupního řetězce.
      JE End            ; Pokud ano, skoč na návěstí End.
      CMP AL,'a'        ; Kontrola, zda se jedná o znak v rozmezí 'a'..'z'.
      JB Store          ; Pokud je menší než 'a', neměň ho a skoč na návěstí Store.
      CMP AL,'z'        ; Kontrola, zda se jedná o znak v rozmezí 'a'..'z'.
      JA Store          ; Pokud je větší než 'z', neměň ho a skoč na návěstí Store.
      AND AL,11011111b  ; Nuluj 5. bit znaku v AL, což jej převede na velké písmeno 'A'..'Z'.
Store:STOSB             ; Ulož znak z AL na adresu [EDI] a zvětši EDI o 1.
      JMP Next          ; Skoč zpět pro další znak vstupního řetězce.
End:  STOSB             ; Hotovo, ukonči nulou z registru AL i výstupní řetězec.
</div>

<p>Řetězcová instrukce
<a class="EXTW" href="https://www.felixcloutier.com/x86/scas:scasb:scasw:scasd">SCAS</a>
slouží k vyhledání pozice hodnoty v registru AL, AX, EAX nebo RAX
ve vstupním řetězci adresovaném pomocí rDI. Porovnání nastaví příznaky a pak zvětší nebo zmenší rDI
o šířku porovnávaného registru (1, 2, 4 nebo 8) v závislosti na Direction Flag.
Instrukce se používá s prefixem REPNE (opakovat, pokud se nerovná), počet opakování je přitom
určen obsahem rCX. Provádění instrukce se ukončí buď nalezením znaku v řetězci (nastaví se Zero Flag
jakožto příznak shody), anebo vyčerpáním délky řetězce v registru rCX. Pokud operace skončila
kvůli vynulování rCX, můžeme ještě podle stavu příznaku ZF zjistit, zda byla hodnota nalezena
v posledním elementu vstupního řetězce.</p>
<div class="SRC">      CLD
      MOV EDI,String        ; Adresa prohledávaného řetězce.
      MOV ECX,SizeOfString  ; Počet znaků v řetězci.
      MOV AL,0              ; Budeme hledat nulový bajt.
      REPNE SCASB           ; EDI nyní ukazuje za nalezený nulový bajt, pokud byl nalezen.
      JNE Error             ; Skoč, pokud řetězec neobsahuje nulový bajt, ale přitom ECX=0.
</div>
<p>Poněkud menší smysl má skenování opakované s prefixem REPE (opakovat, dokud se rovná).
To bychom využili, pokud registr EDI ukazuje například na řetězec samých nulových znaků
a chceme zjistit pozici prvního nenulového:</p>
<div class="SRC">      CLD
      MOV EDI,String        ; Adresa prohledávaného řetězce.
      MOV ECX,SizeOfString  ; Počet znaků v řetězci.
      MOV AL,0              ; Budeme hledat nenulový bajt.
      REPE SCASB            ; EDI nyní ukazuje za nalezený prvý nenulový bajt, pokud byl nalezen.
      JE Error              ; Skoč, pokud řetězec obsahuje pouze nulové bajty.
</div>
<p>Poslední užitečnou řetězcovou instrukcí je
<a class="EXTW" href="https://www.felixcloutier.com/x86/cmps:cmpsb:cmpsw:cmpsd:cmpsq">CMPS</a>,
která porovnává element v paměti (BYTE, WORD, DWORD nebo QWORD) adresovaný pomocí rSI s elementem
stejné šířky adresovaným pomocí rDI. Nastaví aritmetické příznaky a pak zvětší nebo zmenší rSI a rDI
o velikost elementu. Rovněž tuto instrukci můžeme opakovat pomocí prefixu REPE.
Následující příklad ukazuje vyhledání nějakého slova nebo výrazu (Needle) v delším řetězci znaků (Haystack).
Algoritmus nejprve vyhledá pomocí SCASB první znak Needle a pak pomocí CMPSB porovná následné znaky
hledaného slova. Pokud tam nejsou, pokračuje v hledání prvního znaku a celý postup opakuje.</p>
<div class="SRC">     CLD
     MOV ESI,Needle         ; Adresa hledaného výrazu.
     MOV EDI,Haystack       ; Adresa bloku, v němž budeme hledat Needle.
     MOV ECX,HaystackSize   ; Velikost tohoto bloku.
     LODSB                  ; Načti první znak Needle.
Next:REPNE SCASB            ; Vyhledej první znak v Haystack počínaje EDI.
     JNE NotFound           ; Needle není obsaženo v Haystack, skončili jsme.
     PUSH ECX,ESI,EDI       ; Ulož rozpracovaný stav na zásobník.
       MOV ECX,NeedleSize-1 ; ESI ukazuje na druhý znak Needle.
       REPE CMPSB           ; Porovnej s Needle počínaje druhým znakem.
     POP EDI,ESI,ECX        ; Obnov stav ze zásobníku, zatím ignoruj příznaky.
     JE Found               ; Pokud je ZF=1, tak REPE CMPSB nalezlo shodu, máme hotovo.
     JMP Next               ; Jinak pokračuj v hledání prvního znaku, který je stále v AL.
</div>
<p>Linux i Windows vyžadují, aby Direction Flag byl před voláním jeho funkcí vynulován,
a zároveň zaručuje, že při návratu je rovněž DF=0. Pokud bychom potřebovali používat
řetězcovou instrukci s nastaveným Direction Flag, je třeba jej opět vynulovat pomocí CLD,
nejlépe hned po jejím provedení. Pak ani nemusíme tento příznak nulovat na začátku uvedených příkladů.</p>
<p>Pamatujme, že řetězcové instrukce inkrementují registry až po provedení, takže např. <code>REPNE SCASB</code>
se po nalezení bajtu zastaví o jeden element později a nalezený bajt je tedy na adrese EDI-1.</p>
<h6>Instrukce SCAS a CMPS nastavují příznaky, ostatní řetězcové instrukce je ponechávají beze změny.</h6>

<h3 id="FirstProgram"><a href="#top">První program</a></h3>
<p>Po seznámení se základními strojovými instrukcemi se konečně dostáváme k jejich vyzkoušení.
Instrukce je třeba zapsat do <em>zdrojového souboru</em> jako prostý text v osmibitovém kódování (nikoli UTF-16)
a bez interních příznaků uvozujících tučné či skloněné písmo, nadpisy apod.
Soubor pak předložíme programu zvanému asembler, který jej převede do jiného souboru ve spustitelném tvaru.
Tento tutorial doporučuje použít EuroAssembler, který je výhodný tím, že nemusíme specifikovat
žádné parametry na příkazovém řádku, pouze název zdrojového souboru. Výstupem může být přímo spustitelný soubor
pro DOS, Linux nebo Windows, není tedy potřeba linker. Nebudeme využívat ani žádné knihovny třetích stran,
pouze API (Application Programming Interface) operačního systému.</p>
<p>Aby bylo programování zábavné, měl by každý program něco zajímavého vykonávat, přinejmenším něco vypsat
na monitor. Obvykle se začíná vypsáním fráze &quot;Hello, world!&quot;. Monitor, klávesnice, myš
patří k zařízením (devices), která však jsou ve správě operačního systému a ten nám nedovolí použít instrukce
<a class="EXTW" href="https://www.felixcloutier.com/x86/in">IN</a> a
<a class="EXTW" href="https://www.felixcloutier.com/x86/out">OUT</a> k zápisu do zařízení.
Možná by to šlo v reálném DOSu, ale beztak bychom se těžko potýkali s porty rozmanitých videoadaptérů,
jaké se v době DOS používaly. K vypsání řetězce znaků na monitor budeme muset použít služby operačního systému.</p>
<p>Ukážeme si, jak vypsat "Hello, world!" v 16bitovém systému DOS, pak v 32bitovém Linuxu, 64bitovém Linuxu,
32bitovém MS Windows a 64bitovém MS Windows.</p>

<h4 id="HelloDos"><a href="#top">DOS 16 bitů</a></h4>
<p>Služby DOS se vyvolávají strojovou instrukci INT 21h a jsou popsány např. v seznamu
<a class="EXTW" href="http://www.techhelpmanual.com/5-dos_function_index___quick_reference_subset.html">DOS Fn Index</a>
nebo <a class="EXTW" href="https://www.ctyme.com/intr/int-21.htm">INT 21h</a>.
Po rozkliknutí seznamu funkcí INT 21h vidíme dva řádky zabývající se standardním výstupem, tedy zápisem na konzolu:
<code>Int 21/AH=02h - DOS 1+ - WRITE CHARACTER TO STANDARD OUTPUT</code> a
<code>Int 21/AH=09h - DOS 1+ - WRITE STRING TO STANDARD OUTPUT</code>.
Chceme vypisovat celý řetězec, ne jen jednotlivý znak (character), takže se podíváme na tu druhou funkci,
která má dva vstupní parametry:</p>
<code class="PRE"> AH = 09h
 DS:DX -> '$'-terminated string</code>
<p>Vyvolání této funkce tedy vyžaduje následující instrukce:</p>
<div class="SRC">MOV AH,09h
MOV DX,HelloWorldAddress
INT 21h</div>
<p>Zbývá vyřešit maličkost: jak do dvojice DS:DX zapsat adresu řetězce &quot;Hello, world!&quot;,
prozatímně symbolizovanou slovem HelloWorldAddress?</p>
<p>V DOSu budeme preferovat programy ve spustitelném formátu COM. Ten se celý odehrává v rámci
jednoho bloku paměti o velikosti 64 KB, což pro naše drobné úlohy bohatě stačí
a má velikou výhodu, že všechny čtyři segmentové registry jsou již DOSem nastaveny
na potřebný obsah, takže se jimi nemusíme zabývat.
DOS při spouštění našeho programu jej zavede do paměti a před jeho začátek uloží datovou strukturu
o velikosti 256 bajtů zvanou <a class="SRC" href="../maclib/doss.htm#PSP">PSP</a>.
První instrukce našeho programu následuje hned za ní, tedy na adrese 256.
Program nemůže začínat na adrese 256 definicí řetězce "Hello, world!",
protože by procesor zkoušel znaky řetězce vykonávat jako programový kód a nejspíš by ohlásil chybu nebo zatuhnul.
Definici řetězce tedy odsuneme až na konec programu, asembleru je to jedno.
Po instrukci <code>INT 21h</code> bychom měli náš program regulerně ukončit, jinak by sice vypsal pozdrav,
ale pak by se marně snažil vykonávat bajty řetězce jako strojové instrukce a nejspíš přitom zamrzl.
Prohlédnutím seznamu funkcí DOS 21h najdeme hned dvě obsahující text "TERMINATE":
<code class="MSG">Int 21/AH=00h - DOS 1+ - TERMINATE PROGRAM</code> a
<code class="MSG">Int 21/AH=4Ch - DOS 2+ - EXIT - TERMINATE WITH RETURN CODE</code>.
V programu formátu COM ale existuje ještě další a mnohem jednodušší způsob regulerního ukončení:
prostou instrukcí RET. Ta načte z zásobníku nulové slovo a tím způsobí, že se program vrací na adresu CS:0,
kde je začátek PSP a tam je uložena strojová instrukce <code class="SRC">INT 0x20</code>
pro ukončení programu v DOS. Náš program tedy bude vypadat takto:
<div class="SRC">MOV AH,09h
MOV DX,HelloWorldAddress
INT 21h
RET
HelloWorldAddress DB "Hello, world!"</div>
<p>Textový řetězec byl v programu definován pomocí pseudoinstrukce
<a href="../eadoc/#D">DB</a> (definuj bajty) a zapsán v uvozovkách. Assembler použije adresu
následující za instrukcí RET, na ni uloží 13 bajtů řetězce a této adrese přiřadí symbolický název HelloWorldAddress.
<br/>Máme tedy zdrojový kód, zapíšeme ho do souboru nazvaného např. <q>hello.asm</q> a uložíme.
Zkusíme jej přeložit do spustitelného tvaru tím, že zadáme v konzoli povel <code class="MSG">euroasm hello.asm</code>
(uvozovky kolem jména souboru se mohou vynechat, pokud neobsahuje mezery):</p>
<div class="MSG">...
I0180 Assembling source file "hello.asm".
I0270 Assembling source "hello".
I0310 Assembling source pass 1.
I0310 Assembling source pass 2.
I0330 Assembling source pass 3 - final.
I0760 16bit TINY BIN file "hello.bin" created from source, size=29.
I0750 Source "hello" (4 lines) assembled in 3 passes with errorlevel 0.
I0860 Listing file "hello.asm.lst" created, size=881.
I0980 Memory allocation 448 KB. 21 statements assembled in 1 s.
I0990 EuroAssembler terminated with errorlevel 0.</div>
<p>Z výstupních zpráv generovaných EuroAssemblerem v průběhu překladu si povšimněme řádku
<code class="MSG">I0760 16bit TINY BIN file "hello.bin" created from source, size=29.</code>
Program formátu COM by měl mít příponu <q>.com</q>. To je tím, že jsme asembleru nesdělili,
že má překládat do formátu COM, takže použil defaultní příponu <q>.bin</q>, která mimo jiné nevytváří PSP,
takže náš program by beztak nefungoval.</p>
<p>Jak říci EuroAssembleru, že má vygenerovat COM? K tomu slouží dvojice pseudoinstrukcí PROGRAM a ENDPROGRAM
a operandy FORMAT=, WIDTH=, MODEL=, SUBSYSTEM= (a mnoho dalších). Musíme tedy náš program zabalit
mezi PROGRAM a ENDPROGRAM. Jako povinné návěstí povelu PROGRAM uvedeme název programu (bez přípony).
Nazvěme jej třeba HelloDos.
Stejné jméno se uvádí také u ENDPROGRAM, ovšem nikoli v poli návěstí, ale jako operand, jak je obvyklé
u blokových pseudoinstrukcí EuroAssembleru. Jméno programu nemusí nutně odpovídat názvu zdrojového souboru,
jako je tomu u jiných asemblerů. Mohli bychom totiž v jednom souboru definovat více než jeden blok
PROGRAM/ENDPROGRAM a tím vyrábět více různých spustitelných programů najednou. Ale to zatím nebudeme zkoušet.</p>
<p>Kromě názvu programu musíme v parametrech pseudoinstrukce PROGRAM specifikovat ještě formát
a šířku výsledného souboru. EuroAssembler si ale šířku u formátu COM odvodí sám jako WIDTH=16, takže
bychom tento operand mohli vynechat. Obdobně bychom mohli vynechat i operand ENTRY=256,
neboť vstupní bod  programu je u COM programů vždy pevně určen na této adrese.</p>
<div class="SRC">HelloDos PROGRAM FORMAT=COM, WIDTH=16, ENTRY=256
  MOV AH,09h
  MOV DX,HelloWorldAddress
  INT 21h
  RET
HelloWorldAddress DB "Hello, world!"
  ENDPROGRAM HelloDos</div>
<p>Po jeho spuštění pomocí <code class="MSG">euroasm hello.asm</code> dostáváme:</p>
<div class="MSG">...
I0180 Assembling source file "hello.asm".
I0270 Assembling source "hello".
I0310 Assembling source pass 1.
I0330 Assembling source pass 2 - final.
I0470 Assembling program "HelloDos". "hello.asm"{1}
I0510 Assembling program pass 1. "hello.asm"{1}
I0510 Assembling program pass 2. "hello.asm"{1}
I0530 Assembling program pass 3 - final. "hello.asm"{1}
I0660 16bit TINY COM file "HelloDos.com" created, size=29. "hello.asm"{7}
I0650 Program "HelloDos" assembled in 3 passes with errorlevel 0. "hello.asm"{7}
I0750 Source "hello" (6 lines) assembled in 2 passes with errorlevel 0.
I0860 Listing file "hello.asm.lst" created, size=1039.
I0980 Memory allocation 448 KB. 32 statements assembled in 1 s.
I0990 EuroAssembler terminated with errorlevel 0.
</div>
<p>Důležitá je poslední řádka, která informuje o errorlevel 0, tedy bez chyb.
Jinak bychom je nejprve museli ve zdrojovém textu najít a odstranit.
Podobně řádka <code class="MSG">I0660 16bit TINY COM file "HelloDos.com" created, size=29.</code>
potvrzuje, že byl vygenerován program ve formátu COM a jakou má velikost.
Po téměř každé zprávě EuroAssembler ještě připojuje pozici ve zdrojovém souboru,
které se zpráva týká. Například <code class="MSG">"hello.asm"{7}</code> přiřazuje
zprávu k sedmému řádku zdrojového souboru, což je <code class="SRC"> ENDPROGRAM HelloDos</code>.</p>
<p>Ještě si všimněme zprávy <code class="MSG">I0860 Listing file "hello.asm.lst" created, size=1039.</code>.
EuroAssembler bez ptaní vytváří soubor s listingem přeloženého souboru. Je to opět prostý textový soubor,
který si proto můžeme prohlédnout například Notepadem nebo podobným prohlížečem:</p>
<samp>|                          |HelloDos PROGRAM FORMAT=COM, WIDTH=16, ENTRY=256
|[CODE]                    ::::Section changed.
|0000:B409                 |  MOV AH,09h
|0002:BA[0000]             |  MOV DX,HelloWorldAddress
|0005:CD21                 |  INT 21h
|0007:C3                   |  RET
|[DATA]                    ::::Section changed.
|0000:48656C6C6F2C20776F72~|HelloWorldAddress DB "Hello, world!"
|                          |  ENDPROGRAM HelloDos
|        **** ListMap "HelloDos.com",model=TINY,groups=1,segments=3,entry=256,stack=[COMGROUP]:0000FFFEh
|        [COMGROUP],FA=00000000h,RVA=00000000h,size=0000011Dh=285,group [PSP] [CODE] [DATA]
|          [PSP],FA=00000000h,RVA=00000000h,size=00000100h=256,width=0,align=0,purpose=PHDR
|          [CODE],FA=00000000h,RVA=00000100h,size=00000008h=8,width=16,align=0010h,purpose=CODE
|          [DATA],FA=00000010h,RVA=00000110h,size=0000000Dh=13,width=16,align=0010h,purpose=DATA
|        **** ListGlobals "HelloDos.com",Global=0,Public=0,Extern=0,eXport=0,Import=0
</samp>
<p>Vidíme, že listing obsahuje kopii zdrojového kódu odsunutou vpravo a do levé části se vložil
sloupec ohraničený znaky <kbd>|</kbd> obsahující čtyřmístnou hexadecimální adresu ukončenou dvojtečkou,
a po ní strojový kód instrukce. Na konci programu ještě přibyla mapa ukazující, jak byly jeho sekce
slinkovány do výsledného souboru (**** ListMap) a seznam globálních symbolů (**** ListGlobals),
v našem případě prázdný.</p>
<blockquote><p>Formát listingu produkovaného EuroAssemblerem odpovídá platnému zdrojovému kódu,
neboť levý sloupec ohraničený znaky <kbd>|</kbd> se jako <a class="EXT" href="../eadoc/#MachineRemarks">
strojová poznámka</a> ignoruje. Pokud bychom tedy překlad znovu spustili povelem
<code>euroasm hello.asm.lst</code>, opět bychom získali soubor <q>HelloDos.com</q>.</p>
</blockquote>
<p>Překlad programu skončil s errorlevel 0.
Můžeme tedy otevřít emulátor DOSu (DosBox),
přejít do adresáře, v němž máme <q>HelloDos.com</q> a zkusit ho spustit zapsáním <code class="MSG">HelloDos</code>
nebo <code class="MSG">HelloDos.com</code>. Nejspíš v okně DOSu uvidíte text <span class="MSG">Hello, wordl!</span>
následovaný změtí nesmyslných znaků. To je způsobeno přehlédnutím detailu v popisu služby
<code class="PRE">DS:DX -> '$'-terminated string</code> - vypisovaný řetězec musí být zakončen znakem dolaru.
Zároveň s dolarem můžeme na konec řetězce připsat ještě dvojici Carriage Return a Line Feed, tedy 13 a 10,
které způsobí odřádkování:</p>
<code class="SRC">HelloWorldAddress DB "Hello, world!",13,10,'$'</code>
<p>Po opravě řádku a novém přeložení by již mělo všechno fungovat podle očekávání.</p>

<h4 id="HelloBios"><a href="#top">BIOS 16 bitů</a></h4>
<p>Po zapnutí počítače CPU startuje v reálném módu a provádí program pevně &quot;zadrátovaný&quot;
v paměti na základní desce. V té době ještě není z disku zaveden DOS ani jiný operační systém,
ale funguje rozhraní BIOS, případně UEFI, které umí několik základních funkcí počítače:
vypisovat na monitor znaky a řetězce, číst klávesnici, načíst z disku program pro zavedení OS.
Tyto funkce se dají vyvolat instrukcemi INT, za zmínku stojí zejména INT 10h pro práci s videoadaptérem
a tedy i monitorem. Úplný přehled funkcí vyvolávaných přerušením INT je na
<a class="EXTW" href="https://www.ctyme.com/intr/int.htm">Interrupt Jump Table</a>.</p>
<p>V předchozím příkladu bylo k vypsání řetězce použito rozhraní DOSu.
Pokud bychom potřebovali zapisovat na obrazovku hned po zapnutí počítače ještě dříve,
než je DOS nebo jiný operační systém zaveden, museli bychom použít rozhraní BIOS
napevno uložené ve firmware základní desky. Takto se chová například program boot sektoru,
který zavede 512 bajtů dlouhý obsah jednoho diskového sektoru do paměti a předá mu řízení.
Zkusíme vypsat <em>Hello, world!</em> pomocí služby BIOS.
Ty podobně jako služby DOSu zachovávají obsah všech registrů kromě těch, které vracejí výsledek.
My použijeme službu
<a class="EXT" href="https://www.ctyme.com/intr/rb-0106.htm">TELETYPE OUTPUT</a>,
která očekává vypisovaný znak v AL, dále AH=0Eh jako identifikátor služby a BH=0
jako číslo interní stránky videoadaptéru.</p>
<p>EuroAssembler sice dovoluje generovat boot sektor přímo, volbou <code class="SRC">PROGRAM FORMAT=BOOT</code>,
avšak zavádění boot sektoru je komplikované a nepohodlné. Z praktických důvodů budeme opět generovat
osvědčený formát COM:</p>
<div class="SRC">HelloBio PROGRAM FORMAT=COM, WIDTH=16, ENTRY=Start:
Start: MOV AX,CS  ; Naplň segmentový registr DS stejnou hodnotou, jakou má CS.
       MOV DS,AX  ; Nelze k tomu použít <code>MOV DS,CS</code>, neboť taková instrukce není podporována.
       MOV SI,HelloWorldAddress
       MOV CX,HelloWorldSize
       CLD        ; Pro jistotu vynulujeme Direction Flag.
       SUB BX,BX  ; Použijeme základní (nultou) stránku videoadaptéru.
       MOV AH,0Eh ; Číslo funkce BIOS INT 10h.
Next:  LODSB      ; Načtení jednoho znaku řetězce do AL, zvětšení SI.
       INT 10h    ; Vyvolání funkce BIOS pro vypsání znaku.
       LOOP Next  ; Skok pro další znak CX-krát.
       JMP $      ; Program ukončíme nekonečným skákáním na sebe. Bez OS to jinak nejde.
HelloWorldAddress DB "Hello, world!",10
HelloWorldSize    EQU $ - HelloWorldAddress
  ENDPROGRAM HelloBio</div>
<p>Po spuštění programu HelloBio.com v emulátoru DosBOX opět dostáváme očekávaný výstup
<span class="MSG">Hello, world!</span>. Vzhledem k zacyklení programu na konci ale pak
budeme muset DosBOX havarijně ukončit.</p>

<h4 id="HelloL32"><a href="#top">Linux 32 bitů</a></h4>
<p>Spustitelný formát pro Linux se v EuroAssembleru nazývá ELFX, generované programy
v tomto formátu dostávají souborovou příponu <q>.x</q>, které se ale můžeme zbavit přejmenováním pomocí
<code class="MSG">mv HelloL32.x HelloL32</code> a mít tak spustitelný program bez přípony, jak je v Linuxu zvykem.
Kromě parametrů pseudoinstrukce PROGRAM FORMAT=ELFX a WIDTH=32 ještě musíme povinně určit vstupní bod programu,
tedy první prováděnou instrukci. Vstupní bod (ENTRY=) označíme symbolicky návěstím například
Start: nebo Main: apod.</p>
<p>Pokud programy tohoto tutoriálu spouštíme pod MS Windows, ke spuštění linuxové varianty
bychom museli mít ve Windows nainstalován emulátor
<a class="EXTW" href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL</a>.</p>

<p>Pro vypsání textu v Linuxu opět musíme chtě nechtě využít aplikační rozhraní jeho kernelu.
V případě 32bitového systému se funkce kernelu vyvolává instrukcí <code>INT 80h</code>
a její parametry se zadávají do registrů EBX, ECX, EDX, ESI, EDI, EBP, přičemž identifikátor
volané funkce se zadává v EAX. Naplníme samozřejmě pouze ty vstupní registry, které funkce jádra vyžaduje,
v případě funkce zápisu (<em>sys_write</em> má tři parametry) to jsou registry EBX, ECX, EDX.
Volání kernelu vrací výsledek funkce v registru EAX, ostatní registry se vracejí nezměněny.
<br>Pro vypsání řetězce "Hello, world!" budeme tedy potřebovat funkci <em>sys_write</em> zapisující
na standardní výstup. Podle dokumentace
<a class="EXTW" href="https://syscalls32.paolostivanin.com/">Linux Syscall Reference (32 bit)</a>
má tato funkce identifikátor EAX=0x04. V prvním parametru zadávaném v registru EBX se určuje
<em>fd</em>, což je file descriptor neboli file handle. Pro standardní výstup je to číslo 1,
pro výstup chyb by to bylo 2. Do dalších registrů zadáme druhý a třetí parametr, což je adresa a velikost
vypisovaného řetězce. Velikost bychom mohli zadat číslem (v našem příkladě <code>MOV EDX,13</code>),
rozumnější je ale zadat ji nepřímo, jako rozdíl adresy $ a adresy HelloWorldAddress.
Pokud bychom později prodloužili nebo zkrátili řetězec HelloWordAddress, jeho velikost se nastaví samočinně.
Symbol dolaru <em>$</em> označuje aktuální adresu instrukce, v našem případě instrukce EQU.
Jelikož zadáváme délku explicitně, není třeba řetězec zakončovat nulovým znakem.
Zkusíme tedy zadat:</p>
<div class="SRC">HelloL32 PROGRAM FORMAT=ELFX, WIDTH=32, ENTRY=Start:
Start: MOV EAX,4 ; Funkce <em>sys_write</em>.
       MOV EBX,1 ; File descriptor pro standardní výstup.
       MOV ECX,HelloWorldAddress
       MOV EDX,HelloWorldSize
       INT 80h   ; Vypiš řetězec.
       RET
HelloWorldAddress DB "Hello, world!"
HelloWorldSize    EQU $ - HelloWorldAddress
  ENDPROGRAM HelloL32</div>
<p>Program v souboru <q>hello.asm</q> opět přeložíme pomocí <code class="MSG">euroasm hello.asm</code>.
Pokud vše prošlo dobře a EuroAssembler ohlásil</p>
<div class="MSG">I0660 32bit FLAT ELFX file "HelloL32.x" created, size=717. "hello.asm"{11}
I0650 Program "HelloL32" assembled in 3 passes with errorlevel 0. "hello.asm"{11}</div>
<p>můžeme jej zkusit spustit v nativním Linuxu nebo ve WSL povelem <code class="MSG">./HelloL32.x</code>.
V mém případě se na konzoli vypsalo:</p>
<code class="MSG">Hello, world!Segmentation fault (core dumped)</code>.
<p>Program tedy funguje,
ale po vypsání řetězce zhavaroval s chybou <em>Segmentation fault</em>.
Chyba byla v ukončení programu - instrukce RET v Linuxu nestačí, musíme opět použít
funkci kernelu <em>sys_exit</em> s číslem 1. Jako  první parametr jí zadáme nulu,
ostatní parametry nejsou použity. A zároveň na konec řetězce přidáme znak Line Feed (10)
pro odřádkování po skončení výpisu. Carriage Return se v Linuxu obvykle nepoužívá.</p>
<div class="SRC">HelloL32 PROGRAM FORMAT=ELFX, WIDTH=32, ENTRY=Start:
Start: MOV EAX,4 ; Funkce <em>sys_write</em>.
       MOV EBX,1 ; File descriptor pro standardní výstup.
       MOV ECX,HelloWorldAddress
       MOV EDX,HelloWorldSize
       INT 80h   ; Vypiš řetězec.
       MOV EAX,1 ; Funkce <em>sys_exit</em>.
       MOV EBX,0 ; Errorlevel při ukončení programu.
       INT 80h   ; Ukonči program.
HelloWorldAddress DB "Hello, world!",10
HelloWorldSize    EQU $ - HelloWorldAddress
  ENDPROGRAM HelloL32</div>
<p>Po nahrazení RET instrukce pro ukončení programu již program pracuje podle očekávání.</p>

<h4 id="HelloL64"><a href="#top">Linux 64 bitů</a></h4>
<p>Program pro 64bitový Linux vypadá obdobně, liší se parametr WIDTH=64,
který musíme v pseudoinstrukci PROGRAM zadávat, neboť její default je WIDTH=32.
Další věc, která odlišuje 32bitový a 64bitový Linux je volání jádra (funkcí kernelu)
nikoli pomocí <code>INT 80h</code>, nýbrž instrukcí
<a class="EXTW" href="https://www.felixcloutier.com/x86/syscall">SYSCALL</a>.
Liší se také číselné identifikátory funkcí kernelu předávané v RAX
a pořadí registrů pro přenos parametrů: namísto EBX, ECX, EDX, ESI, EDI, EBP
je zadáváme v registrech RDI, RSI, RDX, R10, R8, R9. Jinak ale funkce zůstávají stejné.
Přehled volání jádra je např. v
<a class="EXTW" href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">
Linux System Call Table for x86 64</a>.</p>

<div class="SRC">HelloL64 PROGRAM FORMAT=ELFX, WIDTH=64, ENTRY=Start:
Start: MOV RAX,1 ; Funkce <em>sys_write</em>.
       MOV RDI,1 ; File descriptor pro standardní výstup.
       MOV RSI,HelloWorldAddress
       MOV RDX,HelloWorldSize
       SYSCALL   ; Vypiš řetězec.
       MOV RAX,60; Funkce <em>sys_exit</em>.
       MOV RDI,0 ; Errorlevel při ukončení programu.
       SYSCALL   ; Ukonči program.
HelloWorldAddress DB "Hello, world!",10
HelloWorldSize    EQU $ - HelloWorldAddress
  ENDPROGRAM HelloL64</div>
<p>Při pokusu o přeložení dostáváme řadu varování</p>
<span class="MSG">W2340 This instruction requires option "EUROASM CPU=X64".</span>
<p>I těmito chybami by program fungoval, ale raději mu dáme požadovanou volbu
přidáním řádku <code class="SRC">EUROASM CPU=X64</code> před pseudoinstrukci
<code class="SRC">HelloL64 PROGRAM</code>,
aby zbytečně neupozorňoval, že používáme 64bitové registry.
<br>Po novém přeložení už bychom měli dostat errorlevel 0 a můžeme náš 64bitový program
vyzkoušet:</p>
<div class="MSG">$ ./HelloL64.x
Hello, world!
$</div>

<h4 id="HelloW32"><a href="#top">Windows 32 bitů</a></h4>
<p>Volání funkcí v MS Windows používá aplikační rozhraní <dfn>Win32</dfn> definované
v dynamicky linkovaných knihovnách. Většina základních funkcí je k dispozici v knihovně
&quot;kernel32.dll&quot;.</p>
<p>Budeme opět psát na standardní výstup. Oproti Linuxu zde ale nejsou pevně stanovené
identifikátory souborů <em>fd</em>, jako byly 0 pro standardní vstup, 1 pro standardní výstup
a 2 pro chybový výstup. Místo toho se nejprve musíme operačního systému zeptat,
jaký identifikátor (file handle) je dnes používán pro standardní výstup.
K tomu slouží funkce Win32 nazvaná
<a class="EXTW" href="https://learn.microsoft.com/en-us/windows/console/getstdhandle">GetStdHandle</a>,
které jako parametr zadáme identifikátor standardního výstupu, což je číslo -11.
Hodnota vracená funkcí v registru EAX je pak již <em>file handle</em> použitelný ve funkci
<a class="EXTW" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile">WriteFile</a>.</p>
<p>Zbývá vyřešit, jak funkce Win32 vyvolat a jak jim předat parametry (adresu a velikost řetězce).
32bitový Windows používá volací konvenci <em>standard call</em>, kde se nejprve uloží parametry
na zásobník (PUSH) v pořadí od posledního k prvnímu, a pak se zavolá (CALL) importovaná funkce.
O odstranění uložených parametrů ze zásobníku se postaral programátor dané funkce.
Obvykle to dělá tak, že místo obyčejného návratu pomocí RET
použije <code>RET n*4</code>, kde <code>n</code> je počet parametrů na zásobníku.
Instrukce <code>RET n*4</code> funguje jako obyčejný návrat z funkce (RET),
ale navíc pak zvětší ESP o <em>n*4</em> bajty.</p>
<p>Jak zařídit, aby instrukce CALL poznala, že voláme dynamicky linkovanou funkci?
Buď do programu začleníme importní knihovnu <a class="EXT" href="../objlib">winapi.lib</a>,
anebo jméno funkce definujeme pseudoinstrukcí <a class="EXT" href="../eadoc/#IMPORT">IMPORT</a>.
Tato pseudoinstrukce má parametr LIB=, kterým definujeme soubor (knihovnu), jež funkci obsahuje.
Knihovna je v popisu každé funkce na webu Microsoftu definována v odstavci <em>Requirements</em>.
Pokud je název knihovny &quot;kernel32.dll&quot;, nemusíme ji parametrem LIB= uvádět.
Zkusíme tedy napsat spustitelný program pro Windows, který bude mít formát PE (Portable Executable):</p>

<div class="SRC">HelloW32 PROGRAM FORMAT=PE, WIDTH=32, ENTRY=Start:
       IMPORT GetStdHandle, WriteFile, ExitProcess ; Použijeme 3 importované funkce z "kernel32.dll".
Start: PUSH -11                    ; 1. parametr: Identifikátor pro standardní výstup.
       CALL GetStdHandle           ; Funkce vrací file handle v EAX.
       PUSH 0                      ; 5. parametr (lpOverlapped): nepoužijeme.
       PUSH lpNumberOfBytesWritten ; 4. parametr: adresa dvojslova pro výsledek (skutečně zapsaný počet bajtů).
       PUSH HelloWorldSize         ; 3. parametr: počet zapisovaných bajtů.
       PUSH HelloWorldAddress      ; 2. parametr: adresa řetězce.
       PUSH EAX                    ; 1. parametr: file handle.
       CALL WriteFile              ; Funkce s 5 parametry zapíše řetězec na standardní výstup.
       PUSH 0                      ; 1. parametr: errorlevel.
       CALL ExitProcess            ; Ukončení programu. Funkce nic nevrací.
HelloWorldAddress      DB "Hello, world!",10
HelloWorldSize         EQU $ - HelloWorldAddress
lpNumberOfBytesWritten DD 0        ; Sem Windows zapíše, kolik znaků WriteFile zapsala.
  ENDPROGRAM HelloW32</div>
<p>Přeložíme jej pomocí <code class="MSG">euroasm hello.asm</code> a výsledek by měl být</p>
<div class="MSG">...
I0180 Assembling source file "hello.asm".
I0270 Assembling source "hello".
I0310 Assembling source pass 1.
I0330 Assembling source pass 2 - final.
I0470 Assembling program "HelloW32". "hello.asm"{1}
I0510 Assembling program pass 1. "hello.asm"{1}
I0510 Assembling program pass 2. "hello.asm"{1}
I0530 Assembling program pass 3 - final. "hello.asm"{1}
I0660 32bit FLAT PE file "HelloW32.exe" created, size=2588. "hello.asm"{16}
I0650 Program "HelloW32" assembled in 3 passes with errorlevel 0. "hello.asm"{16}
I0750 Source "HelloW32" (15 lines) assembled in 2 passes with errorlevel 0.
I0860 Listing file "HelloW32.asm.lst" created, size=2514.
I0980 Memory allocation 512 KB. 68 statements assembled in 1 s.
I0990 EuroAssembler terminated with errorlevel 0.</div>

<p>Po spuštění programu ve Windows povelem <code class="MSG">HelloW32.exe</code> nebo jen
<code class="MSG">HelloW32</code> bychom měli dostat pozdrav <code class="MSG">Hello, world!</code>.</p>

<h4 id="HelloW64"><a href="#top">Windows 64 bitů</a></h4>
<p>MS Windows v 64bitovém režimu používá tytéž Win32 funkce a tytéž knihovny &quot;kernel32.dll&quot;
jako 32bitový Windows, podstatně se ale liší volací konvence: namísto StdCall se používá FastCall.
V této konvenci se pro první čtyři parametry používají RCX, RDX, R8, R9.
Vyžaduje-li funkce více než čtyři parametry, ukládají se na zásobník opět v opačném pořadí
(od posledního do pátého). Pak se na zásobníku rezervuje místo (tzv. <em>shadow space</em>)
pro čtyři parametry předávané v registrech, a to i tehdy, má-li funkce méně než čtyři parametry.
Před zavoláním externí funkce (před instrukcí CALL) musí být navíc zásobník (registr RSP) zaokrouhlen
na celý násobek 16 bajtů. V případě, že jsou funkci předávány parametry typu plovoucí desetinné
čárky, namísto příslušného RCX, RDX, R8, R9 se použije dolní polovina XMM0, XMM1, XMM2, XMM3.
Volaná funkce po skončení neodstraňuje parametry ze zásobníku, o to se musí postarat volající.</p>
<p>Vybaveni těmito znalostmi se pokusíme vypsat řetězec v 64bitových Windows:</p>

<div class="SRC">       EUROASM CPU=X64
HelloW64 PROGRAM FORMAT=PE, WIDTH=64, ENTRY=Start:
       IMPORT GetStdHandle, WriteFile, ExitProcess
Start: TEST SPL,08h                  ; Kontrola zarovnání zásobníku na 16.
       JZ Round                      ; Skok přes PUSH RAX, pokud byl zásobník zaokrouhlený na 16.
       PUSH RAX                      ; Jinak proveď instrukci pro snížení RSP o 8 bajtů.
Round: SUB RSP,4*8                   ; Rezervuj shadow space pro 4 registry.
       MOV RCX,-11                   ; 1. parametr: identifikátor pro standardní výstup.
       CALL GetStdHandle             ; Funkce vrací file handle v RAX.
       ADD RSP,4*8                   ; Návrat ukazatele zásobníku na stav Round.
       PUSH RAX                      ; Instrukce pro snížení RSP o 8 bajtů kvůli zaokrouhlení.
       PUSH 0                        ; 5. parametr (lpOverlapped): nepoužijeme.
       SUB RSP,4*8                   ; Rezervuj shadow space pro 4 registry.
       MOV R9,lpNumberOfBytesWritten ; 4. parametr: dvojslovo pro výsledek (skutečně zapsaný počet bajtů).
       MOV R8,HelloWorldSize         ; 3. parametr: počet zapisovaných bajtů.
       MOV RDX,HelloWorldAddress     ; 2. parametr: adresa řetězce.
       MOV RCX,RAX                   ; 1. parametr: file handle.
       CALL WriteFile                ; Funkce zapíše řetězec na standardní výstup.
       ADD RSP,6*8                   ; Návrat ukazatele zásobníku na stav Round.
       SUB RSP,4*8                   ; Rezervuj shadow space pro 4 registry (zbytečné).
       MOV RCX,0                     ; 1. parametr - errorlevel.
       CALL ExitProcess              ; Funkce nic nevrací.
HelloWorldAddress      DB "Hello, world!",10
HelloWorldSize         EQU $ - HelloWorldAddress
lpNumberOfBytesWritten DQ 0          ; Sem Windows zapíše, kolik znaků WriteFile zapsala.
  ENDPROGRAM HelloW64</div>

<h3 id="Macros"><a href="#top">Zkusíme to s makry</a></h3>
<p>Jak je vidět zejména v posledním případě pro 64bitový Windows, vyvolání tak prosté funkce,
jako je vypsání pozdravu, vyžaduje napsání poměrně velkého počtu strojových instrukcí.
Pokusíme se s tím něco udělat. Klíčem k redukci programátorské práce je použití makroinstrukcí.
Každá makroinstrukce neboli <dfn>makro</dfn> může nahradit celou řadu strojových instrukcí,
přitom makro může akceptovat vstupní parametry a upravovat tak svou činnost podle potřeby programátora.</p>
<p>Syntaxe jazyka makroinstrukcí a jeho nuance jsou vlastnosti použitého asembleru,
prakticky každý asembler je řeší po svém. Zde se zaměříme na psaní makroinstrukcí v jazyce EuroAssembler.
Jeho aparát používá pro výrazy používané při psaní maker znak procenta <dfn>%</dfn>.
Pseudoinstrukce začínající procentem se týkají maker nebo pomocných proměnných asembleru.
Zatímco běžné paměťové proměnné zapsané pomocí pseudoinstrukce
<a class="EXT" href="../eadoc/#D">D</a>, například <code>OrdinaryVar DD 1234h</code>
definují místo v paměti nazvané OrdinaryVar a obsahující DWORD s hodnotou 1234h,
proměnná <code>%OrdinaryVar</code> představuje něco zcela jiného: proměnnou samotného EuroAssembleru.
Její místo není v přeloženém programovém kódu nebo v jeho datech,
ale existuje jen během práce EuroAssembleru v jeho paměti.
Její obsah může být nastaven pseudoinstrukcí <a class="EXT">%SET</a> a může jím být
jakýkoli text, aritmetický výraz, řetězec, číslo apod.
Kdykoli se pak ve zdrojovém textu objeví %OrdinaryVar, bude tímto textem nahrazeno.</p>
<div class="PRE">MyAddress %SET "Hello, world!"
MySize    %SET 13
HelloWorldAddress  DB %MyAddress    ; Totéž jako HelloWorldAddress DB "Hello, world"
HelloWorldSize     EQU %MySize      ; Totéž jako HelloWorldSize    EQU 13
</div>

<p>Makroinstrukce jsou definovány dvojicí blokových pseudoinstrukcí %MACRO a %ENDMACRO.
Identifikátor v poli návěstí %MACRO se stává názvem makroinstrukce. Strojové instrukce uvnitř bloku
%MACRO/%ENDMACRO jsou tělem makra. Kdykoli ve zdrojovém kódu napíšeme název makroinstrukce,
nahradí se všemi strojovými instrukcemi z jeho definice. Příklad makra pro 64bitový Linux:</p>
<div class="PRE">; Definice makra WriteString:

WriteString %MACRO StringAddress, StringSize
     MOV RAX,1   ; Funkce <em>sys_write</em> v 64bitovém Linuxu.
     MOV RDI,1   ; File descriptor pro standardní výstup.
     MOV RSI, %1 ; První argument makra.
     MOV RDX, %2 ; Druhý argument makra.
     SYSCALL
    %ENDMACRO WriteString

; Použití (expanze) makra WriteString:

     WriteString HelloWorldAddress, HelloWorldSize
     ; Zde by měl vypsat řetězec "Hello, world!".

HelloWorldAddress  DB "Hello, world!",10
HelloWorldSize     EQU $ - HelloWorldAddress</div>

<p>Nadefinovali jsme makro nazvané WriteString se dvěma parametry: adresou řetězce a jeho délkou.
Uvedení názvu makra v programu pak způsobí jeho rozvinutí do pěti strojových instrukcí,
přičemž první a druhý parametr jsou k dispozici jako proměnné %1 a %2.
Místo číselného označení proměnných parametrů (%1, %2) bychom také mohli použít formální názvy parametrů tak,
že názvu parametru v definici makra (StringAddress, StringSize) předřadíme v těle makra znak procenta:</p>

<div class="PRE">; Definice makra WriteString:

WriteString %MACRO StringAddress, StringSize
     MOV RAX,1                ; Funkce <em>sys_write</em> v 64bitovém Linuxu.
     MOV RDI,1                ; File descriptor pro standardní výstup.
     MOV RSI, %StringAddress  ; První argument makra.
     MOV RDX, %StringSize     ; Druhý argument makra.
     SYSCALL
    %ENDMACRO WriteString</div>

<p>Makro můžeme dále vylepšit tak, že file descriptor pro standardní výstup předávaný v RDI nebudeme zadávat natvrdo jako číslo 1,
ale zadáme jej jako parametr. A abychom nemuseli tento parametr uvádět v případě, že použijeme jeho obvyklou hodnotu 1,
zadáme jej jako <em>klíčový parametr</em>, tedy s rovnítkem a s defaultní hodnotou 1:</p>
<div class="PRE">WriteString %MACRO StringAddress, StringSize, fd=1
     MOV RAX,1                ; Funkce <em>sys_write</em> v 64bitovém Linuxu.
     MOV RDI,%fd              ; File descriptor.
     MOV RSI, %StringAddress  ; První argument.makra.
     MOV RDX, %StringSize     ; Druhý argument.makra.
     SYSCALL
    %ENDMACRO WriteString

    WriteString HelloWorldAddress, HelloWorldSize
    ; Zde by měl vypsat řetězec "Hello, world!" na standardní výstup, neboť jsme nezměnili třetí parametr fd=1.
</div>
<p>Stejné makro nyní můžeme použít i pro psaní na chybový výstup místo standardního; stačí přidat parametr fd=2.</p>

<h3 id="Literals"><a href="#top">Literál namísto symbolu</a></h3>

<p>EuroAssembler dovoluje definovat paměťové proměnné pomocí <em>literálů</em>, tj. bezprostředně zadaných hodnot.
Namísto definování řetězce pseudoinstrukcí DB a vymýšlení jeho symbolického jména
jej definujeme až při jeho použití v instrukci:
<div class="PRE">ClassicVar  DB "Memory variable defined classically.",10
     WriteString ClassicVar, 36                              ; Použita klasická definice řetězce.
     WriteString =B "Memory variable defined as literal.",35 ; Použita definice literálem.</div>
<p>Literál se definuje rovnítkem, za nímž následuje určení typu (BYTE, WORD, DWORD, QWORD nebo jen B, W, D, Q)
a pak jeho hodnota. Výhodou literálu oproti symbolu je, že mu nemusíme vymýšlet název proměnné
a hned vidíme jeho hodnotu v instrukci, kde byl použit.</p>

<p>S použitím makrojazyka a literálů nyní můžeme pro vypsání řetězce na standardní výstup napsat vlastní makra.
Nazveme je třeba <em>StdOutput</em>. Tato práce již byla vykonána a makra jsou uvedena v knihovnách dodávaných
spolu s EuroAssemblerem, konkrétně v makroknihovnách
<a class="EXT" href="../maclib/dosapi.htm#StdOutput">dosapi.htm</a> pro DOS 16 bitů,
<a class="EXT" href="../maclib/linapi.htm#StdOutput">linapi.htm</a> pro Linux 32 bitů,
<a class="EXT" href="../maclib/linabi.htm#StdOutput">linabi.htm</a> pro Linux 64 bitů,
<a class="EXT" href="../maclib/winapi.htm#StdOutput">winapi.htm</a> pro Windows 32 bitů,
<a class="EXT" href="../maclib/winabi.htm#StdOutput">winabi.htm</a> pro Windows 64 bitů.</p>
<p>S použitím makra StdOutput a s použitím literálů se naše zkušební prográmky podstatně zjednoduší,
stačí includovat patřičnou knihovnu podle cílové platformy. Inkludování pomocí pseudoinstrukce
<a class="EXT" href="../eadoc/#INCLUDE">INCLUDE</a> způsobí to, že jmenovaná knihovna
(což je jen další zdrojový soubor) nahradí řádek s povelem <code>INCLUDE "knihovna.htm"</code>.
Knihovny s rozhraním API (16 a 32 bit) nebo ABI (64bit) obsahují definice maker StdOuput,
TerminateProgram a několik dalších.</p>
<p>Pro zjednodušení zapíšeme programy pro DOS, Linux i Windows do jednoho zdrojového souboru <q>hello.asm</q>.
Vzhledem k tomu, že se makra pro zápis na standardní výstup a pro ukončení programu jmenují
ve všech knihovnách stejně (StdOutput a TerminateProgram), měli bychom před nadefinováním
dalšího programu říci EuroAssembleru pomocí <a class="EXT" href="../eadoc/#pcDROPMACRO">%DROPMACRO</a>,
aby zapomenul jejich definice z předchozí knihovny.</p>
<div class="SRC" title="hello.asm">         EUROASM CPU=X64

HelloDos PROGRAM FORMAT=COM, WIDTH=16                         ; Verze pro DOS.
          INCLUDE dosapi.htm
          StdOutput =B "Hello, world!"
          TerminateProgram
         ENDPROGRAM HelloDos

         %DROPMACRO *

HelloL32 PROGRAM FORMAT=ELFX, WIDTH=32, ENTRY=Start            ; Verze pro Linux 32 bit.
          INCLUDE linapi.htm
Start:    StdOutput =B "Hello, world!"
          TerminateProgram
         ENDPROGRAM HelloL32

         %DROPMACRO *

HelloL64 PROGRAM FORMAT=ELFX, WIDTH=64, ENTRY=Start            ; Verze pro Linux 64 bit.
          INCLUDE linabi.htm
Start:    StdOutput =B "Hello, world!"
          TerminateProgram
         ENDPROGRAM HelloL64

         %DROPMACRO *

HelloW32 PROGRAM FORMAT=PE, WIDTH=32, ENTRY=Start              ; Verze pro Windows 32 bit.
          INCLUDE winapi.htm
Start:    StdOutput =B "Hello, world!"
          TerminateProgram
         ENDPROGRAM HelloW32

         %DROPMACRO *

HelloW64 PROGRAM FORMAT=PE, WIDTH=64, ENTRY=Start              ; Verze pro Windows 64 bit.
          INCLUDE winabi.htm
Start:    StdOutput =B "Hello, world!"
          TerminateProgram
         ENDPROGRAM HelloW64</div>
<p>Po přeložení výše uvedeného souboru známým povelem <code class="MSG">euroasm hello.asm</code>
bychom měli dostat pět programů s názvy <q>HelloDos.com</q>, <q>HelloL32.x</q>,
<q>HelloL64.x</q>, <q>HelloW32.exe</q>, <q>HelloW64.exe</q>,
které hned můžeme s pomocí emulátorů (DosBox, WSL, wine) vyzkoušet.</p>

<h4 id="MacroDefinitions"><a href="#top">Definice a expanze maker</a></h4>
<p>Blok instrukcí mezi %MACRO a %ENDMACRO představuje <em>definici</em> makra.
Samotná definice ještě nic zajímavého nedělá, pouze zabírá místo v zdrojovém kódu.
Teprve až se pokusíme makroinstrukci použít v programu, dojde k její <em>expanzi</em>,
tedy k nahrazení názvu makra instrukcemi z jeho těla (a  možná taky k projevení chyb,
pokud jsme nějakou při psaní makra spáchali).</p>
<p>Definici makra můžeme v EuroAssembleru napsat na začátku bloku PROGRAM/ENDPROGRAM,
nebo před tímto  blokem, případně i v separátním includovaném souboru (knihovně), avšak
vždy předtím, než bude makro poprvé použito (expandováno).
Makroinstrukce (a také proměnné EuroAssembleru začínající znakem procenta)
totiž na rozdíl od běžných symbolů <em>procházejí hranicemi</em> bloku PROGRAM/ENDPROGRAM,
jsou viditelné v celém zdrojovém kódu počínaje jejich definicí.
V tom se liší od <em>symbolů</em>, které musí být v bloku PROGRAM/ENDPROGRAM unikátní,
nesmějí se opakovat.</p>
<p>Makra a %proměnné tedy mohou být <em>redefinovány</em> i v rámci téhož zdrojového souboru.
Redefinování makra je ale poněkud neobvyklé, proto na ně EuroAssembler reaguje
varovnou zprávou <code class="MSG">W2512 Overwriting previously defined macro</code>.
Pokud tedy chceme makro přepsat jinou definicí makra se stejným názvem, je lepší ho
nejprve nechat zapomenout pomocí pseudoinstrukce %DROPMACRO.</p>



<h3 id="Input"><a href="#top">Načtení informace od uživatele</a></h3>
<p>Předat text uživateli našeho programu bylo snadné, v předchozích příkladech jsme použili
službu operačního systému obvykle nazvanou <em>write</em> nebo podobně,
možná zabalenou do makra StdOutput. Teď se podíváme na opačný případ,
kdy chceme něco získat od uživatele. Jednou z možností je načtení argumentů z příkazového řádku,
kterým jsme náš program spustili.</p>
<h4 id="GetArg"><a href="#top">Z příkazového řádku</a></h4>
<p>Pokud se náš program jmenuje například MyCalc
a v konsole jsme napsali <code class="MSG">MyCalc.exe&nbsp;2&nbsp;+&nbsp;3</code>, operační systém nám poskytne
řetězec obsahující tutéž informaci <span class="PRE">MyCalc.exe&nbsp;2&nbsp;+&nbsp;3</span>.
Tedy název spuštěného programu (nultý argument) a pak přesnou kopii následujících znaků včetně mezer
či jiných znaků oddělujících argumenty. Kde je tento řetězec uložen?</p>
<p>V DOSu leží ve struktuře PSP počínaje bajtem 81h. Předchozí bajt na adrese 80h obsahuje délku řetězce.
<p>Ve Windows dostaneme ukazatel na obdobný řetězec pomocí funkce API
<a class="EXTW" href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinea">
GetCommandLine</a>.
Pokud bychom chtěli mít každý argument zvlášť, musíme řetězec načítat např. instrukcí LODSB
a reagovat na oddělovací znaky (této činnosti se říká <em>parsing</em>).</p>
<p>V Linuxu je to trochu jinak: řetězec už je rozparsován na jméno programu a na jeho mezerou oddělené argumenty,
přičemž všechny tyto položky jsou zakončeny nulovým znakem a ukazatele na ně jsou uloženy na zásobníku.
Schématicky je to znázorněno na obrázku u makra <a class="EXT" href="../maclib/linabi.htm#GetArg">GetArg</a>.
Adresy zásobníkových položek na tomto obrázku rostou směrem nahoru. Šířka každé položky je 8 bajtů v 64bitovém programu
nebo 4 bajty v 32bitovém programu. Instrukcí <code class="SRC">MOV RCX,[RSP]</code> na začátku programu bychom tedy
do RCX načetli celkový počet argumentů. Adresu prvního argumentu získáme pomocí
<code class="SRC">MOV RSI,[RSP+2*8]</code>, adresu druhého pomocí <code class="SRC">MOV RSI,[RSP+3*8]</code> atd.</p>

<p>Anebo použijeme již hotové makro <em>GetArg</em> které dodá jednotlivé argumenty již rozparsované
bez ohledu na operační systém. Stačí jen použít patřičnou makroknihovnu pro DOS, Linux nebo Windows v potřebné šířce
16, 32 nebo 64 bitů. Knihovny maker se načítají pseudoinstrukcí INCLUDE, které zadáme jako parametr jméno souboru
<q>dosspi.htm</q>, <q>linapi.htm</q>, <q>linabi.htm</q>, <q>winapi.htm</q> nebo <q>winabi.htm</q>. Makro <em>GetArg</em>
se jmenuje ve všech těchto knihovnách stejně a pro požadovaný argument vrátí ukazatel na něj v rSI a jeho délku v rCX.
Případně vrátí CarryFlag, pokud dotyčný argument nebyl na příkazovém řádku dodán.</p>
<p>Zkusíme naprogramovat primitivní čtyřúkonovou kalkulačku. Po zadání dvou celých čísel rozdělených znaménkem
aritmetické operace by naše kalkulačka měla vrátit správný výsledek. Přípustné operace budou určeny znaménkem
<kbd>+</kbd>, <kbd>-</kbd>, <kbd>*</kbd>, <kbd>/</kbd> pro sčítání, odčítání, násobení, dělení.</p>
<p>Jako cílovou platformu vybereme 32bitové Windows, odpovídající knihovnou bude tedy <q>winapi.htm</q>.
Zapíšeme-li na příkazový řádek <code class="MSG">CalcW32 3 + 4</code>, chceme dostat výsledek
<code class="MSG">7</code>. Soubor se zdrojovým kódem nazvěme třeba <q>calc.asm</q>.Zapíšeme do něj:</p>
<div class="SRC" title="calc.asm">CalcW32 PROGRAM FORMAT=PE, WIDTH=32, ENTRY=Start:, IconFile=
        INCLUDE winapi.htm
Start:  GetArg 1          ; Použij makro k načtení 1. argumentu našeho programu.
        JC Error:         ; Pokud argument chybí, skoč na návěstí Error.
        ; ESI ukazuje na první argument (číslici 3), v ECX je jeho délka (1 bajt).
        ; Nemáme dost registrů pro trvalé zapamatování všech argumentů,
        ; takže pro uložení obou číselných argumentů a znaménka operace založíme
        ; tři prázdné řetězcové proměnné Arg1, Arg2, Arg3 v délce jednoho bajtu.
Arg1:   D BYTE            ; Definuj paměťovou proměnnou typu BYTE. Její název je Arg1.
Arg2:   D BYTE
Arg3:   D BYTE
        ; Jelikož jsme úspěšně načetli první argument (CF=0, neskákalo se na návěstí Error:),
        ; uložíme argument do řetězcové proměnné a načteme další.
        MOV EDI,Arg1
        REP MOVSB         ; Přesuň řetězec z adresy ESI na adresu EDI v délce ECX bajtů.
        GetArg 2
        JC Error:
        MOV EDI,Arg2
        REP MOVSB         ; Ulož znak požadované operace (v tomto případě +).
        GetArg 3
        JC Error:
        MOV EDI,Arg3
        REP MOVSB         ; Ulož třetí argument (číslici 4).
        ; Argumenty jsou zadány. Zkusme je pro kontrolu vypsat:
        StdOutput Arg1, Arg2, Arg3, Size=1   ; Kontrolní výpis argumentů.
        CMP [Arg2],'+'    ; Byla zadána operace sčítání?
        JNE Error:        ; Jinou jsme náš program zatím nenaučili.
        StdOutput =B "="  ; Vypíšeme rovnítko, specifikované jako literál.
        MOV AL,[Arg1]     ; První argument do registru AL.
        ADD AL,[Arg3]     ; Přičti k němu třetí argument.
        ; Teď bychom měli vypsat součet z registru AL.
        ; Avšak makro StdOutput vypisuje obsah paměti, nikoli registru.
        ; Musíme proto AL nejprve uložit, třeba do Result.
Result: D BYTE
        MOV [Result],AL
        StdOutput Result, Size=1  ; Výpis výsledného součtu.
        TerminateProgram  ; Makro z knihovny winapi.htm pro ukončení.
Error:  StdOutput Help
Help:   DB "Calculate  number1 operation number2.", 13, 10
        DB "Example:  %^PROGRAM 3 + 4", 13, 10, 0
       ENDPROGRAM
</div>
<p>Mělo by vás zarazit definování proměnných Arg1, Arg2, Arg3 uprostřed toku instrukcí.
To je špatná programátorská technika, která ale v EuroAssembleru funguje díky defaultně
povolenému parametru <code>EUROASM AUTOSEGMENT=ON</code>. Autosegmentace rozlišuje,
zda byla na řádku uvedena strojová instrukce nebo definice dat a podle toho rozděluje
výstup přeložených instrukcí do samostatných sekcí pro programový kód, inicializovaná data
a neinicializovaná data.
Tyto sekce mají tradiční názvy [.text], [.data], [.bss]. Pokud bychom si prohlédli listing
<q>calc.asm.lst</q>, automatickou změnu sekcí tam uvidíme.
<br>Spoléhat na autosegmentaci ale u delších programů není příliš moudré, raději už při psaní
programu zařaďme datové položky Arg* až za programový kód.</p>
<p>Dále si povšimněme řádku nápovědy <code>DB "Example:  %^PROGRAM 3 + 4", 13, 10, 0</code>.
Výraz <em>%^PROGRAM</em> zde nepředstavuje uživatelsky definovanou proměnnou díky znaku
<kbd>^</kbd> (caret) následujícím po znaku procenta.
Takovéto proměnné jsou <em>systémové</em>, jejich hodnota je nastavena samotným EuroAssemblerem,
v tomto konkrétním případě na jméno programu (CalcW32). Systémových proměnných
má EuroAssembler spoustu, každý parametr pseudoinstrukcí EUROASM a PROGRAM
má jednu, viz <a class="EXT" href="../eadoc/euroasm.png">karta nápovědy</a>.</p>

<p>Program se přeložil bez chyby, ale po spuštění vrací  nesprávný výsledek:</p>
<div class="MSG">C:\> CalcW32 3 + 4
3+4=g
C:\></div>
<p>Díky řádku <code>StdOutput Arg1, Arg2, Arg3, Size=1   ; Kontrolní výpis argumentů.</code>
jsme si nechali vypsat, s jakými argumenty byl CalcW32 spuštěn. To je dobrá taktika
pro hledání chyb (debugging). Vidíme, že všechny tři argumenty byly zadány správně.</p>
<p>Zkušenější programátor by v programu CalcW32 našel několik chyb.
Například není určeno, kde má program pokračovat po vypsání nápovědy na řádku s návěstím Error.
Chceme ho poslat na ukončení programu. Přidejme tedy k pseudoinstrukci TerminateProgram návěstí End:,
kam necháme program skočit po vypsání nápovědy. Další chybou, která způsobuje nesprávný výsledek
<span class="MSG">3+4=g</span> je nerozlišování binárního čísla a ASCII kódu jednotlivých číslic,
které nám GetArg vrací. Při zadání číslice <kbd>3</kbd> jako argumentu makro GetArg vrací její ASCII kód,
což je hexadecimálně 33. Obdobně namísto číslice <kbd>4</kbd> dostáváme 34 a protože jsme sčítali
ASCII kódy, výsledkem je 33h + 34h = 67h, což je ASCII kód písmene <kbd>g</kbd> a nikoli číslice 7.
Před použitím instrukce ADD pro sčítání musíme převést ASCII kódy na prostá binární čísla.
To se provede snadno, odečtením 30h neboli '0' od ASCII kódu číslice. Po binárním sečtení pak převedeme
součet přičtením 30h a tento ASCII kód již můžeme nechat vypsat jako výsledek pomocí StdOutput.
Upravíme tedy program CalcW32 takto:</p>
<div class="SRC">
CalcW32 PROGRAM FORMAT=PE, WIDTH=32, ENTRY=Start:
        INCLUDE winapi.htm
[.text] ; Takto se v EuroAssembleru označuje, že budou následovat strojové instrukce.
Start:  GetArg 1         ; Použij makro k načtení 1. argumentu našeho programu.
        JC Error:        ; Pokud argument chybí, skoč na návěstí Error.
        ; ESI ukazuje na první argument (číslici 3), v ECX je jeho délka (1 bajt).
        MOV EDI,Arg1
        REP MOVSB        ; Přesuň řetězec z adresy ESI na adresu EDI v délce ECX bajtů.
        GetArg 2
        JC Error:
        MOV EDI,Arg2
        REP MOVSB        ; Ulož znak požadované operace (v tomto případě +).
        GetArg 3
        JC Error:
        MOV EDI,Arg3
        REP MOVSB        ; Ulož třetí argument (číslici 4).
        ; Argumenty jsou zadány. Zkusme je pro kontrolu vypsat:
        StdOutput Arg1, Arg2, Arg3, Size=1   ; Kontrolní výpis argumentů.
        CMP [Arg2],'+'   ; Byla zadána operace sčítání?
        JNE Error:       ; Jinou jsme náš program zatím nenaučili.
        StdOutput =B "=" ; Vypíšeme rovnítko, specifikované jako literál.
        MOV AL,[Arg1]    ; První argument do registru AL.
        SUB AL,'0'       ; Převod ASCII na binární hodnotu.
        MOV BL,[Arg3]    ; Třetí argument do registru BL.
        SUB BL,'0'       ; Převod ASCII na binární hodnotu.
        ADD AL,BL        ; Binární součet svou celých čísel.
        ADD AL,'0'       ; Převod binárního čísla na ASCII.
        MOV [Result],AL  ; Uložení ASCII výsledku do Arg4.
        StdOutput Result, Size=1  ; Výpis výsledného součtu.
End:    TerminateProgram ; Makro z knihovny winapi.htm pro ukončení.
Error:  StdOutput Help
        JMP End:
[.data] ; Tady skončila sekce programového kódu a začínají data.
Help:   DB "Calculate  number1 operation number2.", 13, 10
        DB "Example:  %^PROGRAM 3 + 4", 13, 10, 0
Arg1:   D BYTE ; Definuj paměťovou proměnnou typu BYTE. Její název je Arg1.
Arg2:   D BYTE
Arg3:   D BYTE
Result: D BYTE
       ENDPROGRAM
</div>
<div class="MSG">C:\> CalcW32 3 + 4
3+4=7
C:\> CalcW32 3 + 7
3+7=:
C:\></div>
<p>Program už funguje dobře, ovšem pouze pro sčítání jednociferných čísel a musíme dodržet mezery mezi argumenty.
Při zadání bez mezer <span class="MSG">CalcW32 3+4</span> program vypisuje nápovědu, tzn. něco se mu nelíbí.
Asi vzal celý řetězec <span class="SRC">3+4</span> jako jeden argument a při pokusu o načtení neexistujícího
druhého a třetího už GetArg vrací chybu.
Budeme muset vyřešit vstup a výstup binárních čísel v ASCII (znakové) podobě pro delší čísla
než pouze jednociferná. Operační systémy bohužel nenabízejí žádnou funkci převodu ASCII čísel na binární a zpět,
vše musíme naprogramovat sami. Máme-li jako vstupní řetězec prvního čísla třeba znaky
<span class="SRC">&quot;123&quot;</span>, očekáváme výsledek v binární podobě jako číslo 123,
tedy hexadecimálně 7Bh v 8bitovém registru neboli 0000007Bh v 32bitovém.
Jak převést řetězec &quot;123&quot; na binární číslo? Každý postupně načtený znak
v rozsahu &quot;0&quot; až &quot;9&quot; nejprve převedeme na číslo v rozsahu 0 až 9 odečtením &quot;0&quot;
neboli odečtením 30h. Pak jsou dva možné přístupy, jak takto získaná čísla postupně skládat do výsledku:</p>
<ol><li>Začneme odzadu (zprava) a každou číslici nejprve vynásobíme její váhou. U trojmístého čísla &quot;123&quot;
je váha trojky 1, váha dvojky 10 a váha jedničky 100. Více číslic není, takže stačí tato tři zvážená čísla sečíst
a dostáváme 3*1 + 2*10 + 1*100 = 123.</li>
<li>Začneme zleva první číslicí (v našem příkladu je to &quot;1&quot;), kterou převedeme na číslo odečtením 30h a vložíme do akumulačního registru. Bude tam tedy binární číslo 1.
Pak načteme další znak a pokud je to číslice (ano, je to &quot;2&quot;), nejprve vynásobíme akumulátor deseti
a pak do něj přičteme odpovídající číslo&nbsp;2. V akumulátoru tedy bude 1*10 + 2 = 12. Opakujeme tento krok, dokud
jsou ve vstupním řetězci číslice. Po třetím kroku bude v akumulátoru 12*10 + 3 = 123. Ve čtvrtém kroku
už se nejedná o číslici, takže končíme s výsledkem 123.</li></ol>
<p>Druhá metoda vypadá jednodušeji, neboť nemusíme počítat narůstající váhy 1, 10, 100 atd.,
místo toho vystačíme s opakovaným násobením deseti.
Nazveme tento algoritmus ASCIItoInteger. Asi jej budeme používat častěji v různých programech,
proto jej zapouzdříme do <em>procedury</em> pomocí pseudoinstrukcí PROC a ENDPROC.
Tu pak budeme volat pomocí <code>CALL ASCIItoInteger</code> kdykoli bude potřeba
převést číslo ze znaků ASCII na celočíselnou binární hodnotu.</p>
<div class="SRC" title="libcvt32.asm">ASCIItoInteger  PROC       ; Definování procedury.
      SUB EAX,EAX          ; Akumulátor výsledku.
      SUB EBX,EBX          ; Registr pro převod čísla.
      SUB ECX,ECX          ; Délka vstupního čísla.
      MOV EDI,10           ; Násobitel.
Next: MOV BL,[ESI+ECX]     ; Načtení ECX-tého znaku ze vstupního řetězce ESI.
      SUB BL,'0'           ; Převod na binární hodnotu, pokud to byla číslice.
      JB End:              ; Skok, pokud to nebyla číslice.
      CMP BL,9             ; Kontrola na horní mez číslice.
      JA End:              ; Skok, pokud to nebyla číslice.
      INC ECX              ; Započtení znaku do registru určujícího délku vstupního čísla.
      MUL EDI              ; Vynásobení akumulátoru deseti.
      JC Over:             ; Skok při přetečení 32 bitů.
      ADD EAX,EBX          ; Přičtení poslední číslice do akumulátoru.
      JMP Next:            ; Zpracování dalšího znaku.
End:  CLC                  ; Návrat s vynulovaným příznakem CF. Binární číslo je v EAX.
Over: RET                  ; Návrat s nastaveným příznakem CF. Výsledek není definován.
    ENDPROC ASCIItoInteger ; Konec procedury.
</div>
<p>Ještě zbývá doplnit proceduru popisem, co přesně dělá, jaké hodnoty očekává na vstupu
a co poskytuje na výstupu.</p>
<div class="SRC" title="libcvt32.asm">; Popis: Procedura ASCIItoInteger převádí řetězec ASCII číslic na binární celé číslo.
; Vstup: ESI obsahuje ukazatel na první znak převáděného čísla v paměti.
;        Procedura načítá znaky dokud obsahují číslice nebo dokud nedojde k přetečení.
; Výstup:Carry Flag je nulový, EAX obsahuje převedené číslo v binárním tvaru.
;        ECX obsahuje počet zpracovaných ASCII znaků ze vstupního řetězce.
; Chyba: Carry Flag je nastaven, pokud by vstupní číslo přesáhlo 32 bitů. EAX je nedefinován.
;        ECX obsahuje počet zpracovaných ASCII znaků ze vstupního řetězce.
; Mění:  EBX,EDX,EDI.
</div>
<p>Vyrobili jsme tak něco jako <em>černou skříňku</em>, u které již nemusíme přemýšlet
nad jejími instrukcemi, ale zabýváme se pouze jejím popisem jako celkem.
Později můžeme celou proceduru umístit do samostatného souboru a vytvořit tím knihovnu,
kterou pak zařadíme do všech programů vyžadujících převody řetězců na čísla.
Knihovnu můžeme nazvat třeba <q>libcvt32.asm</q>.
</p>
<p>V příkladu jednoduché kalkulačky ještě musíme vyřešit opačný převod
binárního čísla na sérii ASCII znaků reprezentující toto číslo ve formátu,
který můžeme tisknout pomocí StdOutput. Opět jsou zde dvě možnosti:</p><ol>
<li>Vstupní číslo opakovaně dělíme deseti a zbytky po celočíselném dělení skládáme do výstupu odzadu.</li>
<li>Vstupní číslo v rozsahu 0..4_294_967_295 dělíme váhou nejvýznamnější číslice (1_000_000_000)
a podíl se zanedbáním zbytku v rozsahu '0'..'9' zapisujeme do výstupu zleva. Pak postup opakujeme se zbytkem,
který dělíme váhou druhé nejvýznamnější číslice (100_000_000) atd, až dojdeme k váze 1.</li></ol>
<p>Druhý přístup je komplikovanější nutností udržovat dělitele 1_000_000_000, 100_000_000, 10_000_000 atd.,
použijeme první metodu. Opět to naprogramujeme jako samostatnou proceduru,
neboť se jedná o často používanou funkci.</p>
<div class="SRC" title="libcvt32.asm">; Popis: Procedura IntegerToASCII převádí binární číslo z registru EAX na řetězec ASCII číslic.
; Vstup: EAX obsahuje vstupní binární bezznaménkové číslo v rozsahu 0..4294967295.
;        ESI obsahuje ukazatel na výstupní pole o velikosti 10 bajtů.
; Výstup:ESI je zvětšen o 0..9 bajtů a ukazuje na první platnou číslici výsledku.
; Chyba: K chybě nemůže dojít.
; Mění:  EAX,ECX,EDX,EDI.
IntegerToASCII PROC        ; Definování procedury.
      MOV ECX,10           ; Počet míst ve výsledku.
      MOV EDI,10           ; Dělitel.
Next1:SUB EDX,EDX          ; Vyšších 32 bitů vstupního čísla je před dělením EDX:EAX nutno vynulovat.
      DIV EDI              ; EAX je teď podíl, EDX zbytek 0..9.
      ADD DL,'0'           ; Převod DL na číslici '0'..'9'.
      DEC ECX              ; Ukládání čísel zezadu.
      JS End1:             ; Skok při ukončení všech deseti číslic.
      MOV [ESI+ECX],DL     ; Uložení číslice na konec výsledku.
      JMP Next1:           ; Zpracování další číslice.
End1: ; Pole výsledku nyní pro vstupní číslo 123 obsahuje "0000000123".
      ; Napozicujeme ESI na první nenulovou číslici výsledku.
      LEA EDI,[ESI+10]     ; Zarážka, za níž už se nebude ESI číst.
Next2:CMP ESI,EDI          ; Konec výstupního čísla?
      JAE End2:            ; Skok pokud ano, ESI bude ukazovat na poslední '0'.
      LODSB                ; Načtení číslice výsledku z ESI, inkrementace ESI.
      CMP AL,'0'           ; Je to začátek platných cifer?
      JE Next2:            ; Skok, pokud nikoli.
End2: DEC ESI              ; Návrat ESI na první platnou číslici.
      RET                  ; Návrat z procedury.
    ENDPROC IntegerToASCII
</div>
<p>Vraťme se k našemu kalkulátoru. Nevýhodou načítání vstupu z příkazového řádku je použitelnost
pouze pro jeden příklad; pro zadání dalšího výpočtu se musí program spustit znovu.
Naučíme se proto číst vstupní znaky zadané z klávesnice, abychom mohli zadávat různé početní příklady opakovaně.</p>
<p>Přímé čtení klávesnice a myši pomocí instrukcí IN a OUT už v době USB periférií
a chráněných operačních systémů není aktuální.
Nejnižší úroveň práce s klávesnicí v DOSu a jeho emulacích poskytuje rozhraní
<a class="EXTW" href="https://www.ctyme.com/intr/int-16.htm">INT 16h</a>, konkrétně funkce
<a class="EXTW" href="https://www.ctyme.com/intr/rb-1755.htm">CHECK FOR KEYSTROKE</a> a pokud tato zjistí, že byla stisknuta klávesa, pak ještě  <a class="EXTW" href="https://www.ctyme.com/intr/rb-1754.htm">GET KEYSTROKE</a>, která vrací ASCII znak v AL.</p>
<div class="PRE">None: MOV AH,01h    ; CHECK FOR KEYSTROKE
      INT 16h       ; Dotaz na klávesnici.
      JZ None:      ; Pokud nic nebylo stisknuto, čekej dále.
      MOV AH,00h    ; GET KEYSTROKE
      INT 16h       ; Získej stisknutý znak v registru AL.</div>

<h4 id="StdInput"><a href="#top">Ze standardního vstupu</a></h4>
<p>Ve Windows, Linuxu, ale i v DOSu je vhodnější funkce pro čtení ze standardního vstupu, která je přesměrovatelná
 a po řádcích vrací text zadaný z klávesnice. Do programu používajícícho
čtení standardního vstupu může být přesměrován obsah jiného textového souboru, například v DOSu takto:
<code class="MSG">type answers.txt | program.exe</code>.</p>
<p>Ke čtení použijeme v DOSU funkci
<a class="EXTW" href="https://www.ctyme.com/intr/rb-2783.htm">READ FROM FILE OR DEVICE</a>, v Linuxu
<a class="EXTW" href="https://manpages.debian.org/unstable/manpages-dev/read.2.en.html">sys_read</a>, ve Windows
<a class="EXTW" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile">ReadFile</a>.
Tyto funkce nevracejí ASCII znaky po každém stisku klávesy, ale implementují řádkový editor.
To znamená, že se napsaný text dá přepisovat nebo mazat pomocí klávesy Backspace a do programu se vrátí
až když stiskneme klávesu Enter. Vracený text bude v Linuxovém programu zakončen znakem Line Feed (0Ah),
v DOSu a ve Windows dvojicí znaků Carriage Return a Line Feed (0Dh 0Ah).
Kromě toho tyto funkce informují o počtu skutečně načtených znaků, včetně oněch zakončujících 0Dh,0Ah.
</p>
<p>Zkusíme náš nepříliš funkční kalkulátor ve zdrojovém souboru <q>calc.asm</q> vylepšit použitím
čtení ze standardního vstupu. Předpokládejme, že již máme textový soubor nazvaný <q>libcvt32.asm</q>,
do něhož jsme uložili obě výše uvedené konverzní procedury ASCIItoInteger a IntegerToASCII.
Tento soubor vložíme do <q>calc.asm</q> pomocí INCLUDE, takže se zdrojový kód kalkulátoru hezky zmenší.</p>
<p>Pro změnu napišme program pro 32bitový Linux:</p>

<div class="SRC" title="calc.asm">CalcL32 PROGRAM FORMAT=ELFX, WIDTH=32, ENTRY=Start:
       INCLUDE libcvt32.asm, linapi.htm ; Použij funkce z těchto knihoven.
[.text] ; Takto se v EuroAssembleru označuje, že budou následovat strojové instrukce.
Start:  StdOutput Prompt     ; Představení programu, výzva k zadání.
        MOV EAX,3            ; Linux32 funkce kernelu č.3 - čtení ze souboru nebo ze zařízení.
        MOV EBX,0            ; 1. parametr je file descriptor standardního vstupu.
        MOV ECX,Buffer       ; 2. parametr je adresa buferu, kam načteme celé zadání příkladu, např. řetězec "3 + 7".
        MOV EDX,SIZE# Buffer ; Atribut SIZE# vrací velikost Buffer v bajtech. Taky bychom mohli použít MOV EDX,80.
        INT 80h              ; Vyvolání funkce kernelu Linuxu.
        ; Buffer je nyní naplněn EAX znaky zadání. Měl by obsahovat dvě ASCII čísla oddělená aritmetickým operátorem.
        MOV ESI,Buffer
Next1:  LODSB                ; Načtení dalšího znaku.
        CMP AL,0             ; Konec vstupního řetězce?
        JE Error:
        CMP AL,' '           ; Oddělující mezery je třeba přeskočit.
        JE Next1:
        DEC ESI              ; Vrácení ukazatele na platný znak.
        CALL ASCIItoInteger  ; Procedura z knihovny libcvt32.asm.
        JC Error:
        MOV [Arg1],EAX       ; Uložení prvního čísla.
        ADD ESI,ECX          ; Umísti ESI za první načtené číslo.
Next2:  LODSB                ; Načtení dalšího znaku
        CMP AL,0             ; Konec vstupního řetězce?
        JE Error:
        CMP AL,' '           ; Oddělující mezery je třeba přeskočit.
        JE Next2:
        MOV [Arg2],AL        ; Uložení operátoru.
Next3:  LODSB                ; Načtení dalšího znaku
        CMP AL,0
        JE Error:
        CMP AL,' '           ; Oddělující mezery je třeba přeskočit.
        JE Next3:
        DEC ESI              ; Vrácení ukazatele na platný znak.
        CALL ASCIItoInteger  ; Procedura z knihovny libcvt32.asm.
        JC Error:
        MOV [Arg3],EAX       ; Uložení druhého čísla.
        CMP [Arg2],'+'
        JE Addition:
        CMP [Arg2],'-'
        JE Subtraction:
        CMP [Arg2],'*'
        JE Multiplication:
        CMP [Arg2],'/'
        JE Division:
Error:  StdOutput Help       ; Pokud byl zadán neplatný operátor, vypíše se nápověda.
        JMP End:
Addition:
        MOV EAX,[Arg1]
        ADD EAX,[Arg3]
        MOV ESI,Result
        CALL IntegerToASCII
        StdOutput ESI
        JMP End:
Subtraction:
        MOV EAX,[Arg1]
        SUB EAX,[Arg3]
        CALL IntegerToASCII
        StdOutput ESI
        JMP End:
Multiplication:
        MOV EAX,[Arg1]
        MUL [Arg3]
        CALL IntegerToASCII
        StdOutput ESI
        JMP End:
Division:
        MOV EAX,[Arg1]
        SUB EDX,EDX
        DIV [Arg3]
        CALL IntegerToASCII
        StdOutput ESI
        JMP End:
End:    TerminateProgram    ; Makro pro ukončení programu.
[.data] ; Tady skončila sekce programového kódu a začínají data.
Arg1    DD 0
Arg2    DD 0
Arg3    DD 0
Result  DB 10 * B
        DB 10,0
Buffer  DB 80 * B
Prompt: DB "%^PROGRAM: Enter two integer numbers separated with arithmetic operator + - * /.",13, 10, 0
Help:   DB "Calculate  number1 operator number2.", 13, 10
        DB "Example:   3 + 4", 13, 10, 0
      ENDPROGRAM
</div>
<p>Při pokusu o přeložení předchozího programu EuroAssembler hlásí tyto chyby:</p>
<div class="MSG">E6610 Symbol "Next1" was already defined at "libcvt32.asm"{38}. "calc.asm"{19}
E6610 Symbol "Next2" was already defined at "libcvt32.asm"{48}. "calc.asm"{25}
E6610 Symbol "End" was already defined at "libcvt32.asm"{16}. "linapi.htm"{763} "calc.asm"{69}</div>

<p>K chybě došlo proto, že jsme v procedurách i v hlavním programu vícekrát použili návěstí nazvaná
<em>Next1, Next2, End</em>. V každém programu může být určité návěstí použito pouze jednou.
Měli bychom vymyslet unikátnější jména, ale existuje ještě lepší řešení, jak se zbavit duplicit:
použít lokální jména symbolů. Lokální jména začínají tečkou a EuroAssembler si je pak ve skutečnosti
pamatuje spojená se jménem procedury nebo programu, v němž bylo návestí definováno.
Takže <em>End</em> v proceduře <em>IntegerToASCII</em> se po přejmenování na <em>.End</em>
uloží jako <em>IntegerToASCII.End</em> a nebude pak kolidovat s Endem v programu <em>CalcL32</em>.</p>
<p>Jak je to vlastně s tečkami před názvem symbolu a s dvojtečkami za ním?
Tečka na začátku označuje symbol jako lokální, ve skutečnosti je jméno symbolu modifikováno
připojení názvu jmenného prostoru (programu, procedury, struktury) před lokální jméno.
Viz také odstavec <a class="EXT" href="../eadoc/#Namespace">jmenného prostoru</a> v manuálu.</p>
<p>Dvojtečka může, ale nemusí být připojena za název symbolu a zdůrazňuje tím, že to je symbol
a nikoli třeba jméno struktury, registru, instrukce. Na rozdíl od většiny jiných asemblerů
může být dvojtečka v &euro;ASM připojena za jméno symbolu nejen při jeho definici v poli návěstí,
ale také kdykoli je symbol zmiňován, například <code class="SRC">MOV RSI, Symbol:</code>.
A pokud je dvojtečka dvojitá, zároveň tím označuje globální viditelnost symbolu,
nemusíme ji pak explicitně stanovovat pomocí <code class="SRC">GLOBAL Symbol</code>,
případně pomocí PUBLIC nebo EXTERN.</p>
<p>Po opravě symbolů Next1, Next2, End1, End2 v knihovně <q>libcvt32.asm</q> na lokální
přidáním tečky před jejich jméno by už měl jít program přeložit bez chyb a můžeme jej vyzkoušet
s různými i delšími čísly a operacemi.</p>
<p>Vidíme, že načítání argumentů ze standardního vstupu funguje lépe než jejich odebírání
z příkazového řádku programu. Stejně ale bylo třeba program <code>./CalcL32.x</code> spouštět
po každém příkladu znova, neboť jsme zatím nenaprogramovali přechod na nové zadání
po každém úspěšném výpočtu. To snadno napravíme, stačí u návěstí End místo TerminateProgram
zařadit skok na začátek, tedy <code class="SRC">End: JMP Start:</code>.
Anebo ještě lépe: nahradíme všechny skoky na End: skokem na Start:.  </p>
<p>Další změnou bude náhrada volání kernelu Linux makrem
<a class="EXT" href="../maclib/linapi.htm#StdInput">StdInput</a> z knihovny <q>linapi.htm</q>,
která dělá v podstatě totéž a je snadno nahraditelné stejnojmenným makrem z knihoven pro jiné
operační systémy.</p>
<p>Poslední věc k opravě předchozího zdrojového kódu jsou redundance ve výpočtu aritmetických operací
Addition, Subtraction, Multiplication, Division: načtení prvního čísla
<code>MOV EAX,[Arg1]</code> může být provedeno pouze jednou a pak použito pro všechny čtyři možné operace.
<br>Instrukce</p>
<div class="PRE">   CALL IntegerToASCII
   StdOutput ESI
   JMP End: </div>
<p>se opakují, takže u druhé, třetí a čtvrté aritmetické operace je můžeme nahradit skokem na tu první.
Zdrojový kód programu v souboru <q>calc.asm</q> se těmito zásahy zkrátí:</p>

<div class="SRC" title="calc.asm">CalcL32 PROGRAM FORMAT=ELFX, WIDTH=32, ENTRY=Start:
       INCLUDE libcvt32.asm, linapi.htm ; Použij funkce z těchto knihoven.
[.text] ; Takto se v EuroAssembleru označuje, že budou následovat strojové instrukce.
Start:  StdOutput Prompt     ; Představení programu, výzva k zadání.
        StdInput Buffer      ; Načtení zadání do proměnné Buffer.
        MOV ESI,Buffer
Next1:  LODSB                ; Načtení dalšího znaku.
        CMP AL,0             ; Konec vstupního řetězce?
        JE Error:
        CMP AL,' '           ; Oddělující mezery je třeba přeskočit.
        JE Next1:
        DEC ESI              ; Vrácení ukazatele na platný znak.
        CALL ASCIItoInteger  ; Procedura z knihovny libcvt32.asm.
        JC Error:
        MOV [Arg1],EAX       ; Uložení prvního čísla.
        ADD ESI,ECX          ; Umísti ESI za první načtené číslo.
Next2:  LODSB                ; Načtení dalšího znaku
        CMP AL,0             ; Konec vstupního řetězce?
        JE Error:
        CMP AL,' '           ; Oddělující mezery je třeba přeskočit.
        JE Next2:
        MOV [Arg2],AL        ; Uložení operátoru.
Next3:  LODSB                ; Načtení dalšího znaku
        CMP AL,0
        JE Error:
        CMP AL,' '           ; Oddělující mezery je třeba přeskočit.
        JE Next3:
        DEC ESI              ; Vrácení ukazatele na platný znak.
        CALL ASCIItoInteger  ; Procedura z knihovny libcvt32.asm.
        JC Error:
        MOV [Arg3],EAX       ; Uložení druhého čísla.
        MOV EAX,[Arg1]       ; Načteme první argument do EAX a pak se podíváme na operátor.
        CMP [Arg2],'+'
        JE Addition:
        CMP [Arg2],'-'
        JE Subtraction:
        CMP [Arg2],'*'
        JE Multiplication:
        CMP [Arg2],'/'
        JE Division:
Error:  StdOutput Help       ; Pokud byl zadán neplatný operátor, vypíše se nápověda.
        TerminateProgram     ;  a program se ukončí.
Addition:
        ADD EAX,[Arg3]
Print:  MOV ESI,Result
        CALL IntegerToASCII
        StdOutput ESI
        JMP Start:
Subtraction:
        SUB EAX,[Arg3]
        JMP Print:
Multiplication:
        MUL [Arg3]
        JMP Print:
Division:
        SUB EDX,EDX
        DIV [Arg3]
        JMP Print
[.data] ; Tady skončila sekce programového kódu a začínají data.
Arg1    DD 0
Arg2    DD 0
Arg3    DD 0
Result  DB 10 * B
        DB 10,0
Buffer  DB 80 * B
Prompt: DB 13,10,"%^PROGRAM: Enter two integer numbers separated with arithmetic operator + - * /.",13, 10, 0
Help:   DB "Calculate  number1 operator number2.", 13, 10
        DB "Example:   3 + 4", 13, 10, 0
      ENDPROGRAM
</div>

<p>Máme tedy fungující kalkulátor <q>calc.asm</q> pro 32bitový Linux. Portace pro Windows 32 bitů je snadná:
místo <code class="SRC">CalcL32 PROGRAM FORMAT=ELFX, WIDTH=32, ENTRY=Start:</code>
použijeme <code class="SRC">CalcW32 PROGRAM FORMAT=PE, WIDTH=32, ENTRY=Start:</code>
a místo <code class="SRC"> INCLUDE libcvt32.asm, linapi.htm</code> použijeme
<code class="SRC">INCLUDE libcvt32.asm, winapi.htm</code>. To je vše, ostatní instrukce se nemění
a makra StdOutput, StdInput a TerminateProgram mění pouze svoje tělo, ale nikoli název.</p>
<p>O něco málo složitější to bude s portací programu pro 64 bitů. Zatímco v 32bitovém módu
se ke práci s daty i s adresami používaly 32bitové registry, v 64bitovém módu se šířka
adres zvětšuje na 64 bitů, zatímco defaultní šířka dat zůstává 32 bitů (i když se dá také zvětšit na 64 bitů
použitím registrů začínajících na R).
Dále je třeba si pamatovat, že zápis do 32bitového registru zároveň nuluje horních 32 bitů odpovídajícího
64bitového registru. Tedy <code>SUB EAX,EAX</code> nuluje nejen registr EAX, ale také horní (významnější)
polovinu registru RAX.</p>
<p>Naše knihovna pro konverzi celých čísel na ASCII a zpět bude po portaci na 64 bitů vypadat mírně odlišně.
Nazvěmě ji <q>libcvt64.asm</q>:</p>

<div class="SRC" title="libcvt64.asm">; Popis: Procedura ASCIItoInteger převádí řetězec ASCII číslic na binární celé číslo.
; Vstup: RSI obsahuje ukazatel na první znak převáděného čísla v paměti.
;        Procedura načítá znaky dokud obsahují číslice nebo dokud nedojde k přetečení.
; Výstup:Carry Flag je nulový, EAX obsahuje převedené číslo v binárním tvaru.
;        RCX obsahuje počet zpracovaných ASCII znaků ze vstupního řetězce.
; Chyba: Carry Flag je nastaven, pokud by vstupní číslo přesáhlo 32 bitů. EAX je nedefinován.
;        RCX obsahuje počet zpracovaných ASCII znaků ze vstupního řetězce.
; Mění:  RBX,RDX,RDI.
ASCIItoInteger  PROC        ; Definování procedury.
       SUB EAX,EAX          ; Akumulátor výsledku.
       SUB EBX,EBX          ; Registr pro převod čísla.
       SUB ECX,ECX          ; Délka vstupního čísla.
       MOV EDI,10           ; Násobitel.
.Next: MOV BL,[RSI+RCX]     ; Načtení RCX-tého znaku ze vstupního řetězce RSI.
       SUB BL,'0'           ; Převod na binární hodnotu, pokud to byla číslice.
       JB .End:             ; Skok, pokud to nebyla číslice.
       CMP BL,9             ; Kontrola na horní mez číslice.
       JA .End:             ; Skok, pokud to nebyla číslice.
       INC ECX              ; Započtení znaku do registru určujícího délku vstupního čísla.
       MUL EDI              ; Vynásobení akumulátoru deseti.
       JC .Over:            ; Skok při přetečení 32 bitů.
       ADD EAX,EBX          ; Přičtení poslední číslice do akumulátoru.
       JMP .Next:           ; Zpracování dalšího znaku.
.End:  CLC                  ; Návrat s vynulovaným příznakem CF. Binární číslo je v EAX.
.Over: RET                  ; Návrat s nastaveným příznakem CF. Výsledek není definován.
     ENDPROC ASCIItoInteger ; Konec procedury.


; Popis: Procedura IntegerToASCII převádí binární číslo z registru EAX na řetězec ASCII číslic.
; Vstup: EAX obsahuje vstupní binární bezznaménkové číslo v rozsahu 0..4294967295.
;        RSI obsahuje ukazatel na výstupní pole o velikosti 10 bajtů.
; Výstup:RSI je zvětšen o 0..9 bajtů a ukazuje na první platnou číslici výsledku.
; Chyba: K chybě nemůže dojít.
; Mění:  RAX,RCX,RDX,RDI.
IntegerToASCII PROC         ; Definování procedury.
       MOV ECX,10           ; Počet míst ve výsledku.
       MOV EDI,10           ; Dělitel.
.Next1:SUB EDX,EDX          ; Vyšších 32 bitů vstupního čísla je před dělením EDX:EAX nutno vynulovat.
       DIV EDI              ; EAX je teď podíl, EDX zbytek 0..9.
       ADD DL,'0'           ; Převod DL na číslici '0'..'9'.
       DEC ECX              ; Ukládání čísel zezadu.
       JS .End1:            ; Skok při ukončení všech deseti číslic.
       MOV [RSI+RCX],DL     ; Uložení číslice na konec výsledku.
       JMP .Next1:          ; Zpracování další číslice.
.End1: ; Pole výsledku nyní pro vstupní číslo 123 obsahuje "0000000123".
       ; Napozicujeme ESI na první nenulovou číslici výsledku.
       LEA RDI,[RSI+10]     ; Zarážka, za níž už se nebude ESI číst.
.Next2:CMP RSI,RDI          ; Konec výstupního čísla?
       JAE .End2:           ; Skok pokud ano, ESI bude ukazovat na poslední '0'.
       LODSB                ; Načtení číslice výsledku z ESI, inkrementace ESI.
       CMP AL,'0'           ; Je to začátek platných cifer?
       JE .Next2:           ; Skok, pokud nikoli.
.End2: DEC RSI              ; Návrat ESI na první platnou číslici.
       RET                  ; Návrat z procedury.
     ENDPROC IntegerToASCII</div>

<p>Kód kalkulátoru pro 64bitový operační systém se změní jen nepatrně, neboť zůstaneme omezeni
na 32bitová čísla a práce s neadresními registry zůstane stejná.
Namísto 32bitových knihoven <em>libcvt32.asm, linapi.htm, winapi.htm</em>
budeme načítat knihovny <em>libcvt64.asm, linabi.htm, winabi.htm</em>.
Namísto <code class="SRC">MOV ESI,Buffer</code> bude lepší použít <code class="SRC">LEA RSI,[Buffer]</code>.
Ostatní instrukce mohou zůstat stejné jako ve 32bitové variantě:</p>
<div class="SRC" title="calc.asm">        EUROASM CPU=x64
CalcL64 PROGRAM FORMAT=ELFX, WIDTH=64, ENTRY=Start:
       INCLUDE libcvt64.asm, linabi.htm ; Použij funkce z těchto knihoven.
[.text] ; Takto se v EuroAssembleru označuje, že budou následovat strojové instrukce.
Start:  StdOutput Prompt     ; Představení programu, výzva k zadání.
        StdInput Buffer      ; Načtení zadání do proměnné Buffer.
        LEA RSI,[Buffer]
Next1:  LODSB                ; Načtení dalšího znaku.
        CMP AL,0             ; Konec vstupního řetězce?
        JE Error:
        CMP AL,' '           ; Oddělující mezery je třeba přeskočit.
        JE Next1:
        DEC RSI              ; Vrácení ukazatele na platný znak.
        CALL ASCIItoInteger  ; Procedura z knihovny libcvt64.asm.
        JC Error:
        MOV [Arg1],EAX       ; Uložení prvního čísla.
        ADD RSI,RCX          ; Umísti ESI za první načtené číslo.
Next2:  LODSB                ; Načtení dalšího znaku
        CMP AL,0             ; Konec vstupního řetězce?
        JE Error:
        CMP AL,' '           ; Oddělující mezery je třeba přeskočit.
        JE Next2:
        MOV [Arg2],AL        ; Uložení operátoru.
Next3:  LODSB                ; Načtení dalšího znaku
        CMP AL,0
        JE Error:
        CMP AL,' '           ; Oddělující mezery je třeba přeskočit.
        JE Next3:
        DEC RSI              ; Vrácení ukazatele na platný znak.
        CALL ASCIItoInteger  ; Procedura z knihovny libcvt64asm.
        JC Error:
        MOV [Arg3],EAX       ; Uložení druhého čísla.
        MOV EAX,[Arg1]       ; Načteme první argument do EAX a pak se podíváme na operátor.
        CMP [Arg2],'+'
        JE Addition:
        CMP [Arg2],'-'
        JE Subtraction:
        CMP [Arg2],'*'
        JE Multiplication:
        CMP [Arg2],'/'
        JE Division:
Error:  StdOutput Help       ; Pokud byl zadán neplatný operátor, vypíše se nápověda.
        TerminateProgram     ;  a program se ukončí.
Addition:
        ADD EAX,[Arg3]
Print:  LEA RSI,[Result]
        CALL IntegerToASCII
        StdOutput RSI
        JMP Start:
Subtraction:
        SUB EAX,[Arg3]
        JMP Print:
Multiplication:
        MUL [Arg3]
        JMP Print:
Division:
        DIV [Arg3]
        JMP Print
[.data] ; Tady skončila sekce programového kódu a začínají data.
Arg1    DD 0
Arg2    DD 0
Arg3    DD 0
Result  DB 10 * B
        DB 10,0
Buffer  DB 80 * B
Prompt: DB 13,10,"%^PROGRAM: Enter two integer numbers separated with arithmetic operator + - * /.",13, 10, 0
Help:   DB "Calculate  number1 operator number2.", 13, 10
        DB "Example:   3 + 4", 13, 10, 0
      ENDPROGRAM</div>
<p>Portace z 64bitového Linuxu na Windows je opět snadná: nahradíme knihovnu <q>linabi.htm</q>
knihovnou <q>winabi.htm</q>, název a formát programu změníme
z <code class="SRC">CalcL64 PROGRAM FORMAT=ELFX</code>
na <code class="SRC">CalcW64 PROGRAM FORMAT=PE</code> a to je vše.
Získáme tím kalkulátor pro 64bitový Windows.</p>

<h3 id="Debugging"><a href="#top">Hledání chyb</a></h3>
<p>Hledání a odstraňování chyb programu &mdash; ladění &mdash; je podstatnou náplní práce programátora,
v asembleru to platí dvojnásob. Ukážeme si několik metod, jak chyby hledat.</p>

<h4 id="DebugCheck"><a href="#top">Hledání chyb kontrolními výpisy</a></h4>
<p>V předchozích příkladech jsme pro kontrolu použili vypsání zadaných argumentů makrem StdOutput.
To je docela dobrá metoda jak se ujistit, že procesor probíhá těmi zákoutími našeho programu, kde ho očekáváme.
Na prvním místě dejme výpis StdOutput hned na začátek, kam ukazuje vstupní bod programu ENTRY=.
Tím se ujistíme, že jsme nechali náš program načíst správnou knihovnu a že výpis na standardní výstup
funguje. Text vypisovaný pomocí StdOutput nemusí být nijak sofistikovaný, stačí aby sdělil,
že program dospěl do určitého bodu. Například <code>StdOutput ="Jsem na řádku 123",Eol=Yes</code>.</p>

<h4 id="DebugDebug"><a href="#top">Hledání chyb makrem Debug</a></h4>
<p>Na mnoha místech programu by bylo užitečné kromě informace, kde zrovna jsme, vidět také obsah
určitého registru nebo paměťového místa.
Mohli bychom sice obsah kteréhokoli registru převést do dekadického nebo hexadecimálního ASCII tvaru,
uložit jej do nějaké dočasné paměťové proměnné a pak ji vypsat pomocí StdOutput,
ale to je nepohodlné řešení náchylné k chybám. Lepší bude použít specializované makro,
které dělá totéž pro všechny registry a nezanechává v laděném programu žádné stopy (kromě zvětšení jeho délky).</p>
<p>K ladění je k dispozici knihovna <a class="EXT" href="../maclib/debug.htm">maclib/debug.htm</a>
a obsahuje jediné makro Debug, nezávislé na operačním systému a na šířce laděného programu (16, 32 nebo 64 bitů).
Nezávislost na OS je vykoupena tím, že makro Debug informaci o registrech nevypisuje samo, ale posílá
naformátovaný výpis do procedury s defaultním názvem <em>DebugOutput</em> volané z makra jako tzv. <em>callback</em>.
Tuto proceduru musíme v laděném programu dočasně použít, naštěstí to není nic složitého.
DebugOutput má za úkol vypsat na standardní výstup řetězec adresovaný registrem rSI v délce rCX bajtů.
Můžeme zde k výpisu použít dobře známé makro StdOutput.</p>
<p>Příklady procedury DebugOutput pro různé šířky programu:</p>
<div class="PRE">DebugOutput PROC  ; 16bitový program.
     StdOutput SI,Size=CX
     RET
    ENDPROC DebugOutput

DebugOutput PROC  ; 32bitový program.
     StdOutput ESI,Size=ECX
     RET
    ENDPROC DebugOutput

DebugOutput PROC  ; 64bitový program.
     StdOutput RSI,Size=RCX
     RET
    ENDPROC DebugOutput</div>

<p>Postup pro ladění pomocí makra Debug:</p>
<ul>
<li>Povolíme ladění uvedením instrukce <code>EUROASM DEBUG=ON</code> na začátku programu.</li>
<li>Do laděného programu includujeme kromě knihovny pro interakci s OS
(dosapi.htm, linapi.htm, linabi.htm, winapi.htm nebo winabi.htm) také knihovnu <q>debug.htm</q>.</li>
<li>Na vhodné místo laděného programu zařadíme proceduru DebugOutput odpovídající
šířce programu (16, 32 nebo 64 bitů).</li>
<li>Do kritických míst našeho programu vložíme instrukce <code>Debug</code>,
program přeložíme, spustíme a pak pozorujeme, zda prochází těmi místy, kudy by měl.</li></ul>
<p>Výpis stavu počítače po každém použití makra Debug vypadá v 32bitovém programu nějak takto:</p>
<div class="MSG">#### Debug at "filename.ext"{1234)       CS=0000 DS=0000 ES=0000 SS=0000
GPR: FL=0000_0000 NT=0 PL=0 OF=0 DF=0 IF=0 TF=0 SF=0 ZF=0 AF=0 PF=0 CF=0
 EAX=0000_0000 ECX=0000_0000 EDX=0000_0000 EBX=0000_0000 FS=0000 GS=0000
 ESP=0000_0000 EBP=0000_0000 ESI=0000_0000 EDI=0000_0000   EIP=0000_0000</div>
<p>Makro na začátku vypsalo svou pozici ve zdrojovém kódu <code class="MSG">"filename.ext"{1234)</code>,
tedy název souboru a ve složených závorkách číslo řádku, a pak obsah všech GPR.
Vložení makra do programu jej nijak neovlivňuje, všechny registry i příznaky zůstávají zachovány.</p>
<p>Debug umí vypsat také obsah jednoho paměťového místa, jehož adresu a velikost specifikujeme
parametrem makra. Například <code class="SRC">Debug ESI, Size=32</code> vypíše kromě obsahu GPR také obsah paměti
na adrese ESI v délce 32 bajty. Parametr <code class="SRC">Size=</code> je v rozsahu 1..256, defaultní hodnota je 16.
U chráněných OS je třeba dbát, aby specifikovaná paměť skutečně existovala (byla programu alokována),
jinak může dojít k havarijnímu ukončení.</p>

<h4 id="DebugAppl"><a href="#top">Hledání chyb ladicí aplikací</a></h4>
<p>Mnohem pohodlnější přístup k ladění poskytují specializované ladicí aplikace &mdash; debuggery.
<br>Pro Linux je k dispozici konzolová aplikace <a class="EXT" href="../eadoc/links.htm#gdb">gdb</a>,
případně její grafická nadstavba <em>nemiver</em> nebo <em>ddd</em>.</p>
<p>Nejvíce jsem si oblíbil tyto:</p>
<p>Pro DOS <a class="EXT" href="../eadoc/links.htm#TDUMP">Turbo Debugger</a> dodávaný firmou Borland
spolu s Turbo Assemblerem nebo Turbo Pascalem.
<br>Pro 32bitový Windows <a class="EXT" href="../eadoc/links.htm#OllyDbg">OllyDbg</a>,
<br>pro 64bitový Windows <a class="EXT" href="../eadoc/links.htm#x64dbg">x64dbg</a>.
Na těchto celoobrazovkových aplikacích je sympatické, že jejich autoři od sebe opsali jednotné základní ovládání
pomocí funkčních kláves F4, F7, F8 apod. Nejčastěji budeme využívat základní obrazovku CPU,
která, rozdělena na čtyři části, zobrazuje strojové instrukce, obsah registrů, obsah paměti a zásobník.
Krokování programu (F7) s případným přeskakováním detailního procházení procedur (F8) umožňuje
po každém kroku sledovat, jak se změnily registry, paměť programu a zásobník.</p>

<p>Debuger ukazuje v levé horní čtvrtině okna CPU adresy a disasemblovaný strojový kód.
Adresy odpovídají tomu, jaké jim byly přiděleny linkerem, vidíme je jako hexadecimální čísla.
Bylo by užitečné vidět na jejich místě raději návěstí použité ve zdrojovém programu.
Toto propojení číselné adresy se symboly se ale bohužel neděje automaticky,
ani když je ve spustitelném souboru přítomna tabulka symbolů s jejich adresami.
Chceme-li znát adresy, jaké EuroAssembler přidělil symbolům, podívejme se do listingu.
Pokud jsme to ponechali povoleno volbou PROGRAM LISTGLOBALS=ON, na konci listingu <q>calc.asm.lst</q>
uvidíme u globálních symbolů jejich virutální adresu (VA=). Pokud bychom potřebovali znát adresu
dalších, neglobálních symbolů, musíme jim přidělit globální viditelnost.
To by šlo přidáním explicitní pseudoinstrukce <code>GLOBAL Division, Error, Multiplication</code> atd.,
ale ještě jednodušší bude na konec názvu každého návěstí přidat dvě dvojtečky.
Po novém přeložení už v listingu jejich adresy uvidíme:</p>
<samp>  ...
|        **** ListGlobals "CalcL64.x",Global=0,Public=12,Extern=0,eXport=0,Import=0
|        Division,[.text]:00000139h,VA=00401629h,scope='P'
|        Error,[.text]:000000EBh,VA=004015DBh,scope='P'
|        LinABI@RT,[.text]:000001C9h,VA=004016B9h,scope='P'
|        Multiplication,[.text]:00000131h,VA=00401621h,scope='P'
|        Next1,[.text]:0000007Dh,VA=0040156Dh,scope='P'
|        Next2,[.text]:00000099h,VA=00401589h,scope='P'
|        Next3,[.text]:000000A8h,VA=00401598h,scope='P'
|        Print,[.text]:0000010Eh,VA=004015FEh,scope='P'
|        Start,[.text]:00000050h,VA=00401540h,scope='P'
|        StdInputLin64@RT,[.text]:00000192h,VA=00401682h,scope='P'
|        StdOutputLin64@RT,[.text]:00000141h,VA=00401631h,scope='P'
|        Subtraction,[.text]:00000129h,VA=00401619h,scope='P'
</samp>
<blockquote>
OllyDebugger pro 32bitový Windows dokonce uměl načítat adresy z tabulky symbolů v objektovém souboru COFF,
pomocí klávesové zkratky <kbd>Ctrl-O</kbd>. My sice překládáme zdrojový kód přímo do spustitelného souboru,
bez mezistupně v podobě COFF souboru, ale mohli bychom dočasně změnit <code class="SRC">PROGRAM FORMAT=PE</code>
na <code class="SRC">PROGRAM FORMAT=COFF</code> a objektový formát COFF pak vygenerovat a použít pro načtení
adres symbolů OllyDebuggerem.
</blockquote>

<br class='CLEAR'/><a id='bottom' href='#top'>&#x25B2;Zpět na začátek&#x25B2;</a>
</body></html>
